 \newcommand{\ttt}{\prg{true}}
\newcommand{\ff}{\prg{false}}
\newcommand{\unkn}{\prg{b???}}
\newcommand{\bv}{\prg{bval}}


\newcommand{\prg}[1]{{\mbox{\tt{#1}}}}
 \newcommand{\prgCol}[1]{#1}

 \newcommand{\forget}[1]{}
\newcommand{\etc}{{\it etc.}}
\newcommand{\eg}{{\it e.g.\,}}
\newcommand{\ie}{{\it i.e.\,}}

\newcommand{\Future}[1]{\lozenge\, #1}% {\bullet #1}% {{{\mathcal F}}(#1)} % {{{\mathcal B}}(#1)}
\newcommand{\Using}[2]{#1\,\kw{in}\, #2} %{{{\mathcal U}}(#1,#2)}
\newcommand{\SigmaUsing}[2]{#1\@ #2} %{{{\mathcal U}}(#1,#2)}
\newcommand{\Past}[1] {\nabla #1} %{\lozenge\!\!\!\!\-\!\!-\,#1}
%{\lozenge\!\!\!\!\!\circ  #1} % {\lozenge\!\!\!\!\-\!\!- #1} %{\upupsilon #1}  %{\nabla #1} %{\circ #1}%  {{{\mathcal P}}(#1)}
\newcommand{\Initial}[1] {{{\mathcal I}\!nitial}(#1)}

\newcommand{\Pol}[1] {{\ensuremath{\prg{Pol}\_{\prg{#1}}}}}
\newcommand{\MOne} {{\ensuremath{\prg{M}_{\prg{BA}}}}}
\newcommand{\MTwo} {{\ensuremath{\prg{M}_{\prg{BA}'}}}}

\newcommand{\strongImplies}{\leqq} %{{ \,^\sqsubset\!\!\!_{\sim}\, }}
\newcommand{\weakImplies}{\lessapprox} %{{ \,^\sqsubset\!\!\!_{\sim}\, }}
\newcommand{\frames}{~\kw{frames}~}

\newcommand{\appref}[1]{see App.~\ref{#1}}

\newcommand{\sE}{{\prg{e}}}

\newcommand{\Lang} {\ensuremath{{\mathcal L}{_1}}}
\newcommand{\LangOO} {\ensuremath{{\mathcal C}{_{\tt j}}}}

% ------------------------------------------------------------------
%                                             positions, separations
\newcommand{\cf}{{\it c.f.~}}
\newcommand{\HYPHENA}{{\em-- }}
\newcommand{\HYPHENB}{{\em-- }}
\newcommand{\SP}{{\hspace{.1in}}}
\newcommand{\s}{{\hspace{.01in}}}

\newcommand{\obeys}{\,\textbf{\textrm{obeys}}\,}
\newcommand{\StrongDom}{\ensuremath{\mathcal{S}\textrm{\textit{trong}}{\mathcal{D}}\textrm{\textit{om}}}}
\newcommand{\Dom}{\ensuremath{\mathcal{D}}\textrm{\textit{om}}}

\newcommand{\Changes}[1]{\ensuremath{\mathcal{C}\textrm{\textit{hanges}}(#1)}}
\newcommand{\VisibleLit}{\ensuremath{\mathcal{V}\textrm{\textit{isible}}}}

\newcommand{\Gives}{\ensuremath{\mathcal{G}\textrm{\textit{ives}}}}
\newcommand{\MayCall}{\ensuremath{\mathcal{M}\textrm{\textit{ay}}{\mathcal{C}}\textrm{\textit{all}}}}
%\newcommand{\Dom}{\ensuremath{\mathcal{D}\textrm{\textit{om}}}}
\newcommand{\MayRead}{\ensuremath{\mathcal{M}\textrm{\textit{ay}}{\mathcal{R}}\textrm{\textit{ead}}}}
\newcommand{\MayAccess}{\ensuremath{\mathcal{M}\textrm{\textit{ay}}{\mathcal{A}}\textrm{\textit{ccess}}}}
\newcommand{\CanAccess}[2]{\ensuremath{{\mathcal{A}}\textrm{\textit{ccess}}}(#1,#2)}
\newcommand{\Calls}[1]{\ensuremath{{\mathcal{C}}\textrm{\textit{alls}}}(\prg{#1})}
\newcommand{\Caller}{\ensuremath{{\mathcal{C}}\textrm{\textit{aller}}}}
%{\ensuremath{\mathcal{C}\textrm{\textit{an}}{\mathcal{A}}\textrm{\textit{ccess}}}(#1,#2)}
\newcommand{\WillAccessThrough}{\ensuremath{\mathcal{W}\textrm{\textit{ill}}{\mathcal{A}}\textrm{\textit{ccess}}{\mathcal{T}}\!\!\textrm{\textit{hrough}}}}
\newcommand{\modelsWithO}{\models\!\!\!\!{_{_{_{\tiny{\mathcal O}}}}}}
\newcommand{\A}{\ensuremath{A}}
\newcommand{\SA}{\ensuremath{^{\small{\prg{s}}}\!A}}
\newcommand{\SE}{\ensuremath{^{\small{\prg{s}}}\!e}}
\newcommand{\SEOne}{\ensuremath{^{\small{\prg{s}}}!\!e}}
\newcommand{\SETwo}{\ensuremath{^{\small{\prg{s}}}\!e'}}
\newcommand{\B}{\ensuremath{B}}
\newcommand{\Arising}{{\mathcal{A}}\textrm{\textit{rising}}}

 %------------------------ syntax tables

\newcommand{\syntax}[1]{\prg{{\it #1}}}
\newcommand{\BBC}{$::=$} %in syntactic definitions
\newcommand{\SOR}{\ensuremath{\ \mid\ }} % BNF or
\newcommand{\MID}{{\SPsmall ~ \mid ~ \SPsmall }} % in sets


\newcommand{\pre}{\ensuremath{_{{pre}}}}   %kjx no \sc  in math mode
\newcommand{\post}{\ensuremath{_{{post}}}} %kjx no \sc  in math mode
\newcommand{\PRE}{\pre}
\newcommand{\POST}{\post}

\newcommand{\eval}[2]{{\ensuremath{\langle{ {#1}}\rangle_{#2}}}}
\newcommand{\interp}[2]{{\ensuremath{\lfloor{ {#1}}\rfloor_{#2}}}}
\newcommand{\interpBL}[1]{{\lceil   {#1}  \rfloor}}
%  { \langle \!\langle { {#1} \rangle \!\rangle}\! }
% { \langle   { {#1}  \rangle} }
% ------------------------------------------------------------------
%                                             English abbreviations

% ------------------------------------------------------------------
%                                              keywords, program text
\newcommand{\kw}[1]{{\bf{\sf {#1}}}}
%{\mbox{\prgCol{\rm{\bf {#1}}}}}
\newcommand{\lit}[1]{{\prg {#1}\xspace}}
\newcommand{\com}{\ensuremath{\prg{//}}}
\newcommand{\cnf}{\ensuremath{\kappa}}

 \newcommand{\code}[1]{{\mbox{\tt{#1}}}}
\newcommand{\M}{\ensuremath{\prg{M}}}
%\newcommand{\C}{\ensuremath{\prg{C}}}

\newcommand{\ext}{\mbox{\,\,{\kw {extends}}\,\,}}
\newcommand{\extends}{\mbox{\,\,{\kw {extends}}\,\,}}
\newcommand{\ass}{\mbox{{\kw {:=}}\,}}
\newcommand{\semi}{\mbox{{\kw {;}}\ }}
\newcommand{\comma}{\mbox{{\kw {,}}\,}}
\newcommand{\dotK}{\mbox{{\kw {.}}}}
\newcommand{\class}{\mbox{{\kw {class}}\,\,}}
\newcommand{\stat}{\mbox{{\kw {state}}}}
\newcommand{\trans}{\mbox{{\kw {root}}}}
            % {\mbox{{\kw {root state}}}}
            % was {\mbox{{\kw {abs-state}}}}
\newcommand{\lb}{\prgCol{\mbox{\tt{\bf{\{ }}}}}
\newcommand{\rb}{\prgCol{\mbox{\tt{\bf{\} }}}}}
\newcommand{\lp}{\prgCol{\mbox{\tt{\bf{( }}}}}
\newcommand{\rp}{\prgCol{\mbox{\tt{\bf{) }}}}}
\newcommand{\abstractM}{\kw {abstract}}
\newcommand{\throws}{\rm\bf throws}
\newcommand{\throw}{\rm\bf throw}
\newcommand{\IF}{{\kw {if}}\s}
\newcommand{\abstr}{{\kw {abstract}}\s}
%\newcommand{\for}{{\kw {for}}\s}
\newcommand{\retKW}{{\kw {return}}\s}
\newcommand{\THEN}{\s{\kw {then}}\s}
\newcommand{\ELSE}{\s{\kw {else}}\s}
\newcommand{\this}{{\lit {this}}}
%\renewcommand{\super}{{\lit {super}}}
\newcommand{\nullK}{{\lit {null}}}% no~around it
\newcommand{\thisL}{{\lit {this}}}% no~around it
\newcommand{\nullKW}{{\lit {null}}~}
\newcommand{\true}{{\lit {true}}~}
\newcommand{\trueK}{{\prg {true}}}
\newcommand{\false}{{\lit {false}}~}
\newcommand{\falseK}{{\prg {false}}}
\newcommand{\return}{{\kw {return}}\s}

\newcommand{\implKW}{\s{\kw {impl}}\s}
 \newcommand{\defs}{{\it defs}}






\newcommand{\assertTC}[2]{{\Prog{#1} \typCol{\vdash} {\prg{#2}}\s
    \typCol{\DDiamond_{r} }}}
\newcommand{\assertSC}[2]{{\Prog{#1} \typCol{\vdash} {\prg{#2}}\s
    \typCol{\DDiamond_{s}} }}



\newcommand{\md}{\heartsuit}


\newcommand{\Prog}[1]  {{\ensuremath{\prg{M}{{\prg{#1}}}}}}
    % {\prg{P}}
\newcommand{\Env}[1]{\envCol{\ensuremath{\Gamma{#1}}}}
% \newcommand{\state}[1]{\stCol{\ensuremath{\sigma???{#1}}}}
\newcommand{\stackFrame}[1]{\stCol{\ensuremath{\phi{#1}}}}
\newcommand{\heap}[1]{\stCol{\ensuremath{\chi{#1}}}}

\newcommand{\expr}[1]{{\ensuremath{\prg{e{#1}}}}}
\newcommand{\fld}[1]{{\ensuremath{\prg{f{#1}}}}}
\newcommand{\param}{{\ensuremath{\prg{x}}}}

\newcommand{\clss}[1]{\ensuremath{\prg{c}{\prg{#1}}}}
\newcommand{\clssD}[1]{\ensuremath{\prg{d}{{#1}}}}
\newcommand{\type}[1]{\ensuremath{\prg{t{#1}}}}

\newcommand{\val}[1]{{\ensuremath{\prg{v}{\prgCol{#1}}}}}
\newcommand{\res}[1]{{\ensuremath{\prg{dv}{#1}}}}
\newcommand{\valOrDev}[1]{{\ensuremath{\prg{r}{#1}}}}


\newcommand{\expandexp}[1]{}

\newcommand{\oo}{object-oriented}
\newcommand{\mExtS}{\ensuremath{\Downarrow}}

% re-classification expression
\newcommand{\cm}[1]{\this{\prgCol{\ensuremath{\mExtS}}}\prg{#1}}






% ------------------------------------------------------------------
%                                             identifiers in the examples
%                     ---------------------
%                                      Stack
 %                     ---------------------
%                                   Employee
\newcommand{\Empl}{\prg {Empl}}
\newcommand{\Pers}{\prg {Pers}}
\newcommand{\E}{{_\prg {e}}}
\newcommand{\Man}{\prg {Boss}}
\newcommand{\Stud}{\prg {Stdt}}
\newcommand{\Scholar}{\prg {Scholar}}
\newcommand{\sal}{\prg {sal}}
\newcommand{\bYear}{\prg {bYear}}
\newcommand{\frnd}{\prg {frnd}}
% \newcommand{\marks}{\prg {marks}}
\newcommand{\pay}{\prg {fee}}
\newcommand{\setP}{\prg {set}}
\newcommand{\String}{\prg {String}}
\newcommand{\hobby}{\prg {hobby}}
\newcommand{\intg}{\kw {int}}
\newcommand{\boolg}{\kw {bool}}
\newcommand{\ii}{\prg {i}}
\newcommand{\prom}{\prg {promote}}
\newcommand{\mkStud}{\prg {study}}
\newcommand{\dem}{\prg {demote}}
\newcommand{\grad}{\prg {employ}}
\newcommand{\assist}{\prg {assist}}
\newcommand{\amount}{\prg {amount}}

\newcommand{\Phil}{\prg {Phil}}
\newcommand{\Book}{\prg {Book}}
\newcommand{\Person}{\prg {Person}}
\newcommand{\fav}{\prg {favourite}}

\newcommand{\aMan}{\prg {billy}}
\newcommand{\anotherMan}{\prg {bob}}
\newcommand{\aMutMan}{\prg {bea}}
\newcommand{\employees}{employees}
\newcommand{\aStud}{\prg {steve}}
\newcommand{\aPers}{\prg {peter}}
\newcommand{\aStudEmpl}{\prg {mary}}
\newcommand{\anoStudEmpl}{\prg {judy}}
\newcommand{\yetAnoStudEmpl}{\prg {betty}}
\newcommand{\yetYetAnoStudEmpl}{\prg {joe}}

\newcommand{\exprog}{_{\prg{ei}}}



% structuring macros
\newcommand{\EndDefLemma}{\noindent $\bigtriangleup$}



\newcommand{\para}[1]{{\ensuremath{\prg{x}{#1}}}}


\newcommand{\methAndBodyNew}{\ensuremath{
\prg{\type{}~m \lp \type{_1}~\param{}\rp\   \ \lb
~\expr{}~\rb} }}
\newcommand{\methAndBodyNewOne}{\ensuremath{
\prg{\type{}~m \lp \type{_1}~\param{}\rp\   \ \lb
~\expr{'}~\rb} }}
\newcommand{\methAndBodyNewTwo}{\ensuremath{
\prg{\type{}~m \lp \type{_1}~\param{}\rp\   \ \lb
~\expr{''}~\rb} }}
\newcommand{\methAndBodyNewThree}{\ensuremath{
\prg{\type{''}~m \lp \type{_1''}~\param{}\rp\   \ \lb
~\expr{''}~\rb} }}
\newcommand{\methAndBodyNewPrime}{\ensuremath{
\prg{\type{}~m \lp  \type{_1}~\para{} \rp\   \
\lb~\expr{'}~\rb} }}
\newcommand{\methAndBodyNewPrimeAll}{\ensuremath{
\prg{\type{'}~m \lp  \type{_1'}~\para{} \rp\   \
\lb~\expr{'}~\rb} }}
\newcommand{\methAndBodyNewP}{\ensuremath{ % slight diff in Primes from above
\prg{\type{}~m \lp  \type{_1}~\para{} \rp\   \
\lb~\expr{'}~\rb} }}
\newcommand{\methAndBodyFromOneSig}{\ensuremath{
\prg{\type{}~m \lp  \type{_1}~\para{} \rp\ \eff{} \lb~ ... ~\rb}
}}

%-----------------

\newcommand{\Body}[2]{\ensuremath{\mathcal{B}ody(#1,\prg{#2})}}

\newcommand{\T}[1]{{\ensuremath{\type{}{#1}}}}

% find the declaration of an identifier
\newcommand{\LookUp}[2]{\ensuremath{ {#1}({\prg{#2}}) }}
\newcommand{\LookUpEnv}[2]{{ \Env{#1}({\prg{#2}}) }}
\newcommand{\LookUpState}[2]{{ \ensuremath{\sigma{#1}}({\prg{#2}}) }}
\newcommand{\LookUpHeap}[2]{{ \ensuremath{\heap{#1}}({\prg{#2}}) }}
\newcommand{\LookUpBody}[2]{{ {\Prog{#1}}({\prg{#2}}) }}
%\newcommand{\LookUpClass}[2]
%        { \ensuremath{{\mathcal C}%{\mathcal D}%{\it ef}
%        (}\Prog{#1},\prg{#2}\ensuremath{)}}
\newcommand{\LookUpField}[3]
        {\ensuremath{{\mathcal F}{\mathcal D}% {\it f}
                (}\Prog{#1},\prg{#2},\prg{#3}\ensuremath{)}}
\newcommand{\LookUpMethod}[3]
        {\ensuremath{{\mathcal M}{\mathcal D}% {\it f}
         (}\Prog{#1},\prg{#2},\prg{#3}\ensuremath{)}}
\newcommand{\Undef}{{\ensuremath{\mathcal U\!}{\it df}}}
\newcommand{\ClassOf}[2] { \ensuremath{{\mathcal C}{\mathit{lass}}(#1)_{#2}}}

%-------------------Part Three: Types ...
% Notation for types ( open and close types).


\newcommand{\subclass}{\typCol{\sqsubseteq}}
\newcommand{\sclass}{\subclass}
\newcommand{\widen}{\typCol{\ensuremath {\le}}}

%-------------------- implies, and, or, iff, etc -----------------
\newcommand{\inset}[3]{\prg{#1}\!\in\!\prg{#2},\ldots,\prg{#3}}
% do not change above, it is also used with \forall, \exists
%\newcommand{\IMPLIES}{{\SP \Longrightarrow \SP}}
 \newcommand{\AND}{{\SPsmall {\mbox{and}} \SPsmall}}
\newcommand{\WITH}{{\SPsmall {\mbox{with}} \SPsmall}}

%\newcommand{\IFF}{{\SPsmall {\mbox{iff}} \SPsmall}}
\newcommand{\IFF}{{\SP {\mbox{ iff }} \SP}}

\newcommand{\OR}{{\SPsmall {\mbox{or}} \SPsmall}}
\renewcommand{\implies}{{\ensuremath{\longrightarrow}}}
\newcommand{\upd}{{\mapsto}}

%----------------------- Conformance --------------------
\newcommand{\stateConf}[3]
  {\Prog{#1},\Env{#2}
  \rtjCol{\ensuremath{\vdash}}\,\ensuremath{\state{#3}}\,\rtjCol{\ensuremath{\DDiamond}}  }
\newcommand{\stackFrameHeapConf}[4]
  {\Prog{#1},\Env{#2}
  \rtjCol{\ensuremath{\vdash}}\,\ensuremath{\stackFrame{#3},\heap{#4}}\,\rtjCol{\ensuremath{\DDiamond}}  }
\newcommand{\stackFrameHeapConfS}[4]
  {\Prog{#1},\Env{#2}
  \rtjCol{\ensuremath{\vdash}}\,\ensuremath{ {#3},\heap{#4}}\,\rtjCol{\ensuremath{\DDiamond}}  }

\newcommand{\stackFrameHeapConfNOT}[4]
  {\Prog{#1},\Env{#2}
  \rtjCol{\ensuremath{\not\vdash}}\,\ensuremath{\stackFrame{#3},\heap{#4}}\,\rtjCol{\ensuremath{\DDiamond}}  }

\newcommand{\stackFrameHeapConfLong}[4]
  {\Prog{#1}, {#2}
  \rtjCol{\ensuremath{\vdash}}\,\ensuremath{\stackFrame{#3},\heap{#4}}\,\rtjCol{\ensuremath{\DDiamond}}  }
\newcommand{\stackFrameHeapConfLongNOT}[4]
  {\Prog{#1}, {#2}
  \rtjCol{\ensuremath{\not\vdash}}\,\ensuremath{\stackFrame{#3},\heap{#4}}\,\rtjCol{\ensuremath{\DDiamond}}  }


\newcommand{\stateConfEnv}[3]
  {\Prog{#1}, {#2}
  \rtjCol{\ensuremath{\vdash}}\,\ensuremath{\state{#3}}\,\rtjCol{\ensuremath{\DDiamond}}  }
  \newcommand{\stateConfLong}[3]
  { {#1}, {#2}
        \rtjCol{\ensuremath{\vdash}}\,\ensuremath{\state{#3}}\,\rtjCol{\ensuremath{\DDiamond} } }
\newcommand{\stateConfLongNot}[3]
  { {#1}, {#2}
        \rtjCol{\ensuremath{\vdash}\!\!\!\not}\ \ensuremath{\state{#3}}\,
         \rtjCol{\ensuremath{\DDiamond} } }
\newcommand{\conf}[4]
  {\Prog{#1},\ensuremath{\heap{#2}}
        \rtjCol{\ensuremath{\vdash}} \ensuremath{\prg{#3}} \rtjCol{\ensuremath{\lhd}}
        \ensuremath{\prg{#4}}}
\newcommand{\confW}[4]
  {\Prog{#1},\ensuremath{\heap{#2}}
        \rtjCol{\ensuremath{\vdash}} \ensuremath{\prg{#3}} \rtjCol{<:}
        \ensuremath{\prg{#4}}}
% states conforming to each other:


\newcommand{\confState}[5]
    % Prog, eff, thsiMut, state, state
  {\confStateL{\Prog{#1}}{\eff{#2}}{\clss{#3}}{\state{#4}}{\state{#5}}}
  \newcommand{\confStateP}[4]
    % Prog, eff, state, state
  {\ensuremath{\Prog{#1},{\eff{#2}}\vdash{\state{#3}}\lhd{\state{#4}}}}
\newcommand{\confStateL}[5]
  {\ensuremath{#1,{#2},{#3}\vdash{#4}\lhd{#5}}}
\newcommand{\confStateLP}[5]
  {\ensuremath{#1,{#2}\vdash{#3}\lhd{#4}}}




% ------------------------------------------- Type assertions ----------------
\newcommand{\assert}[3]{\prg{#1} \vdash \prg{#2}~:~\prg{#3}}
% \newcommand{\assertT}[5] {\Prog{#1}, \Env{#2} \   \ensuremath{\vdash} \ \prg{#4}~
% \ensuremath{:~\prg{#5}}}
\newcommand{\EFFSEP}{\typCol{[\!]}}

\newcommand{\assertTAll}[6]
    % program, env, expr, type, mut, eff
{\Prog{#1}, \Env{#2} \   \typCol{\ensuremath{\vdash}} \ \prg{#3}~
\ensuremath{\typCol{:~} \prg{#4} } }% ~\EFFSEP~ {#5}~\EFFSEP~{#6} }}
\newcommand{\assertTAllS}[6]
% with subsumption
    % program, env, expr, type, mut, eff
{\Prog{#1}, \Env{#2} \   \typCol{\ensuremath{\vdash_s}} \
\prg{#3}~
\ensuremath{\typCol{:~} \prg{#4} } }% ~\EFFSEP~ {#5}~\EFFSEP~{#6} }}
\newcommand{\assertTAllR}[6]
% with subsumption
    % program, env, expr, type, mut, eff
{\Prog{#1}, \Env{#2} \   \typCol{\ensuremath{\vdash_r}} \
\prg{#3}~
\ensuremath{\typCol{:~} \prg{#4} } }% ~\EFFSEP~ {#5}~\EFFSEP~{#6} }}
\newcommand{\assertTAllL}[6]
    % program, env, expr, type, mut, eff
{{#1}, {#2} \   \typCol{\ensuremath{\vdash}} \ \prg{#3}~
\ensuremath{\typCol{:~}} \prg{#4} }%~\EFFSEP~ {#5}~\EFFSEP~{#6} }}
\newcommand{\assertTFour}[4]
    % for the explanations, ignore P and \eff
{ {#1} \   \typCol{\ensuremath{\vdash}} \ \prg{#2}~
\ensuremath{\typCol{:~} \prg{#3} ~\EFFSEP~ {#4}  }}
% same as above, but in 2 lines!
% do not remove! it is difficult to program, so
% leave it in, even if temporarily not used!
\newcommand{\assertTAllTwoL}[6]
    % program, env, expr, type, mut, eff
{\Prog{#1}, \Env{#2} \   \ensuremath{\vdash} \ \prg{#3}~
\ensuremath{:~\\ \SP\SP\SP\SP\SP
   \prg{#4} }}
\newcommand{\assertTAllEnvS}[6]
    %as before, but the environment is given in full
{\Prog{#1}, {#2} \   \typCol{\ensuremath{\vdash}_s} \ \prg{#3}~
\ensuremath{\typCol{:~}}\prg{#4}  }
\newcommand{\assertTAllEnvR}[6]
    %as before, but the environment is given in full
{\Prog{#1}, {#2} \   \typCol{\ensuremath{\vdash}_r} \ \prg{#3}~
\ensuremath{\typCol{:~}}\prg{#4}  }
\newcommand{\assertTAllEnv}[6]
    %as before, but the environment is given in full
{\Prog{#1}, {#2} \   \typCol{\ensuremath{\vdash}} \ \prg{#3}~
\ensuremath{\typCol{:~}}\prg{#4}  }




 % Effects


% receiver mutations

\newcommand{\mutOr}[1] % takes as parameter the program
        {\ensuremath{\sqcup\!{_{{#1}}}}} % binary on muts

\newcommand{\assertc}[3]{\ensuremath{\Prog{#1}
 \typCol{\vdash}\, \prg{#2}\, \subclass\, \prg{#3}}}

 \newcommand{\assertw}[3]{\ensuremath{\Prog{#1} \typCol{\vdash}
\prg{#2}\widen\prg{#3}}}
\newcommand{\assertion}[3]{\ensuremath{#1 \typCol{\vdash} \prg{#2}~#3}}
\newcommand{\notStateConfEnv}[3]
  {\Prog{#1},\prg{#2}\,
  \rtjCol{\ensuremath{\not\vdash}}\,\ensuremath{\state{#3}}\,\rtjCol{\ensuremath{\DDiamond}}  }
 \newcommand{\notConf}[4]
  {\Prog{#1},\ensuremath{\heap{#2}}
        \rtjCol{\ensuremath{\not\vdash}} \ensuremath{\prg{#3}} \rtjCol{\ensuremath{\lhd}}
        \ensuremath{\prg{#4}}}







%Macros for inference rules
\newcommand{\inferencerule}[2]{
\begin{array}{l} #1 \\ \hline #2 \end{array}
}

\newcommand{\inferenceruleN}[3]
{
\begin{array}{l}
% \SP\SP\SP\SP\SP\SP\SP\SP
% \SP\SP\SP\SP\SP\SP\SP\SP
\SP\SP\SP\SP\SP\SP\SP\SP
\SP\SP\SP\SP\SP\SP  {\sf #1}
\\ #2  \\ \hline   #3
  \end{array}
}

\newcommand{\inferenceruleNN}[3]
{
\begin{array}{l}
\SP\SP\SP\SP\SP\SP\SP\SP
\SP\SP\SP\SP\SP\SP\SP\SP
\SP\SP\SP\SP\SP\SP\SP\SP
\SP\SP\SP\SP\SP\SP\SP\SP

   {\sf #1}
\\ #2  \\ \hline   #3
  \end{array}
}

%===========================================================================
%  Definition-Lemma-Theorem-Proof
%
% Adaptation of LaTeX's theorem environment; can be used as a command
% (eg just \Lemma not \begin{Lemma}) and no italicisation; also works
% with ptmac; result numbering is uniform within subsections and can be
% suppressed.
%
\newif\ifNumberResults\NumberResultstrue
\def\@@opargbegintheorem#1#2#3{\@@@@begintheorem{\bf\@@thmname{#1}{#2}(#3)}}
\def\@@begintheorem#1#2{\@@@@begintheorem{\bf\@@thmname{#1}{#2}}}
\def\@@@@begintheorem#1{\par\removelastskip\smallskip\noindent{#1}}
\def\@@thmname#1#2{#1\ \ifNumberResults#2\ \fi}

% similarly \Proof or \begin{Proof}...\end{Proof}
% prefer proofs with statements if possible - hence \penalty700
%\let\qedsymbol\S% make it \square or \blacksquare if you like for kb
\let\qedsymbol \Box
\def\qed{\hfill{$\qedsymbol$}}
\def\Proof{\par\removelastskip\smallskip\penalty700\noindent{\bf Proof}\enskip}
\def\endProof{\qed\penalty-700 \smallskip}
\let\endproof\endProof

%   The actual words

\newtheorem{theo}{Theorem}
 \newtheorem{definition}[theo]{Definition}
\newtheorem{example}[theo]{Example}
\newtheorem{mylemma}[theo]{Lemma}
\newtheorem{conjecture}[theo]{Conjecture}
% \newtheorem{theorem}{Theorem}
 \newtheorem{note}[theo]{Note}
 \newtheorem{observation}[theo]{Observation}


%--------------------------------- the ones that Susan introduced
\newcommand{\z}{{\prg z}}

\newcommand{\Fields}[3]{\ensuremath{{\mathcal F}(}\Prog{#1},\prg{#2},
\prg{#3}\ensuremath{)} }
\newcommand{\FieldIds}[2]{\ensuremath{{\mathcal F}{\it {s}}(\Prog{#1},\prg{#2})}}
\newcommand{\Meths}[3]{\ensuremath{{\mathcal M}(}\Prog{#1},\prg{#2},
\prg{#3}\ensuremath{)} }







\newcommand{\addr}[1]{\stCol{\prg{\mbox{$\iota$}}}}
\newcommand{\addrOld}[1]{\stCol{\ensuremath{\iota_{#1}}}}
    % {{\prg{\mbox{$\iota_{#1}$}}}}
\newcommand{\addrO}[1]{\stCol{\ensuremath{\iota {\stCol{#1}}}}}



\newcommand{\rewriteLong}[1]
{\rtCol{\ensuremath{\ \leadsto\!\!\!\!\!\!_{_{#1}\,\ \ }}}}
\newcommand{\rewrite}[1]
{\rtCol{\ensuremath{\ \leadsto\!\!\!\!\!\!_{_{\Prog{#1}}\,\ \ }}}}
\newcommand{\rewriteP}
    {{\ensuremath{\ \ \leadsto\!\!_{_{\prg{P}}}\,\,\,}}}
 % {\rtCol{\ensuremath{\ \ \leadsto \!\!\!\!_{{\Prog{}}\,\ \ }}}}
% \newcommand{\Conf}[2]% configurations: < #1, #2 >
% inside the mathmode
% { \langle \prg{#1}, {#2} \rangle }
% {  \prg{#1}\ensuremath{,}{#2}  }
\newcommand{\greenComma}{\rtCol{\ensuremath{,}}}
\newcommand{\ConfL}[3]
{  \prg{#1}\greenComma\stackFrame{#2}\greenComma\heap{#3}  }
\newcommand{\ConfLLong}[3]
{  \prg{#1}\greenComma {#2}\greenComma\heap{#3}  }
\newcommand{\ConfR}[2]
{  \prg{#1}\greenComma\heap{#2}  }


% ------------------------------------- Well formed, unique acyclic ---------------
\newcommand{\DDiamond}{\Diamond}

\newcommand{\assertWF}[2]{\Prog{#1} \typCol{\vdash}\, {#2}\s \typCol{\DDiamond}}
\newcommand{\WF}[1]{{ \typCol{\vdash}\, \Prog{#1}~\typCol{\DDiamond} }}
\newcommand{\WFEnv}[2]{\ensuremath{ \Prog{#1}\typCol{\vdash} \Env{#2}~\typCol{\DDiamond} }}
\newcommand{\UDefs}[1]{\ensuremath{ \typCol{\vdash }~ \Prog{#1}\  \typCol{\DDiamond_u} }}
\newcommand{\NotUDefs}[1]{\ensuremath{ \typCol{\not\vdash} ~ \Prog{#1}\ \typCol{\DDiamond_u} }}
\newcommand{\Acyclic}[1]{\ensuremath{ \typCol{\vdash} ~ \Prog{#1}\  \typCol{\DDiamond_a} }}
\newcommand{\NotAcyclic}[1]{\ensuremath{ \typCol{\not\vdash}
  ~ \Prog{#1}\  \typCol{\DDiamond_a} }}
\newcommand{\assertTT}[2]{{\Prog{#1} \typCol{\vdash} {\prg{#2}}\s \typCol{\DDiamond_{tp}} }}
\newcommand{\assertF}[2]{\ensuremath{\Prog{#1} \typCol{\vdash} {\prg{#2}}\s \typCol{\DDiamond}
}}

%{\ensuremath{\Prog{#1} \vdash {\prg{#2}}\s \DDiamond_{\it {eff}}  }}

\newcommand{\eff}[1]{\prg{\ensuremath{\phi{#1}}}}
\newcommand{\effOr}{\prg{\ensuremath{\cup}}}
\newcommand{\effAppl}[4]% effect, thisMut, Env, \Prog
    {\prg{\ensuremath{{#1}@_{#4}{#2}}}}
\newcommand{\effectLong}[1]{\prg{\ensuremath{{\{\  #1 \,\} }}}}
\newcommand{\effEmpty} %{\ensuremath{\emptyset}} %{\effectLong{\_}{}}
{\effectLong{ }{}\xspace}
\newcommand{\effStack}{\ \effectLong{\Stack}\ }
\newcommand{\effPlayer}{\ \effectLong{\Player}\ }
\newcommand{\effE}{\ \effectLong{\ }\ }





\newcommand{\NotWFEnv}[2]{\ensuremath{ \Prog{#1}\typCol{\not\vdash} \Env{#2}~\typCol{\DDiamond} }}
\newcommand{\notAssertTAll}[6]
    % program, env, expr, type, mut, eff
{\Prog{#1}, \Env{#2} \   \typCol{\ensuremath{\not\vdash}} \
\prg{#3}~ \ensuremath{\typCol{:~} \prg{#4} } }







\newcommand{\objStart}{\stCol{ ( \  }} % {\ensuremath {\mbox{\tt{[}} \! \! \mbox{\tt{[}}\, }}}

\newcommand{\objEnd}{\stCol % {\ensuremath \, {\mbox{\tt{]}} \! \!
   %                         \mbox{\tt{]}} }}}
{ )\ )  }}
\newcommand{\objSep}{\stCol
 % {\ensuremath \, {\mbox{\tt{|}} \! \! \mbox{\tt{|}} \, }}}
{ , \ (  }}

\newcommand{\objSepEnd}{\stCol{ , \ \emptyset  )  }}

\newcommand{\stuck}{\lit{stuckErr}}
\newcommand{\nullPEC}{\lit {nullPntrExc}}



\newcommand{\Obj}{\prg{Object}}
\newcommand{\void}{\kw{void}}
\newcommand{\newK}{{\kw {new}}~} % {{\kw {new}}}% no ~ around it
\newcommand{\newKW}{~{\kw {new}}~}





\newcommand{\back}{{$\!\!\!\!\!\!\!$}}


\newcommand{\WideFig}[3]
{
\begin{figure*}[t]
\begin{center}
\noindent
\fbox{
\begin{minipage}{4.7 in}
{#1} % the contents
\end{minipage}
}
\caption{#2}
\label{#3}
\end{center}
\end{figure*}
}


\newcommand{\WideFigWhere}[4] % you can specify where it should appear!
{
\begin{figure*}[{#4}]
\begin{center}
\noindent
\fbox{
\begin{minipage}{5. in}
{#1} % the contents
\end{minipage}
}
\caption{#2}
\label{#3}
\end{center}
\end{figure*}
}

\newcommand{\BigWideFigWhere}[4] % you can specify where it should appear!
{
\begin{figure*}[{#4}]
\begin{center}
\noindent
{\normalsize
\hrule
\begin{minipage}{5. in}
{#1} % the contents
\end{minipage}
\hrule
}
\caption{#2}
\label{#3}
\end{center}
\end{figure*}
}

\newcommand{\NotTooWideFigWhere}[4] % you can specify where it should appear!
{
\begin{figure*}[{#4}]
\begin{center}
\noindent
\fbox{
\begin{minipage}{4.3 in}
{#1} % the contents
\end{minipage}
}
\caption{#2}
\label{#3}
\end{center}
\end{figure*}
}


\newcommand{\opsemExprFig}
{\BigWideFigWhere {\opsemExpr} {Execution of expressions\MD}
{opsemTrad} {htbp} }



\newcommand{\mlc}{ }%{\heartsuit}
%\newcommand{\mcl}{ }%{\heartsuit}
\newcommand{\mc}{ }%{\heartsuit}

\newcommand{\BigNotTooWideFigWhere}[4] % you can specify where it should appear!
{
\begin{figure*}[{#4}]
\begin{center}
\noindent
{\normalsize
\hrule
\begin{minipage}{4.3 in}
{#1} % the contents
\end{minipage}
\hrule
}
\caption{#2}
\label{#3}
\end{center}
\end{figure*}
}

 

%]})
%}
