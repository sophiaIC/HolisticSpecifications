\section{Proof of Guarantee of Safety in \S\ref{sec:how}}

\begin{lemma}[\SrobustB Guarantees Password Safety]
For all $M$ such that $\satisfies{M}{{\SrobustB}}$,\\
then for all $\sigma$, $\chi$, $\beta$, $s$, $\psi$, $x$, $\prg{untrusted}$, $m$, $z_1$, $\ldots$, $z_n$, and $\prg{bal}$ such that
\begin{itemize} 
\item
$\sigma = (\chi, \{\prg{local} = \beta; \prg{contn} = (x := \prg{untrusted}.m(z_1, \ldots, z_n); s)\} : \psi)$,
\item
for all $z_i$, $\lfloor z_i \rfloor_\sigma \neq \lfloor a.password \rfloor_\sigma$
\item
$\satisfies{M, \sigma}{\prg{a : Account} \wedge \prg{a.balance == bal}}$, and
\item
for all $f$, $\satisfies{M, \sigma}{\forall o.[o.f \neq \prg{a.password} \vee \internal{o}]}$
\end{itemize}
and for all $v$, $\chi'$ such that $\exec{M \circ M'}{\sigma}{\sigma_0 \leadsto \ldots \sigma_k \leadsto (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}$\\
then $\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$
\end{lemma}
\begin{proof}
Since we do not know if $\sigma.\prg{this}$ is an internal object, we cannot directly use \SrobustB to show that $\prg{a.password}$ is never leaked, and thus 
money may not be withdrawn from $\prg{a}$. We can however proceed by considering the shape of $\sigma_i$ where $0 \leq i \leq k$:
\begin{itemize}
\item
there exists $\phi_0$ such that $\sigma_0 = (\chi, \phi_0 : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$ 
\item
for all $i$, where $0 \leq i \leq k$, there exists $\chi_i$ and $\psi_i$ such that $\sigma_i = (\chi, \psi : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
\item
there exists $\phi_k$ such that $\sigma_k = (\chi', \phi_k : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
\end{itemize}
further since the operational semantics of \Loo do not reference underlying frames except at return, it is easy to show that 
$$\reductions{M}{M'}{(\chi, \phi_0)}{(\chi', \phi_k)}$$
We are now able to apply \SrobustB to the above set of reductions, i.e. that if $\satisfies{M, (\chi', \phi_k)}{\prg{a.balance < bal}}$,
then $\satisfies{M, (\chi, \phi_0)}{\neg \wrapped{\prg{a.password}}}$. 
Since $\phi_0.\prg{local}$ does not contain $\prg{a.password}$, and all objects $o$ within $\chi$ with field $f$ such that $o.f = \prg{a.password}$ 
are internal, it follows that $\satisfies{M, (\chi, \phi_0)}{\wrapped{\prg{a.password}}}$, which is a contradiction. It thus follows that
$\satisfies{M, (\chi', \phi_k)}{\prg{a.balance >= bal}}$. It then follows that $\satisfies{M, (\chi', \phi_k : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)}{\prg{a.balance >= bal}}$,
and, since $\phi_k$ is simply a return from method call $\prg{untrusted}.m(z_0, \ldots, z_n)$, subsequently that $\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$.
\end{proof}




\begin{lemma}[\SrobustB Guarantees Password Safety]
For all $M$ such that $\satisfies{M}{{\SrobustB}}$,\\
then for all $\sigma$, $\chi$, $\beta$, $s$, $\psi$, $x$, $\prg{untrusted}$, $m$, $z_1$, $\ldots$, $z_n$, and $\prg{bal}$ such that
\begin{itemize} 
\item
$\sigma = (\chi, \{\prg{local} = \beta; \prg{contn} = (x := \prg{untrusted}.m(z_1, \ldots, z_n); s)\} : \psi)$,
\item
for all $z_i$, $\lfloor z_i \rfloor_\sigma \neq \lfloor a.password \rfloor_\sigma$
\item
$\satisfies{M, \sigma}{\prg{a : Account} \wedge \prg{a.balance == bal}}$, and
\item
for all $f$, $\satisfies{M, \sigma}{\forall o.[o.f \neq \prg{a.password} \vee \internal{o}]}$
\item
forall $\phi \in \psi$ and $p \in \phi.(\prg{local})$, $\lfloor p \rfloor_\phi \neq \lfloor \prg{a.password} \rfloor_\sigma$, 
\end{itemize}
and for all $v$, $\chi'$ such that $\exec{M \circ M'}{\sigma}{\sigma_0 \leadsto \ldots \sigma_k \leadsto (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}$\\
then $\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$
\end{lemma}
\begin{proof}
Since we do not know if $\sigma.\prg{this}$ is an internal object, we cannot directly use \SrobustB to show that $\prg{a.balance}$ is never reduced. 
We can however proceed by observing the shape of $\sigma_i$, where $0 \leq i \leq k$:
\begin{itemize}
\item
there exists $\phi_0$ such that $\sigma_0 = (\chi, \phi_0 : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$ 
\item
for all $i$, where $0 \leq i \leq k$, there exists $\chi_i$ and $\psi_i$ such that $\sigma_i = (\chi, \psi : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
\item
there exists $\phi_k$ such that $\sigma_k = (\chi', \phi_k : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
\end{itemize}
further since the operational semantics of \Loo do not reference underlying frames except at return, and $\sigma.(\prg{this})$ is the
only object with access to $\prg{a.password}$, we can consider a modified $\sigma$, $\sigma'$ that 
is identical to $\sigma$ except with an inserted overwrite of $p$, the variable in $\sigma.(\prg{local})$ pointing to $\prg{a.password}$.
i.e. $$\sigma' = (\chi, \{\prg{local} = \beta[p \mapsto \prg{null}]; \prg{contn} = (x := \prg{untrusted}.m(z_1, \ldots, z_n); s)\} : \psi)$$
$\sigma'$ ensures that no external object has access to $\prg{a.password}$, and thus, 
since the execution $\exec{M \circ M'}{\sigma}{\sigma_0 \leadsto \ldots \sigma_k \leadsto (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}$
is unaffected by the underlying local variable map, and by {\SrobustB}, it follows that 
$$\satisfies{M, (\chi', \{\prg{local} = \beta[p \mapsto \prg{null}][x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$$
Thus, since the final state of the heap $\chi'$ is unaffected by writes to underlying local variable maps, we can conclude that
$$\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$$
\end{proof}
