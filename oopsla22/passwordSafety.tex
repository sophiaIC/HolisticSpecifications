\section{Proof of Guarantee of Safety in \S\ref{sec:how}}
\label{app:safety}
\jm[]{
In this section we provide a proof sketch that \SrobustB ensures our balance
does not decrease in contexts with no access to our password. This 
property is expressed in \S\ref{sec:how}, and the example is repeated below.
}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{1}$
     ...
    method cautious(untrusted:Object)
        a = new Account
        p = new Password
        a.set(null,p)
        ...
        untrusted.make_payment(a)
        ...
\end{lstlisting}
\jm[]{
Informally, the property we wish to express of the above code snippet is 
that as long as there is no \prg{untrusted} does not have external access (whether transitive or direct)
to \prg{a.password} before the call on line 7, then \prg{a.balance} will not decrease during the 
execution of line 8. This property is expressed and proven in Theorem \ref{thm:safety}.
}
%\begin{itemize}
%\item
%suppose we rewrite \prg{Mod$\_1$} such that we duplicate all methods used in line 7. In the duplicated version of the methods
%we add a tuple as an argument that contains the account, and the current password. In every duplicate method, whenever the
%method \prg{setPassword} is called, we check if the receiver is \prg{a}, and if so we update the password in the tuple to the 
%new password. In this manner by the end of line 7, we still know what the password of the account is.
%\item
%We then insert the following code at the end of line 7:\\
%\prg{a.setPassword(t.snd(), new Password())}
%\item
%We are now in an arising program state where there is no external knowledge of the password, and we are able to apply \SrobustB
%\end{itemize}

\begin{lemma}[]

\end{lemma}
\begin{proof}
\end{proof}

\begin{theorem}[\SrobustB Guarantees Account Safety]
\label{thm:safety}
Let \prg{BankMdl} be some module that satisfies \SrobustB, 
$M$ be some external module, and $\sigma_1 = (\chi_1, \phi_1 : \psi_1)$ be some \textit{Arising} program state. If the continuation of $\phi_1$, $c_1$, is
\begin{verbatim}
a = new Account; 
p = new Password; 
a.set(null,p); 
s; 
untrusted.make_payment(a, z1, ..., zn); 
s'
\end{verbatim}
let 
\begin{itemize}
\item
$\sigma_2 = (\chi_2, \phi_2 : \psi_2)$ be the program state immediately preceding the execution of \prg{s}
\item
$\sigma_3 = (\chi_3, \phi_3 : \psi_3)$ be the program state immediately following the execution of \prg{s} where $\satisfies{\prg{BankMdl};\sigma_3}{\prg{a.password} \neq \prg{zk}}$ for all $i \leq \prg{k} \leq n$
\item
$\sigma_4 = (\chi_4, \phi_4 : \psi_4)$ be the program state immediately following the execution of\\ \prg{untrusted}\prg{.make\_payment}\prg{(a, z1, ..., zn)} 
\end{itemize}
if 
\begin{itemize}
\item
for all objects $o \in \chi_3$ such that $\satisfies{\prg{BankMdl}; \sigma_3}{\access{o}{\prg{a.password}}}$ and $o$ is transitively accessible (i.e. the transitive closure of $\access{\_}{\_}$) from \prg{untrusted}
then $\satisfies{\prg{BankMdl}; \sigma_3}{\internal{o}}$, and
\item
$\satisfies{\prg{BankMdl}; \sigma_3}{\prg{a.balance}\geq b}$
\end{itemize}
then 
\begin{itemize}
\item
$\satisfies{\prg{BankMdl};\sigma_4}{\prg{a.balance} \geq b}$.
\end{itemize}
\end{theorem}
\begin{proof}
The challenge in constructing a proof is that \SrobustB is not directly applicable to $\sigma$ since there may be an external 
object that has access to \prg{a.password}, depending on what code exists in \prg{s}. For example, if \prg{s} 
is blank then $\sigma_1.(\prg{this})$ has access to \prg{a}. The second difficulty is that any applicable program state must be 
\textit{Arising}, and thus we are not able to artificially modify the heap to attain such a program state. The solution is 
to create a \prg{M'} that results in an effectively equivalent heap (from the perspective of \prg{a.balance}) after execution of \prg{untrusted.make\_payment(a, z1, ..., zn)}. To attain such a module we
\begin{enumerate}
\item
introduce a class \prg{Tuple} to $M'$ that has two fields, \prg{fst : Account} and \prg{snd : Password}, and three methods \prg{fst()}, \prg{snd()}, and \prg{setSnd(p)} that 
return the first, and second elements of the \prg{Tuple}, and set the second element of the \prg{Tuple}.
\item
duplicate every method called in \prg{s}, and rewrite the code to call the duplicate methods
\item
the duplicate methods are identical to the original methods, except they take an extra argument that is a tuple \prg{t}, and
\item
whenever a method called in \prg{s} calls \prg{a'.setPassword(p1, p2)} for some 
\prg{a'}, \prg{p1}, and \prg{p2}, the following code is subsequently inserted:
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
if (a' == t.fst() && p1 == t.snd())
  t.setSnd(p2)
\end{lstlisting}
\item
the following statement is inserted at the beginning of \prg{s} (in $\sigma_2$)
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
t = new Tuple(a, p)
\end{lstlisting}
\item
the following statement is inserted at the end of \prg{s} (in $\sigma_3$)
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
a.setPassword(t.snd(), new Password())
\end{lstlisting}
\end{enumerate}
Clearly the resulting heap at the end of \prg{s}, when executed in the context of \prg{M'} ($\chi_3'$)
will be equivalent to $\chi_3$, except in the case of \prg{a.password}, which is now a new object.
This will not alter the execution of \prg{untrusted.make\_payment(a, z1, ..., zn)}, as we know that all other objects with knowledge of the old value of \prg{a.password} are not reachable from \prg{untrusted},
and thus from the perspective of \prg{untrusted} the heaps are equivalent.
Thus, it follows that \prg{a.balance} in $\chi_3'$ is equal to \prg{a.balance} in $\chi_3$.
Since \SrobustB is applicable to $\sigma_3'$, we can conclude that \prg{a.balance} in $\chi_4'$ (and thus $\chi_4$)
remains unchanged.
\end{proof}




