\section{Proof of Guarantee of Safety in \S\ref{sec:how}}


\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{1}$
     ...
    method cautious(untrusted:Object)
        a = new Account
        p = new Password
        a.set(null,p)             // heap = $\red{\chi_A}$
        ...                       // heap = $\red{\chi_B}$
        untrusted.make_payment(a) // heap = $\red{\chi_C}$
        ...
\end{lstlisting}
\begin{itemize}
\item
Let $\sigma_A = (\chi_A, \phi_A : \psi_A)$ be the program state at the end of line 6.
\item
Let $\sigma_B = (\chi_B, \phi_B : \psi_B)$ be the program state at the end of line 7.
\item
Let $\sigma_C = (\chi_C, \phi_C : \psi_C)$ be the program state at the end of line 8.
\item
Let the execution of code at line 7 be represented by $$\exec{M \circ \prg{BankMdl}}{\sigma_A}{\sigma_0 \leadsto \ldots \leadsto \sigma_n \leadsto \sigma_B}$$\\
Let the execution of \prg{untrusted.make\_payment(a)} be represented by $$\exec{M \circ \prg{BankMdl}}{\sigma_B}{\sigma'_0 \leadsto \ldots \leadsto \sigma'_n \leadsto \sigma_C}$$
where $\sigma'_0$ is the inital program state at the start of the \prg{make\_payment} method call, and $\sigma'_n$ is the final program state directly before the return of \prg{make\_payment}.
\end{itemize}
What we know:
\begin{itemize}
\item
$\psi_A = \psi_B = \psi_C$
\item
$\chi_A$ can be split into 2 disjoint parts:
\begin{enumerate}
\item
$\chi'_A$: Those objects that are accessible from \prg{untrusted}
\item
$\chi''_A$: Those objects that are not accessible from \prg{untrusted}
\end{enumerate}
\item
$\chi_B$ can be split into 2 disjoint parts:
\begin{enumerate}
\item
$\chi'_B$: Those objects that are accessible from \prg{untrusted}
\item
$\chi''_B$: Those objects that are not accessible from \prg{untrusted}
\end{enumerate}
\item
for all objects $o$ in $\chi'_B$ with field $f$, $o.f = p$ if $o$ is internal, i.e. $o.(\prg{class}) \in BankMdl$.
\item
$\chi_C$ can be split into 2 disjoint parts:
\begin{enumerate}
\item
$\chi'_C$: Those objects that are accessible from \prg{untrusted}
\item
$\chi''_C$: Those objects that are not accessible from \prg{untrusted}
\end{enumerate}
\item
$\chi''_B = \chi''_C$
\end{itemize}
Now if we can make a single simplifying assumption, our proof becomes significantly easier:
$$\chi'_A = \chi'_B$$
i.e. that line 7 does not modify untrusted or the portion of the heap accessible from untrusted
Now our proof takes the following form:
\begin{itemize}
\item
we can replace line 7 with \prg{p = null}
\item
the computation at line 8 is unchanged as $\chi'_B$, the portion of the heap that line 8 relies upon, remains unchanged
\item 
thus we now have a program state where no external objects have access to the password, and we can show the desired result
\item
we can now show that the resulting $\chi'_C$ is unchanged from before the change to line 7 (even if $\chi''_C$ differs)
\item
\prg{a} is in $\chi'_C$, thus giving us the desired result
\end{itemize}
\paragraph{Problem}: we cannot necessarily make the simplifying assumption, i.e. $\chi'_A \neq \chi'_B$.
We do know however that there exists some transformation $T$ such that $T(\chi'_A) = \chi'_B$,
and that there exists some code (i.e. line 7) that makes that transformation. What we need to show,
is that it is possible to rewrite line 7 (and any functions called in line 7) such that the only changes 
to the heap that result from line 7 are made to the untrusted portion of the heap, thereby allowing us 
to add \prg{p = null} to the end of line 7. It seems reasonable that we could argue that such a transformation
exists, but the details of that transformation are complex. I believe they require us to duplicate every method
that is used in line 7, where the duplicate method overwrites field references to \prg{p} at the end of the method, 
and we replace usages of those methods with the duplicate only in the case where the object with those field references
is last used (we cannot do it until that object is not needed in line 7 anymore). In fact, we could probably just do this for all fields indiscriminately as it will not affect computation
at line 8 ...

.... alternatively we make our simplifying assumption, arguing that we assume that ``our code'' (i.e. \prg{Mod$_1$})
only interacts with untrusted code via \prg{untrusted}

%\begin{lemma}[\SrobustB Guarantees Password Safety]
%For all $M$ such that $\satisfies{M}{{\SrobustB}}$,\\
%then for all $\sigma$, $\chi$, $\beta$, $s$, $\psi$, $x$, $\prg{untrusted}$, $m$, $z_1$, $\ldots$, $z_n$, and $\prg{bal}$ such that
%\begin{itemize} 
%\item
%$\sigma = (\chi, \{\prg{local} = \beta; \prg{contn} = (x := \prg{untrusted}.m(z_1, \ldots, z_n); s)\} : \psi)$,
%\item
%for all $z_i$, $\lfloor z_i \rfloor_\sigma \neq \lfloor a.password \rfloor_\sigma$
%\item
%$\satisfies{M, \sigma}{\prg{a : Account} \wedge \prg{a.balance == bal}}$, and
%\item
%for all $f$, $\satisfies{M, \sigma}{\forall o.[o.f \neq \prg{a.password} \vee \internal{o}]}$
%\end{itemize}
%and for all $v$, $\chi'$ such that $\exec{M \circ M'}{\sigma}{\sigma_0 \leadsto \ldots \sigma_k \leadsto (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}$\\
%then $\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$
%\end{lemma}
%\begin{proof}
%Since we do not know if $\sigma.\prg{this}$ is an internal object, we cannot directly use \SrobustB to show that $\prg{a.password}$ is never leaked, and thus 
%money may not be withdrawn from $\prg{a}$. We can however proceed by considering the shape of $\sigma_i$ where $0 \leq i \leq k$:
%\begin{itemize}
%\item
%there exists $\phi_0$ such that $\sigma_0 = (\chi, \phi_0 : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$ 
%\item
%for all $i$, where $0 \leq i \leq k$, there exists $\chi_i$ and $\psi_i$ such that $\sigma_i = (\chi, \psi : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
%\item
%there exists $\phi_k$ such that $\sigma_k = (\chi', \phi_k : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
%\end{itemize}
%further since the operational semantics of \Loo do not reference underlying frames except at return, it is easy to show that 
%$$\reductions{M}{M'}{(\chi, \phi_0)}{(\chi', \phi_k)}$$
%We are now able to apply \SrobustB to the above set of reductions, i.e. that if $\satisfies{M, (\chi', \phi_k)}{\prg{a.balance < bal}}$,
%then $\satisfies{M, (\chi, \phi_0)}{\neg \wrapped{\prg{a.password}}}$. 
%Since $\phi_0.\prg{local}$ does not contain $\prg{a.password}$, and all objects $o$ within $\chi$ with field $f$ such that $o.f = \prg{a.password}$ 
%are internal, it follows that $\satisfies{M, (\chi, \phi_0)}{\wrapped{\prg{a.password}}}$, which is a contradiction. It thus follows that
%$\satisfies{M, (\chi', \phi_k)}{\prg{a.balance >= bal}}$. It then follows that $\satisfies{M, (\chi', \phi_k : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)}{\prg{a.balance >= bal}}$,
%and, since $\phi_k$ is simply a return from method call $\prg{untrusted}.m(z_0, \ldots, z_n)$, subsequently that $\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$.
%\end{proof}
%
%
%
%
%\begin{lemma}[\SrobustB Guarantees Password Safety]
%For all $M$ such that $\satisfies{M}{{\SrobustB}}$,\\
%then for all $\sigma$, $\chi$, $\beta$, $s$, $\psi$, $x$, $\prg{untrusted}$, $m$, $z_1$, $\ldots$, $z_n$, and $\prg{bal}$ such that
%\begin{itemize} 
%\item
%$\sigma = (\chi, \{\prg{local} = \beta; \prg{contn} = (x := \prg{untrusted}.m(z_1, \ldots, z_n); s)\} : \psi)$,
%\item
%for all $z_i$, $\lfloor z_i \rfloor_\sigma \neq \lfloor a.password \rfloor_\sigma$
%\item
%$\satisfies{M, \sigma}{\prg{a : Account} \wedge \prg{a.balance == bal}}$, and
%\item
%for all $f$, $\satisfies{M, \sigma}{\forall o.[o.f \neq \prg{a.password} \vee \internal{o}]}$
%\item
%forall $\phi \in \psi$ and $p \in \phi.(\prg{local})$, $\lfloor p \rfloor_\phi \neq \lfloor \prg{a.password} \rfloor_\sigma$, 
%\end{itemize}
%and for all $v$, $\chi'$ such that $\exec{M \circ M'}{\sigma}{\sigma_0 \leadsto \ldots \sigma_k \leadsto (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}$\\
%then $\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$
%\end{lemma}
%\begin{proof}
%Since we do not know if $\sigma.\prg{this}$ is an internal object, we cannot directly use \SrobustB to show that $\prg{a.balance}$ is never reduced. 
%We can however proceed by observing the shape of $\sigma_i$, where $0 \leq i \leq k$:
%\begin{itemize}
%\item
%there exists $\phi_0$ such that $\sigma_0 = (\chi, \phi_0 : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$ 
%\item
%for all $i$, where $0 \leq i \leq k$, there exists $\chi_i$ and $\psi_i$ such that $\sigma_i = (\chi, \psi : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
%\item
%there exists $\phi_k$ such that $\sigma_k = (\chi', \phi_k : \{\prg{local} = \beta; \prg{contn} = (x := \bullet; s)\} : \psi)$
%\end{itemize}
%further since the operational semantics of \Loo do not reference underlying frames except at return, and $\sigma.(\prg{this})$ is the
%only object with access to $\prg{a.password}$, we can consider a modified $\sigma$, $\sigma'$ that 
%is identical to $\sigma$ except with an inserted overwrite of $p$, the variable in $\sigma.(\prg{local})$ pointing to $\prg{a.password}$.
%i.e. $$\sigma' = (\chi, \{\prg{local} = \beta[p \mapsto \prg{null}]; \prg{contn} = (x := \prg{untrusted}.m(z_1, \ldots, z_n); s)\} : \psi)$$
%$\sigma'$ ensures that no external object has access to $\prg{a.password}$, and thus, 
%since the execution $\exec{M \circ M'}{\sigma}{\sigma_0 \leadsto \ldots \sigma_k \leadsto (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}$
%is unaffected by the underlying local variable map, and by {\SrobustB}, it follows that 
%$$\satisfies{M, (\chi', \{\prg{local} = \beta[p \mapsto \prg{null}][x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$$
%Thus, since the final state of the heap $\chi'$ is unaffected by writes to underlying local variable maps, we can conclude that
%$$\satisfies{M, (\chi', \{\prg{local} = \beta[x \mapsto v]; \prg{contn} = s\} : \psi)}{\prg{a.balance >= bal}}$$
%\end{proof}
