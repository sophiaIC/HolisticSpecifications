\section{Proof of Guarantee of Safety in \S\ref{sec:how}}
\label{app:safety}
\jm[]{
In this section we provide a proof sketch that \SrobustB ensures our balance
does not decrease in contexts with no access to our password. This 
property is expressed in \S\ref{sec:how}, and the example is repeated below.
}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{1}$
     ...
    method cautious(untrusted:Object)
        a = new Account
        p = new Password
        a.set(null,p)
        ...
        untrusted.make_payment(a)
        ...
\end{lstlisting}
\jm[]{
Informally, the property we wish to express of the above code snippet is 
that as long as there is no \prg{untrusted} does not have external access (whether transitive or direct)
to \prg{a.password} before the call on line 7, then \prg{a.balance} will not decrease during the 
execution of line 8. This property is expressed and proven in Theorem \ref{thm:safety}.
}
%\begin{itemize}
%\item
%suppose we rewrite \prg{Mod$\_1$} such that we duplicate all methods used in line 7. In the duplicated version of the methods
%we add a tuple as an argument that contains the account, and the current password. In every duplicate method, whenever the
%method \prg{setPassword} is called, we check if the receiver is \prg{a}, and if so we update the password in the tuple to the 
%new password. In this manner by the end of line 7, we still know what the password of the account is.
%\item
%We then insert the following code at the end of line 7:\\
%\prg{a.setPassword(t.snd(), new Password())}
%\item
%We are now in an arising program state where there is no external knowledge of the password, and we are able to apply \SrobustB
%\end{itemize}

%\begin{lemma}[Out of Scope heap locations are not modified by execution]
%Let $\sigma_1 = (\chi_1, \phi_1 : \psi)$ and $\sigma_2 = (\chi_2, \phi_2 : \psi)$ be program states such that
%$\reductions{M}{M'}{\sigma_1}{\sigma_2}$ for some modules $M$ and $M'$.
%Let $\chi = \chi_A \cup \chi_B$, where $\chi_A$ is the portion of the heap that is not
%transitively accessible by $\phi_1.(\prg{this})$ (i.e. the transitive closure of $\access{\_}{\_}$), then $\chi_A \subset \chi_2$.
%\end{lemma}
%\begin{proof}
%We proceed simply by contradiction. Suppose that $\chi_A \not\subset \chi_2$, that means that there must 
%have been some single execution step where $\chi_A$ was modified. Such a step requires access to some object $o$
%in $\chi_A$. Thus, there must have been some series of execution steps that provided access to $o$ to an object $o'$
%that is transitively accessible from $\phi_1.(\prg{this})$. This contradicts our premise.
%\end{proof}

\begin{lemma}[Execution is unaffected by out of scope heap locations]
\label{lemma:scoped-execution}
Let $\sigma_1 = (\chi_1, \phi_1 : \psi)$ and $\sigma_2 = (\chi_2, \phi_2 : \psi)$ be program states such that
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$ for some modules $M$ and $M'$.
Let $\chi = \chi_A \cup \chi_B$, where $\chi_A$ is the portion of the heap that is not
transitively accessible by $\phi_1.(\prg{this})$ (i.e. the transitive closure of $\access{\_}{\_}$), then 
\begin{enumerate}
\item
there exists $\chi_C$ such that $\chi_2 = \chi_A \cup \chi_C$ and 
\item
for any $\chi_A'$, we have $\reductions{M}{M'}{(\chi_A' \cup \chi_B, \phi_1 : \psi)}{(\chi_A' \cup \chi_C, \psi_2)}$
\end{enumerate}
\end{lemma}
\begin{proof}
In both instances we proceed simply by contradiction. 

\begin{enumerate}
\item
Suppose that $\chi_A \not\subset \chi_2$, that means that there must 
have been some single execution step where $\chi_A$ was modified. Such a step requires access to some object $o$
in $\chi_A$. Thus, there must have been some series of execution steps that provided access to $o$ to an object $o'$
that is transitively accessible from $\phi_1.(\prg{this})$. Such a series of execution steps requires transitive
access from $\sigma.(\prg{this})$ (whether by method calls or field accesses) since heap locations in \Loo are unforgeable.
Such a case would imply transitive access from $\sigma.(\prg{this})$ to $o$. This contradicts our premise.

\item
For execution to differ in the modified program state $(\chi_A' \cup \chi_B, \phi_1 : \psi)$,
that would imply that there must have been at least one execution step that differed in outcome due to the presence of $\chi_A'$ over $\chi_A$.
By case analysis on the semantics of \Loo detailed in Fig. \ref{f:loo-semantics}, we can see that in each instance for 
a result from execution to differ as a result a modification to the heap (when all else remains that same), would require transitive access 
to the modified portion of the heap. Again, as before this implies a contradiction to our original premise.
\end{enumerate}
\end{proof}

\begin{lemma}[Constructing an Effectively Equivalent Heap]
\label{lemma:garbage}
Let $\sigma = (\chi_A \cup \chi_B, \phi : \psi)$ be a program state arising (in the context of internal module $M_I$, and external module $M_E$)
and let $o$ be an object in $\chi_B$, where $\chi_A$ is the set of all objects that are 
not transitively accessible by $o$. Let $p$ be some internal object in $\chi_B$ of class $C$. There exists some 
$M_E'$ and $\chi_A'$ such that $(\chi_A' \cup \chi_B, \phi : \psi)$ is \textit{Arising}
in modules $M_I$ and $M_E'$ and for all $o'$ in $\chi_A'$, $\satisfies{M_I; (\chi_A', \chi_B, \phi : \psi)}{\neg \access{o}{o'}}$
\end{lemma}
\begin{proof}
The solution is to start by creating an $M_E'$ that results in such a $\chi_A'$. To attain such a module we
\begin{enumerate}
\item
add a \prg{nullify} method to all classes in $M_E$, that when called replaces all references to objects of type $C$ with \prg{null}
\item
for each instance in the execution from the initial program state until $\sigma$, whenever an external object with 
access to an object of type $C$ is about to leave scope for the remainder of that execution (whether by overwriting a reference, or by making a method call),
a duplicate of that method is made, and in the duplicate we insert a call to \prg{nullify} on that object. The current call 
is then replaced with a call to the duplicate of that method
\end{enumerate}
In this way we are effectively manually ``garbage collecting'' objects of type $C$. The result of this $M_E'$ will be a $\chi_A'$ that does not have
any references to object $p$. Further, since the process only works when objects leave scope, none of the modified objects will be in $\chi_B$.
\end{proof}

\begin{theorem}[\SrobustB Guarantees Account Safety]
\label{thm:safety}
Let \prg{BankMdl} be some module that satisfies \SrobustB, 
$M$ be some external module, and $\sigma_1 = (\chi_1, \phi_1 : \psi_1)$ be some \textit{Arising} program state. If the continuation of $\phi_1$, $c_1$, is
\begin{verbatim}
a = new Account; 
p = new Password; 
a.set(null,p); 
s; 
untrusted.make_payment(a, z1, ..., zn); ...
\end{verbatim}
let 
\begin{itemize}
\item
$\sigma_2 = (\chi_2, \phi_2 : \psi_2)$ be the program state immediately preceding the execution of \prg{s}
\item
$\sigma_3 = (\chi_3, \phi_3 : \psi_3)$ be the program state immediately following the execution of \prg{s}
% where $\satisfies{\prg{BankMdl};\sigma_3}{\prg{a.password} \neq \prg{zk}}$ for all $i \leq \prg{k} \leq n$
\item
$\sigma_4 = (\chi_4, \phi_4 : \psi_4)$ be the program state immediately following the execution of\\ \prg{untrusted}\prg{.make\_payment}\prg{(a, z1, ..., zn)} 
\end{itemize}
if 
\begin{itemize}
\item
for all objects $o \in \chi_3$ such that $\satisfies{\prg{BankMdl}; \sigma_3}{\access{o}{\prg{a.password}}}$ and $o$ is transitively accessible (i.e. the transitive closure of $\access{\_}{\_}$) from \prg{untrusted}
then $\satisfies{\prg{BankMdl}; \sigma_3}{\internal{o}}$, and
\item
$\satisfies{\prg{BankMdl}; \sigma_3}{\prg{a.balance} = b}$
\end{itemize}
then 
\begin{itemize}
\item
$\satisfies{\prg{BankMdl};\sigma_4}{\prg{a.balance} \geq b}$.
\end{itemize}
\end{theorem}
\begin{proof}
The challenge in constructing a proof is that \SrobustB is not directly applicable to $\sigma$ since there may be an external 
object that has access to \prg{a.password}, depending on what code exists in \prg{s}. For example, if \prg{s} 
is blank then $\sigma_1.(\prg{this})$ has access to \prg{a}. The challenge is to then create 
a program state where there is no external access to \prg{a.password}, but the execution of \prg{untrusted.make\_payment(a, z1, ..., zn)}
is effectively equivalent. Such a program state must also be \textit{Arising} for us to apply the \Nec specification 
\SrobustB to it.

By Lemma \ref{lemma:garbage}, we know that there exists such a program state, and that we can construct it. By Lemma \ref{lemma:scoped-execution} this will 
not alter the execution of \prg{untrusted.make\_payment(a, z1, ..., zn)}.
Thus, it follows that \prg{a.balance} in $\chi_3'$ is equal to \prg{a.balance} in $\chi_3$.
Since \SrobustB is applicable to $\sigma_3'$, we can conclude that \prg{a.balance} in $\chi_4'$ (and thus $\chi_4$)
remains unchanged.
\end{proof}




