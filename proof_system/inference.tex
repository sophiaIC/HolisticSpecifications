\title{Chainmail Inference System}	

\documentclass[12pt]{article}
	
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{color,soul}
\usepackage{oz}
\usepackage{listings}
\usepackage{color}
\usepackage{csquotes}	
\usepackage{relsize}
\usepackage{stackengine}
\usepackage{graphicx}
\usepackage[dvipsnames]{xcolor}

%constrained reduction
\newcommand{\constrained}{\mathrel{\leadsto\ \!\!\!\!{\raisebox{1pt}{$\mathsmaller{\mathsmaller{\mathsmaller{\mathsmaller\rvert}}}$}}}}
\newcommand{\reduction}[4]{#1\ \fcmp\ #2\ \bullet\ #3\ \leadsto\ #4}
\newcommand{\reductions}[4]{#1\ \fcmp\ #2\ \bullet\ #3\ \leadsto^*\ #4}
\newcommand{\constrainedReduction}[4]{#1\ \fcmp\ #2\ \bullet\ #3\ \constrained\ #4}
\newcommand{\constrainedReductions}[4]{#1\ \fcmp\ #2\ \bullet\ #3\ \constrained^*\ #4}
\newcommand{\satisfies}[4]{#1\ \fcmp\ #2,\ #3 \vDash\ #4}

\newcommand\trans{\mathlarger{\mathlarger \leadsto}}
\newcommand\intstep{\hspace{1.5mm}{\raisebox{3pt}{$\bullet$}}\hspace{-1.5mm}{\hookrightarrow}}
\newcommand\en{\hspace{1.5mm}{\raisebox{0pt}{$\bullet$}}\hspace{-4mm}{\hookrightarrow}}
\newcommand\oi{\hspace{1mm}{\raisebox{1pt}{$\bullet$}}\hspace{-1mm}{\trans}}
\newcommand\ot{\hspace{2mm}{\raisebox{1pt}{$\bullet$}}\hspace{-3mm}{\trans}}
\newcommand\otAlt{\hspace{2mm}{\raisebox{0.5pt}{$\bullet$}}\hspace{-2.75mm}{\trans}}
\newcommand\mut[3]{\langle #1\ \texttt{mut}\ #2.#3 \rangle}
\newcommand\gives[3]{\langle #1\ \texttt{gives}\ #2\ \texttt{to}\ #3 \rangle}
\newcommand\exposes[2]{#1\ \texttt{exposes}\ #2}
\newcommand\univ{U}
\newcommand\onlyIf[3]{#1,\ #2\ \oi\ #3}
\newcommand\oiInternal[3]{#1,\ #2\ \intstep\ #3}
\newcommand\ensures[3]{#1,\ #2\ \en\ #3}
\newcommand\onlyThrough[3]{#1,\ #2\ \ot\ #3}
\newcommand\hoare[3]{\{#1\}\ #2\ \{#3\}}
\newcommand\hoareIf[4]{#1,\ #2,\ \{#3\}\ \intstep\ #4}
\newcommand\rtrns[3]{\{#1\}\ #2\ \texttt{returns}\ #3}
\newcommand\effect[3]{\{#1\}\ #2\ [#3]}

\newcommand\encapsulated[1]{\langle \texttt{encapsulated}\ #1 \rangle}
\newcommand\encapsulates[2]{\langle #1\ \texttt{encapsulates}\ #2 \rangle}
\newcommand\encapsulatesStrong[2]{\langle #1\ \texttt{encapsulates}_\texttt{strong}\ #2 \rangle}
\newcommand\encapsulatesMdl[1]{\langle \texttt{encapsulating}_\texttt{int}\ #1 \rangle}
\newcommand\calls[4]{\langle #1\ \texttt{calls}\ #2.#3(#4) \rangle}
\newcommand\changes[2]{\langle #1\ \texttt{changes}\ #2 \rangle}
\newcommand\access[2]{\langle #1\ \texttt{access}\ #2 \rangle}
\newcommand\internal[1]{\langle #1\ \texttt{internal}\rangle}
\newcommand\external[1]{\langle #1\ \texttt{external}\rangle}
\newcommand\comprehension[2]{\{#1 | #2\}}
\newcommand\internalStep{\langle \texttt{internal step}\rangle}
\newcommand\sepImpl{-\hspace{-1.5mm}*}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{case}{Case}
\newtheorem{subcase}{Subcase}
\newtheorem{lemma}{Lemma}

\numberwithin{case}{lemma}
\numberwithin{case}{theorem}
\numberwithin{subcase}{case}

\renewcommand\lstlistingname{Quelltext} % Change language of section name

\lstset{ % General setup for the package
	language=Java,
	basicstyle=\scriptsize\sffamily,
	numbers=left,
 	numberstyle=\tiny,
	frame=tb,
	tabsize=4,
	columns=fixed,
	showstringspaces=false,
	showtabs=false,
	keepspaces,
	morekeywords={field, method, module, calls, presumes, achieves, external, internal, access},
	commentstyle=\color{red},
	keywordstyle=\color{blue},
	deletekeywords={if}
}

\date{}

\begin{document}
\maketitle

\section{Mutation and Access}


In this Section I try to define ``Only Through'' and ``Only If'' without using the intermediate of ``Only By''.
To do this I extend the assertion syntax to include a new assertion form
\begin{itemize}
\item
$\changes {S}{A}$ {\color{red}(Julian: not so new actually, but maybe different)}: 
The satisfaction of $A$ changes as the result of a single constrained execution step
by $x$.
%\item
%$\mut{x}{y}{f}$: 
%This can be interpreted as essentially the same as $\exists z.[\changes{x}{y.f = z}]$, but with
%the added specification that $x$ was the object resposible for the mutation.
%\item
%$\gives{x}{y}{z}$: this can be interpreted as $\changes{x} {\access z y}$, but with the 
%added specification that $x$ was the object resposible for the granting of access to $y$
\end{itemize}
{\color{red}(Julian: this can model both $\mut{x}{y}{f}$ and $\gives{x}{y}{z}$ 
as $\changes{x}{\exists z.[y.f=z]}$ and $\changes{x}{\neg \access{z}{y}}$, but 
is also able to capture the necessary specification for the DAO that is more 
nuanced than just heap mutation, i.e. 
$\changes{\_}{\texttt{d.balances()} \geq \texttt{ether}}$. It)}

\noindent Thus, we give the new assertion syntax in Figure \ref{f:assertions_triple2}.
	
	\begin{figure}[h]
	\[
	\begin{array}{llr}
	A & ::= & \textit{Assertions}\\  
	| & e & \\
	| & e\ :\ C & \\
	| & e\ \in\ S & \\
	| & A\ \texttt{in}\ S & \\
	| & \access{x}{y} \\
	| & \internal{x} \\
	| & \external{x} \\
%	| & \mut x y f &\\
%	| & \gives x y z &\\
	| & \calls{x}{y}{m}{args} \\
	| & \changes{S}{A} \\
	| & \neg A & \\
	| & A\ \wedge\ A & \\
	| & A\ \vee\ A & \\
	| & A\ \longrightarrow\ A & \\
	| & \forall\ x.\ [A] & \\
	| & \exists\ x.\ [A] & \\
	| & \forall\ S.\ [A] & \\
	| & \exists\ S.\ [A] &
	\end{array}
%	\begin{array}{llr}
%	s & ::= & \textit{Source}\\
%	| & \texttt{int} & \\
%	| & \texttt{ext} & \\
%	| & \_ &
%	\end{array}
	\]
	\caption{Assertions}
	\label{f:assertions_triple2}
	\end{figure}
Formally, this new assertion form has the following semantics:
\begin{itemize}
\item
$M_1\ \fcmp\ M_2,\ \sigma\ \vDash\ \changes {S} {A}$ if and only if there exists $\sigma'$ such that 
\begin{itemize}
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$ and
\item
$M_1\ \fcmp\ M_2,\ \sigma\ \vDash\ A$ and
\item
$M_1\ \fcmp\ M_2,\ \sigma'\ \vDash\ \neg A$ and
\begin{itemize}
\item
$M_1\ \circ\ M_2,\ \bullet\ \sigma\ \leadsto \sigma'$ and $\sigma.(\texttt{this})\ \in\ S$ or
\item
$\exists \sigma_1, \ldots, \sigma_n$ such that
\begin{itemize}
\item
$M_1\ \circ\ M_2,\ \bullet\ \sigma\ \leadsto\ \sigma_1\ \leadsto\ \ldots\ \leadsto\ \sigma_n \leadsto \sigma'$ and
\item
$M_1\ \fcmp\ M_2,\ \sigma_i\ \vDash\ \internal{\sigma_i.(\texttt{this})}$ for all $1 \leq i \leq n$ and
\item
$M_1\ \fcmp\ M_2,\ \sigma_j\ \vDash\ A$ and $M_1\ \fcmp\ M_2,\ \sigma_{j + 1}\ \vDash\ \neg A$ for some $1 \leq j < n$ and
\item
$\sigma_j.(\texttt{this})\ \in\ S$
\end{itemize}
\end{itemize}
\end{itemize}
{\color{red}(Julian: I'm not 100\% sure if this form of \texttt{changes} makes sense. It works for things like $\changes{x}{y.f=\_}$ and $\changes{z}{\access{x}{y}}$, but not $\changes{x}{\calls{x}{y}{m}{args}}$. I did think about an alternate form of \texttt{changes} that 
was just $\langle \texttt{changes}\ A \rangle$, and then coupled this with $\mut{x}{y}{f}$ and $\gives{x}{y}{z}$, but it seemed imprecise and inefficient.)}
%\item
%$M,\ \sigma \vDash\ \mut{x}{y}{f}$ iff $\forall\ v,\ \sigma',$ such that $M\ \sigma\ \vDash\ y.f\ =\ v$ and $M\, \sigma\ \vDash\ \sigma\ \constrained\ \sigma'$ then 
%\begin{itemize}
%\item
%$M\ \sigma'\ \vDash\ y.f\ \neq\ v$ and
%\item
%either
%\begin{itemize}
%\item
%$\lfloor this \rfloor_\sigma\ = x$ and $\sigma.(\texttt{contn})$  is not an internal method call or
%\item
%$M,\ \sigma\ \vDash\ \exists x'\ m\ args,[\langle x'\ \texttt{calls}\ x.m(args)\rangle\ \wedge\ \langle \texttt{internal}\ x\rangle]$
%\end{itemize}
%\end{itemize}
%\item
%$M,\ \sigma\ \vDash\ \gives{x}{y}{z}$ iff $\forall\ \sigma',$ such that $M\, \sigma\ \vDash\ \sigma\ \constrained\ \sigma'$ then 
%\begin{itemize}
%\item
%$M,\ \sigma\ \vDash\ \neg \access z y$ and
%\item
%$M,\ \sigma'\ \vDash\ \access z y$ and 
%\item
%either
%\begin{itemize}
%\item
%$\lfloor this \rfloor_\sigma = z$, $\sigma.(\texttt{contn})\ =\ (\_\ :=\ x.f; \_)$, and $\lfloor x.f \rfloor_\sigma = y$ or
%\item
%$\lfloor this \rfloor_\sigma = x$ and $\sigma.(\texttt{contn})\ =\ (z.f\ :=\ y; \_)$ or
%\item
%$\lfloor this \rfloor_\sigma = x$, $\sigma.(\texttt{contn}) = (\texttt{return}\ y)$, and $\sigma'.(this) = z$ or
%\item
%$\lfloor this \rfloor_\sigma = x$ and $\sigma.(\texttt{contn}) = (\_ := z.m(\_, y,\_))$ or
%\item
%$M,\ \sigma\ \vDash\ \{A\}\ \calls {x'} {y'} m {\texttt{args}}\ \{\gives {x}{y}{z} \}$ and $M, \sigma\ \vDash\ A\ \wedge\ \internal{x'}\ \wedge\ \calls {x'} {y'} m {\texttt{args}}$
%\end{itemize}
%\end{itemize}
\end{itemize}

\section{Only Through and Only If}

\begin{enumerate}
\item
\emph{Only Through} [$\onlyThrough{A_1}{A_2}{A}$]: If a program execution starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.\\
e.g.if the balance of the bank account changes over time, then the paths connecting the two states must contain 
an intermediate program state where the balance is changed.
\item
\emph{Only If} [$\onlyIf{A_1}{A_2}{A}$]: If program execution starts at some $A_1$ state, and reaches some $A_2$ state, 
then the original program state must have also satisfied $A$.\\
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account.
\end{enumerate}

\begin{definition}[\textsc{Only Through}]
\label{def:ot}
$M \vDash\ \onlyThrough {A_1}{A_2}{A}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$M \fcmp M', \sigma_1\ \vDash A_1$
\item
$M \fcmp M', \sigma_2\ \vDash\ A_2$ and
\item
$M \fcmp M'\ \bullet\ \sigma_1\ \constrained^*\ \sigma_2$
\end{itemize}
then $\exists\ \sigma,$ such that
\begin{itemize}
\item
$\sigma\ =\ \sigma_1$ or $M \fcmp M'\ \bullet\ \sigma_1\ \constrained^*\ \sigma$
\item
$M \fcmp M'\ \bullet\ \sigma\ \leadsto^*\ \sigma_2$
\item
$M \fcmp M',\ \sigma\ \vDash\ A$
\end{itemize}
\end{definition}
We give the definition of ``only  through'' in Def. \ref{def:ot}. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
but may not be the final state ($\sigma_2$). The reason for this is
the triple is explicitly stating the behaviour that must occur prior to
the final state in order for it to be true. That is, 
if we say $M\ \vDash\ \onlyThrough{x.f=y}{x.f \neq y}{\changes{\_}{x.f=y}}$,
we intend to say that the mutation of $x.f$ must occur prior to $x.f\neq y$

\begin{definition}[\textsc{Only If}]
\label{def:oi}
$M \vDash\ \onlyIf {A_1}{A_2}{A}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$M \fcmp M', \sigma_1\ \vDash A_1$
\item
$M \fcmp M', \sigma_2\ \vDash\ A_2$ and
\item
$M \fcmp M'\ \bullet\ \sigma_1\ \constrained^*\ \sigma_2$
\end{itemize}
then $M \fcmp M',\ \sigma_1\ \vDash\ A$
\end{definition}

\section{Encapsulation}

I now introduce a few Chainmail predicate
forms of expressing encapsulation of data, and
discuss the topic of encapsulation more generally.
In Chainmail, the natural form of encapsulation is 
data being encapsulated by module internal component objects. Thus, we can define encapsulation in the following way:
$$\encapsulated x\ \equiv\ \forall y.[\neg \access y x\ \vee\ \internal y\ \vee\ y = x]\ \wedge\ x \neq \texttt{this}$$
Thus, we are saying that an object is regarded as encapsulated
if only internal objects have access to it.
This version of encapsulation is not however sufficient for the Safe example, as 
in that case we need to talk about encapsulation of data by some data structure 
that does not necessarily include all module internal objects, and may even include 
module external objects. In the Safe example we define this using a ghost field definition \texttt{is\_internal}.
%For that reason we define a more general form of 
%encapsulation. First we first define membership of a set comprehension,
%or, an abstract definition of set membership based on
%the satisfaction of some assertions.
%$$e\ \in\ \{x | A^x\}\ \equiv\ \exists S.[\forall z.[(\neg z\ \in\ S\ \vee\ A^z)\ \wedge\ (\neg A^z\ \vee\ z\ \in\ S)]\ \wedge\ e\ \in\ S]$$
%Now we can express alternative forms of encapsulation.
To this end we first define encapsulation of an object by a subset of the heap:
$$\encapsulates {S} {x}\ \equiv\ \forall y.[\neg \access y x\ \vee\ y\ \in\ S]$$
That is, a set $S$ encapsulates an object $o$ if and only if only objects in $S$
have access to $o$.
This form of encapsulation is expressive enough to express encapsulation for some safe $s$:
$$\forall y.[y \in S\ \longleftrightarrow s.\texttt{is\_internal}(y)]\ \wedge\ \encapsulates {S}{x}$$
Note in the above example, $s$ is some safe, and \texttt{is\_internal} is a ghost field defined 
in the \texttt{Safe} class that defines what is internal to some instance of safe.
Further, we use $A_1\ \longleftrightarrow\ A_2$ as shorthand for 
$(A_1\ \longrightarrow\ A_2)\ \wedge\ (A_2\ \longrightarrow\ A_1)$.

Both of these forms of encapsulation are related. We can think of $\internal {\_}$ as representative of the 
subset of the heap that contains all module internal objects and nothing else. If we call this set $I$, one distinction between 
$I$ and the $S$ used in the Chainmail syntax is that since $S$ refers to a concrete set of objects and is defined in a specific program state it has a fixed size over execution,
while $I$ grows monotonically (new module internal objects may be created, but never destroyed). Thus, there is a general 
form from which both \texttt{encapsulated} and \texttt{encapsulates} can be
expressed. In order to find a general way to express both these forms of encapsulation
we need a general definition of encapsulation.
Such general definition of an encapsulating set might be
\begin{quote}
An encapsulating set $S$ of an object $o$ is a subset of the objects in the heap
whereby objects external to the set may only gain access by a member of $S$ explicitly 
giving away access to $o$ via either a method call, a field read, or a field write.
\end{quote}
Note, the size and membership of the set does not necessarily need to be immutable over program execution, 
and the above definition can encompass our the module internal set of objects as used
in our first definition of encapsulation. Further, as in our 
definition of internal for the Safe example, such an encapsulating set might be static. 
Chainmail already has an obvious way to define a static set, but it is not obvious
that there is a way to define a set that potentially changes over program execution.
In order to model such a set, we extend Chainmail with a set comprehension form given 
in Figure \ref{f:sets}.
\begin{figure}[h]
	\[
	\begin{array}{llr}
	\mathcal{S} & ::= & \textit{Set}\\
	| & S & \textit{Concrete}\\
	| & \comprehension{x}{A^x} & \textit{Comprehension}\\
	\end{array}
	\]
	\caption{Set Syntax}
	\label{f:sets}
\end{figure}
Here sets are defined as either a concrete set of elements that does not vary over 
program execution, and a set comprehension that defines its members by satisfaction of 
an assertion. Note, I use the $A^x$ to indicate that $x$ is free in $A$. We can define 
the set membership for comprehensions using existing Chainmail definitions:
%$$M,\ \sigma\ \vDash\ e\ \in\ \comprehension{x}{A^x}\ \textit{iff}\ M,\ \sigma\ \vdash\ e\ \hookrightarrow\ \alpha\ \textit{and}\ M,\ \sigma\ \vDash\ [\alpha/x]A$$
$$e\ \in\ \comprehension{x}{A^x}\ \equiv\ \exists x.[e = x\ \wedge\ A^x]$$
Thus, an expression $e$ is an element of a set comprehension defined by assertion $A^x$ 
if and only if
$e$ evaluates to some address in the heap and $A^x$ is satisfied when substituted with that address.
%, and 
%that value is an object in the heap (i.e. there is some set that $e$ is part of, even if that set is just $\{x\}$, although this may not).
Clearly the elements of set comprehensions are dependent on the entire program configuration, 
not just the heap, and for that reason might change during program execution. We are 
now able to explicitly define the set referred to by \texttt{internal}, i.e. $I$:
$$I\ \triangleq\ \comprehension{x}{\internal x}$$

Our definition of encapsulation of an object by a set does not generally hold
for all sets defined using a set comprehension. As an example, consider the set
defined as the internal, constituent objects that make up some linked list $l$, 
where the ghost field \texttt{is\_internal} returns true for each node that makes 
up the list, and nothing else.
$$L\ \triangleq\ \comprehension{x}{\texttt{l.\texttt{is\_internal(x)}}}$$
If one of those nodes $n$ of $l$ contains some object $o$, is $\encapsulates{L}{o}$
true? By the definition given earlier, the answer is no. If $n$ is removed from the list,
then implicitly an object external to $L$ has access to $o$ (i.e. $n$), however 
nothing has gained or lost access to $o$ so this change in access is not explicit, and so 
does not meet our earlier definition. It is possible to design a linked list that 
took a stricter approach to encapsulation by ensuring that whenever a node was removed 
from the list, all connections to encapsulated data were removed too.
It is not immediately clear how one would
go about generally defining which sets do properly encapsulate data by our definition, and which do not.
It is true that those sets that grow monotonically over program execution (as with $I$)
do encapsulate data by our definition.

{\color{red}Julian: I'm not sure if there is a way to generally define encapsulating sets
other than to restrict it to the conservative form of sets that grow monotonically. For this 
reason at least, there is likely to be a completeness issue with the proof rules. i.e. there
are some set comprehensions that can be defined that do encapsulate data in the way defined in
this section, and thus have some ``only through'' statement about this encapsulation that is
unprovable until we can more accurately define these encapsulating sets.

The only definition that I can think of would be ``those sets that require 
operations on one or more of their members to expose encapsulated data''. From the perspective
of designing proof rules, this is unhelpful as it is basically a restatement of the rule for how 
encapsulated data may be accessed by external object, i.e.
``data encapsulated by a set may only be externally accessed by an operation on one of the members of the set''
This is an obvious circularity.

Ideally we would like some easily verifiable definition of an encapsulating set (given as ``$\mathcal{S}\ \textit{is an encapsulating set}$'' below), and then use the following proof rule:
\begin{mathpar}
\infer
	{
	A = \encapsulates {\mathcal{S}} {y} \\
	\mathcal{S}\ \textit{is an encapsulating set}
	}
	{
	M\ \vdash\ \onlyThrough
		{A}
		{\neg A}
		{\exists x\ z.[\gives{x}{y}{z}\ \wedge\ 
		                   x \in S \wedge\ 
		                   z \not\in s]}
	}
\end{mathpar}}
{\color{Green}
\subsection{Encapsulating Sets}
We define several predicates for encapsulation of one set by another, along with related concepts.
\begin{enumerate}
\item
$\langle S_1\ \texttt{encapsulates}\ S_2 \rangle\ \triangleq\ \forall x, y.[\neg y \in S_2\ \vee \neg \access{x}{y}\ \vee\ x\ \in\ S_1\ \cup\ S_2]\ \wedge\ \texttt{this}\ \not\in\ S_2$
\item
$\encapsulates{x}{S}\ \triangleq\ \encapsulates{\comprehension{y}{y = x}}{S} $
\item
$\textit{int}(S)\ \triangleq\ \comprehension{x}{x\ \in\ S\ \wedge\ \internal{x}}$
\item
$\textit{ext}(S)\ \triangleq\ \comprehension{x}{x\ \in\ S\ \wedge\ \external{x}}$
\item
$\encapsulatesMdl{S}\ \triangleq\ \encapsulates{S^\texttt{int}}{S^\texttt{ext}}$
\end{enumerate}

We can rewrite some of our earlier predicates in terms of encapsulation of a set by another set:
\begin{enumerate}
\item
$\encapsulated{x}\ \equiv\ \encapsulates{\comprehension{y}{\internal{y}}}{\comprehension{z}{z = x}}$
\item
$\encapsulates{x}{y}\ \equiv\ \encapsulates{\comprehension{x'}{x' = x}}{\comprehension{y'}{y' = y}}$
\end{enumerate}
This generalization is useful not just because it is able to express both previous forms of 
encapsulation, but also because it is able to express more complex forms of encapsulation
that follow both the structure of an ADT, along with that of the internal module. As an example,
consider the Safe. The simplified version of the safe expresses the secret as a single object, 
however it could in fact be a complex datastructure with it's own notion of ``internal''. To 
fully specify the Safe, we would like to be able to state that the Safe encapsulates the entire
secret, not just the representative object of the secret. Further, we would want to be able to 
say that the module internal part of the safe encapsulates all module external parts of the safe,
and thus that any changes involving the module external aspects must be done via the module internal
(in this case, the Safe itself).
}



\section{Proof System}
\label{s:proof_system}

I now introduce the proof system for Chainmail. The proof system consists of four relations with the following informally presented semantics:
\begin{enumerate}
\item
$M\ \vdash\ A$: for all $M'$ and $\sigma$ $M\ \fcmp\ M',\ \sigma\ \vdash\ A$
\item
$M\ \vdash\ \oiInternal{A_1}{A_2}{A}$: for all $M'$ and $\sigma$, such that the continuation of $\sigma$ is either a call or return to internal code, if $A_1$ is true before execution, and $A_2$ is true when program evaluations next returns to external code, it follows that $A$ 
was true in the original program state.
\item
$M\ \vdash\ \onlyThrough{A_1}{A_2}{A}$: for all program states that satisfy $A_1$, and after some number of execution steps results in a program state satisfying $A_2$, then it follows that some intermediate program state satisfied $A$.
\item
$M\ \vdash\ \onlyIf{A_1}{A_2}{A}$: for all program states that satisfy $A_1$, and after some number of execution steps results in a program state satisfying $A_2$, then it follows that $A$ was satisfied by the original program state.
\end{enumerate}
All of these relations are mutually defined. We start with the rules for $M\ \vdash\ \onlyThrough{A_1}{A_2}{A}$, otherwise referred to as ``Only Through''. I follow up with $M\ \vdash\ \onlyIf{A_1}{A_2}{A}$ (``Only If''), $M\ \vdash\ \oiInternal{A_1}{A_2}{A}$, and finally $M\ \vdash\ A$.

{\color{red}(Julian: I think this makes a bit more sense that the 
previous version as it keeps the different properties each relation is
trying to express confined to that relation. i.e. $M\ \vdash\ \onlyThrough{A_1}{A_2}{A}$ and 
$M\ \vdash\ \onlyIf{A_1}{A_2}{A}$) are only concerned with proofs of temporal 
specifications. Other proofs can then be constructed in a normal logic.)}

\subsection{Temporal Specifications as ``Only Through'' and ``Only If''}

Figure \ref{f:only_through} provides the proof rules for ``Only Through''.


%\begin{figure}[t]
%\begin{mathpar}
%\infer
%	{}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{\texttt{true}}}
%	\quad(\textsc{True})
%	\and
%\infer
%	{}
%	{
%	M\ \vdash\ \onlyThrough{x.f\ =\ y}{x.f\ \neq\ y}{\exists z.[\mut{z}{x}{f}]}
%	}
%	\quad(\textsc{Mut$_1$})
%	\and
%\infer
%	{}
%	{
%	M\ \vdash\ \onlyThrough{x.f\ \neq\ y}{x.f\ =\ y}{\exists z.[\mut{z}{x}{f}]}
%	}
%	\quad(\textsc{Mut$_2$})
%	\and
%\infer
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists z.[\mut{z}{x}{f}]}}
%	{
%	M\ \vdash\ \onlyThrough{A_1\ \wedge\ \internal{x}}{A_2}{\exists z.[\mut{z}{x}{f}\ \wedge\ \internal {z}]}
%	}
%	\quad(\textsc{Mut-Int})
%	\and
%%\infer
%%	{
%%	M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists z.[\mut{z}{x}{f}]}
%%	}
%%	{
%%	M\ \vdash\ \onlyThrough
%%					{A_1\ \wedge\ \langle \texttt{internal}\ x \rangle}
%%					{A_2}
%%					{\exists z.[\mut{z}{x}{f}\ \wedge\ \langle \texttt{internal}\ z \rangle]}
%%	}
%%	\quad(\textsc{Mut-Int})
%%	\and
%\infer
%	{}
%	{M\ \vdash\ \onlyThrough{\neg \langle x\ \texttt{access}\ y \rangle}{\langle x\ \texttt{access}\ y \rangle}{\exists z.[\gives{z}{x}{y}]}}
%	\quad(\textsc{Give})
%	\and
%\infer
%	{
%	A = \encapsulated {y} \\
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists x,\ z.[\gives {x}{y}{z}]}
%	}
%	{
%	M\ \vdash\ \onlyThrough
%		{A_1\ \wedge\ A}
%		{A_2}
%		{\exists x,\ z.[\gives{x}{y}{z}\ \wedge\ \internal {x}]}
%	}
%	\quad(\textsc{Give-Int$_1$})
%	\and
%\infer
%	{
%	A = \encapsulated {y} \\
%%	M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists x\ z.[\gives{x}{y}{z}\ \wedge\ \internal{x}]}
%	}
%	{
%	M\ \vdash\ \onlyThrough
%		{A}
%		{\neg A}
%		{\exists x,\ z.[\gives{x}{y}{z}\ \wedge\ 
%		                   \internal{x} \wedge\ 
%		                   \external{z}]}
%	}
%	\quad(\textsc{Give-Int$_2$})
%	\and
%\infer
%	{
%	A = \encapsulates {S} {y} \\
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists x\ z.[\gives {x}{y}{z}]}
%	}
%	{
%	M\ \vdash\ \onlyThrough
%		{A_1\ \wedge\ A}
%		{A_2}
%		{\exists x,\ z.[\gives{x}{y}{z}\ \wedge\ x \in S]}
%	}
%	\quad(\textsc{Give-Set$_1$})
%	\and
%\infer
%	{
%	A = \encapsulates {S} {y}
%%	M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists x\ z.[\gives{x}{y}{z}\ \wedge\ x \in S]}
%	}
%	{
%	M\ \vdash\ \onlyThrough
%		{A}
%		{\neg A}
%		{\exists x,\ z.[\gives{x}{y}{z}\ \wedge\ 
%		                   x \in S \wedge\ 
%		                   z \not\in s]}
%	}
%	\quad(\textsc{Give-Set$_2$})
%\end{mathpar}
%\caption{\emph{Only Through} - Mutation and Encapsulation Rules}
%\label{f:only_through_base}
%\end{figure}
\begin{figure}[p]
\begin{mathpar}
\infer
	{}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{\texttt{true}}}
	\quad(\textsc{True})
	\and
\infer
	{}
	{
	M\ \vdash\ \onlyThrough{A}{\neg A}{\exists S.[\changes{S}{A}]}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	M\ \vdash\ A_1 \longrightarrow A_1'\\
	M\ \vdash\ A_2 \longrightarrow A_2'\\
	M\ \vdash\ A_3' \longrightarrow A_3\\
	M\ \vdash\ \onlyThrough{A_1'}{A_2'}{A_3'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3}}
	\quad(\textsc{$\longrightarrow$})
%	\and
%\infer
%	{
%	M\ \vdash\ A \longrightarrow A'\\
%	M\ \vdash\ \onlyThrough{A_1}{A'}{A_2}
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A}{A_2}}
%	\quad(\textsc{$\longrightarrow_2$})
%	\and
%\infer
%	{
%	M\ \vdash\ A \longrightarrow A'\\
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{A}
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A'}}
%	\quad(\textsc{$\longrightarrow_3$})
%	\and
%\infer
%	{
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{A} \\
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{A'}
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ A'}}
%	\quad(\textsc{$\wedge$I})
%	\and
%\infer
%	{
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ A'}
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
%	\quad(\textsc{$\wedge$E$$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A} \\
	M\ \vdash\ \onlyThrough{A_1'}{A_2}{A'}
	}
	{M\ \vdash\ \onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A} \\
	M\ \vdash\ \onlyThrough{A_1}{A_2'}{A'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A'}{\texttt{false}} \\
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \vee\ A'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{$\vee$E})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3} \\
	M\ \vdash\ \onlyThrough{A_1}{A_3}{A}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3} \\
	M\ \vdash\ \onlyThrough{A_3}{A_2}{A}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{If})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only_through}
\end{figure}

Figure \ref{f:only_if} provides the proof rules for ``Only If''.

\begin{figure}[p]
\begin{mathpar}
\infer
	{}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{\texttt{true}}}
	\quad(\textsc{If-True})
	\and
\infer
	{
	M\ \vdash\ A_1 \longrightarrow A_1'\\
	M\ \vdash\ A_2 \longrightarrow A_2'\\
	M\ \vdash\ A_3' \longrightarrow A_3\\
	M\ \vdash\ \onlyIf{A_1'}{A_2'}{A_3'}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A_3}}
	\quad(\textsc{If-$\longrightarrow$})
%	\and
%\infer
%	{
%	M\ \vdash\ A \longrightarrow A'\\
%	M\ \vdash\ \onlyIf{A_1}{A'}{A_2}
%	}
%	{M\ \vdash\ \onlyIf{A_1}{A}{A_2}}
%	\quad(\textsc{If-$\longrightarrow_2$})
%	\and
%\infer
%	{
%	M\ \vdash\ A \longrightarrow A'\\
%	M\ \vdash\ \onlyIf{A_1}{A_2}{A}
%	}
%	{M\ \vdash\ \onlyIf{A_1}{A_2}{A'}}
%	\quad(\textsc{If-$\longrightarrow_3$})
%	\and
%\infer
%	{
%	M\ \vdash\ \onlyIf{A_1}{A_2}{A} \\
%	M\ \vdash\ \onlyIf{A_1}{A_2}{A'}
%	}
%	{M\ \vdash\ \onlyIf{A_1}{A_2}{A\ \wedge\ A'}}
%	\quad(\textsc{If-$\wedge$I})
%	\and
%\infer
%	{
%	M\ \vdash\ \onlyIf{A_1}{A_2}{A\ \wedge\ A'}
%	}
%	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
%	\quad(\textsc{If-$\wedge$E})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A} \\
	M\ \vdash\ \onlyIf{A_1'}{A_2}{A'}
	}
	{M\ \vdash\ \onlyIf{A_1\ \vee\ A_	1'}{A_2}{A\ \vee\ A'}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A} \\
	M\ \vdash\ \onlyIf{A_1}{A_2'}{A'}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
%\infer
%	{
%	M\ \vdash\ \onlyIf{A_1}{A_2}{A\ \vee\ A'} \\
%	M\ \vdash\ A_1\ \longrightarrow\ \neg A'
%	}
%	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
%	\quad(\textsc{If-$\vee$E$_1$})
%	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A\ \vee\ A'} \\
	M\ \vdash\ \onlyThrough{A'}{A_2}{\texttt{false}}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
	\quad(\textsc{If-$\vee$E$$})
	\and
\infer
	{}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A_1}}
	\quad(\textsc{If-Start})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3} \\
	M\ \vdash\ \onlyIf{A_1}{A_3}{A}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
	\quad(\textsc{If-Trans)}
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_2}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A_2}}
	\quad(\textsc{If-Ind)}
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only_if}
\end{figure}

\newpage

%\section{Separation Logic}
%
%In order to write traditional specs for Loo methods, we need to define a separation logic for Chainmail assertions. At first we are only concerned with mutations on the heap, and how access is given away, as a result we use a restricted subset of Chainmail.
%	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	p, q & ::= & \textit{Hoare Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & p\ \texttt{in}\ S \\
%	| & \neg p & \\
%	| & p\ \wedge\ p & \\
%	| & p\ \vee\ p & \\
%	| & p\ \longrightarrow\ p & \\
%	| & \forall\ x.\ [p] & \\
%	| & \exists\ x.\ [p] & \\
%	| & \forall\ S.\ [p] & \\
%	| & \exists\ S.\ [p] &
%	\end{array}
%	\]
%	\caption{Assertions used in Chainmail Hoare Logic}
%	\label{f:assertions_hoare}
%	\end{figure}
%	
%The restricted set of assertions used in the hoare logic 
%defined in this section is given in Fig \ref{f:assertions_hoare}.
%These assertions include the usual connectives and 
%quantifications, along with simple expressions and 
%class assertions. Further, this restricted form of assertions
%also includes spatial assertions for reasoning about the 
%heap.
%
%We use this assertion language to define the usual assertion
%forms for separation logic as chainmail predicates:
%\begin{enumerate}
%\item
%Separating conjunction:
%$$p\ *\ q\ \equiv\ \exists S,\ S'.[\forall x.[(x\ \in\ S\ \longleftrightarrow\ x\ \not\in\ S')]\ \wedge\ p\ \texttt{in}\ S\ \wedge\ q\ \texttt{in}\ S']$$
%\item
%Separating implication:
%$$p\ \sepImpl\ q\ \equiv\ \exists S.[p\ \texttt{in}\ S\ \longrightarrow\ q]$$
%\item
%Empty heap
%$$\texttt{emp}\ \equiv\ \forall x,\ S.[x\ \not\in\ S]$$
%\item
%Address mapping in the heap:
%$$x.f\ \mapsto\ v\ \equiv\ \forall y.[y = x]\ \wedge\ x.f\ =\ v$$
%\end{enumerate}
%\hfill\fbox{$M\ \vdash\ \hoare{p}{s}{q}$}
%\begin{mathpar}
%\infer
%	{}
%	{M\ \vdash\ \hoare{y.f\ =\ v\ \wedge\ [x/v]p}{x \texttt{:=} y.f}{p}}
%	\quad(\textsc{H-Access})
%%	\and
%%\infer
%%	{}
%%	{M\ \vdash\ \hoare{\exists v.[x.f\ \mapsto\ v]}{x.f \texttt{:=} y}{x.f\ \mapsto\ y}}
%%	\quad(\textsc{H-Assgn-Local})
%	\and
%\infer
%	{}
%	{M\ \vdash\ \hoare{\exists v.[x.f\ \mapsto\ v]\ *\ p}{x.f \texttt{:=} y}{x.f\ \mapsto\ y\ *\ p}}
%	\quad(\textsc{H-Assgn})
%	\and
%\infer
%	{
%	M\ \vdash\ y : C\\
%	C\ \in\ M\\
%	\hoare{p}{y.m(args)}{q}\ \in\ C
%	}
%	{
%	M\ \vdash\ \hoare{p}{x := y.m(args)}{q}
%	}
%	\quad(\textsc{H-Meth})
%	\and
%\infer
%	{
%	M\ \vdash\ y : C\\
%	C\ \in\ M\\
%	\rtrns{p}{y.m(args)} {v} \ \in\ C
%	}
%	{M\ \vdash\ \hoare{p}{x := y.m(args)}{x = v}}
%	\quad(\textsc{H-Rtrns})
%	\and
%\infer
%	{q = \exists v_1, \ldots, v_n.[x_1 = v_1 \wedge \ldots \wedge x_n = v_n\ \wedge x\ \mapsto\ C\{f_1 \mapsto v_1, \ldots, f_n \mapsto v_n\}]}
%	{M\ \vdash\ \hoare{p}{x\ \texttt{:=}\ \texttt{new C}(f_1 \mapsto x_1, \ldots, f_n \mapsto x_n)}{p\ *\ q}}
%	\quad(\textsc{H-New})
%	\and
%\infer
%	{
%	M\ \vdash\ \hoare{p}{s}{q'}\\
%	M\ \vdash\ \hoare{q'}{s'}{q}
%	}
%	{M\ \vdash\ \hoare{p}{s; s'}{q}}
%	\quad(\textsc{H-Seq})
%	\and
%\infer
%	{
%	M\ \vdash\ p\ \longrightarrow\ e\\
%	M\ \vdash\ \hoare{p}{s}{q}
%	}
%	{M\ \vdash\ \hoare{p}{\texttt{if}\ e\ \texttt{then}\ s\ \texttt{else}\ s'}{q}}
%	\quad(\textsc{H-If$_1$})
%	\and
%\infer
%	{
%	M\ \vdash\ p\ \longrightarrow\ \neg e\\
%	M\ \vdash\ \hoare{p}{s'}{q}
%	}
%	{M\ \vdash\ \hoare{p}{\texttt{if}\ e\ \texttt{then}\ s\ \texttt{else}\ s'}{q}}
%	\quad(\textsc{H-If$_2$})
%	\and
%\infer
%	{
%	M\ \vdash\ p\ \longrightarrow\ p'\\
%	M\ \vdash\ \hoare{p'}{s}{q'}\\
%	M\ \vdash\ q'\ \longrightarrow\ q
%	}
%	{M\ \vdash\ \hoare{p}{s}{q}}
%	\quad(\textsc{H-$\longrightarrow$})
%\end{mathpar}
%
%\hfill\fbox{$M\ \vdash\ \rtrns{p}{s}{v}$}
%\begin{mathpar}
%\infer
%	{}
%	{M\ \vdash\ \rtrns{x=v}{\texttt{return}\ x}{v}}
%	\quad(\textsc{Rtrns$_1$})
%	\and
%\infer
%	{}
%	{M\ \vdash\ \rtrns{x=v}{\texttt{return}\ x; s}{v}}
%	\quad(\textsc{Rtrns$_2$})
%	\and
%\infer
%	{M\ \vdash\ \rtrns{p}{s}{v}}
%	{M\ \vdash\ \rtrns{p}{s; s'}{v}}
%	\quad(\textsc{Rtrns-Seq$_1$})
%	\and
%\infer
%	{
%	M\ \vdash\ \hoare{p}{s}{q}\\
%	M\ \vdash\ \rtrns{q}{s'}{v}
%	}
%	{M\ \vdash\ \rtrns{p}{s; s'}{v}}
%	\quad(\textsc{Rtrns-Seq$_2$})
%	\and
%\infer
%	{
%	M\ \vdash\ p\ \longrightarrow\ e\\
%	M\ \vdash\ \rtrns{p}{s}{v}
%	}
%	{M\ \vdash\ \rtrns{p}{\texttt{if}\ e\ \texttt{then}\ s\ \texttt{else}\ s' }{v}}
%	\quad(\textsc{Rtrns-If$_1$})
%	\and
%\infer
%	{
%	M\ \vdash\ p\ \longrightarrow\ \neg e\\
%	M\ \vdash\ \rtrns{p}{s'}{v}
%	}
%	{M\ \vdash\ \rtrns{p}{\texttt{if}\ e\ \texttt{then}\ s\ \texttt{else}\ s' }{v}}
%	\quad(\textsc{Rtrns-If$_2$})
%\end{mathpar}
%
%Since we are primarily concerned with what heap mutations are 
%made by a given program, we define a third triple form that 
%makes use of the Hoare and \emph{returns} triples we have already 
%defined. $M\ \vDash\ \effect{p}{s}{H}$ holds if forall 
%program configurations where $p$ is true, if the statement $s$ is
%executed, then there will be some intermediate state where
%$H$ will be true. $H$ is a restricted assertion form that is limited to
%assertions related to heap mutations. This is given in Fig. \ref{f:heap_mut_syntax}.
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	H & ::= & \textit{Heap Mutations}\\  
%	| & \mut{x}{y}{f} &\\
%	| & \gives{x}{y}{z} &
%	\end{array}
%	\]
%	\caption{Assertions relating to heap mutation.}
%	\label{f:heap_mut_syntax}
%	\end{figure}
%We provide proof rules for this triple in 
%Fig. \ref{f:effect_triple}.
%
%\begin{figure}[h]
%\hfill\fbox{$M\ \vdash\ \effect{p}{s}{H}$}
%\begin{mathpar}
%\infer
%	{}
%	{M\ \vdash\ \effect{\texttt{true}}{x \texttt{:=} y.f}{\gives{y}{y.f}{\texttt{this}}}}
%	\quad(\textsc{M-Give$_1$})
%	\and
%\infer
%	{}
%	{M\ \vdash\ \effect{\texttt{true}}{x.f \texttt{:=} y}{\gives{\texttt{this}}{y}{x}}}
%	\quad(\textsc{M-Give$_2$})
%	\and
%\infer
%	{}
%	{M\ \vdash\ \effect{\texttt{true}}{x.f \texttt{:=} y}{\mut{\texttt{this}}{x}{f}}}
%	\quad(\textsc{M-Mut})
%	\and
%\infer
%	{M\ \vdash\ \effect{p}{s}{H}}
%	{M\ \vdash\ \effect{p}{s; s'}{H}}
%	\quad(\textsc{M-Seq$_1$})
%	\and
%\infer
%	{
%	M\ \vdash\ \hoare{p}{s'}{q}\\
%	M\ \vdash\ \effect{q}{s'}{H}
%	}
%	{M\ \vdash\ \effect{p}{s; s'}{H}}
%	\quad(\textsc{M-Seq$_2$})
%	\and
%\infer
%	{
%	M\ \vdash\ p\ \longrightarrow p'\\
%	M\ \vdash\ \effect{p'}{s}{H}
%	}
%	{M\ \vdash\ \effect{p}{s}{H}}
%	\quad(\textsc{M-$\longrightarrow$})
%\end{mathpar}
%\caption{Heap Mutations by a program.}
%\label{f:effect_triple}
%\end{figure}
{\color{Blue}
\subsection{Bridging the Gap with Traditional Specifications}
	
Several proof steps require reasoning about steps 
through internal module code and their resulting internal heap mutations and external method calls. 
We assume traditional
specifications for 
internal heap mutations and external method calls, i.e. assertions of the following forms
\begin{itemize}
%\item
%$\changes{x}{\access {y}{z}}\ \wedge\ \internal{x}$
\item
External method calls:
$\calls{x}{y}{m}{args}\ \wedge\ \internal{x}\ \wedge\ \external{y}$
\item
Internal changes to state:
$\changes{x}{A}\ \wedge\ \internal{x}$
\end{itemize}

\subsubsection{External Method Calls}
\label{s:ext_meth}

In order to deal with external method calls from internal code, we 
now redefine satisfaction for the \texttt{calls} assertion.
\begin{definition}[\textsc{Control}]\label{def:control}
$M\ \fcmp\ M',\ \sigma\ \vDash \calls{\alpha_\texttt{this}}{\alpha_x}{m}{v_1, .., v_n}$ if and only if 
\begin{itemize}
\item
$\sigma.(\texttt{contn}) = (\texttt{\_ := x.m(x$_1$, ..., x$_n$)}; \_)$ and
\item
$[\texttt{x}\ \mapsto\ \alpha]\ \in\ \sigma.(local)$ and
\item
$[\texttt{this}\ \mapsto\ \alpha_\texttt{this}]\ \in\ \sigma.(local)$ and
\item
$[\texttt{x}_i\ \mapsto\ v_i]\ \in\ \sigma.(local)$ where $1 \leq i \leq n$ and 
\end{itemize}
or
$\exists \sigma_1, \ldots, \sigma_m$ such that
\begin{itemize}
\item
$M\ \fcmp\ M'\ \sigma\ \vDash\ \internalStep$ and
\item
$M\ \fcmp\ M',\ \sigma_j\ \vDash\ \internal{\texttt{this}}$ for all $j$  where $1 \leq j < m$ and
\item
$M\ \fcmp\ M',\ \sigma_m\ \vDash\ \external{\texttt{this}}$ and
\item
$M\ \circ\ M'\ \bullet\ \sigma\ \leadsto \sigma_1\ \leadsto\ \ldots\ \leadsto\ \sigma_m$ and
\item
$\sigma_{m - 1}.\texttt{contn} = (\texttt{\_ := x.m(x$_1$, ..., x$_n$)}; \_)$ and
\item
$[\texttt{x}\ \mapsto\ \alpha]\ \in\ \sigma_{m - 1}.(local)$ and
\item
$[\texttt{this}\ \mapsto\ \alpha_\texttt{this}]\ \in\ \sigma_{m - 1}.(local)$ and
\item
$[\texttt{x}_i\ \mapsto\ v_i]\ \in\ \sigma_{m - 1}.(local)$ where $1 \leq i \leq n$ and 
\end{itemize}
\end{definition}
\noindent Thus, in Definition \ref{def:control}, we attribute external method calls from internal 
code to the program state where the internal code step was initiated. This is in keeping
with the approach of eliding internal execution from the perspective of external code 
(as we do with pair execution). Further, it allows internal modules to use traditional specifications
to assert that certain external methods are called.

\subsubsection{Internal Changes to State}

In order to construct proofs about modifications to state made by 
internal objects, we need a way to reason about internal computation.
To do this, we use three relations:
\begin{enumerate}
\item
$\hoare{A_1}{s}{A_2}$: The traditional Hoare triple read as ``if statement $s$ is executed in 
a program state $A_1$, the resulting state will be $A_2$''. We do not define a proof system 
for this, we rather assume one.
%\item
%$\hoareIf{A_1}{A_2}{s}{A}$: Only If - Internal Computation, read as ``if computation of $s$ in state $A_1$
%results in $A_2$, then $A$ must have also been true of the initial state''.
\item
$M\ \vdash\ \hoareIf{A_1}{A_2}{x.m(x_1,\ \ldots,\ x_n)}{A}$: Only If - Method Call, read as ``if computation of 
method call $x.m(x_1,\ \ldots,\ x_n)$ in state $A_1$
results in $A_2$ (whether by returns, or by external method call), 
then $A$ must have also been true of the initial state''.
\item
$M\ \vdash\ \oiInternal{A_1}{A_2}{A}$: Only If - Module, read as ``if a computation, internal
to module $M$ is initiated in state $A_1$, and results in $A_2$, then $A$ must have also been true 
in the initial state''.
\end{enumerate}
As stated above, we assume the existence of some standard proof system for triples of the form $\hoare{A_1}{s}{A_2}$.
%Figure \ref{f:oi-step} defines proof rules for $\hoareIf{A_1}{A_2}{s}{A}$.
%\begin{figure}[p]
%\color{Blue}
%\begin{mathpar}
%\infer
%	{\hoareIf{e\ \wedge\ A_1}{A_2}{s}{A}}
%	{\hoareIf{A_1}{A_2}{\texttt{if}\ e \ \texttt{then}\ s\ \texttt{else}\ s'}{e\ \wedge\ A}}
%	\quad(\textsc{If$_{\texttt{s}}$-If}_1)
%	\and
%\infer
%	{\hoareIf{\neg e\ \wedge\ A_1}{A_2}{s'}{A}}
%	{\hoareIf{A_1}{A_2}{\texttt{if}\ e \ \texttt{then}\ s\ \texttt{else}\ s'}{e'\ \wedge\ A}}
%	\quad(\textsc{If$_{\texttt{s}}$-If}_2)
%	\and
%\infer
%	{\hoare{A_1}{s}{A_2}}
%	{
%	\hoareIf{A_1}{A_2}{s}{\texttt{true}}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-Hoare}_1)
%	\and
%\infer
%	{\hoare{A_1}{s}{\neg A_2}}
%	{
%	\hoareIf{A_1}{A_2}{s}{\texttt{false}}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-Hoare}_2)
%	\and
%\infer
%	{
%	\hoareIf{A_1}{A_2\ \wedge\ A'}{s}{A} \\
%	\hoareIf{A_2}{A_3}{s'}{A'}
%	}
%	{
%	\hoareIf{A_1}{A_3}{s;\ s'}{A}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-Seq})
%	\and
%\infer
%	{
%	\hoareIf{A_1'}{A_2}{s}{A}\\
%	A_1\ \longrightarrow\ A_1'
%	}
%	{
%	\hoareIf{A_1}{A_2}{s}{A}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-}\longrightarrow_1)
%	\and
%\infer
%	{
%	\hoareIf{A_1}{A_2'}{s}{A'}\\
%	A_2\ \longrightarrow\ A_2'
%	}
%	{
%	\hoareIf{A_1}{A_2}{s}{A}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-}\longrightarrow_2)
%	\and
%\infer
%	{
%	\hoareIf{A_1}{A_2}{s}{A'}\\
%	A'\ \longrightarrow\ A
%	}
%	{
%	\hoareIf{A_1}{A_2}{s}{A}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-}\longrightarrow_3)
%	\and
%\infer
%	{
%	\hoareIf{A_1}{A_2}{s}{A}\\
%	\hoareIf{A_1}{A_2}{s}{A'}
%	}
%	{
%	\hoareIf{A_1}{A_2}{s}{A\ \wedge\ A'}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-}\wedge)
%	\and
%\infer
%	{
%	\hoareIf{A_1}{A_2}{s}{A}\\
%	\hoareIf{A_1'}{A_2}{s}{A'}
%	}
%	{
%	\hoareIf{A_1\ \vee\ A_1'}{A_2}{s}{A\ \vee\ A'}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-}\vee_1)
%	\and
%\infer
%	{
%	\hoareIf{A_1}{A_2}{s}{A}\\
%	\hoareIf{A_1}{A_2'}{s}{A'}
%	}
%	{
%	\hoareIf{A_1}{A_2\ \vee\ A_2}{s}{A\ \vee\ A'}
%	}
%	\quad(\textsc{If$_{\texttt{s}}$-}\vee_2)
%\end{mathpar}
%\caption{Only If Internal Computation}
%\label{f:oi-step}
%\end{figure}
We now extend $\hoareIf{A_1}{A_2}{s}{A}$ to the module level with
$M\ \vdash\ \oiInternal{A_1}{A_2}{A}$. 
That is, for internal module $M$, any program state satisfying $A_1$
that makes an internal method call, or returns to an internal 
method, and that internal execution results in a program state satisfying $A_2$ 
must have also satisfied $A$ to begin with. The formal definition is
given as
\begin{definition}[Only If - Internal Step]
$M\ \vDash\ \oiInternal{A_1}{A_2}{A}$ if and only if for all $M'$, $\sigma$, $\sigma_1$, and $\sigma_2$ such that 
\begin{itemize}
\item
$M\ \circ\ M'\ \bullet\ \sigma_1\ \leadsto\ \sigma$ and
\item
$M\ \fcmp\ M'\ \bullet\ \sigma_1\ \leadsto\ \sigma_2$ and
\item
$M\ \fcmp\ M',\ \sigma_1 \vDash\ A_1$ and
\item
$M\ \fcmp\ M',\ \sigma_2 \vDash\ A_2$ and
\item
$M\ \fcmp\ M',\ \sigma_1 \vDash\ \external{this}$ and
\item
$M\ \fcmp\ M',\ \sigma \vDash\ \internal{this}$
\end{itemize}
it follows that $M\ \fcmp\ M', \sigma_1\ \vDash\ A$
\end{definition}
We provide the 
formal model of a module.
A module $M$ is modeled as a set of classes. A class $C$ is
modeled as a class identifier, set of field names, and a set of methods. 
A method $m$ is modeled as a method identifier, a set of local variables,
and a statement that forms the method body:
\[
\begin{array}{llr}
M & ::=\  \overline{C} &
\end{array}\\
\begin{array}{llr}
C & ::=\  \texttt{class}\ id\ \{\ \overline{f};\ \overline{m}\}  &
\end{array}\\
\begin{array}{llr}
m & ::=\  \texttt{method}\ id\ (\overline{x}) \{\ s\ \}  &
\end{array}
\]
%We now make the assumption that for any method in a module,
%we are able to use traditional proof techniques to prove relations 
%of the following two forms:
%\begin{enumerate}
%\item
%$M\ \vdash\ \hoare{A}{x.m(x_1,\ \ldots, x_n)}{\texttt{returns}\ y}$: given a precondition $A$, method call
%$x.m(x_1,\ \ldots, x_n)$ will return $y$.
%\item
%$M\ \vdash\ \hoare{A\ \wedge\ \external{y}}{x.m_x(x_1,\ \ldots, x_n)}{\texttt{calls}\ y.m_y(y_1,\ \ldots, y_n)}$: given a precondition $A$, method call
%$x.m_x(x_1,\ \ldots, x_n)$ will make the external method call $y.m_y(y_1,\ \ldots, y_n)$.
%\end{enumerate}
%Both of the above forms are fairly straightforward for 
%traditional specification systems to prove.
%We are now able to define rules for 
%Figure \ref{f:internal-onlyIf} provides rules for triples of the form 
%$$M\ \vdash\ \hoareIf{A_1}{A_2}{x.m(x_1,\ \ldots, x_n)}{A}$$
%That is, given a method call $x.m(x_1,\ \ldots, x_n)$ to 
%some object internal to $M$, if $A_1$ was true when the method 
%call was made, and $A_2$ is true after, then $A$ must have also 
%been true initially. Rules for the above relation are given in 
%Figure \ref{f:internal-method}.
%\begin{figure}[h]
%\color{Blue}
%\begin{mathpar}
%\infer
%	{
%	M\ \vdash\ \hoare{A}{x.m(x_1,\ \ldots, x_n)}{\texttt{returns}\ y}
%	}
%	{
%	M\ \vdash\ \hoareIf{\neg \access{\texttt{this}}{y}}{\access{\texttt{this}}{y}}{x.m(x_1,\ \ldots, x_n)}{\texttt{true}}
%	}
%	\quad(\textsc{If$_{\textsc{m}}$-Rtrn})
%	\and
%\infer
%	{
%	1 \leq i \leq j\\
%	\hoare{A\ \wedge\ \external{y}}{x.m_x(x_1,\ \ldots, x_n)}{\texttt{calls}\ y.m_y(y_1,\ \ldots, y_j)}
%	}
%	{
%	M\ \vdash\ \hoareIf{\neg \access{y}{y_i}}{\access{y}{y_i}}{x.m(x_1,\ \ldots, x_n)}{\texttt{true}}
%	}
%	\quad(\textsc{If$_{\textsc{m}}$-Calls})
%	\and
%\infer
%	{
%	C\ \in\ M\\
%	\texttt{method}\ m_x(x_1,\ \ldots,\ x_n)\{s\}\ \in\ C.(\texttt{methods})\\
%	\hoareIf{A_1\ \wedge\ \external{y}}{A_2}{s}{A}
%	}
%	{
%	M\ \vdash\ \hoareIf{A_1}{A_2}{x.m(x_1,\ \ldots, x_n)}{A}
%	}
%	\quad(\textsc{If$_{\textsc{m}}$-Body})
%\end{mathpar}
%\caption{Only If - Method Call}
%\label{f:internal-method}
%\end{figure}
%Thus, Figure \ref{f:internal-method} captures that state change as a result of an internal method 
%call is as a result of either a method return or external method call granting access, or 
%some internal computation (and thus change to internal state only).

Finally, the construction of the necessary precondition on a module 
level requires some computation. The triple
$$M\ \vdash\ \oiInternal{A_1}{A_2}{A}$$
essentially states that there is some internal method that when 
called in a state $A_1\ \wedge\ A$, will result in a state $A_2$.
Further, this internal method call will be specified as part of 
$A$. To compute this $A$ from $M$, $A_1$, and $A_2$, we need to consider
all possible internal steps through $M$. This is made significantly more
complex by the possibility of internal steps to result from return 
statements (i.e. from external method calls), not just internal method calls.
{\color{red}(Julian: I can't quite figure out how to deal with external method 
calls in this case. I feel like it might be possible to consider state changes over an 
entire method first and then consider if that method makes any external method calls.)}
For this reason, we presently do not consider external method calls. We now define
the following assertion:
\begin{definition}[\textsc{Module Necessary Condition}]
\label{def:module_necessary}
$$\textit{Necessary}(M,A_1,A_2)\ =\ \underset{C\ \in\ M,\ m\ \in\ C}{\bigvee}\ \exists y, y_1,\ \ldots,\ y_n.[ A\ \wedge\ \calls{\emph{\texttt{this}}}{y}{m}{y_1,\ \ldots,\ y_n}]$$
\hfill where $M\ \vdash\ \hoare{A_1\ \wedge\ \neg A_2}{y.m(y_1,\ \ldots,\ y_n)}{\neg A}$\\
And finally we say that
$$M\ \vdash\ \oiInternal{A_1}{A_2}{\textit{Necessary}(M, A_1, A_2)}$$
\end{definition}

{\color{red}(Julian: I don't like the above definition, but I can't quite figure
out a better way of expressing it.)}

%For some method $m$, of class $C$, in module $M$, we assume that for a given 
%internal method call
%$$x.m(x_1, \ldots, x_n)$$
%%or a method return to an internal frame derived from an internal method call
%%$$\texttt{return}\ y$$
%we are able to use Hoare logic to prove (or disprove)
%specifications of the form:
%$$M\ \vdash\ \hoare{A_1}{x.m(x_1,\ \ldots, x_n)}{A_2}$$
%where $x$ is some internal object.
%
%We then generalize the above specifications to the following module wide
%invariant
%$$M\ \vdash\ \oiInternal{A_1}{A_2}{A}$$
%that holds if and only if for all possible method calls or method returns
%to internal code, either
%\begin{itemize}
%\item
%$M\ \vdash\ \hoare{A_1}{x.m(x_1,\ \ldots,\ x_n)}{A_2}$
%\end{itemize}
%
%More specifically we assume for a fully specified internal
%module $M$, we are able to prove a relation of the following form:
%$$M\ \vDash\ \oiInternal{A_1}{A_2}{A}$$
%That is, for internal module $M$, any program state satisfying $A_1$
%that either makes an internal method call, or returns to an internal 
%method, and that internal execution results in a program state satisfying $A_2$ 
%must have also satisfied $A$ to begin with. The formal definition is
%given as
%\begin{definition}[Only If - Internal Step]
%$M\ \vDash\ \oiInternal{A_1}{A_2}{A}$ if and only if for all $M'$, $\sigma$, $\sigma_1$, and $\sigma_2$ such that 
%\begin{itemize}
%\item
%$M\ \circ\ M'\ \bullet\ \sigma_1\ \leadsto\ \sigma$ and
%\item
%$M\ \fcmp\ M'\ \bullet\ \sigma_1\ \leadsto\ \sigma_2$ and
%\item
%$M\ \fcmp\ M',\ \sigma_1 \vDash\ A_1$ and
%\item
%$M\ \fcmp\ M',\ \sigma_2 \vDash\ A_2$ and
%\item
%$M\ \fcmp\ M',\ \sigma_1 \vDash\ \external{this}$ and
%\item
%$M\ \fcmp\ M',\ \sigma \vDash\ \internal{this}$
%\end{itemize}
%it follows that $M\ \fcmp\ M', \sigma_1\ \vDash\ A$
%\end{definition}
%We then assume that given a fully specified internal module, 
%it is possible to prove such a specification using only 
%traditional specifications.
%
%
%We now extend the Chainmail assertion syntax to model the boundary
%between external and internal code:
%	\begin{figure}[h]
%	$$
%	A ::= \ldots\ |\ \internalStep \\  
%	$$
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}
%We define sastisfaction of internal execution step as
%\begin{definition}[Satisfaction - $\internalStep$]
%$M\ \fcmp\ M',\ \sigma \vDash\ \internalStep$ if and only if we have
%\begin{itemize}
%\item
%$\sigma.(\texttt{contn})\ =\ (\_\ :=\ x.m(args); \_)$ and
%\item
%$[x\ \mapsto\ \alpha_x]\ \in\ \sigma.(local)$ and
%\item
%$M\ \fcmp\ M',\ \sigma\ \vDash\ \internal{\alpha_x}$
%\end{itemize}
%or
%\begin{itemize}
%\item
%$\sigma.(\texttt{contn})\ =\ (\texttt{return}\ \_; \_)$ or $\sigma.(\texttt{contn})\ =\ (\texttt{return}\ \_)$ and
%\item
%$\sigma\ =\ (\_,\phi\ :\ \phi'\ :\ \_)$ and
%\item
%$[\phi'.(\texttt{this})\ \mapsto\ \alpha_\texttt{this}]\ \in\ \sigma$ and
%\item
%$M\ \fcmp\ M',\ \sigma\ \vDash\ \internal{\alpha_\texttt{this}}$
%\end{itemize}
%\end{definition}
%\noindent Less formally, $M\ \fcmp\ M',\ \sigma \vDash\ \internalStep$ is satisfied if and only if the next command to 
%be executed is either a method call or a return to an internal object. 
%
%With this addition we are able to extend the proof system of Section \ref{s:proof_system}
%with the following Lemma:
%\begin{lemma}[\textsc{Internal Step} - $\longrightarrow$]
%If $M\ \vdash\ \oiInternal{A_1}{\texttt{true}}{A_2}$ then $M\ \vDash\ (A_1\ \wedge\ \internalStep)\ \longrightarrow\ A_2$
%\end{lemma}
%
%Finally, we assume that using traditional specifications we are able to
%prove assertions of the form: $M\ \vdash\ \oiInternal{A_1}{A_2}{A}$
\subsection{Non-Temporal Proof System for Chainmail}

Finally we introduce a proof system for constructing proofs
of Chainmail assertions for a single program state. Figure \ref{f:non-temporal} presents the usual proof rules for constructing 
proofs of consequence in a single program state.

{
\color{Green}
\begin{figure}[h]
\color{Green}
\small
\begin{mathpar}
\infer
		{}
		{
		M\ \vdash\ \calls{x}{y}{m}{args}\ \longrightarrow\ \access{x}{y}
		}
		\quad(\textsc{Calls-Recv})
		\and
\infer
		{}
		{
		M\ \vdash\ \calls{x}{y}{m}{\ldots,z,\ldots}\ \longrightarrow\ \access{x}{z}
		}
		\quad(\textsc{Calls-Args})
		\and
\infer
		{
		M\ \vdash\ \oiInternal{A}{\neg A}{A'}
		}
		{
		M\ \vdash\ \changes{S}{A}\ \wedge\ \forall x.[x\ \not\in\ S\ \vee\ \internal{x}]\ \longrightarrow\ A'
		}
		\quad(\textsc{Int-Changes})
%		\and
%\infer
%		{
%		M\ \vdash\ \oiInternal{A}{\texttt{true}}{A'}
%		}
%		{M\ \vdash\ \internal{y}\ \wedge\ \calls{\texttt{this}}{y}{m}{args}\ \wedge\ A \longrightarrow\ A'}
%		\quad(\textsc{Int-Call})
		\and
\infer
		{}
		{M\ \vdash\ \changes {S}{y.f = z}\ \internal{y} \longrightarrow\ \changes{\textit{int}(S)}{y.f = z}}
		\quad(\textsc{Mut-Class})
		\and
%\infer
%		{}
%		{M\ \vdash\ \changes {S}{y.f = z} \longrightarrow\ \exists C.[x : C\ \wedge\ y : C]}
%		\quad(\textsc{Mut-Class})
		\and
\infer
		{C\ \in\ M}
		{M\ \vdash\ x : C \longrightarrow\ \internal{x}}
		\quad(\textsc{Class-Int})
%		\and
%\infer
%		{}
%		{
%		M\ \vdash\ \encapsulated{z}\ \wedge\ \changes {x}{\access{y}{z}}\ \longrightarrow\ \internal{x}
%		}
%		\quad(\textsc{Gives-Int})
%		\and
%\infer
%		{}
%		{
%		M\ \vdash\ \encapsulates{S_1}{S_2}\ \wedge\ z\ \in\ S_2\ \wedge\ \changes {x}{\access{y}{z}} \longrightarrow\ \\ \exists x', \ y'.[x'\ \in\ S_1\ \wedge\ \changes{x'}{\access {y'}{z}}]
%		}
%		\quad(\textsc{Gives})
		\and
\infer
		{}
		{
		M\ \vdash\ \encapsulates{S_1}{S_2}\ \wedge\ z\ \in\ S_2\ \wedge\ y\ \not\in\ S_1\ \union\ S_2\ \vee\ \changes {S}{\access{y}{z}} \longrightarrow\ \\ 
		\exists y'.[y'\ \not\in\ S_1\ \union\ S_2\ \wedge\ \changes{S_1}{\access {y'}{z}}]
		}
		\quad(\textsc{Gives})
\end{mathpar}
\caption{Non-Temporal Chainmail Proof Rules}
\label{f:non-temporal}
\end{figure}
Figure \ref{f:non-temporal} provides rules for constructing non-temporal proofs 
for Chainmail. 
\begin{itemize}
\item
\textsc{Calls-Recv} and \textsc{Calls-Args} state that if an object
makes an internal method call, then it follows that that object has access to both 
the receiver and the arguments of that method call (the same is not true of method 
calls to external objects, due to the modified definition for method calls defined
in Section \ref{s:ext_meth}).
\item
\textsc{Int-Changes} states that if $A'$ is a necessary condition to satisfaction of $A$ changing
via an internal function, and some internal object will change $A$ in the next step, 
then it follows that $A'$ must be true now.
\item
\textsc{Mut} states that if some object modifies the state of some other object, then it 
follows that both objects have the same class.
\item
\textsc{Class-Int} states that an object whose class is internal, is itself internal.
\item
\textsc{Gives} states that if one set encapsulates another, and some object external to 
both sets gains access to an object from the encapsulated set, then it follows that some
object from the encapsulating set exposed that object.
\end{itemize}

\subsubsection*{Connecting State Changes to Internal Operations}
The rules \textsc{Mut} and \textsc{Gives} are important for connecting changes to 
program state to internal operations. The only two operations that necessitate 
internal computation is mutation of internal state and granting of access to 
internally encapsuated data. Key to making this connection, is thus identifying 
which objects conducted this change in state. \textsc{Mut} can be used to infer 
that only objects of the same class are able to modify the internals of an object, 
and then \textsc{Class-Int} can be used to infer that the modifying object is 
module internal. \textsc{Gives} can be used to infer that only objects inside an 
encapsulating set may grant access to an external object. If all the objects 
in the encapsulating set are module internal, we are then able to infer that the 
object that exposed the data must be module internal. Once these steps have been
made, we can then use \textsc{Int-Changes} to infer necessary preconditions to 
those changes.
}
}


\section{Examples}

\subsection{Bank Account Example}

Now, to demonstrate the use of the proof system presented in Section \ref{s:proof_system}, we construct 
a proof of the bank account example. 

{\color{Green}New $>>>>>>>>$}\\
We rewrite the bank account example using the triples define here.
The original specification is written below.
\begin{lstlisting}[mathescape=true]
SpecA $\triangleq$ $\forall$ a b. [ a : Account $\wedge$ a.balance = b $\wedge$
               will $\langle\ \neg$ a.balance $\neq$ b $\rangle$
               $\longrightarrow$
               $\exists$ o.[$\langle$ external o $\rangle$ $\wedge$ $\langle$ o access a $\rangle$]
\end{lstlisting}
We now rewrite it as this
\begin{lstlisting}[mathescape=true]
Spec $\triangleq$  a : Account $\wedge$ a.balance = b,
         $\langle\ \neg$ a.balance $\neq$ b $\rangle$
               $\oi$
          $\neg\ \encapsulated{\texttt{a}}$
\end{lstlisting}
We assume that the method \texttt{deposit} conforms to the following 
specification
\begin{lstlisting}[mathescape=true]
DepositSpec $\triangleq$  {a'.balance = b $\wedge$ a' $\neq$ a $\wedge$ a' $\neq$ from}
					a.deposit(from, amt) 
			   {a'.balance = b}
\end{lstlisting}
And all other methods \texttt{m} in \texttt{Account} conform to the 
following spec
\begin{lstlisting}[mathescape=true]
AccountMethSpec $\triangleq$  {a : Account $\wedge$ a.balance = b}
					  a.m(...) 
			       {a.balance = b}
\end{lstlisting}
From \texttt{DepositSpec}, \texttt{AccountMethSpec}, and Definition \ref{def:module_necessary} we can derive \texttt{BASafety}
\begin{lstlisting}[mathescape=true]
BASafety $\triangleq$  a : Account $\wedge$ $\mut{\texttt{x}}{\texttt{a}}{\texttt{balance}}$
              $\intstep$
            x : Account $\wedge$ $\calls{\_}{\texttt{x}}{\texttt{deposit}}{\texttt{a, \_}}$ $\vee$ x = a $\wedge$ $\calls{\_}{\texttt{a}}{\texttt{deposit}}{\_,\_}$
\end{lstlisting}
Then we assume that all methods $m$ in \texttt{Account} observe the following specification:
\begin{lstlisting}[mathescape=true]
AccountEncapsulation $\triangleq$ {a : Account $\wedge$ $\neg$ $\langle$ x access a $\rangle$}
				          a.m(...)
				       {$\neg$ $\langle$ x access a $\rangle$}
\end{lstlisting}
And thus from \texttt{AccoutnEncapsulation} and Definition \ref{def:module_necessary} we can derive \texttt{BAEncapsulation}
\begin{lstlisting}[mathescape=true]
BAEncapsulation $\triangleq$  a : Account $\wedge$ $\changes{\_}{\access{\_}{a}}$
                    $\intstep$
                   false
\end{lstlisting}
{\color{Green} $<<<<<<$}\\
Proof:
\vspace{3mm}
\footnotesize
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\}
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\ot$$
$$
	\exists x.[\changes{x}{a.\texttt{balance} = b}]
$$
\hfill by \textsc{Changes}
\hrule
\vspace{3mm}
%$$
%	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\ \wedge\  \langle \texttt{internal}\ a \rangle\}
%$$
%$$
%	\{\neg\ a.\texttt{balance} \neq b\}
%$$
%$$\ot$$
%$$
%	{\exists x.[\mut{x}{a}{\texttt{balance}}]}
%$$
%\hfill by \textsc{$\longrightarrow_1$}
%\hrule
%\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\ \wedge\  \langle \texttt{internal}\ a \rangle\}
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\ot$$
$$
	{\exists x.[\changes{x}{a.\texttt{balance} = b}\ \wedge\ \langle \texttt{internal}\ x \rangle]}
$$
\hfill by \textsc{Mut-Class} and \textsc{Class-Int}
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\ \wedge\  \langle \texttt{internal}\ a \rangle\}
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\ot$$
$$
	{\exists o.[\langle o\ \texttt{calls}\ a.\texttt{deposit}(\_, \_) \rangle\ \vee\ \langle o\ \texttt{calls}\ \_.\texttt{deposit}(a, \_) \rangle]}
$$
\hfill by \textsc{Int Changes}, \texttt{BASafety}, and $\longrightarrow_3$ \\
%({\color{red}Julian: we should probably build an inference system for non-temporal assertions, along with a hoare logic for single step assertions (i.e. \texttt{gives} and \texttt{mut}).
%This is necessary to connect the \texttt{mut} in the previous proof step to the \texttt{deposit} call in this one. I think our old idea of designing a hoare logic of the form $\{A_1\}\ M\ \{A_2\}$ 
%might work here. i.e. if $A_1$ is true before some method call to module $M$, then $A_2$ will be true after. This is the sufficient form, but we might need a necessary form, i.e. we might want to say that
%if $A_2$ is true after a call to some method in $M$, then $A_1$ must have been true before.})
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\ \wedge\  \langle \texttt{internal}\ a \rangle\},
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\ot$$
$$
	{\exists o.[\langle o\ \texttt{access}\ a\rangle\ \wedge\ \langle \texttt{external}\ o \rangle]}
$$
\hfill by $\longrightarrow_3$
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\ \wedge\  \langle \texttt{internal}\ a \rangle\},
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\ot$$
$$
	{\neg \encapsulated{a}}
$$
\hfill by $\longrightarrow_3$
\hrule
\vspace{3mm}
(a)
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b \},
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\ot$$
$$
	{\neg \encapsulated{a}}
$$
\hfill by $\longrightarrow_1$
\hrule
\vspace{3mm}
\normalsize
\noindent now we show that access to bank accounts cannot be leaked:
\vspace{3mm}
\footnotesize
\hrule
\vspace{3mm}
$$
	\{\encapsulated{a}\}
$$
$$
	\{\neg\encapsulated{a}\}
$$
$$\ot$$
$$
	\exists x\ y.[\changes{y}{\access{x}{a}}]
$$
\hfill by \textsc{Changes}
\hrule
\vspace{3mm}
(b)
$$
	\{\encapsulated{a}\}
$$
$$
	\{\neg\encapsulated{a}\}
$$
$$\ot$$
$$
	\texttt{false}
$$
\hfill by \textsc{Int-Changes}, \texttt{BAEncapsulation}, and $\longrightarrow_3$ \\
\hrule
\vspace{3mm}
\noindent{\color{red}Julian: then we use (a) and (b) to give us:}
\vspace{3mm}
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\}
$$
$$
	\{\neg \encapsulated{a}\}
$$
$$\oi$$
$$
	{\texttt{true}}
$$
\hfill by \textsc{If-True}
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\}
$$
$$
	\{\neg \encapsulated{a}\}
$$
$$\oi$$
$$
	{\encapsulated{a}\ \vee\ \neg\encapsulated{a}}
$$
\hfill by \textsc{If-$\longrightarrow_3$} and \textsc{Excluded Middle}
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\}
$$
$$
	\{\neg \encapsulated{a}\}
$$
$$\oi$$
$$
	{\neg \encapsulated{a}\ \vee\ \encapsulated{a}}
$$
\hfill by \textsc{If-$\longrightarrow_3$}
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\}
$$
$$
	\{\neg \encapsulated{a}\}
$$
$$\oi$$
$$
	{\neg\encapsulated{a}}
$$
\hfill by \textsc{If-$\vee$E$_1$} and (b)
\hrule
\vspace{3mm}
$$
	\{a : \texttt{Account}\ \wedge a.\texttt{balance} = b\}
$$
$$
	\{\neg\ a.\texttt{balance} \neq b\}
$$
$$\oi$$
$$
	{\neg\encapsulated{a}}
$$
\hfill by \textsc{If-Trans} and (a)
\hrule
\vspace{3mm}
\normalsize

\newpage

\subsection{Safe Example}
{\color{Green} New $>>>>>>>>>$}\\
We recall the original Safe specification:
\begin{lstlisting}[mathescape=true]
Spec $\triangleq$ $\forall$ s scr. [ s : Safe $\wedge$ s.treasure $\neq$ null $\wedge$
               will $\langle$ s.treasure = null $\rangle$
               $\longrightarrow$
               $\exists$ o.[ $\neg$ s.is_internal(o) $\wedge$ $\langle$ o access s.secret $\rangle$ ]
\end{lstlisting}
We now rewrite it as this
\begin{lstlisting}[mathescape=true]
Spec $\triangleq$  { s : Safe $\wedge$ s.treasure $\neq$ null },
        { s.treasure = null}
               $\oi$
          [$\exists$ o.[ $\neg$ s.is_internal(o) $\wedge$ $\langle$ o access s.secret $\rangle$ ]]
\end{lstlisting}
Note, this is the modified version of the Safe that uses a ghost field to define what is internal to Safe. 
In this case, this is the safe, and the secret.

We assume that the following traditional specification can be proven of \texttt{take}
\begin{lstlisting}[mathescape=true]
TakeSpec $\triangleq$  { s : Safe $\wedge$ s.treasure = t $\wedge$ scr $\neq$ s.secret}
                        s.take(scr')
                    {s.treasure = t}
\end{lstlisting}
Further, we assume that all other methods \texttt{m} of \texttt{Safe} observe the following specification:
\begin{lstlisting}[mathescape=true]
SafeMethodSpec $\triangleq$  { s : Safe $\wedge$ s.treasure = t}
                        s.m(....)
                    {s.treasure = t}
\end{lstlisting}
Thus, by \texttt{TakeSpec}, \texttt{SafeMethodSpec}, and Definition \ref{def:module_necessary} we get
\begin{lstlisting}[mathescape=true]
SafeTreasureMut $\triangleq$  a : Safe $\wedge$ $\changes{\_}{s.\texttt{treasure} \neq \texttt{null}}$
                    $\intstep$
                   $\exists$ o.[$\external{\texttt{o}}$ $\vee$ $\calls{\texttt{o}}{\texttt{s}}{\texttt{take}}{\texttt{s.secret}}$]
\end{lstlisting}
Then we assume that all methods $m$ in \texttt{Safe} observe the following specification:
\begin{lstlisting}[mathescape=true]
SecretEncapsulation $\triangleq$ {s : Safe $\wedge$ $\langle$ S encapsulates s.secret $\rangle$}
				          s.m(...)
				       {$\langle$ S encapsulates s.secret  $\rangle$}
\end{lstlisting}
And thus from \texttt{SecretEncapsulation} and Definition \ref{def:module_necessary} we can derive \texttt{SafeEncapsulation}
\begin{lstlisting}[mathescape=true]
SafeEncapsulation $\triangleq$  s : Safe $\wedge$ $\changes{\_}{\encapsulates{\_}{s.secret}}$
                    $\intstep$
                   false
\end{lstlisting}
{\color{Green} $<<<<<<<<$}
\noindent Proof:
\vspace{3mm}
\footnotesize
\hrule
\vspace{3mm}
$$
	\{s.\texttt{treasure} \neq \texttt{null}\}
$$
$$
	\{s.\texttt{treasure} = \texttt{null} \}
$$
$$\ot$$
$$
	\exists S.[\changes{S}{s.\texttt{treasure} \neq \texttt{null}}]
$$
\hfill by \textsc{Changes}
\hrule
\vspace{3mm}
$$
	\{s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\ \wedge\ \internal{s}\}
$$
$$
	\{s.\texttt{treasure} = \texttt{null} \}
$$
$$\ot$$
$$
	\exists S.[\changes{\textit{int}(S)}{s.\texttt{treasure} \neq \texttt{null}}]
$$
\hfill by \textsc{Mut-Class}, \texttt{Class-Int}, and $\longrightarrow_3$
\hrule
\vspace{3mm}
$$
	\{s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\ \wedge\ \internal{s}\}
$$
$$
	\{s.\texttt{treasure} = \texttt{null} \}
$$
$$\ot$$
$$
	\exists o. [\langle \texttt{external}\ o \rangle\ \wedge\ \langle o\ \texttt{calls}\ s.\texttt{take}(s.\texttt{secret}) \rangle]
$$
\hfill by \textsc{Changes-Int}, \texttt{SafeTreasureMut}$\longrightarrow_3$\\
%({\color{red}Julian: again this consequence needs to be derived via a logic for single internal. The reasoning goes: ``if s.treasure is modified via a call to \texttt{s.take(...)}``})
\hrule
\vspace{3mm}
$$
	\{s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\ \wedge\ \internal{s}\}
$$
$$
	\{s.\texttt{treasure} = \texttt{null} \}
$$
$$\ot$$
$$
	\exists o. [\langle \texttt{external}\ o \rangle\ \wedge\ \langle o\ \texttt{access}\ s.\texttt{secret} \rangle]
$$
\hfill by \textsc{Calls-Args} and $\longrightarrow_3$
\hrule
\vspace{3mm}
$$
	\{s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\ \wedge\ \internal{s}\}
$$
$$
	\{s.\texttt{treasure} = \texttt{null} \}
$$
$$\ot$$
$$
	\neg \encapsulated{\texttt{s.secret}}
$$
\hfill by $\longrightarrow_3$
\hrule
\vspace{3mm}
(a)
$$
	\{s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\}
$$
$$
	\{s.\texttt{treasure} = \texttt{null} \}
$$
$$\ot$$
$$
	\neg \encapsulated{\texttt{s.secret}}
$$
\hfill by $\longrightarrow_1$
\hrule
\vspace{3mm}
\normalsize
\noindent{\color{red}Julian: now we need to show that there is no way to leak \texttt{s.secret}}
\vspace{3mm}
\footnotesize
\hrule
\vspace{3mm}
$$
	\{\encapsulates{\comprehension{x}{\texttt{s.internal(x)}}}{\texttt{s.secret}} \}
$$
$$
	\{\neg \encapsulates{\comprehension{x}{\texttt{s.internal(x)}}}{\texttt{s.secret}} \}
$$
$$\ot$$
$$
	\exists S.[\changes{S}{\comprehension{x}{\texttt{s.internal(x)}}}]
$$
\hfill by \textsc{Changes}
\hrule
\vspace{3mm}
$$
	\{\encapsulates{s}{\texttt{s.secret}} \}
$$
$$
	\{\neg \encapsulates{s}{\texttt{s.secret}} \}
$$
$$\ot$$
$$
	\exists x\ y.[\changes{x}{\access{y}{\texttt{s.secret}}}\ \wedge\ x \in\ \{\texttt{s}\} \wedge\ y \not\in \{\texttt{s}\} \cup \{\texttt{s.secret}\}]
$$
\hfill by \textsc{Gives}
\hrule
\vspace{3mm}
$$
	\{\encapsulates{s}{\texttt{s.secret}} \}
$$
$$
	\{\neg \encapsulates{s}{\texttt{s.secret}} \}
$$
$$\ot$$
$$
	\exists x\ y.[\changes{x}{\access{y}{\texttt{s.secret}}}\ \wedge\ x = \texttt{s}\ \wedge\ \internal{x}]
$$
\hfill by $\longrightarrow_3$
\hrule
\vspace{3mm}
(b)
$$
	\{\encapsulates{s}{\texttt{s.secret}} \}
$$
$$
	\{\neg \encapsulates{s}{\texttt{s.secret}} \}
$$
$$\ot$$
$$
	\texttt{false}
$$
\hfill by \textsc{Changes-Int}, \textsc{SafeEncapsulation}, and $\longrightarrow_3$
\hrule
\vspace{3mm}
\normalsize
Now have
\vspace{3mm}
\hrule
\footnotesize
\vspace{3mm}
$$
	\{ s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\ \wedge\ \internal{s} \}
$$
$$
	\{\neg \encapsulates{s}{\texttt{s.secret}} \}
$$
$$\oi$$
$$
	\encapsulates{\texttt{s}}{\texttt{s.secret}}\ \vee\ \neg \encapsulates{\texttt{s}}{\texttt{s.secret}}
$$
\hfill by (a), \texttt{True}, \textsc{If-}$\longrightarrow_3$ and \textsc{Excluded Middle}\\
\hrule
\vspace{3mm}
$$
	\{ s : \texttt{Safe} \wedge s.\texttt{treasure} \neq \texttt{null}\ \wedge\ \internal{s} \}
$$
$$
	\{\neg \encapsulates{s}{\texttt{s.secret}} \}
$$
$$\oi$$
$$
	\neg \encapsulates{\texttt{s}}{\texttt{s.secret}}
$$
\hfill by \textsc{If-}$\vee$\textsc{E} and (b)\\
\hrule
\vspace{3mm}
\normalsize

\newpage

\subsection{DAO}
The DAO specification does not follow have the same kind of structure 
as that of Bank/Account and Safe. There is no obvious way to capture 
an invariant like \texttt{Spec} below.
\begin{lstlisting}[mathescape=true]
Spec $\triangleq$ $\forall$ d, p, m. [ s : DAO $\wedge$ m : Nat $\wedge$ d.balances(p) = m
               $\longrightarrow$
               d.ether $\geq$ m ]
\end{lstlisting}
\texttt{Spec} states that the balance of any individual never exceeds the \texttt{ether},
and it is always possible to repay an investor. Another way to state \texttt{Spec} is 
to say that at creation this property is true, and once true it is never possible
to violate this property. The proof system of Section \ref{s:proof_system} currently only 
allows us to capture the second part of this specification:
\begin{lstlisting}[mathescape=true]
Spec $\triangleq$  d : DAO $\wedge$ d.balance(p) $\leq$ d.ether,
         d.balance(p) > d.ether
               $\otAlt$
          false
\end{lstlisting}
In order to capture the first part of the specification, we need to assume a traditional specification 
on the construction of DAO objects of the following form:
\begin{lstlisting}[mathescape=true]
DAO_WF $\triangleq$  $\forall$ d'.[d' $\neq$ d],
         d : DAO
               $\en$
          $\forall$ p.[d.balance(p) $\leq$ d.ether]
\end{lstlisting}
Above we are specifying that if there is ever an internal step that results in the creation of 
a DAO object, the resulting object will observe our invariant.
{\color{red}(Julian: at the moment the above triple does not exist, but it is easily definable, in
a similar way to $\intstep$)}

The combination of \texttt{Spec} and \texttt{DAO\_WF} gives us our original specification.
We also assume that 
$$\texttt{DAOInv}\triangleq\texttt{DAO}\ \vdash\ \oiInternal{\texttt{d.balances(p)} \leq \texttt{d.ether}}{\neg \texttt{d.balances(p)} \leq \texttt{d.ether}}{\texttt{false}}$$
is provable by traditional specifications
We now provide a step by step proof of the new \texttt{Spec}:
\vspace{3mm}
\footnotesize
\hrule
\vspace{3mm}
$$
	\texttt{d.balance(p)} \leq \texttt{d.ether},
$$
$$
	\neg\texttt{d.balance(p)} \leq \texttt{d.ether}
$$
$$\ot$$
$$
	\exists x.[\changes{x}{\texttt{d.balance} \leq \texttt{d.ether}}]
$$
\normalsize
\hfill by \textsc{Changes}
\hrule
\vspace{3mm}
\footnotesize
$$
	\texttt{d.balance(p)} \leq \texttt{d.ether},
$$
$$
	\neg\texttt{d.balance(p)} \leq \texttt{d.ether}
$$
$$\ot$$
$$
	\texttt{false}
$$
\normalsize
\hfill by $\longrightarrow_3$ and \texttt{DAOInv} and \textsc{Int-Step}
\hrule
\vspace{3mm}
\footnotesize
$$
	\texttt{d : DAO} \wedge \texttt{m : Nat} \wedge \texttt{d.balance(p)} \leq \texttt{d.ether},
$$
$$
	\neg\texttt{d.balance(p)} \leq \texttt{d.ether}
$$
$$\ot$$
$$
	\texttt{false}
$$
\normalsize
\hfill by $\longrightarrow_1$
\hrule
\vspace{3mm}
\footnotesize
$$
	\texttt{d : DAO} \wedge \texttt{m : Nat} \wedge \texttt{d.balance(p)} \leq \texttt{d.ether},
$$
$$
	\texttt{d.balance(p) > d.ether}
$$
$$\ot$$
$$
	\texttt{false}
$$
\normalsize
\hfill by $\longrightarrow_2$
\hrule

The new semantics of $\calls{x}{y}{m}{args}$, we are able to prove 
specifications that refer to external method calls from internal 
library code. As an example consider the below specification
that was included in the TOSEM paper:
\begin{lstlisting}[mathescape=true]
DAOSend $\triangleq$  $\forall$ d, p, m .[ d : DAO $\wedge$ m : Nat $\wedge$ d.balance(p) = m $\wedge$ $\calls{\texttt{p}}{\texttt{d}}{\texttt{repay}}{\_}$
                          $\longrightarrow$ will $\langle$ $\calls{\texttt{d}}{\texttt{p}}{\texttt{send}}{\texttt{m}}$ $\rangle$]
\end{lstlisting}
Using the original semantics of \textsc{Control}, the above specification could not be expressed as there was no way to express an external call from internal code.
Assuming it is possible to prove \texttt{RepayCallsSend} using traditional verification techniques:
\begin{lstlisting}[mathescape=true]
RepayCallsSend $\triangleq$  d : DAO $\wedge$ m : Nat $\wedge$ d.balance(p) = m $\wedge$ $\calls{\texttt{p}}{\texttt{d}}{\texttt{repay}}{\_}$,
				true
              $\intstep$
            $\calls{\texttt{d}}{\texttt{p}}{\texttt{send}}{\texttt{m}}$
\end{lstlisting}
the new semantics of $\calls{\texttt{p}}{\texttt{d}}{\texttt{repay}}{\_}$ allow us to express \texttt{DAOSend} in the following way:

\begin{lstlisting}[mathescape=true]
DAOSend $\triangleq$  $\forall$ d, p, m .[ d : DAO $\wedge$ m : Nat $\wedge$ d.balance(p) = m $\wedge$ $\calls{\texttt{p}}{\texttt{d}}{\texttt{repay}}{\_}$
                          $\longrightarrow$ $\calls{\texttt{d}}{\texttt{p}}{\texttt{send}}{\texttt{m}}$]
\end{lstlisting}
Proof:
\vspace{3mm}
\footnotesize
\hrule
\vspace{3mm}
$$
	\texttt{d : DAO}\ \wedge\ \texttt{m : Nat}\ \wedge\ \texttt{d.balance(p) = m}\ \wedge\ \calls{\texttt{p}}{\texttt{d}}{\texttt{repay}}{\_}\
                          \longrightarrow\ \calls{\texttt{d}}{\texttt{p}}{\texttt{send}}{\texttt{m}}
$$
\normalsize
\hfill by \textsc{Int-Call} and \texttt{RepayCallsSend}
\hrule
\vspace{3mm}


\newpage
{\color{Green}
\section{Soundness}
Since the proof rules for Only Through (Figure \ref{f:only_through}) 
and Only If (\ref{f:only_if}) are mutually dependent, the proof of
soundness must employ a mutual induction on the derivation of both
only through and only if.
\begin{lemma}[Satisfaction Changes over Reduction]
\label{lem:changes_reduction}
For all $M$, $M'$, $\sigma_1$, $\sigma_2$, $A_1$, and $A_2$, such that 
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$, 
$\satisfies{M}{M'}{\sigma_1}{A_1}$, and
$\satisfies{M}{M'}{\sigma_2}{A_2}$, there 
exists $\sigma$ and $\sigma'$ such that 
\begin{itemize}
\item
$\sigma_1 = \sigma\ \vee\ \reductions{M}{M'}{\sigma_1}{\sigma}$,
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$, and
\item
$\sigma_2 = \sigma'\ \vee\ \reductions{M}{M'}{\sigma'}{\sigma_2}$,
\end{itemize}
\end{lemma}
\begin{theorem}[Only Through/If Soundness]
For all modules $M$ and assertions $A_1$, $A_2$, and $A_3$, 
\begin{itemize}
\item
if $M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3}$ then 
$M\ \vDash\ \onlyThrough{A_1}{A_2}{A_3}$
and
\item
if $M\ \vdash\ \onlyIf{A_1}{A_2}{A_3}$ then 
$M\ \vDash\ \onlyIf{A_1}{A_2}{A_3}$
\end{itemize}
\end{theorem}
\begin{proof}
We proceed by mutual induction on the derivation of 
$M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3}$ and
$M\ \vdash\ \onlyIf{A_1}{A_2}{A_3}$
\begin{case}[\textsc{Only Through}]
\begin{subcase}[\textsc{True}]
$$M\ \vdash\ \onlyThrough{A_1}{A_2}{\texttt{true}}\ \Rightarrow\ M\ \vDash\ \onlyThrough{A_1}{A_2}{\texttt{true}}$$
Let $M'$ be some module, and $\sigma_1$ and $\sigma_2$ be some program configurations where\\
$\constrainedReductions{M}{M'}{\sigma_1}{\sigma_2}$, $\satisfies{M}{M'}{\sigma_1}{A_1}$, and
$\satisfies{M}{M'}{\sigma_2}{A_2}$. It is trivial to show that $\satisfies{M}{M'}{\sigma_1}{\texttt{true}}$,
and thus desired result.
\end{subcase}
\begin{subcase}[\textsc{Changes}]
$$M\ \vdash\ \onlyThrough{A}{\neg A}{\exists x.[\changes{x}{A}]}\ \Rightarrow\ M\ \vDash\ \onlyThrough{A}{\neg A}{\exists x.[\changes{x}{A}]}$$
Let $M'$ be some module, and $\sigma_1$ and $\sigma_2$ be some program configurations where\\
$\constrainedReductions{M}{M'}{\sigma_1}{\sigma_2}$, $\satisfies{M}{M'}{\sigma_1}{A_1}$, and
$\satisfies{M}{M'}{\sigma_2}{A_2}$.
By Lemma \ref{lem:changes_reduction} we have the desired result.
\end{subcase}
\begin{subcase}[$\longrightarrow_1$]
\label{scase:consequence1}
\begin{mathpar}
\infer
	{
	M\ \vdash\ A\ \longrightarrow\ A'\\
	M\ \vdash\ \onlyThrough{A'}{A_1}{A_2}
	}
	{
	M\ \vdash\ \onlyThrough{A}{A_1}{A_2}
	}
\end{mathpar}
By our induction hypothesis we have $M\ \vDash\ \onlyThrough{A'}{A_1}{A_2}$.
It is then simple to demonstrate that if we have $M\ \vDash\ A\ \longrightarrow\ A'$
we get $M\ \vDash\ \onlyThrough{A}{A_1}{A_2}$, the desired result.
\end{subcase}
\begin{subcase}[$\longrightarrow_2$]
By similar reasoning to Subcase \ref{scase:consequence1}.
\end{subcase}
\begin{subcase}[$\longrightarrow_3$]
By similar reasoning to Subcase \ref{scase:consequence1}.
\end{subcase}
\begin{subcase}[$\vee\textsc{I}_1$]
\label{scase:disj1}
\begin{mathpar}
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A} \\
	M\ \vdash\ \onlyThrough{A_1'}{A_2}{A'}
	}
	{M\ \vdash\ \onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}
\end{mathpar}
By our induction hypothesis we have $M\ \vDash\ \onlyThrough{A_1}{A_2}{A}$ and $M\ \vdash\ \onlyThrough{A_1'}{A_2}{A'}$.
Thus, for all $M'$, 
\end{subcase}
\begin{subcase}[$\vee\textsc{I}_2$]
By similar reasoning to Subcase \ref{scase:disj1}.
\end{subcase}
\end{case}
\begin{case}[\textsc{Only If}]
\end{case}
\end{proof}
}


\newpage
\appendix

\section{Temporal Invariants}
{\color{red}(Julian: this section is old. I need to rethink some of this stuff.)}\\
Both the proof of Bank Account and the Safe examples rely on the invariant of encapsulation over time.
In the bank account proof, we rely on the fact that it is not possible for internal components to 
expose access to an account, and thus that if an external object has access to an account in the future, then 
some external object must have access to the account in the present moment. 
i.e.
$$\neg\langle \texttt{encapsulated}\ a  \rangle$$
is invariant. Specifically the following triple must be true:
$$\onlyThrough{a\ :\ \texttt{Account}}{\neg\langle \texttt{encapsulated}\ a  \rangle}{\neg\langle \texttt{encapsulated}\ a  \rangle}$$
We then use the rule \textsc{OI-Invariant} to arrive at 
$$\onlyIf{a\ :\ \texttt{Account}}{\neg\langle \texttt{encapsulated}\ a  \rangle}{\neg\langle \texttt{encapsulated}\ a  \rangle}$$

In the Safe example, we rely on the fact that the safe does not expose
its secret. Define the following predicate:
$$\langle x\ \texttt{encapsulated\_in}\ y\rangle\ =\ \forall\ z.[\neg \langle z\ \texttt{access}\ x \rangle\ \vee\ y.\texttt{is\_internal}(z)]$$
Now the following invariant is required to hold for the specification to be satisfied:
\small
$$\onlyThrough{s\ :\ \texttt{Safe}}{\neg\langle s.\texttt{secret}\ \texttt{encapsulated\_in}\ s  \rangle}{\neg\langle s.\texttt{secret}\ \texttt{encapsulated\_in}\ s  \rangle}$$
\normalsize
We then use \textsc{OI-Invariant} to get
\small
$$\onlyIf{s\ :\ \texttt{Safe}}{\neg\langle s.\texttt{secret}\ \texttt{encapsulated\_in}\ s  \rangle}{\neg\langle s.\texttt{secret}\ \texttt{encapsulated\_in}\ s  \rangle}$$
\normalsize

It isn't immediately clear how to deal with these invariants, as they both involve quantification, but they both form key parts of the proof 
of satisfaction in their respective examples.

%\section{Some work on different logics}
%In order to simplify some of the logics that are being developed in this 
%document, I am going to attempt to define the simplest form of these triples.
%{\color{red}(Julian: what I am doing here is trying to see if there is anything 
%interesting from using our triples in a different context. I think that there are 
%some things that might be interesting when coupling using the separating operators
%to model encapsulation (see Encap below). I think what is almost missing here is 
%some kind of guard mechanism for mutating the heap, i.e methods and objects, not
%just records. Plain Hoare logic is less interesting because of the lack of mutable state.)}
%	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	p, q & ::= & \textit{Hoare Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & p\ *\ q \\
%	| & p\ \sepImpl\ q \\
%	| & \neg p & \\
%	| & p\ \wedge\ p & \\
%	| & p\ \vee\ p & \\
%	| & p\ \longrightarrow\ p & \\
%	| & \forall\ x.\ [p] & \\
%	| & \exists\ x.\ [p] & \\
%	| & \mut{}{x}{f} & \\
%	| & \gives{}{x}{y} &
%	\end{array}
%	\]
%	\caption{Assertions Syntax for Intermediate State Separation Logic}
%	\label{f:assert_sep}
%	\end{figure}
%Fig. \ref{f:assert_sep} gives an assertion syntax for a logic about intermediate states that 
%includes the usual separating operators. The assertion forms include assertions for
%heap mutation: $\mut{}{x}{f}$ and $\gives{}{x}{y}$. 
%Satisfaction of assertions for given heap $h$, local variable map $s$, and continuation $c$, is given as 
%$$h,\ s,\ c\ \vDash\ p$$
%The heap $h$ contains records with fields that point to either other record locations, or values ($\integer\ \cup\ Locations\ \cup\ Booleans$).
%({\color{red}Julian: need to elaborate full semantics for satisfaction, also syntax for underlying language})
%
%Fig. \ref{f:intermediate_separation_logic} presents proof rules for a logic for reasoning about 
%intermediate states with separating operators.
%\begin{figure}[h]
%\footnotesize
%\begin{mathpar}
%\infer
%	{}
%	{\onlyThrough{x.f = y}{x.f \neq y}{\mut{}{x}{f}}}
%	\quad(\textsc{Mut$_1$})
%	\and
%\infer
%	{}
%	{\onlyThrough{x.f \neq y}{x.f = y}{\mut{}{x}{f}}}
%	\quad(\textsc{Mut$_2$})
%	\and
%\infer
%	{}
%	{\onlyThrough{\neg \access{x}{y}}{\access{x}{y}}{\gives{}{y}{x}}}
%	\quad(\textsc{Gives})
%	\and
%\infer
%	{}
%	{\onlyThrough{x\ \mapsto\ -\ *\ \forall z.[\access {z}{y}]}{\access{x}{y}}{x\ \mapsto\ -\ *\ (\forall z.[\access {z}{y}]\ \wedge\ \gives{}{y}{x}})}
%	\quad(\textsc{Encap})
%\end{mathpar}
%\caption{Intermediate State Separation Logic}
%\label{f:intermediate_separation_logic}
%\end{figure}


\bibliographystyle{abbrv}
\bibliography{main}
	
	\end{document}