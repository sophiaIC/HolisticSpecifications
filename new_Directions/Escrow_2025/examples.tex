
The specification of  a \prg{Purse} appears in Fig. \ref{fig:PurseSpec}. This specification is at level 1, and therefore pre-conditions for not mention $\obeys x {Purse}$ but postconditions do.
The specification of  an  \prg{Escrow} appears in Fig. \ref{fig:EscrowSpec}. This specifications is at level 2, and therefore both pre- and post-conditions may mention  $\obeys x {Purse}$ .

\newcommand{\sMT}{sellerM} 
\newcommand{\bMT}{buyerM}
\newcommand{\sGT}{sellerG} 
\newcommand{\bGT}{buyerG}
\newcommand{\sM}{\prg{\sMT}}
\newcommand{\bM}{\prg{\bMT}}
\newcommand{\sG}{\prg{\sGT}}
\newcommand{\bG}{\prg{\sGT}}


\subsection{Purse}

The \prg{Purse} has a ghost field (or abstract predicate), \prg{SameMint(\_)}, which guarantees that the receiver and argument belong to the same \prg{Mint}.  It also has another ghost field, which is the balance of the account.

\textbf{To discuss} \begin{enumerate}
\item
implicit obeys for the receiver
\item
\prg{SameMint} definition
\item
\prg{SameMint} role
\end{enumerate}
%   fields sellerMoney, sellerGoods, buyerMoney, buyerGoods //  Purse
%   fields price, amt   // Number
% had to drop this one

\begin{figure*}[t]
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{specification}$ $Purse$ {
    
    $\textbf{ghost}$ balance:int
    $\textbf{ghost}$ SameMint(x):bool  
         
    $\textbf{scoped-invr}\  \forall b:nat.[\ \inside{\prg{this}}  \ \wedge \prg{this}.\prg{balance}\geq b \ ]$
    $\textbf{invr}\   \forall p:\prg{Object}[\ \ \prg{this.SameMint(p)}\ \ ]$ // enough?
    $\textbf{scoped-invr}\   \forall p:\prg{Object}.,\forall b:bool.[\ \ \neg \prg{this.SameMint(p)}\ \ ]$ // enough?
    $\textbf{invr}\  \prg{this}.\prg{balance}\geq 0$       
    $\textbf{invr}\  \forall p:\prg{Object}.[\ \ \prg{this.SameMint(p)} \ \longrightarrow \  \obeys {\prg{p}} {Purse}\ \ ]$
     
    true  // implicit $\obeys {\prg{this}} {Purse}$
         $\textbf{\{}$ this.transfer(p,amt) $\textbf\}$ : bool
    res $\wedge$  this.SameMint(p) // implicit $\obeys {\prg{p}} {Purse}$
    $\vee$
    $\neg$res $\wedge$ [ this==p $\vee$ this.balance$\leq$amt $\vee$ $\neg(\, \prg{this.SameMint(p)}\,)$ ]

    this$\neq$p $\wedge$ this.balance=bm$\geq$amt  $\wedge$   this.SameMint(p)  
     // implicit $\obeys {\prg{this}} {Purse} \ \wedge\ \    \obeys {\prg{p}} {Purse}$
         $\textbf{\{}$ this.transfer(p,amt) $\textbf\}$ : bool
    res $\wedge$ this.balance=balT-amt $\wedge$ p.balance=balP+amt 

}

\end{lstlisting}
\caption{Specification of  $Purse$ }
\label{fig:PurseSpec}
 \end{figure*}
 
 NOTE: Julian proposed to replace lines 7 and 8 above with   \\
 $\ \ \  $ $\textbf{scoped-invr}\   \forall p:\prg{Object}.,\forall b:bool.[\ \ \neg \prg{this.SameMint(p)}\ \ ]$ 
But this would require us to ecplain that $b$ is a value and not a variable. HMHHHHH Is this also a problem in the OOPSLA-25 paper!!!

A possible implementation of \prg{Purse} appears below. The Purses have a field storing therr Mint and their balance

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{class}$ $PurseImpl\_a\ \textbf{implements} Purse$ {
    
    $\textbf{field}$  myMint: Mint
    $\textbf{field}$  myBalance: int
     
    $\textbf{ghost}$ SameMint(x) $\textbf{is}$ this.myMint = x.myMint
    $\textbf{ghost}$ balance $\textbf{is}$ this.myBalance
    
    method transfer(p:Object,amt:nat)  // external
    	if p.myMint == this.myMint and this.blance>= amt 
	then
		this.balance -= amt
		p.balance += amt
		// will throw exception if p is not from class \prg{Purse}
		return true
	else
		return false	
  
}
\end{lstlisting}

A anotherimplementation of \prg{Purse} appears below. The Purses have a field storing their Mint, but their balances are stored in a 
lookup table in the Mint

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
 $\textbf{class}$ Mint{

	field myPurses ... a list of Purse
	field myBalances .., a map from Purse to int
	
	method inMint(p:Purse) : bool    //  internal
	...	
	method getBalance{p:Purse): int
	...
	method setBalance(p:Purse,amt:int): void
	...	
}
 $\textbf{class}$Purse{
    
    $\textbf{field}$  myMint: Mint
     
    $\textbf{ghost}$ SameMint(x) $\textbf{is}$ this.myMint.inMint(x)
    $\textbf{ghost}$ balance $\textbf{is}$ this.myMint = x.myMint
    
    method transfer(p:Object,amt:nat) // external 
    	if myMint.inMint(p) and myMint.getBalance(this)>= amt 
	then
		myMint.setBalance(this,...)
		myMint.setBalance(p,...)
		return true
	else
		return false	
  
}
\end{lstlisting}



\begin{figure*}[t]
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{specification}$ $Escrow$ {
    
    //   1$^{st}$ case:
    $\obeys  {\{\sM,\sG\}} {Purse}$ $\wedge$ 
    $\sM$.SameMint($\bM$) $\wedge$  $\sG$.SameMint($\bG$)  $\wedge$ price, amt:$\mathbb{N}$  $\wedge$
    $\bM$.balance=bm$\geq$price  $\wedge$  $\sM$.balance=sG$\geq$amt $\wedge$ ...
    $\obeys  {p} {Purse}$   $\wedge$ p.balance = pM
           $\textbf{\{}$ this.deal($\sM,\, \bM,\, \sG,\, \bG$, price, amt) $\textbf\}$
    res $\wedge$
    $\bM$.balance=bM-price $\wedge$ $\sM$.balance=....  $\wedge$
    p.balance=pM

     //   2$^{nd}$ case:
    $\obeys  {\sM } {Purse}$ $\wedge$ $\neg(\obeys  { \bM} {Purse})$ $\wedge$ 
    ....
    $\obeys  {p} {Purse}$ $\wedge$ $\protectedFrom {p} {\{ \bM, \sG, \bG \}}$  $\wedge$ p.balance = pM
          $\textbf{\{}$ this.deal($\sM,\, \bM,\, \sG,\, \bG$, price, amt) $\textbf\}$
    $\neg$ res $\wedge$
    .... $\wedge$
    p.balance=pM
     
}

\end{lstlisting}
\caption{Specification of  $Escrow$.\prg{::deal} -- Incomplete}
\label{fig:EscrowSpec}
 \end{figure*}