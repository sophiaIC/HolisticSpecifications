\label{sub:SpecO}


Our assertions are    standard  (\eg properties of the values of expressions,  connectives, quantification \etc),   about protection (\ie ${\protectedFrom{{\re}} {{\re}}} $ and  $ {\inside {{\re}}} $), and about adherence to Specifications ($ {\obeys {\re} {S}}$).


\begin{definition}
\label{def:assert:syntax}
%Expressions, $\re$, 
%Assertions, $A$,  are defined as follows:
%
%\label{f:chainmail-syntax}
%$
%\begin{syntax}
%\syntaxElement{A\ \ }{}
%		{
%		\syntaxline
%				{{\re}}
%				{{\re} : C}
%				{\external{{\re}}}
% 				{\protectedFrom{{\re}} {{\re}}} 
%				 {\inside {{\re}}} 
%				 {\obeys {\re} {S}}
%				 {\neg A}
%				{A\ \wedge\ A}
%				{\all{x:C}{A}}				
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\end{syntax}
% 

We   define \emph{concrete} assertions $\co {A}$, \emph{basic} assertions which contain no $\textbf{obeys}$ clauses $\ba A$, and well-formed assertions $\wf {A}$, as follows (where $S$ stands for a specification identifier):

$
\begin{syntax}
\syntaxElement{\co A}{}
		{
		\syntaxline
				{{\re}}
				{{\re} : C}
				{\external{{\re}}}
 				{\protectedFrom{{\re}} {{\re}}} 
				 {\inside {{\re}}} 
				  {\neg \co A}
				{\co A\ \wedge\ \co A}			
		\endsyntaxline
		}
\endSyntaxElement
 \\
\syntaxElement{\ba A}{}
		{
		\syntaxline
				{{\re}}
				{{\re} : C}
				{\external{{\re}}}
 				{\protectedFrom{{\re}} {{\re}}} 
				 {\inside {{\re}}} 
				  {\neg \ba A}
				{\ba A\ \wedge\ \ba A}
								{\all{x:C}{\ba A}}				
		\endsyntaxline
		}
\endSyntaxElement
\\
\syntaxElement{\wf A  }{}
		{
		\syntaxline
				{{\re}}
				{{\re} : C}
				{\external{{\re}}}
 				{\protectedFrom{{\re}} {{\re}}} 
				 {\inside {{\re}}} 
				{\neg \ba A}
				{\wf A\ \wedge\ \wf A \strut \  \ \  \ }
				{\all{x:C}{\wf A} }	
				 {\obeys {\re} {S}}				 			
		\endsyntaxline
		}
\endSyntaxElement
\end{syntax}
$

 
\end{definition}

Concrete assertions, $\co A$ will be used when modules give meaning to abstract predicates, and basic assertions $\ba A$ are used in order to ensure that $\textbf{obeys}$ clauses do not appear in negative positions in our assertions $\wf A$.
 
\footnote{ AUTHORS:  
 Note that $\re$ are ghostfields, and therefore can also be abstract predicates whose bodies are defined in the modules -- same as in ghostfields. 
 Perhaps we do not need to clarify this.
 }
 
%\label{def:chainmail-semantics-all}
%\label{dup:def:chainmail-semantics}
%\noindent
 Satisfaction  of  obeys-free assertions, $\ba A$ by a module and a state is expressed  through \ $\satisfiesAB{M}{\sigma}{{\ba A}}$ \  and defined by cases on the shape of $\ba A$, in definitions \ref{def:chainmail-semantics}.


\begin{definition}[Satisfaction of Basic Assertions] 
\label{def:chainmail-semantics}
\label{def:chainmail-protection-from}
\label{sect:semantics:assert:prtFrom}
 \label{def:chainmail-protection}
 We define satisfaction of basic assertions, $\ba A$, by a % program 
state $\sigma$ and 
 module $M$ as:\footnote{AUTHORS: This is essentially OOPSLA 2025}
\begin{enumerate}
\item
\label{cExpr}
$\satisfiesAB{M}{\sigma}{{\re}}\ \ \ \triangleq \ \ \   \eval{M}{\sigma}{{\re}}{\true}$
\item
\label{cClass}
$\satisfiesAB{M}{\sigma}{{{\re}} : C}\ \ \ \triangleq \ \ \   \eval{M}{\sigma}{{\re}}{\alpha}\   \wedge \ \class{\alpha} {\sigma}= C$
\item
\label{cExternal}
$\satisfiesAB{M}{\sigma}{\external{{\re}}} \ \ \ \triangleq \ \ \  \exists C.[\ \satisfiesAB{M}{\sigma}{{{\re}} : C} \ \wedge \ C \notin M \ ]$
 
 \item
 \label{cProtected}
$\satisfiesAB{M}{\sigma}{\protectedFrom{{\re}} {{\re_{o}}}}$ $\ \  \triangleq\ \ $
$\exists \alpha, \alpha_{o}. [$ 
  \begin{enumerate}
 \item
 $ \eval{M}{\sigma}{{\re}}{\alpha}\ \ \ \wedge\ \ \eval{M}{\sigma}{{\re_o}}{\alpha_o}$,
  \item
$\alpha\neq \alpha_0$,
 \item
$\forall \alpha'.\forall f.[\ \alpha' \in {\Relevant {\alpha_o} {\sigma}} \wedge\   \satisfiesAB{M}{\sigma}{\external {\alpha'}} 
\ \ \Longrightarrow \ \  
  \interpret {\sigma} {\alpha'.f} \neq \alpha     \ ] $  $  \strut \hspace{.25cm} ] $.
\end{enumerate}

\item
 \label{sect:semantics:assert:prt}
$\satisfiesAB{M}{\sigma}{\inside{{\re}}} $ $\ \  \triangleq\ \  $ 
$\exists \alpha. [$  
\begin{enumerate}
\item
$ \eval{M}{\sigma}{{\re}}{\alpha}$,
 \item 
 $\satisfiesAB{M}{\sigma}{\extThis}\ \ \Longrightarrow\ \ \forall x\!\in\! \sigma.\ \satisfiesAB{M}{\sigma}{x\neq \alpha}$,
 \item
$\forall \alpha'.\forall f.[\ \alpha' \in {\LRelevantO {\sigma}} \wedge\   \satisfiesAB{M}{\sigma}{\external {\alpha'}} 
\ \ \Longrightarrow \ \  
  \interpret {\sigma} {\alpha'.f} \neq \alpha     \ ]$ 
 \strut \hspace{.25cm} ].    \end{enumerate} 
 
  \item
$\satisfiesAB{M}{\sigma}{\neg \ba A}\ \ \ \triangleq \ \ \   \notsatisfiesAB{M} {\sigma} {\ba A}$
\item
$\satisfiesAB{M}{\sigma}{\ba A_1\ \wedge\ \ba A_2}\ \ \ \triangleq \ \ \   \satisfiesAB{M}{\sigma}{\ba A_1} \   \wedge \ \satisfiesAB{M}{\sigma}{\ba A_2}$
\item
\label{quant1}
$\satisfiesAB{M}{\sigma}{\all{x:C}{\ba A}} \ \ \ \triangleq \ \ \   
\forall \alpha.[\   \satisfiesAB {M}{\sigma} {\alpha:C}  \ \Longrightarrow   \ \satisfiesAB{M}{\sigma} {\ba A[\alpha/x]} \ ] $
\end{enumerate}

 \end{definition} 

We now define specifications

\begin{definition}[Specifications]
A specification consists of a name and a set of policies

$
\begin{syntax}
\syntaxElement{Spec}{}
		{
		\syntaxline
				{ {\textbf{specification}}\ \  S \ \{ \ { {\textbf{abstt}}\ P ( x^* ) } \ Policy^* \} }		
		\endsyntaxline
		}
\endSyntaxElement
\syntaxElement{Policy}{}
		{
		\syntaxline				
 				{ \{ \ \wf A \ \} \ \  \prg{this.m(y}^*\prg{)} \ \ 	     \{ \ \wf A \ \}	}
% 				{ \{ \ \wf A \ \} \ \ \prg{any\_code} \ \   \{ \ \wf A \ \}	}	
				{ {\textbf{inve}}\ A \  }	
		\endsyntaxline
		}
\endSyntaxElement
\end{syntax}
$

 \end{definition} 
 
 We now define satisfaction of well-formed assertions, For this, we will be using step-indexing. 
 We use $\satisfiesAK M \sigma k A$, where $k\in \mathbb{N}$ to express that $A$ is satisfied at level $k$.
 
 
 \begin{definition}[Satisfaction of Well-fomedAssertions] 
For any module $M$, state $\sigma$, assertion $A$ and $k\!\in\! \mathbb{N}$ we define
\begin{enumerate}
\item
\label{cExpr}
$\satisfiesAK{M}{\sigma} k {\re}  \ \ \triangleq \ \ \   \satisfiesAB{M}{\sigma}{{\re}}$
\item
\label{cClass}
$\satisfiesAK{M}{\sigma} k {\re  : C}\ \ \ \triangleq \ \ \    \satisfiesAB{M}{\sigma} {\re  : C}$
\item
\label{cExternal}
$\satisfiesAK{M}{\sigma} k {\external{{\re}}} \ \ \ \triangleq \ \ \satisfiesAB{M}{\sigma}{\external{{\re}}} $
 
 \item
 \label{cProtected}
$\satisfiesAK{M}{\sigma} k {\protectedFrom{{\re}} {{\re_{o}}}}$ $\ \  \triangleq\ \ $
$\satisfiesAB{M}{\sigma}{\protectedFrom{{\re}} {{\re_{o}}}}$ 

\item
 \label{sect:semantics:assert:prt}
$\satisfiesAK{M}{\sigma} k {\inside{{\re}}} $ $\ \  \triangleq\ \  $ 
$\satisfiesAB{M}{\sigma}{\inside{{\re}}}$ 
 
 
  \item
$\satisfiesAK{M}{\sigma} k {\neg \ba A}\ \ \ \triangleq \ \ \   \satisfiesAB{M}{\sigma}{\neg \ba A}$
\item
$\satisfiesAK{M}{\sigma} k {\wf A_1\ \wedge\ \wf A_2}\ \ \ \triangleq \ \ \   \satisfiesAK{M}{\sigma} k {\wf A_1}\ \wedge\ \satisfiesAK{M}{\sigma} k {\wf A_2}$
\item
\label{quant1}
$\satisfiesAK{M} k {\sigma}{\all{x:C}{\wf A}} \ \ \ \triangleq \ \ \   
\forall \alpha.[\   \satisfiesAB {M}{\sigma} {\alpha:C}  \ \Longrightarrow   \ \satisfiesAK{M}{\sigma}  k {\wf A[\alpha/x]} \ ] $
\item
$\satisfiesAK{M} \sigma k {\obeys \re S}$ \ \ is defined by cases on $k$:
\begin{itemize}
\item
$\satisfiesAK{M} \sigma  0 {\obeys \re S}  \ \ \ \ \ \triangleq \ \ \   \exists \alpha. \eval{M}{\sigma}{{\re}}{\alpha}$
\item
$\satisfiesAK{M} \sigma  {k+1} {\obeys {\re} {S}}  \ \ \ \triangleq \ \ \   \satisfiesAK{M} \sigma {k} {\obeys {\re} {S}} \wedge \forall pol\! \in\! S. \satisfiesAK{M}\sigma  {k} {\obeys {\re} {pol}}$
\end{itemize}
\item
$\satisfiesAK{M} \sigma  k {\obeys \re pol}$ \ \ for policies, $pol$  is defined by cases on $piol$
\begin{itemize}
\item
$\satisfiesAK{M} \sigma  0 {\obeys \re pol}  \ \ \ \triangleq \ \ \   \exists \alpha. \eval{M}{\sigma}{{\re}}{\alpha}$
\item
$\satisfiesAK{M} \sigma  {k+1} {\obeys {\re} {S}}  \ \ \ \triangleq \ \ \ $
\begin{itemize}
\item
 $ \satisfiesAK{M} \sigma {k} {\obeys {\re} {pol}} $
 \item
$\forall M', \sigma''.[ M'*M. \sigma \leadsto^k \sigma'' \wedge  the pol after k steps for k $
\end{itemize}
\end{itemize}
\end{enumerate}

 \end{definition} 
 
 
 
 
