\section{Example: Taming Effects for the Shop/Account}
In Section \ref{s:outline} we introduced a \verb|Shop| that allows clients to make purchases through the
\verb|buy| method, a method that included a method call to an unknown external object (\verb|buyer.pay(...)|).
Here we use our Hoare logic from Section \ref{sect:proofSystem} to prove that the \verb|buy| method
does not expose the \verb|Shop|'s  \verb|Account|, its \verb|Key|, or allow the \verb|Account|'s balance to be illicitly modified. 
More specifically, we prove the following scoped invariants are satisfied by \verb|M|$_{good}$\\
%$\strut \SPSP  S_1\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{a}}} $ 
%\\
$\strut  \SPSP  S_1\ \  \triangleq \ \ \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}} $ 
 \\
%$\strut  \SPSP   S_3\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account},\prg{b}:\prg{int}}  {\inside{\prg{a}} \wedge \prg{a.\balance}=\prg{b}}  $
%\\
$\strut  \SPSP  S_2\ \  \triangleq \ \ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.key}} \wedge \prg{a.\balance} \geq \prg{b} } $\\
\verb|M|$_{good}$ is given below.
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{good}$
  ...   
  class Shop
    field accnt:Account, invntry:Inventory, clients:[external]    
  
    public method buy(buyer:external, anItem:Item)
      int price = anItem.price
      int oldBlnce = this.accnt.blnce
      buyer.pay(this.accnt, price)     // $\red{\mbox{external\ call}}!$
      if (this.accnt.blnce == oldBlnce+price)  this.send(buyer,anItem)
      else
         buyer.tell("you have not paid me") 
      return 0
     
      private method send(buyer:external, anItem:Item)  
       ... 
  class Key
  class Account
    field blnce:int 
    field key:Key
    public method transfer(dest:Account, key':Key, amt:int)
      if (this.key==key')
        this.blnce-=amt
        dest.blnce+=amt
     public method set(key':Key)
      if (this.key==null)  this.key=key'
\end{lstlisting}

For brevity we only show that \verb|buy| satisfies our scoped invariants, as the all other methods of 
the \verb|M|$_{good}$ interface are relatively simple, and do not make any external calls. 
Our approach follows the 3 phases outlined in Section \ref{sect:proofSystem}. That is, in
phase 1 we use more an assumed underlying Hoare logic and more traditional Hoare triples to prove the adherence of internal code to
the specification. In phase 2 we use Hoare quadruples to prove external calls adhere
to the specificaiton, and finally in phase 3 we use raise the results from phase 1 and 2 to proved
the entire module satisfies the specification.

In this section we deal with scalar values are well as addresses, and therefore extend the defintion of protection (Def \ref{def:chainmail-protection-from }) as follows:

\begin{definition}[Satisfaction 
of Assertions  -- Protected From] 
extending the defintion of Def 
\ref{def:chainmail-protection-from}, where we use $\alpha$ to range over addresses, $\beta$  to range over scalars, and   $\gamma$ to range over addresses or scalars.

\noindent
We define  $\satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\gamma_{o}}}} $ as:
\begin{enumerate}
\item
\label{cProtected}
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\alpha}} {{\alpha_{o}}}}   \ \ \ \triangleq $ 
  \begin{itemize}
 \item
$\alpha\neq \alpha_0$,
 \ \ \ \  and% \\
 \item
$\forall n\in\mathbb{N}. \forall f_1,...f_n..
[\ \ \interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha \ \ \  \Longrightarrow \ \ \  \satisfiesA{M}{\sigma}{ {\interpret{\sigma}{\alpha_{o}.f_1...f_{n-1}}}:C} \ \wedge \ C\in M\ \ ]$
\end{itemize}
\item
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\beta_{o}}}}   \ \ \ \triangleq  \ \ \ true$
 \item
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\beta}} {{\alpha_{o}}}}   \ \ \ \triangleq  \ \ \ false$
  \item
$\satisfiesA{M}{\sigma}{\protectedFrom{{\re}} {{\re_{o}}}} \ \ \ \triangleq $ \\
  $\exists \gamma, \gamma_{o}. [\  \ \eval{M}{\sigma}{{\re}}{\gamma}\ \wedge \eval{M}{\sigma}{{\re_0}}{\gamma_0} \  \wedge \ 
  \satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\gamma_{o}}}}
 \ \  ]$
 \end{enumerate}
 \end{definition} 

\begin{lemma}
\label{lemma:exampleKeyProtect}
$M_{good} \vdash S_1$
\end{lemma}
\begin{proof}
We construct our proof tree using a top down approach.  That is, we start with our goal
$$M_{good} \vdash \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{\prg{a.key}}}}$$
and apply  \textsc{Invariant} from Fig. \ref{f:wf}.
From this we are left with a subgoal for each method $m$ in  class $C$ with parameters $\overline{y:D}$ in the public interface of $M_{good}$ (note, we denote the body of such a method as \prg{C}::\prg{m}.\prg{body}):
\small
\begin{align*}
M_{good} \vdash
		& \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\,
		   {\inside{\prg{a.key}}}\} \\
		& \prg{C}::\prg{m}.\prg{body}\ \\
		& \{\ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}\ \}\ ||\ \{\ {\inside{\prg{a.key}}} \ 			\} 
\end{align*}
\normalsize
Thus, we need to prove the above for \prg{buy} in the \prg{Shop} class:
\small
\begin{align*}
\text{(1)}  \ \ \ \ M_{good} \vdash 
		&	\{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account}\,\wedge\, 
				{\inside{\prg{a.key}}} \} \\
		& \prg{Shop}::\prg{buy}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
\prg{transfer} in the \prg{Account} class:
\small
\begin{align*}
\text{(2)}  \ \ \ \ M_{good} \vdash 
		&	\{  \prg{this}:\prg{Account}, \prg{dest} : \prg{Account}, 
			\prg{key'} : \prg{Key},\, \prg{amt}:\prg{int},\, \prg{a}:\prg{Account}\,
			\wedge\,{\inside{\prg{a.key}}} \} \\
		& \prg{Account}::\prg{transfer}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
and \prg{set} in the \prg{Account} class:
\small
\begin{align*}
\text{(3)}  \ \ \ \ M_{good} \vdash 
		&	\{  \prg{this}:\prg{Account},\,
			\prg{key'} : \prg{Key},\, \prg{a}:\prg{Account}\,
			\wedge\,{\inside{\prg{a.key}}} \} \\
		& \prg{Account}::\prg{set}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize

We start with the \prg{buy} method within the \prg{Shop} class. i.e.:
\small
\begin{align*}
\text{(1)}  \ \ \ \ M_{good} \vdash 
		&	\{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account}\,\wedge\, 
				{\inside{\prg{a.key}}} \} \\
		& \prg{Shop}::\prg{buy}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
We construct this proof using the quadruple rules described in \ref{sect:proofSystem}. By our hoare triple extension and the \textsc{Mid} rule that raises triples to quaruples, the first two lines
of \prg{buy} preserve the precondition in (1) above, and further that 
\small
$$
\text{(2)} \ \ \ \ \prg{price} : \prg{int}
$$ 
$$
\text{(3)} \ \ \ \ \prg{this.accnt} : \prg{Account}
$$ 
We now need to prove that the external method call \prg{buyer.pay(this.accnt, price)} protects the \prg{key}. i.e.
\small
\begin{align*}
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\inside{\prg{a.key}}}  \} \ \ \  || \ \ \ 
		  		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
By the \textsc{Consequ} in Fig. \ref{f:substructural} and \ref{rule for deriving protection from integers and internal objects} (add to underlying assertion proof system???), we have
\small
\begin{align*}
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \ \ \  || \ \ \ \\
		  		& \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
Using the rules \textsc{Call\_Ext\_Adapt\_Strong} and \textsc{Consequ} above, we prove that our precondition is maintained across the external call. 
Next need to show that the precondition is maintained across the If-statement:
\small
\begin{align*}
\text{(4)}  \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \\
		  		&\;\;\; \prg{if (this.accnt.blnce == oldBlnce+price) this.send(buyer, anItem)}\ \\  
				&\;\;\;  \prg{else buyer.tell("you have not paid me")}\\
		  		& \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \ \ \  || \ \ \ \\
		  		& \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
This can easily be discharged using the rule for \prg{if}-statements in the underlying Hoare logic, giving the following two proof obligations:
\small
\begin{align*}
\text{(5)}  \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}} \\
				& \prg{this.accnt.blnce} = \prg{oldBlnce+price}\} \\
		  		&\;\;\; \prg{this.send(buyer, anItem)}\ \\  
		  		& \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \ \ \  || \ \ \ \\
		  		& \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
and 
\small
\begin{align*}
\text{(6)}  \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}} \\
				& \prg{this.accnt.blnce} \neq \prg{oldBlnce+price}\} \\
		  		&\;\;\; \prg{buyer.tell("you have not paid me")}\ \\  
		  		& \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \ \ \  || \ \ \ \\
		  		& \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
(5) can be discharged using the method specifications for the private method \prg{Shop::send}. (6) can be discharged using a similar approach as with (4).

%\jm{(julian: I did the below bit because I thought it would be necessary, but I'm not sure that it is. I feel like this might be a problem. Don't we need to know that \prg{a.key} is protected from the arguments to \prg{buyer.pay}?????)}
%
%From the definition of protection \jm{(Julian: we need some proof rules for this)}, 
%we have 
%$$
%\text{(5)} \ \ \ \ \protectedFrom{\prg{a.key}}{\prg{this.accnt}}
%$$
%since $\prg{this.accnt}:\prg{Account}$ and $\prg{Account} \in M_{good}$.
%We also get
%$$
%\text{(6)} \ \ \ \ \protectedFrom{\prg{a.key}}{\prg{price}}
%$$
%because \prg{price} is a prmitive and is thus everything is protected from 
%it. \jm{(julian: we need to add this.)}
%
%This gives us:
%\small
%\begin{align*}
%\text{(7)} \ \ \ \ 
%M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
%				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
%				  \prg{this.accnt}:\prg{Account},\, \\
%				& \prg{price} : \prg{int},\,
%				  \wedge\, 
%				  \external z \wedge\ 
%				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge\, 
%				  \protectedFrom{\prg{a.key}}{\prg{price}}\, \wedge\, \\
%				& \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \\
%		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
%		  		& \{ {\protectedFrom{\prg{a.key}}{z}} \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
%\end{align*}
%\normalsize
%
%
%\jm{Julian: I don't think below is necessary...}\\
%\jm{Julian: I think there might be a problem here. If \prg{buyer.pay} had an external 
%object as an
%argument, then there would be no way we'd able to prove that \prg{a.key} was 
%protected from that external object.}
%Now we use the fact the \jm{law of excluded middle} and \textsc{Conseq} to introduce $\prg{a} = \prg{this.accnt}\ \vee\ \prg{a} \not= \prg{this.accnt}$ to the precondition.
%\small
%\begin{align*}
%\text{(5)} \ \ \ \ 
%M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
%				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
%				  \prg{this.accnt}:\prg{Account},\, \\
%				& \prg{price} : \prg{int},\,
%				  \wedge\, 
%				  \external z \wedge\ 
%				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge \,
%				  \prg{a} = \prg{this.accnt}\ \vee\ \prg{a} \not= \prg{this.accnt} \} \\
%		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
%		  		& \{ {\protectedFrom{\prg{a.key}}{z}}  \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
%\end{align*}
%\normalsize
%Now \jm{the traditional  Hoare rule for disjunction} gives us two subgoals:
%\small
%\begin{align*}
%\text{(6.1)} \ \ \ \ 
%M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
%				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
%				  \prg{this.accnt}:\prg{Account},\, \\
%				& \prg{price} : \prg{int},\,
%				  \wedge\, 
%				  \external z \wedge\ 
%				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge \,
%				  \prg{a} = \prg{this.accnt} \} \\
%		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
%		  		& \{ {\protectedFrom{\prg{a.key}}{z}}  \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
%\end{align*}
%\normalsize
%\small
%\begin{align*}
%\text{(6.2)} \ \ \ \ 
%M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
%				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
%				  \prg{this.accnt}:\prg{Account},\, \\
%				& \prg{price} : \prg{int},\,
%				  \wedge\, 
%				  \external z \wedge\ 
%				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge \,
%				  \prg{a} \not= \prg{this.accnt} \} \\
%		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
%		  		& \{ {\protectedFrom{\prg{a.key}}{z}}  \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
%\end{align*}
%\normalsize
%Both (5.1) and (5.2) can now be discharged in the same manner, since in both cases, \prg{a.key} is protected from the arguments of \prg{buyer.pay}.  Finally, by application of \textsc{Conseq} and \textsc{Call\_Ext\_Adapt} we get our goal.
%\small
%\begin{align*}
%\text{(3)} \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item}, \prg{price} : \prg{int} \, \wedge\, 
%		 \prg{a} : \prg{Account}\, \wedge\,  \inside{\prg{a.key}} \}  \\
%		 & \prg{buyer.(this.accnt, price)} \ \{ \inside{\prg{a.key}} \} \ \ \  || \ \ \  \{ \inside{\prg{a.key}} \}
%
%\normalsize
\end{proof}



\begin{lemma}
$M_{good} \vdash S_2$
\end{lemma}
\begin{proof}
We construct our proof tree using a top down approach.  That is, we start with our goal
$$M_{good} \vdash \TwoStatesN {\prg{a}:\prg{Account}, \prg{b} : \prg{int}}  {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}$$
and apply  \textsc{Invariant} from Fig. \ref{f:wf}.
From this we are left with a subgoal for each method $m$ in  class $C$ with parameters $\overline{y:D}$ and body $stmt$ in the public interface of $M_{good}$:
\small
\begin{align*}
M_{good} \vdash
		& \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\,
		   {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\} \\
		& stmt\ \\
		& \{\ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\ \wedge\ {\PushASLong {\prg{res}} {(\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b})}}\ \}\ ||\ \{\ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}} \ 			\} 
\end{align*}
\normalsize
We can simplify the above using the definition of $\PushASLong{\overline{z}}{A}$:
\small
\begin{align*}
M_{good} \vdash
		& \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\,
		   {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\} \\
		& stmt\ \\
		& \{\ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\ \wedge\ \protectedFrom{\prg{a.key}}{\prg{res}}\ \}\ ||\ \{\ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}} \ 			\} 
\end{align*}
\normalsize
This is relatively simple to prove for methods without external method calls, as we can rely entirely on the Hoare logic extension described in Section \ref{sect:proofSystem}. As in Lemma \ref{lemma:exampleKeyProtect} the only  method within $M_{good}$ that contains 
an external method call is  the \prg{buy} method within the \prg{Shop} class. Thus, we need to prove:
\small
\begin{align*}
\text{(1)}  \ \ \ \ M_{good} \vdash 
		&	\{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account}\,\wedge\, 
				{\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\} \\
		& stmt\ \\  
		& \{ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\ \wedge\ \protectedFrom{\prg{a.key}}{\prg{res}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}} \}
\end{align*}
\normalsize
Where $stmt$ is the body of \prg{buy}. We now construct this proof using the quadruple rules described in \ref{sect:proofSystem}. By our hoare triple extension and the \textsc{Mid} rule that raises triples to quaruples, the first two lines
of \prg{buy} preserve the precondition in (1) above, and further that 
\small
$$
\text{(2)} \ \ \ \ \prg{price} : \prg{int}
$$ 
$$
\text{(3)} \ \ \ \ \prg{this.accnt} : \prg{Account}
$$ 
We now need to prove that the external method call \prg{buyer.pay(this.accnt, price)} protects the \prg{key}. i.e.
\small
\begin{align*}
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\ \wedge\ \protectedFrom{\prg{a.key}}{\prg{res}}  \} \ \ \  || \ \ \ 
		  		   \{ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}} \}
\end{align*}
\normalsize
By the \textsc{Consequ} in Fig. \ref{f:substructural} and \ref{rule for deriving protection from integers and internal objects} (add to underlying assertion proof system???), we have
\small
\begin{align*}
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{this.accnt}:\prg{Account}\\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\ \wedge\ 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\ \wedge\ 
				   \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}\ \wedge\ \protectedFrom{\prg{a.key}}{\prg{res}}  \} \ \ \  || \ \ \ 
		  		   \{ {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}} \}
\end{align*}
\normalsize

This is discharged by the rules \textsc{Call\_Ext\_Adapt\_Strong} and \textsc{Consequ}, giving us the desired result.
\end{proof}

%$$M_{shop} \vdash \{{\inside{\texttt{a.key}}}\}\ {\texttt{public}\ \texttt{Shop}}::{\texttt{buy}}{(\texttt{buyer} : \texttt{external})}\ \{{\inside{\texttt{a.key}}}\}\ ||\ \{{\inside{\texttt{a.key}}} \}$$
%\end{proof}
%\begin{lemma}
%$$M_{good} \vdash \{{\inside{\texttt{a.key}}}\}\ {\texttt{public}\ \texttt{Shop}}::{\texttt{buy}}{(\texttt{buyer} : \texttt{external}, \texttt{price} : \texttt{int})}\ \{{\inside{\texttt{a.key}}}\}\ ||\ \{{\inside{\texttt{a.key}}} \}$$
%\end{lemma}
%\begin{lemma}
%$$M_{good} \vdash \{{\inside{\texttt{a.key}}}\}\ {\texttt{public}\ \texttt{Shop}}::{\texttt{buy}}{(\texttt{buyer} : \texttt{external}, \texttt{price} : \texttt{int})}\ \{{\inside{\texttt{a.key}}}\}\ ||\ \{{\inside{\texttt{a.key}}} \}$$
%\end{lemma}