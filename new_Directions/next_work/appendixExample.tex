\newcommand{\SPT}{~ \strut \hspace{.9cm}}
%\newcommand{\Aparams}{\prg{A}_{prms}}
\newcommand{\Alocals}{\prg{A}_{buy}}
\newcommand{\Alocalsb}{\prg{A}_{1}}
\newcommand{\Ids}{\prg{Ids}_{buy}}
%\newcommand{\Aparamstr}{\prg{A}_{prmsT}}
\newcommand{\Alocalstr}{\prg{A}_{trns}}
\newcommand{\Idstr}{\prg{Ids}_{trns}}
%\newcommand{\Aparamsset}{\prg{A}_{prmsS}}
\newcommand{\Alocalsset}{\prg{A}_{set}}
\newcommand{\Alocalssets}{\prg{A}_{2}}
\newcommand{\Idsset}{\prg{Ids}_{set}}
\newcommand{\stmtsP}{\prg{stmts}_{10,11,12}}
\newcommand{\step}[1]{ \vspace{.1cm} \noindent {\textbf{#1}}}

\section{  {Proving \Tamed Effects for the Shop/Account Example}}

\label{s:app:example}

In Section \ref{s:outline} we introduced a \verb|Shop| that allows clients to make purchases through the
\verb|buy| method.
The body if this method  includes a method call to an unknown external object (\verb|buyer.pay(...)|).

In this section  we use our Hoare logic from Section \ref{sect:proofSystem} to {outline the proof} that the \verb|buy| method
does not expose the \verb|Shop|'s  \verb|Account|, its \verb|Key|, or allow the \verb|Account|'s balance to be illicitly modified. 

More generally,   given  the following scoped invariants, \\  
$\strut  \SPSP  S_2\ \  \triangleq \ \ \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}} $ 
 \\
$\strut  \SPSP  S_3\ \  \triangleq \ \ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.key}} \wedge \prg{a.\balance} \geq \prg{b} } $ 
\\
 we {outline the proof} that $M_{good} \vdash S_2$, and that $M_{fine} \vdash S_2$.
{We  also show why $M_{bad} \not\vdash S_2$.}

{We first extend the semantics and the logic to deal with scalars (\S \ref{s:app:scalars}). 
We then extend the Hoare Logic with rules for conditionals, case analysis, and a contradiction rule
(\S \ref{s:app:more:Hoare}).
We then rewrite the code of $M_{good}$ and so $M_{fine}$
so that it adheres to the syntax as defined in Fig. \ref{f:loo-syntax} (\S \ref{s:app:syntax:transform}). 
After that, we outline the proofs (\S \ref{s:app:example:proofs}) --
these proofs have been mechanized in Coq, and the source code will be
submitted as an artefact. %{xxxx}.
Finally, we discuss why $M_{bad} \not\vdash S_2$ (\S \ref{s:app:example:why}).}


\subsection{Extend the semantics and Hoare logic to accommodate scalars and conditionals}
\label{s:app:scalars}

{We extend the notion of protection to also allow it to apply to scalars. }

\begin{definition}[Satisfaction  of Assertions  -- Protected From]
\label{def:chainmail-protection-from-ext}
extending the definition of Def 
\ref{def:chainmail-protection-from}. We use $\alpha$ to range over addresses, $\beta$  to range over scalars, and   $\gamma$ to range over addresses or scalars.

\noindent
We define  $\satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\gamma_{o}}}} $ as:
\begin{enumerate}
\item
\label{cProtectedNew}
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\alpha}} {{\alpha_{o}}}}   \ \ \ \triangleq $ 
  \begin{itemize}
 \item
$\alpha\neq \alpha_0$,
 \ \ \ \  and% \\
 \item
$\forall n\in\mathbb{N}. \forall f_1,...f_n..
[\ \ \interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha \ \ \  \Longrightarrow \ \ \  \satisfiesA{M}{\sigma}{ {\interpret{\sigma}{\alpha_{o}.f_1...f_{n-1}}}:C} \ \wedge \ C\in M\ \ ]$
\end{itemize}
\item
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\beta_{o}}}}   \ \ \ \triangleq  \ \ \ true$
 \item
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\beta}} {{\alpha_{o}}}}   \ \ \ \triangleq  \ \ \ false$
  \item
$\satisfiesA{M}{\sigma}{\protectedFrom{{\re}} {{\re_{o}}}} \ \ \ \triangleq $ \\
  $\exists \gamma, \gamma_{o}. [\  \ \eval{M}{\sigma}{{\re}}{\gamma}\ \wedge \eval{M}{\sigma}{{\re_0}}{\gamma_0} \  \wedge \ 
  \satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\gamma_{o}}}}
 \ \  ]$
 \end{enumerate}
 \end{definition} 

{The definition from above gives rise to further cases of  protection; we supplement the triples from 
Fig. \ref{f:protection} with some further inference rules, given   in Fig. \ref{f:protection:conseq}.}


\begin{figure}[htb]
\begin{mathpar}
\inferrule
	{M \vdash x : \prg{int} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Int}_1]
	\and
\inferrule
	{M \vdash x : \prg{bool} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Bool}_1]
	\and
\inferrule
	{M \vdash x : \prg{str} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Str}_1]
	\and
 {
\inferrule
	{M \vdash  \protectedFrom{e}{e'}   \rightarrow e\neq e'} 
	{}
	\quad[\textsc{Prot-Neq]}
  }
\end{mathpar}
\caption{Protection for Scalar Types}
%  Extended Consequence Rules for Protection that include rules for protection involving scalars.}
\label{f:protection:conseq:ext}
\end{figure}

\subsection{More Hoare logic rules}
\label{s:app:more:Hoare}

We now  extend the Hoare Logic with rules for conditionals, case analysis, and a contradiction rule.
These are in Fig. \ref{f:if}, {where we expect the obvious syntax and semantics for $Cond$}.

\begin{figure}[htb]
$
\begin{array}{c}
\inferruleSD{\hspace{2.5cm} [\sc{If\_Rule}]}
	{
	 \begin{array}{c}
	  \hprovesN {M}   
		{\  A \wedge Cond \  }
		{\    stmt_1   \ }
 		{\ A' \ }
		{\ A'' \ }
	\\
	    \hprovesN {M}   
		{\  A \wedge \neg Cond \  }
		{\    stmt_2   \ }
 		{\ A' \ }
		{\ A'' \ }	
	\end{array}
	}	
 	{  	
	\hprovesN {M}   
		{\  A \  }
		{\  \prg{if}\ Cond\ \prg{then}\ stmt_1\ \prg{else}\ stmt_2 \ \ }
		{\ A' \ }
		{\ A'' \ }
}
\\
\\
\begin{array}{lcl}
{
\inferruleSD{\hspace{0.5cm} [\sc{Absurd}]}
	{	
	}	 
 	{  	
	\hprovesN {M}   
		{\  false \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
}
} & &
{
\inferruleSD{\hspace{0.5cm} [\sc{Cases}]}
	{ \begin{array}{l}
	\hprovesN {M}   
		{\  A \wedge A_{1}  \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
		\\
		\hprovesN {M}   
		{\   A \wedge A_{2} \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
	\end{array}	
	}	 
 	{  	
	\hprovesN {M}   
		{\  A \wedge (A_1 \vee A_2) \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
}
}
\end{array}
\end{array}
$
\caption{Hoare Quadruple  for conditionals, and more Substructural Hoare Quadruples}
\label{f:if}
\end{figure}


\subsection{Expressing the \prg{Shop} example in the syntax from Fig. \ref{f:loo-syntax}}
\label{s:app:syntax:transform}

{
We now express our example in the syntax of Fig. \ref{f:loo-syntax}. 
For this, we  add a return type to each of the methods; 
We turn all local variables to parameter; We add an explicit assignment to the variable \prg{res}: and We   add a temporary variable \prg{tmp} to which we assign the result of our \prg{void} methods.
For simplicity, we allow %sequences of field reads, \eg \prg{this.accnt.blnce} rather than using   temporaty variables, as 
the shorthands \prg{+=} and \prg{-=}.
And we also allow definition of local variables, \eg  \prg{int price := ..} }

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{good}$
  ...   
  class Shop
    field accnt : Account, 
    field invntry : Inventory, 
    field clients: ..
  
    public method buy(buyer:external, anItem:Item, price: int, 
            myAccnt: Account, oldBalance: int, newBalance: int, tmp:int) : int
      price := anItem.price;
      myAccnt := this.accnt;
      oldBalance := myAccnt.blnce;
      tmp := buyer.pay(myAccnt, price)     // $\red{\mbox{external\ call}}!$
      newBalance := myAccnt.blnce;
      if (newBalance == oldBalance+price) then
          tmp := this.send(buyer,anItem)
      else
         tmp := buyer.tell("you have not paid me") ; 
      res := 0
     
      private method send(buyer:external, anItem:Item) : int
       ... 
  class Account
    field blnce : int 
    field key : Key
    
    public method transfer(dest:Account, key':Key, amt:int) :int
      if (this.key==key') then
        this.blnce-=amt;
        dest.blnce+=amt
      else
        res := 0
      res := 0
	  
     public method set(key':Key) : int
      if (this.key==null)  then
      		this.key:=key'
      else 
        res := 0
      res := 0
\end{lstlisting}
% I removed class Key
% it does not have to belong to c=the module

\noindent
Remember that $M_{fine}$ is identical to $M_{good}$, except for the method \prg{set}. We describe the module below.

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{fine}$
  ...   
  class Shop
     ...  $ as in M_{good}$
  class Account
    field blnce : int 
    field key : Key
    
    public method transfer(dest:Account, key':Key, amt:int) :int
       ...  $\mbox{as in } M_{good}$
	  
     public method set(key':Key, k'':Key) : int
      if (this.key==key')  then
      		this.key:=key''
      else 
        res := 0
      res := 0
\end{lstlisting}

\subsection{Demonstrating that $M_{good} \vdash S_2$, and that $M_{fine} \vdash S_2$}
 \label{s:app:example:proofs}
 
For brevity we only show that \verb|buy| satisfies our scoped invariants, as the all other methods of 
the \verb|M|$_{good}$ interface are relatively simple, and do not make any external calls. 
%Our approach follows the 3 phases outlined in Section \ref{sect:proofSystem}. That is, in
%phase 1 we use more an assumed underlying Hoare logic and more traditional Hoare triples to prove the adherence of internal code to
%the specification. In phase 2 we use Hoare quadruples to prove external calls adhere
%to the specification, and finally in phase 3 we use raise the results from phase 1 and 2 to proved
%the entire module satisfies the specification.

{ To write our proofs more succinctly, we will use \prg{ClassId}::\prg{methId}.\prg{body} as a shorthand for the method body of \prg{methId} defined in \prg{ClassId}.}

  

\begin{lemma}
\label{lemma:exampleKeyProtect}
\label{l:Mgood:S2}
$M_{good} \vdash S_2$
\end{lemma}
\begin{proofO}
%We construct our proof tree using a top down approach.  
In order to prove that 
$$M_{good} \vdash \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{\prg{a.key}}}}$$
we have to apply  \textsc{Invariant} from Fig. \ref{f:wf}.
 That is, for each  class $C$  defined in $M_{good}$, and for each public method $m$ in $C$, with parameters $\overline{y:D}$, we have to prove that
 \small
\begin{align*}
M_{good}\ \vdash \ \ &   \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\,
		             {\inside{\prg{a.key}}}\ \wedge\       \protectedFrom {\prg{a.key}} {(\prg{this},\overline y)} \  \} \\
		& \SPT  \prg{C}::\prg{m}.\prg{body}\  \\
		&
                   \{\ {\inside{\prg{a.key}}}\ \wedge\ \ \protectedFrom {\prg{a.key}} {\prg{res}}   \ \}\ ||\ \{\ {\inside{\prg{a.key} } } \ \} \\
\end{align*}


\normalsize
Thus, we need to prove  three Hoare quadruples: one for \prg{Shop::buy}, one for  \prg{Account::transfer}, and one for  \prg{Account::set}.  That is, we have to prove that
 \small
\begin{align*}
\text{(1?)}  \ \ \ \ M_{good}\ \vdash  \  \ 
		&	\{  \ \Alocals, \, \prg{a}:\prg{Account} \, \wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Ids}  \  \} \\
		& \SPT \prg{Shop}::\prg{buy}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\\
\text{(2?)}  \ \ \ \ M_{good} \vdash \ 
		&	\{  \ \Alocalstr, \, \prg{a}:\prg{Account}\, \wedge\,  {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idstr}  \  \} \\
		& \SPT \prg{Account}::\prg{transfer}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\\
\text{(3?)}  \ \ \ \ M_{good} \vdash \ 
		&	\{  \ \Alocalsset, \, \prg{a}:\prg{Account}\, \wedge\,  {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset}  \  \} \\
		& \SPT \prg{Account}::\prg{set}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
\normalsize
where we are using ? to indicate that this needs to be proven, and 
where we are using the shorthands\\
\small
$
\begin{array}{c}
\begin{array}{lcl}
 \Alocals\ &  \triangleq   \  &   \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{price} : \prg{int},  \\
&  & \prg{myAccnt} : \prg{Account},\, \prg{oldBalance}:  \prg{int},  \prg{newBalance}:  \prg{int},  \prg{tmp}:  \prg{int}.\\
  \Ids\ &   \triangleq   & \prg{this},  \prg{buyer}, \prg{anItem}, \prg{price}, \prg{myAccnt},\, \prg{oldBalance},\  \prg{newBalance},  \prg{tmp}.\\ 
\Alocalstr\  & \triangleq \  &   \prg{this}:\prg{Account}, \prg{dest} : \prg{Account}, \prg{key'} : \prg{Key}. \\
  \Idstr\  &  \triangleq  & \prg{this},\, \prg{dest} ,\, \prg{key'}. \\
  \Alocalsset\  & \triangleq \  &   \prg{this}:\prg{Account}, \, \prg{key'} : \prg{Key},\, \prg{key''} : \prg{Key}.\\
    \Idsset\  &  \triangleq  & \prg{this},\, \prg{key'} ,\, \prg{key''}. \\
\end{array}
\end{array}
$
\normalsize

We do not need to prove anything for  \prg{Shop::send}, because it is a private method. But we will use its specification, and we will need, or course, to prove that  \prg{Shop::send} sarisfies that specification.
\red{Actually,  a better way to think about this is if we are proving that $M_{good} \vdash S_2 \wedge S_4$ where $S_4$ is the specification of \prg{Shop::send}.}

We outline the proof of (1?) in Lemma \ref{l:sub:one} in \S \ref{s:buy:sat}.
%, and the proof for \prg{Account::set} from module $M_{fine}$  in Lemma \ref{l:set:sat} in \S{s:set:sat}.

\end{proofO}

We also want to prove that $M_{fine}$ satisfies the specification $S_2$.

\begin{lemma}
\label{l:Mfine:S2}
$M_{fine} \vdash S_2$
\end{lemma}
\begin{proofO}
%We construct our proof tree using a top down approach.  
The proof of
$$M_{fine} \vdash \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{\prg{a.key}}}}$$
goes along similar lines to the proof of lemma \ref{l:Mgood:S2}.
Thus, we need to prove the following  three Hoare quadruples: 
 \small
\begin{align*}
\text{(4?)}  \ \ \ \ M_{fine}\ \vdash  \  \ 
		&	\{  \ \Alocals, \, \prg{a}:\prg{Account} \, \wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Ids}  \  \} \\
		& \SPT \prg{Shop}::\prg{buy}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\\
\text{(5?)}  \ \ \ \ M_{fine} \vdash \ 
		&	\{  \ \Alocalstr, \, \prg{a}:\prg{Account}\, \wedge\,  {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idstr}  \  \} \\
		& \SPT \prg{Account}::\prg{transfer}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\\
\text{(6?)}  \ \ \ \ M_{fine} \vdash \ 
		&	\{  \ \Alocalsset, \, \prg{a}:\prg{Account}\, \wedge\,  {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset}  \  \} \\
		& \SPT \prg{Account}::\prg{set}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

 
\normalsize

The proof of (4?) is identical to that of (1?); the proof of (5?) is identical to that of (2?). 
We outline the proof (6?)    in Lemma \ref{l:set:sat} in \S{s:set:sat}.

\end{proofO}



\subsection{Proving that \prg{Shop::buy} from $M_{good}$ satisfies $S_2$}
\label{s:buy:sat}

\begin{lemma}
\label{l:buy:sat}
 
\begin{align*}
\text{(1)}  \ \ \ \ M_{good} \vdash 
		&	\{  \ \Alocals\,\prg{a}:\prg{Account}\ \wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Ids}  \  \} \\
		& \SPT \prg{Shop}::\prg{buy}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

\end{lemma}

\begin{proofO}
We will use the shorthand $\Alocalsb \triangleq \Alocals, \,\prg{a}:\prg{Account}$.
We will split the proof into 1) proving that statements 10, 11, 12 preserve the protection of \prg{a.key} from the \prg{buyer}, 2) proving that the external call 

\step{1st Step: proving statements 10, 11, 12}

We apply the underlying Hoare logic and prove that the statements on lines 10, 11, 12 do not affect the value of \prg{a.key}, ie that for a $z\notin \{ \prg{price}, \prg{myAccnt}, \prg{oldBalance} \}$, we have 

\begin{align*}
\text{(10)}  \ \ \ \ {M_{good} \vdash_{ul}} 
		&	\{  \ \Alocalsb\  \wedge\ z=\prg{a.key} \} \\
		&   \SPT \prg{price:=anItem.price}; \\  
		&   \SPT \prg{myAccnt:=this.accnt}; \\  
                 &   \SPT \prg{oldBalance := myAccnt.blnce};\\
		& \{ z=\prg{a.key} \}
\end{align*}

We then apply {\sc{Embed\_UL}}, {\sc{Prot-1}} and {\sc{Prot-2}} and {\sc{Combine}} and and {\sc{Types-2}} on (10) and use the shorthand $\stmtsP$ for the statements on lines 10, 11 and 12, and obtain: 
\\
\begin{align*}
\text{(11)}  \ \ \ \ M_{good} \vdash 
		&	\{  \ \Alocalsb\  \wedge\ {\inside{\prg{a.key}}} \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}}  \} \\
		& \SPT \stmtsP\ \\  
		& \{ \ {\inside{\prg{a.key}}}  \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}}   \}
\end{align*}



We apply  {\sc{Mid}}  on (11) and obtain 
\begin{align*}
\text{(12)}  \ \ \ \ M_{good} \vdash 
		&	\{  \ \Alocalsb\, \wedge\, \protectedFrom {\prg{a.key}} {\prg{buyer}}\  \} \\
		& \SPT \stmtsP\ \\  
		& \{ \ \Alocalsb\, \wedge \  {\inside{\prg{a.key}}} \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}}  \ \} \ \ || \\
		& \{ \ {\inside{\prg{a.key}}}\  \}
\end{align*}

\step{2nd Step: Proving the External Call}

 

We now need to prove that the external method call \prg{buyer.pay(this.accnt, price)} protects the \prg{key}. i.e.
%\small
\begin{align*}
\text{(13?)} \ \ \ M_{good} \vdash & \{ \ \Alocalsb \   \wedge\    {\inside{\prg{a.key}}},\, \wedge\, \protectedFrom {\prg{a.key}} {\prg{buyer}}  \} \\
		  		& \SPT  \prg{tmp := buyer.pay(myAccnt, price)}\ \\  
		  		& \{ \ \ \ \Alocalsb \ \wedge\ {\inside{\prg{a.key}}} \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}} \} \ \ \  || \ \ \  \\
		  		&   \{ \   {\inside{\prg{a.key}}}\  \}
\end{align*}
\normalsize

We use that $M \vdash \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}}$
 and  obtain
 \\
 \small
\begin{align*}
\text{(14)} \ \ \ M_{good} \vdash & \{ \ \prg{buyer}:\prg{external},\,  {\inside{\prg{a.key}}} \, \wedge\, 
\protectedFrom {\prg{a.key}} {(\prg{buyer},\prg{myAccnt},\prg{price})} \  \} \\
		  		& \SPT  \prg{tmp := buyer.pay(myAccnt, price)}\ \\  
		  		& \{ \ \inside{\prg{a.key}} \, \wedge\, 
\protectedFrom {\prg{a.key}} {(\prg{buyer},\prg{myAccnt},\prg{price})}\ \} \ \ \  || \ \ \  \\
		  		&   \{ \   {\inside{\prg{a.key}}}\  \}
\end{align*}
\normalsize 
 
In order to obtain (13?) out of (14), we apply \textsc{Prot-Intl} and \textsc{Prot-Int}$_1$,   which gives us\\
$
\begin{array}{llll}
& (15) & & M_{good} \vdash \Alocalsb \wedge  {\inside{\prg{a.key}}}  \longrightarrow \protectedFrom {\prg{a.key}} {\prg{myAccnt}} 
\\
& (16) & & M_{good} \vdash \Alocalsb \wedge  {\inside{\prg{a.key}}}  \longrightarrow \protectedFrom {\prg{a.key}} {\prg{price}} 
\end{array}
$

We apply {\textsc{Consequ}} on (15), (16) and (14) and obtain (13)!

\normalsize


\end{proofO}

\subsection{Proving method \prg{set} from $M_{fine}$}
\label{s:set:sat}
 

We want to prove that this public method satisfies the specification  $S_2$, namely

\begin{lemma}
\label{l:set:sat}
\label{l:satisfies:Mfine:pec2}
 
\begin{align*}
\text{(6)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocalsset\ \wedge\  {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset}  \  \} \\
%	Latex experiment; does not work 
%	&
%		\mbox{\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
%      if (this.key==key') then
%        this.blnce-=amt;
%        dest.blnce+=amt
%      else
%        res := 0
%      res := 0
%\end{lstlisting}
%}
%\\
		& \SPT   \prg{if (this.key==key') then }\\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
	        & \SPT   \prg{else }\\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \SPT \prg{res:=0} \\
& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
	   \{ {\inside{\prg{a.key}}} \}
\end{align*}

\end{lemma}

\begin{proofO}
We will be  using the shorthand 
 $\SPT  \Alocalssets\ \triangleq \  \prg{a}:\prg{Account},\  \Alocalsset$.\\


To prove (6), we will use the  {\sc{Sequence}} rule, and we want to prove
\\
\begin{align*}
\text{(61?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocalssets\ \wedge\  {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset} \  \} \\
		& \SPT   \prg{if (this.key==key') then }\\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
	        & \SPT   \prg{else }\\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \{ \ \Alocalssets\,\wedge\ {\inside{\prg{a.key}}}\    \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
and that
\begin{align*}
\text{(62?)}  \ \ \ \ M_{fine} \vdash
          &  \{ \ \Alocalssets\,\wedge \inside{\prg{a.key}} \  \}  \\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

(62?) follows   from the types, and {\sc{Prot-Int}}$_1$, the fact that \prg{a.key} did not change, and  \sdN{ {\sc{Prot-1}}}.

\vspace{.5cm}
Wenow  want to  prove (61?). For this, will apply the {\sc{If-Rule}}. That is, we need to prove that

\begin{align*}
\text{(63?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocalssets\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset} \, \wedge  \,  \prg{this.key}=\prg{key'}\  \} \\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
		& \{ {\inside{\prg{a.key}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
 
and that
 
\begin{align*}
\text{(64?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocalssets\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset} \, \wedge  \,  \prg{this.key}\neq\prg{key'}\  \} \\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \{ {\inside{\prg{a.key}}}\   \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

(64?) follows easily from  the fact that \prg{a.key} did not change, and  {\sc{Prot-1}}.

\vspace{.5cm}
We look at the proof of (63?).  We will apply the {\sc{Cases}} rule, and distinguish on whether \prg{a.key}=\prg{this.key}. That is, we want to prove that\\
\small{
\begin{align*}
\text{(65?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocalssets\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset} \, \wedge  \,  \prg{this.key}=\prg{key'}\ \wedge\ \prg{this.key}=\prg{a.key}  \} \\
			& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
	       	& \{ {\inside{\prg{a.key}}}\   \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
}
\\
and that
\\
\small{
\begin{align*}
\text{(66?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocalssets\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Idsset} \, \wedge  \,   \,  \prg{this.key}=\prg{key'}\   \prg{this.key}\neq\prg{a.key'}\  \} \\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
		& \{ {\inside{\prg{a.key}}}\   \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
}
\vspace{.2cm}
\normalsize
We can prove (65?) through application of {\sc{Absurd}}, {\sc{ProtNeq}}, and {\sc{Consequ}}, as follows

\begin{align*}
\text{(61c)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ false  \} \\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
		& \{ {\inside{\prg{a.key}}}\   \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

By  {\sc{ProtNeq}}, we have $M_{fine} \vdash  \protectedFrom {\prg{a.key}} {\prg{key'}} \, \longrightarrow\, {\prg{a.key}}\neq {\prg{key'}}$, and therefore obtain

\begin{align*}
\text{(61d)}  \ \ \ \ M_{fine} \vdash  ... \wedge \, \protectedFrom {\prg{a.key}} {\Idsset} \, \wedge  \, \prg{this.key}=\prg{a.key}\, \wedge\,  \prg{this.key}=\prg{key'}\ \longrightarrow \ false 
\end{align*}

We apply  {\sc{Consequ}} on (61c) and (61d) and obtain (61aa?).

\vspace{.5cm}
We can prove (66?) by proving that \prg{this.key}$\neq$\prg{a.key} implies that $\prg{this}\neq \prg{a}$ (by the underlying Hoare logic), which again implies that the assignment \prg{this.key := ... } leaves the value of \prg{a.key} unmodified. We apply {\sc{Prot-1}}, and are done.

\end{proofO} 


