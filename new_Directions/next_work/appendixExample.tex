\section{Example: Taming Effects for the Shop/Account}
In Section \ref{s:outline} we introduced a \verb|Shop| that allows clients to make purchases through the
\verb|buy| method, a method that included a method call to an unknown external object (\verb|buyer.pay(...)|).
Here we use our Hoare logic from Section \ref{sect:proofSystem} to prove that the \verb|buy| method
does not expose the \verb|Shop|'s  \verb|Account|, its \verb|Key|, or allow the \verb|Account|'s balance to be illicitly modified. 
More specifically, we prove the following scoped invariants are satisfied by \verb|M|$_{good}$\\
%$\strut \SPSP  S_1\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{a}}} $ 
%\\
$\strut  \SPSP  S_1\ \  \triangleq \ \ \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}} $ 
 \\
%$\strut  \SPSP   S_3\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account},\prg{b}:\prg{int}}  {\inside{\prg{a}} \wedge \prg{a.\balance}=\prg{b}}  $
%\\
$\strut  \SPSP  S_2\ \  \triangleq \ \ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.key}} \wedge \prg{a.\balance} \geq \prg{b} } $\\
\verb|M|$_{good}$ is given below.
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{good}$
  ...   
  class Shop
    field accnt:Account, invntry:Inventory, clients:[external]    
  
    public method buy(buyer:external, anItem:Item)
      int price = anItem.price
      int oldBlnce = this.accnt.blnce
      buyer.pay(this.accnt, price)     // $\red{\mbox{external\ call}}!$
      if (this.accnt.blnce == oldBlnce+price)  this.send(buyer,anItem)
      else
         buyer.tell("you have not paid me") 
     
      private method send(buyer:external, anItem:Item)  
       ... 
  class Key
  class Account
    field blnce:int 
    field key:Key
    public method transfer(dest:Account, key':Key, amt:int)
      if (this.key==key')
        this.blnce-=amt
        dest.blnce+=amt
     public method set(key':Key)
      if (this.key==null)  this.key=key'
\end{lstlisting}

For brevity we only show that \verb|buy| satisfies our scoped invariants, as the all other methods of 
the \verb|M|$_{good}$ interface are relatively simple, and do not make any external calls. 
Our approach follows the 3 phases outlined in Section \ref{sect:proofSystem}. That is, in
phase 1 we use more an assumed underlying Hoare logic and more traditional Hoare triples to prove the adherence of internal code to
the specification. In phase 2 we use Hoare quadruples to prove external calls adhere
to the specificaiton, and finally in phase 3 we use raise the results from phase 1 and 2 to proved
the entire module satisfies the specification.

\begin{lemma}
$M_{good} \vdash S_1$
\end{lemma}
\begin{proof}
We construct our proof tree using a top down approach.  That is, we start with our goal
$$M_{good} \vdash \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{\prg{a.key}}}}$$
and apply  \textsc{Invariant-Hope} from Fig. \ref{f:wf}.
From this we are left with a subgoal for each method $m$ in  class $C$ with parameters $\overline{y:D}$ and body $stmt$ in the public interface of $M_{good}$:
\small
\begin{align*}
M_{good} \vdash
		& \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\, 
\external z \wedge\ {\PushASLong {z} {\inside{\prg{a.key}}}}\} \\
		& stmt\ \\
		& \{\ {\PushASLong {z} {\inside{\prg{a.key}}}}\ \}\ ||\ \{\ {\PushASLong {z} {\inside{\prg{a.key}}}} \ 			\} 
\end{align*}
\normalsize
This is relatively simple to prove for methods without external method calls, as we can rely entirely on the Hoare logic extension described in Section \ref{sect:proofSystem}. The only  method within $M_{good}$ that contains 
an external method call is  the \prg{buy} method within the \prg{Shop} class. Thus, we need to prove:
\small
\begin{align*}
\text{(1)}  \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account}\,\wedge\, \external z \wedge\ {\PushASLong {z} {\inside{\prg{a.key}}}} \} \\
		  &stmt\ \\  &\{ {\PushASLong {z} {\inside{\prg{a.key}}}} \} \ \ \  || \ \ \ \{ {\PushASLong {z} {\inside{\prg{a.key}}}} \}
\end{align*}
\normalsize
Where $stmt$ is the body of \prg{buy}. We now construct this proof using the quadruple rules described in \ref{sect:proofSystem}. By our hoare triple extension and the \textsc{Mid} rule that raises triples to quaruples, the first two lines
of \prg{buy} preserve the precondition in (1) above, and further that 
\small
$$
\text{(2)} \ \ \ \ \prg{price} : \prg{int}
$$ 
$$
\text{(3)} \ \ \ \ \prg{this.accnt} : \prg{Account}
$$ 
We now need to prove that the external method call \prg{buyer.pay(this.accnt, price)} protects the \prg{key}. i.e.
\small
\begin{align*}
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
				  \prg{this.accnt}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  \external z \wedge\ {\PushASLong {z} {\inside{\prg{a.key}}}} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\PushASLong {z} {\inside{\prg{a.key}}}} \} \ \ \  || \ \ \ \{ {\PushASLong {z} {\inside{\prg{a.key}}}} \}
\end{align*}
\normalsize
or simplifying the precondition to what we need and applying the ``pop''.
\small
\begin{align*}
\text{(4)} \ \ \ \ 
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
				  \prg{this.accnt}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  \external z \wedge\ 
				  {\protectedFrom{\prg{a.key}}{z}} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\protectedFrom{\prg{a.key}}{z}} \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
\end{align*}
\normalsize

This is discharged by the rule \textsc{Call\_Ext\_Adapt}, giving us the desired result.

\jm{(julian: I did the below bit because I thought it would be necessary, but I'm not sure that it is. I feel like this might be a problem. Don't we need to know that \prg{a.key} is protected from the arguments to \prg{buyer.pay}?????)}

From the definition of protection \jm{(Julian: we need some proof rules for this)}, 
we have 
$$
\text{(5)} \ \ \ \ \protectedFrom{\prg{a.key}}{\prg{this.accnt}}
$$
since $\prg{this.accnt}:\prg{Account}$ and $\prg{Account} \in M_{good}$.
We also get
$$
\text{(6)} \ \ \ \ \protectedFrom{\prg{a.key}}{\prg{price}}
$$
because \prg{price} is a prmitive and is thus everything is protected from 
it. \jm{(julian: we need to add this.)}

This gives us:
\small
\begin{align*}
\text{(7)} \ \ \ \ 
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
				  \prg{this.accnt}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  \external z \wedge\ 
				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge\, 
				  \protectedFrom{\prg{a.key}}{\prg{price}}\, \wedge\, \\
				& \protectedFrom{\prg{a.key}}{\prg{this.accnt}}\} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\protectedFrom{\prg{a.key}}{z}} \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
\end{align*}
\normalsize


\jm{Julian: I don't think below is necessary...}\\
\jm{Julian: I think there might be a problem here. If \prg{buyer.pay} had an external 
object as an
argument, then there would be no way we'd able to prove that \prg{a.key} was 
protected from that external object.}
Now we use the fact the \jm{law of excluded middle} and \textsc{Conseq} to introduce $\prg{a} = \prg{this.accnt}\ \vee\ \prg{a} \not= \prg{this.accnt}$ to the precondition.
\small
\begin{align*}
\text{(5)} \ \ \ \ 
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
				  \prg{this.accnt}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  \external z \wedge\ 
				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge \,
				  \prg{a} = \prg{this.accnt}\ \vee\ \prg{a} \not= \prg{this.accnt} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\protectedFrom{\prg{a.key}}{z}}  \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
\end{align*}
\normalsize
Now \jm{the traditional  Hoare rule for disjunction} gives us two subgoals:
\small
\begin{align*}
\text{(6.1)} \ \ \ \ 
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
				  \prg{this.accnt}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  \external z \wedge\ 
				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge \,
				  \prg{a} = \prg{this.accnt} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\protectedFrom{\prg{a.key}}{z}}  \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
\end{align*}
\normalsize
\small
\begin{align*}
\text{(6.2)} \ \ \ \ 
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
				  \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\,
				  \prg{this.accnt}:\prg{Account},\, \\
				& \prg{price} : \prg{int},\,
				  \wedge\, 
				  \external z \wedge\ 
				  {\protectedFrom{\prg{a.key}}{z}}\, \wedge \,
				  \prg{a} \not= \prg{this.accnt} \} \\
		  		& \prg{buyer.pay(this.accnt, price)}\ \\  
		  		& \{ {\protectedFrom{\prg{a.key}}{z}}  \} \ \ \  || \ \ \ \{ {\protectedFrom{\prg{a.key}}{z}} \}
\end{align*}
\normalsize
Both (5.1) and (5.2) can now be discharged in the same manner, since in both cases, \prg{a.key} is protected from the arguments of \prg{buyer.pay}.  Finally, by application of \textsc{Conseq} and \textsc{Call\_Ext\_Adapt} we get our goal.
%\small
%\begin{align*}
%\text{(3)} \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item}, \prg{price} : \prg{int} \, \wedge\, 
%		 \prg{a} : \prg{Account}\, \wedge\,  \inside{\prg{a.key}} \}  \\
%		 & \prg{buyer.(this.accnt, price)} \ \{ \inside{\prg{a.key}} \} \ \ \  || \ \ \  \{ \inside{\prg{a.key}} \}
%
%\normalsize
\end{proof}



\begin{lemma}
$M_{good} \vdash S_2$
\end{lemma}
\begin{proof}
We construct our proof tree using a top down approach.  That is, we start with our goal
$$M_{good} \vdash \TwoStatesN {\prg{a}:\prg{Account}, \prg{b} : \prg{int}}  {\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b}}$$
and apply  \textsc{Invariant} from Fig. \ref{f:wf}.
From this we are left with a subgoal for each method $m$ in  class $C$ with parameters $\overline{y:D}$ and body $stmt$ in the public interface of $M_{good}$:
\small
\begin{align*}
M_{good} \vdash
		& \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\, 
\external z \wedge\ {\PushASLong {z} {(\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b})}}\} \\
		& stmt\ \\
		& \{\ {\PushASLong {z} {(\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b})}}\ \}\ ||\ \{\ {\PushASLong {z} {(\inside{\prg{a.key}} \wedge \prg{a.blnce} \geq \prg{b})}} \ 			\} 
\end{align*}
\normalsize
This is relatively simple to prove for methods without external method calls, as we can rely entirely on the Hoare logic extension described in Section \ref{sect:proofSystem}. The only  method within $M_{good}$ that contains 
an external method call is  the \prg{buy} method within the \prg{Shop} class. Thus, we need to prove:
\small
\begin{align*}
\text{(1)} \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item} \, \wedge\, \neg\inside{this}\wedge \\ 
		&\neg\inside{\prg{buyer}} \wedge \neg\inside{\prg{anItem}}, \wedge\, \prg{a} : \prg{Account}\, \wedge\,  \inside{\prg{a.key}} \} 
		 stmt\ \{ \inside{\prg{a.key}} \} \ \ \  || \ \ \ \{ \inside{\prg{a.key}} \}
\end{align*}
\normalsize
Where $stmt$ is the body of \prg{buy}. We now construct this proof using the quadruple rules described in \ref{sect:proofSystem}. By our hoare triple extension and the \textsc{Mid} rule that raises triples to quaruples, the first two lines
of \prg{buy} preserve the precondition in (1) above, and further that 
\small
$$
\text{(2)} \ \ \ \ \prg{price} : \prg{int}
$$ 
$$
\text{(3)} \ \ \ \ \prg{this.accnt} : \prg{Account}
$$ 
We now need to prove that the external method call \prg{buyer.pay(this.accnt, price)} protects the \prg{key}. i.e.
\small
\begin{align*}
M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, 
		\prg{anItem} : \prg{Item}, \prg{price} : \prg{int} \, \wedge\, 
		\neg\inside{this}\wedge \\ 
		&\neg\inside{\prg{buyer}} \wedge \neg\inside{\prg{anItem}}, \wedge\, \prg{a} : \prg{Account}\, \wedge\,  \inside{\prg{a.key}} \}  \\
		 & \prg{buyer.(this.accnt, price)} \ \{ \inside{\prg{a.key}} \} \ \ \  || \ \ \  \{ \inside{\prg{a.key}} \}
\end{align*}
\normalsize
or simplifying the precondition to what we need:
\small
\begin{align*}
\text{(3)} \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item}, \prg{price} : \prg{int} \, \wedge\, 
		 \prg{a} : \prg{Account}\, \wedge\,  \inside{\prg{a.key}} \}  \\
		 & \prg{buyer.(this.accnt, price)} \ \{ \inside{\prg{a.key}} \} \ \ \  || \ \ \  \{ \inside{\prg{a.key}} \}
\end{align*}
\normalsize
Now, by application of \textsc{Conseq} and \textsc{Call\_Ext\_Adapt} we get our goal.
%\small
%\begin{align*}
%\text{(3)} \ \ \ \ M_{good} \vdash & \{  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item}, \prg{price} : \prg{int} \, \wedge\, 
%		 \prg{a} : \prg{Account}\, \wedge\,  \inside{\prg{a.key}} \}  \\
%		 & \prg{buyer.(this.accnt, price)} \ \{ \inside{\prg{a.key}} \} \ \ \  || \ \ \  \{ \inside{\prg{a.key}} \}
%
%\normalsize
\end{proof}

%$$M_{shop} \vdash \{{\inside{\texttt{a.key}}}\}\ {\texttt{public}\ \texttt{Shop}}::{\texttt{buy}}{(\texttt{buyer} : \texttt{external})}\ \{{\inside{\texttt{a.key}}}\}\ ||\ \{{\inside{\texttt{a.key}}} \}$$
%\end{proof}
%\begin{lemma}
%$$M_{good} \vdash \{{\inside{\texttt{a.key}}}\}\ {\texttt{public}\ \texttt{Shop}}::{\texttt{buy}}{(\texttt{buyer} : \texttt{external}, \texttt{price} : \texttt{int})}\ \{{\inside{\texttt{a.key}}}\}\ ||\ \{{\inside{\texttt{a.key}}} \}$$
%\end{lemma}
%\begin{lemma}
%$$M_{good} \vdash \{{\inside{\texttt{a.key}}}\}\ {\texttt{public}\ \texttt{Shop}}::{\texttt{buy}}{(\texttt{buyer} : \texttt{external}, \texttt{price} : \texttt{int})}\ \{{\inside{\texttt{a.key}}}\}\ ||\ \{{\inside{\texttt{a.key}}} \}$$
%\end{lemma}