\newcommand{\SPT}{~ \strut \hspace{.9cm}}

\section{  {Proving \Tamed Effects for the Shop/Account Example}}

\label{s:app:example}

In Section \ref{s:outline} we introduced a \verb|Shop| that allows clients to make purchases through the
\verb|buy| method.
The body if this method  includes a method call to an unknown external object (\verb|buyer.pay(...)|).

In this section  we use our Hoare logic from Section \ref{sect:proofSystem} to {outline the proof} that the \verb|buy| method
does not expose the \verb|Shop|'s  \verb|Account|, its \verb|Key|, or allow the \verb|Account|'s balance to be illicitly modified. 

More generally,   given  the following scoped invariants, \\  
$\strut  \SPSP  S_2\ \  \triangleq \ \ \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}} $ 
 \\
$\strut  \SPSP  S_3\ \  \triangleq \ \ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.key}} \wedge \prg{a.\balance} \geq \prg{b} } $ 
\\
 we {outline the proof} that $M_{good} \vdash S_2$, and that $M_{fine} \vdash S_2$.
{We  also show why $M_{bad} \not\vdash S_2$.}

{We first extend the semantics and the logic to deal with scalars (\S \ref{s:app:scalars}). 
We then extend the Hoare Logic with rules for conditionals, case analysis, and a contradiction rule
(\S \ref{s:app:more:Hoare}).
We then rewrite the code of $M_{good}$ and so $M_{fine}$
so that it adheres to the syntax as defined in Fig. \ref{f:loo-syntax} (\S \ref{s:app:syntax:transform}). 
After that, we outline the proofs (\S \ref{s:app:example:proofs}) --
these proofs have been mechanized in Coq, and the source code will be
submitted as an artefact. %{xxxx}.
Finally, we discuss why $M_{bad} \not\vdash S_2$ (\S \ref{s:app:example:why}).}


\subsection{Extend the semantics and Hoare logic to accommodate scalars and conditionals}
\label{s:app:scalars}

{We extend the notion of protection to also allow it to apply to scalars. }

\begin{definition}[Satisfaction 
of Assertions  -- Protected From]
\label{def:chainmail-protection-from-ext}
extending the definition of Def 
\ref{def:chainmail-protection-from}. We use $\alpha$ to range over addresses, $\beta$  to range over scalars, and   $\gamma$ to range over addresses or scalars.

\noindent
We define  $\satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\gamma_{o}}}} $ as:
\begin{enumerate}
\item
\label{cProtectedNew}
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\alpha}} {{\alpha_{o}}}}   \ \ \ \triangleq $ 
  \begin{itemize}
 \item
$\alpha\neq \alpha_0$,
 \ \ \ \  and% \\
 \item
$\forall n\in\mathbb{N}. \forall f_1,...f_n..
[\ \ \interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha \ \ \  \Longrightarrow \ \ \  \satisfiesA{M}{\sigma}{ {\interpret{\sigma}{\alpha_{o}.f_1...f_{n-1}}}:C} \ \wedge \ C\in M\ \ ]$
\end{itemize}
\item
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\beta_{o}}}}   \ \ \ \triangleq  \ \ \ true$
 \item
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\beta}} {{\alpha_{o}}}}   \ \ \ \triangleq  \ \ \ false$
  \item
$\satisfiesA{M}{\sigma}{\protectedFrom{{\re}} {{\re_{o}}}} \ \ \ \triangleq $ \\
  $\exists \gamma, \gamma_{o}. [\  \ \eval{M}{\sigma}{{\re}}{\gamma}\ \wedge \eval{M}{\sigma}{{\re_0}}{\gamma_0} \  \wedge \ 
  \satisfiesA{M}{\sigma}{\protectedFrom{{\gamma}} {{\gamma_{o}}}}
 \ \  ]$
 \end{enumerate}
 \end{definition} 

{The definition from above gives rise to further cases of  protection; we supplement the triples from 
Fig. \ref{f:protection} with some further inference rules, given   in Fig. \ref{f:protection:conseq}.}


\begin{figure}[htb]
\begin{mathpar}
\inferrule
	{M \vdash x : \prg{int} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Int}_1]
	\and
\inferrule
	{M \vdash x : \prg{bool} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Bool}_1]
	\and
\inferrule
	{M \vdash x : \prg{str} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Str}_1]
	\and
 {
\inferrule
	{M \vdash  \protectedFrom{e}{e'}   \rightarrow e\neq e'} 
	{}
	\quad[\textsc{Prot-Neq]}
  }
\end{mathpar}
\caption{Protection for Scalar Types}
%  Extended Consequence Rules for Protection that include rules for protection involving scalars.}
\label{f:protection:conseq:ext}
\end{figure}

\subsection{More Hoare logic rules}
\label{s:app:more:Hoare}

We now  extend the Hoare Logic with rules for conditionals, case analysis, and a contradiction rule.
These are in Fig. \ref{f:if}, {where we expect the obvious syntax and semantics for $Cond$}.

\begin{figure}[htb]
$
\begin{array}{c}
\inferruleSD{\hspace{2.5cm} [\sc{If\_Rule}]}
	{
	 \begin{array}{c}
	  \hprovesN {M}   
		{\  A \wedge Cond \  }
		{\    stmt_1   \ }
 		{\ A' \ }
		{\ A'' \ }
	\\
	    \hprovesN {M}   
		{\  A \wedge \neg Cond \  }
		{\    stmt_2   \ }
 		{\ A' \ }
		{\ A'' \ }	
	\end{array}
	}	
 	{  	
	\hprovesN {M}   
		{\  A \  }
		{\  \prg{if}\ Cond\ \prg{then}\ stmt_1\ \prg{else}\ stmt_2 \ \ }
		{\ A' \ }
		{\ A'' \ }
}
\\
\\
\begin{array}{lcl}
{
\inferruleSD{\hspace{0.5cm} [\sc{Absurd}]}
	{	
	}	 
 	{  	
	\hprovesN {M}   
		{\  false \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
}
} & &
{
\inferruleSD{\hspace{0.5cm} [\sc{Cases}]}
	{ \begin{array}{l}
	\hprovesN {M}   
		{\  A \wedge A_{1}  \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
		\\
		\hprovesN {M}   
		{\   A \wedge A_{2} \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
	\end{array}	
	}	 
 	{  	
	\hprovesN {M}   
		{\  A \wedge (A_1 \vee A_2) \  }
		{\  \ stmt \ \ }
		{\ A' \ }
		{\ A'' \ }
}
}
\end{array}
\end{array}
$
\caption{Hoare Quadruple  for conditionals, and more Substructural Hoare Quadruples}
\label{f:if}
\end{figure}


\subsection{Expressing the \prg{Shop} example in the syntax from Fig. \ref{f:loo-syntax}}
\label{s:app:syntax:transform}

{
We now express our example in the syntax of Fig. \ref{f:loo-syntax}. 
For this, we  add a return type to each of the methods; 
We turn all local variables to parameter; We add an explicit assignment to the variable \prg{res}: and We   add a temporary variable \prg{tmp} to which we assign the result of our \prg{void} methods.
For simplicity, we allow %sequences of field reads, \eg \prg{this.accnt.blnce} rather than using   temporaty variables, as 
the shorthands \prg{+=} and \prg{-=}.
And we also allow definition of local variables, \eg  \prg{int price := ..} }

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{fine}$
  ...   
  class Shop
    field accnt : Account, 
    field invntry : Inventory, 
    field clients: ..
  
    public method buy(buyer:external, anItem:Item, price: int, 
            myAccnt: Account, oldBalance: int, newBalance: int, tmp:int) : int
      int price := anItem.price;
      Account myAccnt := this.accnt;
      int oldBalance := myAccnt.blnce;
      tmp := buyer.pay(myAccnt, price)     // $\red{\mbox{external\ call}}!$
      int newBalance := myAccnt.blnce;
      if (newBalance == oldBalance+price) then
          tmp := this.send(buyer,anItem)
      else
         tmp := buyer.tell("you have not paid me") ; 
      res := 0
     
      private method send(buyer:external, anItem:Item) : int
       ... 
  class Account
    field blnce : int 
    field key : Key
    
    public method transfer(dest:Account, key':Key, amt:int) :int
      if (this.key==key') then
        this.blnce-=amt;
        dest.blnce+=amt
      else
        res := 0
      res := 0
	  
     public method set(key':Key) : int
      if (this.key==null)  then
      		this.key:=key'
      else 
        res := 0
      res := 0
\end{lstlisting}
% I removed class Key
% it does not have to belong to c=the module

Remember that $M_{fine}$ is identical to $M_{good}$, except for the method \prg{set}. We describe the module below.

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{good}$
  ...   
  class Shop
     ...  $\mbox{as in } M_{good}$
  class Account
    field blnce : int 
    field key : Key
    
    public method transfer(dest:Account, key':Key, amt:int) :int
       ...  $\mbox{as in } M_{good}$

	  
     public method set(key':Key, k'':Key) : int
      if (this.key==kay')  then
      		this.key:=key''
      else 
        res := 0
      res := 0
\end{lstlisting}

\subsection{Demonstrating that $M_{good} \vdash S_2 $}
 \label{s:app:example:proofs}
 
For brevity we only show that \verb|buy| satisfies our scoped invariants, as the all other methods of 
the \verb|M|$_{good}$ interface are relatively simple, and do not make any external calls. 
Our approach follows the 3 phases outlined in Section \ref{sect:proofSystem}. That is, in
phase 1 we use more an assumed underlying Hoare logic and more traditional Hoare triples to prove the adherence of internal code to
the specification. In phase 2 we use Hoare quadruples to prove external calls adhere
to the specification, and finally in phase 3 we use raise the results from phase 1 and 2 to proved
the entire module satisfies the specification.

{ To write our proofs more succinctly, we will use \prg{ClassId}::\prg{Methodid}.\prg{body} as a shorthand for the method body of \prg{Methodid} defined in \prg{ClassId}.}

 \subsubsection{Proof outline for $M_{good} \vdash S_2$}



\begin{lemma}
\label{lemma:exampleKeyProtect}
$M_{good} \vdash S_2$
\end{lemma}
\begin{proofO}
We construct our proof tree using a top down approach.  That is, we start with our goal
$$M_{good} \vdash \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{\prg{a.key}}}}$$
and apply  \textsc{Invariant} from Fig. \ref{f:wf}.
From this we are left with a subgoal for each method $m$ in  class $C$ with parameters $\overline{y:D}$ in the public interface of $M_{good}$ (we denote the body of such a method as \prg{C}::\prg{m}.\prg{body}):
\small
\begin{align*}
M_{good} \vdash & \\
		& \{ \ \prg{this}:\prg{C},\, \overline{y:D},\, \prg{a}:\prg{Account}\, \wedge\,
		   {\inside{\prg{a.key}}}\ \wedge\       \protectedFrom {\prg{a.key}} {\prg{this},\overline y} \  \} \\
		& \prg{C}::\prg{m}.\prg{body}\  \\
		&
                   \{\ {\inside{\prg{a.key}}}\ \wedge\ \ \protectedFrom {\prg{a.key}} {\prg{res}}   \ \}\ ||\ \{\ {\inside{\prg{a.key} } } \ \} \\
\end{align*}
\normalsize
{Thus, we need to prove   three Hoare quadruples:}
    

We outline the proof for \prg{buy} in Lemma \ref{l:sub:one}.

\end{proofO}

\newcommand{\Aparams}{\prg{A}_{params}}
\newcommand{\Alocals}{\prg{A}_{dcls}}
\newcommand{\Ids}{\prg{X}_{dcls}}
\newcommand{\stmtsP}{\prg{stmts}_{10,11,12}}
\newcommand{\step}[1]{ \vspace{.1cm} \noindent {\textbf{#1}}}

\begin{lemma}
\label{l:sub:one}
 
\begin{align*}
\text{(1)}  \ \ \ \ M_{good} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Ids}  \  \} \\
		& \SPT \prg{Shop}::\prg{buy}.\prg{body}\ \\  
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
where we are using the shorthands\\
 $ \SPT  \Aparams\ \triangleq \  \prg{this}:\prg{Shop}, \prg{buyer} : \prg{external}, \prg{anItem} : \prg{Item},\, \prg{a}:\prg{Account},\, \prg{price} : \prg{int}$.\\
  $ \SPT  \Alocals\ \triangleq \  \Aparams,  \prg{myAccnt} : \prg{Account},\, \prg{oldBalance}:  \prg{int},  \prg{newBalance}:  \prg{int},  \prg{tmp}:  \prg{int}$.\\
   $ \SPT  \Ids\ \triangleq \   \prg{this}, \prg{buyer}, \prg{anItem}$.\\

\end{lemma}

\begin{proofO}


\step{1st Step: proving statements 10, 11, 12}

We apply the underlying Hoare logic and prove that the statements on lines 10, 11, 12 do not affect the value of \prg{a.key}, ie that for a $z\notin \{ \prg{price}, \prg{myAccnt}, \prg{oldBalance} \}$, we have 

\begin{align*}
\text{(10)}  \ \ \ \ {M_{good} \vdash_{ul}} 
		&	\{  \ \Alocals\  \wedge\ z=\prg{a.key} \} \\
		&   \SPT \prg{price:=anItem.price}; \\  
		&   \SPT \prg{myAccnt:=this.accnt}; \\  
                 &   \SPT \prg{oldBalance := myAccnt.blnce};\\
		& \{ z=\prg{a.key} \}
\end{align*}

We then apply {\sc{Embed\_UL}}, {\sc{Prot-1}} and {\sc{Prot-2}} and {\sc{Combine}} and and {\sc{Types-2}} on (10) and use the shorthand $\stmtsP$ for the statements on lines 10, 11 and 12, and obtain: 
\\
\begin{align*}
\text{(11)}  \ \ \ \ M_{good} \vdash 
		&	\{  \ \Alocals\  \wedge\ {\inside{\prg{a.key}}} \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}}  \} \\
		& \SPT \stmtsP\ \\  
		& \{ \ {\inside{\prg{a.key}}}  \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}}   \}
\end{align*}



We apply  {\sc{Mid}}  on (11) and obtain 
\begin{align*}
\text{(12)}  \ \ \ \ M_{good} \vdash 
		&	\{  \ \Alocals\, \wedge\, \protectedFrom {\prg{a.key}} {\prg{buyer}}\  \} \\
		& \SPT \stmtsP\ \\  
		& \{ \ \Aparams\ \wedge \  {\inside{\prg{a.key}}} \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}}  \ \} \ \ || \\
		& \{ \ {\inside{\prg{a.key}}}\  \}
\end{align*}

\step{2nd Step: Proving the External Call}

 

We now need to prove that the external method call \prg{buyer.pay(this.accnt, price)} protects the \prg{key}. i.e.
%\small
\begin{align*}
\text{(20?)} \ \ \ M_{good} \vdash & \{ \ \Alocals \   \wedge\    {\inside{\prg{a.key}}},\, \wedge\, \protectedFrom {\prg{a.key}} {\prg{buyer}}  \} \\
		  		& \SPT  \prg{tmp := buyer.pay(myAccnt, price)}\ \\  
		  		& \{ \ \ \Aparams \ \wedge\ {\inside{\prg{a.key}}} \, \wedge\, \protectedFrom{\prg{buyer}} {\prg{a.key}} \} \ \ \  || \ \ \  \\
		  		&   \{ \   {\inside{\prg{a.key}}}\  \}
\end{align*}
\normalsize

We use that $M \vdash \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}}$
 and  obtain
 \\
 \small
\begin{align*}
\text{(21)} \ \ \ M_{good} \vdash & \{ \ \prg{buyer}:\prg{external},\,  {\inside{\prg{a.key}}} \, \wedge\, 
\protectedFrom {\prg{a.key}} {(\prg{buyer},\prg{myAccnt},\prg{price})} \  \} \\
		  		& \SPT  \prg{tmp := buyer.pay(myAccnt, price)}\ \\  
		  		& \{ \ \inside{\prg{a.key}} \, \wedge\, 
\protectedFrom {\prg{a.key}} {(\prg{buyer},\prg{myAccnt},\prg{price})}\ \} \ \ \  || \ \ \  \\
		  		&   \{ \   {\inside{\prg{a.key}}}\  \}
\end{align*}
\normalsize 
 
In order to obtain (20?) out of (21), we apply \textsc{Prot-Intl} and \textsc{Prot-Int}$_1$,   which gives us\\
$
\begin{array}{llll}
& (23) & & M_{good} \vdash \Alocals \wedge  {\inside{\prg{a.key}}}  \longrightarrow \protectedFrom {\prg{a.key}} {\prg{myAccnt}} 
\\
& (24) & & M_{good} \vdash \Alocals \wedge  {\inside{\prg{a.key}}}  \longrightarrow \protectedFrom {\prg{a.key}} {\prg{price}} 
\end{array}
$

We apply {\textsc{Consequ}} on (23), (24) and (21) and obtain (20)!

\normalsize


\end{proofO}

\subsection{Proving method \prg{set} from $M_{fine}$}

We want to prove that this public method satisfies the specification  $S_2$, namely

\begin{lemma}
\label{l:satisfies:Mfine:pec2}
 
\begin{align*}
\text{(30)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Aparams}  \  \} \\
		& \SPT   \prg{if (this.key==key') then }\\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
	        & \SPT   \prg{else }\\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \SPT \prg{res:=0} \\
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
where we are using the shorthands\\
 $ \SPT  \Aparams\ \triangleq \  \prg{this}:\prg{Account}, \prg{key'} : \prg{Key}, \prg{key''} : \prg{Key}$.\\
   $ \SPT  \Alocals\ \triangleq \    \prg{a}:\prg{Account}, \ \Aparams, $.\\

\end{lemma}

\begin{proofO}

We will use the  {\sc{Sequnece}} rule, and we want to prove
\\
\begin{align*}
\text{(31?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Aparams} \  \} \\
		& \SPT   \prg{if (this.key==key') then }\\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
	        & \SPT   \prg{else }\\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \{ \ \Alocals\,\wedge\ {\inside{\prg{a.key}}}\    \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
and that
\begin{align*}
\text{(32?)}  \ \ \ \ M_{fine} \vdash
          &  \{ \ \Alocals\,\wedge\{\inside{\prg{a.key}}\  \}  \\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \{ {\inside{\prg{a.key}}}\ \wedge\ {\PushASLong {\prg{res}} {\inside{\prg{a.key}}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

(32?) follows   from the types, and {\sc{Prot-Int}}$_1$, the fact that \prg{a.key} did not change, and  \sdN{ {\sc{Prot-1}}}.

\vspace{.5cm}
Wenow  want to  prove (31?). For this, will apply the {\sc{If-Rule}}. That is, we need to prove that

\begin{align*}
\text{(31a?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Aparams} \, \wedge  \,  \prg{this.key==key'}\  \} \\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
		& \{ {\inside{\prg{a.key}}}  \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
 
and that
 
\begin{align*}
\text{(31b?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Aparams} \, \wedge  \,  \prg{this.key}\neq\prg{key'}\  \} \\
		& \SPT\SPT   \SPT\SPT  \prg{res:=0} \\
		& \{ {\inside{\prg{a.key}}}\   \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

(31b?) follows easily from  the fact that \prg{a.key} did not change, and  {\sc{Prot-1}}.

\vspace{.5cm}
We look at the proof of (31a?).  We will apply the {\sc{Cases}} rule, and distinguish on whether \prg{a.key}==\prg{this.key}. That is, we want to prove that\\
\small{
\begin{align*}
\text{(31aa?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Aparams} \, \wedge  \,  \prg{this.key==key'}\ \wedge \prg{this.key==a.key}  \} \\
			& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
	       	& \{ {\inside{\prg{a.key}}}\   \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
}
\\
and that
\\
\small{
\begin{align*}
\text{(31ab?)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ \Alocals\,\wedge\, {\inside{\prg{a.key}}} \, \wedge \, \protectedFrom {\prg{a.key}} {\Aparams} \, \wedge  \,   \,  \prg{this.key==key'}\   \prg{this.key}\neq\prg{a.key'}\  \} \\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
		& \{ {\inside{\prg{a.key}}}\   \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}
}
\vspace{.2cm}
We can prove (31aa?) through application of {\sc{Absurd}}, {\sc{ProtNeq}}, and {\sc{Consequ}}, as follows

\begin{align*}
\text{(31c)}  \ \ \ \ M_{fine} \vdash 
		&	\{  \ false  \} \\
		& \SPT \SPT   \SPT\SPT  \prg{this.key:=key''} \\
		& \{ {\inside{\prg{a.key}}}\   \} \ \ \  || \ \ \ 
		   \{ {\inside{\prg{a.key}}} \}
\end{align*}

By  {\sc{ProtNeq}}, we have $M_{fine} \vdash  \protectedFrom {\prg{a.key}} {\prg{key'}} \, \longrightarrow\, {\prg{a.key}}\neq {\prg{key'}}$, and therefore obtain

\begin{align*}
\text{(31d)}  \ \ \ \ M_{fine} \vdash  ... \wedge \, \protectedFrom {\prg{a.key}} {\Aparams} \, \wedge  \, \prg{this.key}==\prg{a.key}\, \wedge\,  \prg{this.key}==\prg{key'}\ \longrightarrow \ false 
\end{align*}

We apply  {\sc{Consequ}} on (31c) and (31d) and obtain (31aa?).

\vspace{.5cm}
We can prove (31ab?) by proving that \prg{this.key}$\neq$\prg{a.key} implies that $\prg{this}\neq a$, which again implies that the assignment \prg{this.key := ... } leaves the value of \prg{a.key} unmodified. We apply {\sc{Prot-1}}, and are done.

\end{proofO} 


