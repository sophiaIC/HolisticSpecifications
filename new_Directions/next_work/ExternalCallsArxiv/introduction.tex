%\se{You use 'some effects' as the opposite of 'uncertain/unknown effects'. I think the effects shouldn't be some effects, but certain effects or specific effects. Some has the feel of randomness (but who knows which) which isn't meant}
%kjx fixed




\section{Introduction}
\label{s:intro}


This paper addresses reasoning about \emph{external calls} --- when
trusted internal code calls out to untrusted, unknown external code:
% By ``external code''   we mean  code
% 
code for which we don't have the source  nor a specification.
% , or which may even have been written to attack and subvert the system.
\forget{
External code may be written years or decades after the core 
trusted system was released --- software plugins for audio and video
editors have lasted for more than thirty years, and new
trusted retrocomputing hosts (``emulators'')
can run code for machines back to the Manchester 
Baby \cite{MAME-SSEM}, where source code is long lost in the bits of
history \cite{Smalltalk-bits}.
 }

 

\noindent
\begin{minipage}{.55\textwidth}
In the code sketch to the right, 
an internal module, $M_{intl}$, has two methods. %,  \prg{m1}  and \prg{m2}. 
Method \prg{m2} takes an untrusted parameter \prg{untrst},
at line 6 it calls an unknown external method \prg{unkn} passing itself as an argument. 
The challenge is: % What can that method call do?
What effects will that method call have?
What if \prg{untrst} calls back into $M_{intl}$? %, \eg  by calling  \prg{m1}? 
\end{minipage}
\hfill
\begin{minipage}{.4\textwidth}
\begin{lstlisting}[mathescape=true, language=Chainmail,frame=none]
module $M_{intl}$        
  method m1 ..
    ...  $\mbox{trusted code}$ ...  
  method m2(untrst:external) 
    ... $\mbox{trusted code}$ ...
    $\mbox{\red{untrst.unkn(this)}}$   
    ... $\mbox{trusted code}$ ...
\end{lstlisting}
\end{minipage}

 
 {\em{External calls  need not have  arbitrary   effects.}}
If the programming language supports encapsulation (\eg no address forging, privacy,
% private fields, %, ownership, no direct memory access 
 \etc) then internal modules can be  written % \emph{defensively} %\cite{MillerPhD}, 
so  that effects are  % either

 \begin{customquote}
\emph{Precluded}, \ie  guaranteed to \emph{never happen}.
  E.g., a  correct  %defensive 
 implementation of the DAO  \cite{Dao} can ensure that  
 the DAO's balance  never falls below the sum of the balances of its subsidiary accounts, \ \ \. or


 \emph{Limited}, \ie  they  \emph{may happen}, but
 only in well-defined circumstances.
%%   \emph{only if} the external 
%% code  uses  certain \emph{object  capabilities}.
E.g., while the DAO does not preclude that a signatory's balance will decrease, it  does ensure that the balance decreases only
as a direct consequence of calls from the signatory.
% if the code causing this reduction uses the signatory itself.
 
 \end{customquote}
 
%  \vspace{.1cm}
 
\noindent
%\{Reasoning about  effects limited through capabilities is the remit of this paper.}
Precluded effects are special case of limited effects,
and have been studied extensively in the context of object invariants   \cite{staticsfull,DrossoFrancaMuellerSummers08,BarDelFahLeiSch04,objInvars,MuellerPoetzsch-HeffterLeavens06}.
In this paper, we tackle the more general, %more difficult,  
and more subtle case of reasoning about limited effects for external calls.
 


 
 
\paragraphsd{The Object Capability Model}
combines the capability model
of operating system security \cite{levy:capabilities,CAP}
with pure object-oriented programming
\cite{selfpower,selfexp95,agha_actors_1987}.  Capability-based
operating systems reify resources
%and effects 
%(such as memory regions,
%  files, or even hardware devices)}
as \textit{capabilities} ---
unforgeable, distinct, duplicable, attenuable, communicable bitstrings
which both denote a resource and grant rights over that resource.
%Causing an effect
%on a resource
%requires invoking the capability to that resource:
Effects can only be caused by invoking capabilities:
controlling effects reduces to controlling capabilities.
%% \forget{that reify those
%% effects. To create a new file, for example, a process must possess a
%% capability to the directory that will contain the new file, a
%% capability strong enough to create new files. Invoking the
%% ``\texttt{creat}'' system call \cite{Kern84a} on that capability will
%% create a new file and return a capability for that file.  Duplicating
%% the capability and sending it to another process shares the file with
%% that process, granting that process access to the file; sending a suitably
%% attenuated capability can e.g.\ grant the other process read-only
%% access.}


Mark Miller's \cite{MillerPhD}
\textit{object}-capability model treats
object references
as capabilities. 
Building on early object-capability languages such as E
\cite{MillerPhD,ELang} and Joe-E \cite{JoeE}, 
a range of recent programming languages and web systems
\cite{CapJavaHayesAPLAS17,CapNetSocc17Eide,DOCaT14} including Newspeak
\cite{newspeak17},
AmbientTalk \cite{ambientTalk}
Dart \cite{dart15}, Grace \cite{grace,graceClasses},
JavaScript (aka Secure EcmaScript \cite{miller-esop2013}),
and Wyvern \cite{wyverncapabilities} have adopted the object
capability model.
%\forget{Object references cannot be forged; each refers to a distinct object; references can be duplicated (by reference
%assignment, SIMULA's ``\texttt{:-}''); attenuated (typically via Proxies \cite{gof,proxiesECOOP2013}); and communicated to other
%objects. Possession of a ``reference to an object'' (in this setting, also described as possessing an ``object-capability'', a
%``capability'', a ``reference'') can be used to execute any method in that object's public interface. Critically, in object-capability systems
%there is no third-party access controller or security manager or hypervisor which is responsible for security --- rather} 
Security  and encapsulation 
is encoded in the relationships between the objects, and the interactions between them.
%\forget{-- interactions which can communicate capabilities around the system.  As such, object
%capabilities offer a seamless model throughout a programming language or even a distributed global system\footnote{To quote Dan Ingalls,
%``Operating System:\ldots there shouldn't be one'' \cite{ingalls1981}.}. } 
 As argued in  \cite{capeFTfJP}, % by \citet{capeFTfJP}, %Drossopoulou and Noble have put it:
%\textit{``
 object capabilities
 %are a mechanism which makes
 make it possible to write secure
  programs,
% }  %  \cite{capeFTfJP}\forget{ in ways other security models simply do not, }although they 
  but cannot by themselves guarantee that any particular program
  %  using the provided mechanism is, indeed,  secure.
  will be secure.
  %  uses the provided mechanism to be correct or even secure.
%The formulation and verification of such guarantees 
%

%% Object Capability Model (OCAP)  \cite{MillerPhD}  is a security model   based on the concept of capabilities, which  
%% Capabilities are transferable rights that allow the performance of one or more operations on a specific object. 
%% Capabilities are unforgeable and can be obtained only through creation of the corresponding object, or through receipt of a message.
%% Capabilities are {\emph{necessary}} conditions for causing effects; callers can only produce effects if they possess the required capabilities. 
%% For example, a signatory can withdraw funds from a DAO only if they hold a ``withdraw'' capability for that specific account within that particular DAO.  

%% Languages like E, subsets of JavaScript (CITE SES), Caja, Wyvern, Rholang,  implement OCAP principles. CITE-CITE-CITE

\paragraphsd{Logics for Reasoning with Capabilities}
% \sdnew
 {%Recent work proposes 
% Logics to prove properties of programs employing object capabilities, 
have been proposed in
 \cite{BirkedalL:caps-mmio-conf,ddd,vmsl-pldi2023,irisWasm23},   
 %\sdnewer
 {primarily in object-based settings -- our work operates in a class-based setting.}
 More importantly, in these  works,  capabilities are statically embedded within objects, and authority is conferred through the object’s interface. In contrast, our approach models capabilities in a manner that is, in some sense, the dual of theirs: capabilities are not intrinsic to objects but may be 
 %\sdnewer
 {dynamically accessible to the callee—typically via ambient authority in the execution environment.}}
 
 %\sdnew
 {This distinction carries important implications for reasoning  about   effects. 
 In  \cite{BirkedalL:caps-mmio-conf,ddd,vmsl-pldi2023,irisWasm23}, one can argue that if an object is exported with an interface that omits certain capabilities, then the corresponding effects are  ruled out. 
 However, this argument hinges on the assumption that the exporting site has precise knowledge of the object’s embedded capabilities.
 % at the time of export. 
 Our model requires no such assumption. Instead, we reason about potential effects based on the capabilities available in the receiving context. %\sdnewer
{As long as the target context lacks access to specific capabilities}, we can guarantee that the corresponding effects are unobservable —regardless of the object’s interface.
 }

%\citet{ddd} develop a logic to prove that code employing object
%capabilities for encapsulation preserves invariants for
%intertwingled code, but without external calls. 
%\citet{dd}
%describe and verify invariants
%about multi-object structures and the availability and exercise of object capabilities.  
%Similarly,
%\citet{vmsl-pldi2023} propose a separation logic to support formal modular reasoning about communicating VMs, including in the presence of unknown VMs.
%\citet{irisWasm23} specify WASM modules,  
%and prove that adversarial code can affect other modules only through functions they explicitly export. 
% \citet{CassezFQ24} model external calls as an unbounded number of invocations to a module's public interface.
 

%\sdnew
{Our earlier work} %\sdnew
{\cite{FASE,OOPSLA22}   follows a
similar dynamic model of object capabilities, though without addressing external effects.}
Specifically, \cite{FASE}  introduces “holistic specifications” to capture a module’s emergent behavior, while
\cite{OOPSLA22}  proposes
a logic for proving that modules devoid of external calls conform to their holistic specifications.
%\citet{CassezFQ24} model external calls as an unbounded number of invocations to a module's public interface.


%Rather than relying on problem-specific, custom-made proofs, we propose a Hoare logic that addresses access to capabilities, limited effects, and external calls.
 

 
\paragraphsd{This paper contributes}
% (0) a demonstration that object-capabilities can reify the effects of external calls,
(1) \emph{protection assertions} to limit access to object-capabilities, % and concomitantly limit effects}, 
(2) a specification language to define how limited access to capabilities should limit effects, %effects should be limited by capabilities.
(3) a Hoare logic to reason about external calls and to prove that modules satisfy their %\tamed effects 
specifications,
(4) proof of soundness,
(5) a worked illustrative example {with a mechanised proof in Coq}.
 

  \paragraphsd{Structure of this paper:}
Sect.\ \ref{s:outline}   outlines the main ingredients of our approach in terms of an {example}.
% chopped to not get a page break:, and explains the main contributions.
Sect.\ \ref{sect:underlying} outlines a simple object-oriented language used for our work. 
Sect.\ \ref{s:assertions} and 
% Sect 
\ref{sect:spec}  give syntax and semantics of assertions  and  specifications.
%{while Sect. \ref{s:preserve} discusses preservation of satisfaction of assertions.}
Sect.\ \ref{sect:proofSystem} develops a Hoare logic  
 to prove external calls, and modules' adherance to  specifications, and summarises our  proof
  of  the running example 
 { \red{(%the source code is -- SD chopped to avoid early page break
 Coq  at \cite{artefact})}. }
Sect.\ \ref{sect:sound:proofSystem} outlines %{our} 
proof of soundness of
the Hoare logic. 
 Sect.\ \ref{sect:conclusion} concludes. % with related work. 
Full  technical details can be found in the appendices %\sdnew
{in the extended version \cite{externalCallsFull}.}

