\section{\SpecLang specifications}
\label{s:semantics}

 
 \renewcommand{\sd}[1]{#1}
 \newcommand{\sdOct}[1]{\red{#1}} 
\newcommand{\re}{\mathit{e}}

\subsection{\LangOO -- the underlying object oriented programming languages}

  \subsubsection{\sd{Relevant  Objects}}


\begin{definition} We define 
\begin{itemize}
\item
$\Relevant \alpha \phi \sigma $  \ \ \ \ \ \ \ iff\ \  
$\exists n\in \mathbb{N}.\exists \prg{f}_1,... \prg{f}_n.\exists \prg{x}.[ \ \interpret{\sigma}{\phi(x).\prg{f}_1.....\prg{f}_n} = \alpha  ]$.
\item
$ \LRelevant \alpha \sigma $ \ \ iff\ \  
$\exists \phi.[\ \sigma=(\phi\cdot\_, \_)$ and $\Relevant \alpha \phi \sigma\ ]$. % for some $\phi$
\item
$\GRelevant \alpha \sigma$  \ \ iff\ \  
$\exists \phi.[\ \sigma=(\_\cdot\_\phi\cdot\_, \_)$ and $\Relevant \alpha \phi \sigma\ ]$. % for some $\phi$
\end{itemize}
\end{definition}


\sdN{
\begin{lemma}
\label{lemma:relevant}
For all $\sigma$, $\sigma'$, for all objects $o$, and for all modules $M$:
\begin{itemize}
\item
$M, \sigma  \leadsto   {\sigma'} \ \wedge \  \GRelevant o {\sigma'} \ \wedge \ o\in dom(\sigma) \ \ \Longrightarrow \ \  \GRelevant o {\sigma}$
\end{itemize}
\end{lemma}
}
 
 
 
 \subsubsection{Observable States Semantics}

\begin{definition}[\sd{Observable} States Semantics]
\label{def:pair-reduce}
For    modules $M$,  $M_{ext}$, and     states $\sigma$, $\sigma'$, 
we say that $\ \ \ \ \ \ \ \ \reduction{M_{ext}}{M}{\sigma}{\sigma'}\ \ \ \ \ \ \ \ $ if and only if there exist 
$n\in\mathbb{N}$, and states $\sigma_1$,...$\sigma_n$, such that
\begin{enumerate}
\item
\label{vis1}
$\sigma$=$\sigma_1$, and  $\sigma'$=$\sigma_n$,
\item
\label{vis2}
$M_{ext} \circ M, \sigma_i \leadsto \sigma_{i+1}$  \ \ \ for all $i\in [\sd{1}..n)$,
\item
\label{vis3}
\sd{$| \sigma_1 | \leq | \sigma_i |$ \ \ \  for all $i\in [1..n]$,}
\item
\label{vis4}
$\class {\prg{this}}{\sigma}, \class {\prg{this}} {\sigma'}\!\in\! M_{ext}$,\ \ \ and \ \ \
%\item
$\class {\prg{this}} {\sigma_i}\!\in\! M$\ \ \ for all $i\!\in\! (1..n)$.
\end{enumerate} 
\end{definition}
 
 
\subsubsection{Arising States}

\begin{definition}[Arising  States]
\label{def:arising}
For   modules $M$ and  $M_{ext}$, a % program
 state $\sigma$ is 
called an \emph{arising} state, formally \ \ \ $\arising{\sigma}{M_{ext}}{M}$,\ \ \ 
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$\reductions{M_{ext}}{M}{\sigma_0}{\sigma}$.
\end{definition}

\sdN{\textbf{TODO} Say that$ \arising{\sigma}{M_{ext}}{M}$, implies that $\sigma$ is an external state, since  $M_{ext} \circ M, \sigma  \leadsto^* \sigma' $ implies that both $\sigma$ abd $\sigma'$ are external states}

 
\subsubsection{\sd{Relevant  Objects and observable states}}


The lemma below is the counterpart to lemma \ref{lemma:relevant}:

\begin{lemma}
For all $\sigma$, $\sigma'$, for all objects $o$, and for all modules $M_{ext}$, and $M$:
\begin{itemize}
\item
$\reduction {M_{ext}} {M} {\sigma} {\sigma'} \ \wedge \  \GRelevant o {\sigma'} \ \wedge \ o\in dom(\sigma) \ \ \Longrightarrow \ \  \GRelevant o {\sigma}$.
\item
$\reduction {M_{ext}} {M} {\sigma} {\sigma'} \ \wedge \    \LRelevant o {\sigma'}\   \wedge \ o\in dom(\sigma) \ \ \Longrightarrow \ \  \LRelevant o {\sigma}$.
\end{itemize}
\end{lemma}
 

\subsection{\AssertLang -- the assertion language}
\label{sub:SpecO}



\sdOct{
\begin{definition}
We define  $\re$ (runtime expressions) which will be the same as $e$ in previous,  \textbf{but can mention addresses} -- this is a simple syntactic extension wrt previous. We also extend the definition of assertions, $A$ to allow for $re$ and the definition of 
the evaluation relation to allow for $\eval{M}{\sigma}{\re}{val}$
\end{definition}
}




\begin{definition}
Assertions ($A$) in
\AssertLang are defined as follows:

\label{f:chainmail-syntax}
 \[
\begin{syntax}
\syntaxElement{A}{}
		{
		\syntaxline
				{\sdOct{\re}}
				{\sdOct{\re} : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x:C}{A}}
				{\ex{x:C}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\internal{\sdOct{\re}}}
				{\protectedFrom{\sdOct{\re}} {\sdOct{\re}}} 
				 {\inside {\sdOct{\re}}} 
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]


\end{definition}

\sdOct{\textbf{NOTE}  This allows for the ugliness that we can write assertions like $\alpha.bal > 700$ which obviously makes no sense without a $\sigma$. We could say that assertion that contain variables are the run-time counterpart of those which do not. Also, note that universal quantification over expressions ($\forall \alpha:C.[A]$) is not supported\footnote{This may only be a techncality, though}. On the other hand, $a.bal > 700$ does not make sense without a $\sigma$ either.
}

\sdOct{\textbf{NOTE} It also allows assertions like $a1.passwd \neq a2.passwd$, whereas in the past we would have written as
$\exists x,y.[\ a1.passwd=x \wedge  a2.passwd=y \wedge x\neq y\ ]$.}

\subsubsection{Semantics of \AssertLang}
 

\begin{definition}[Satisfaction 
of Assertions by a module and a state] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a % program 
state $\sigma$ with 
 module $M$ as:
\begin{enumerate}
\item
\label{cExpr}
$\satisfiesA{M}{\sigma}{\sdOct{\re}}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{\sdOct{\re}}{\true}$
\item
\label{cClass}
$\satisfiesA{M}{\sigma}{{\sdOct{\re}} : C}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{\sdOct{\re}}{\alpha}\   \wedge \ \class{\alpha} {\sigma}= C$
\item
$\satisfiesA{M}{\sigma}{\neg A}$ \ \ \ iff \ \ \  ${M},{\sigma}\nvDash{A}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \wedge\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1} \   \wedge \ \satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \vee\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}\   \vee \ \satisfiesA{M}{\sigma}{A_2}$

\item
\label{quant1}
$\satisfiesA{M}{\sigma}{\all{x:C}{A}}$ \ \ \ iff \ \ \  
 \sdOct{$\forall \alpha.[\ \GRelevant \alpha \sigma \wedge  \satisfiesA {M}{\sigma} {\alpha:C}  \ \Longrightarrow   \ \satisfiesA{M}{\sigma} {A[x/\alpha]}\ ]$.} 
% $\satisfiesA{M}{\sigma[x \mapsto o]}{x:C} \ \ \Longrightarrow \ \ \ \satisfiesA{M}{\sigma[x \mapsto o]}{A}$, \\
%\strut \hspace{1.3in}  \sd{for all  $o$ such that $ \GRelevant o \sigma$ }%, where $x$ is free in $\sigma$ } 

\item
\label{quant2}
$\satisfiesA{M}{\sigma}{\ex{x:C}{A}}$ \ \ \ iff \ \ \  
 \sdOct{$\exists \alpha.[\ \GRelevant \alpha \sigma \wedge  \satisfiesA {M}{\sigma} {\alpha:C}  \ \wedge \ \satisfiesA{M}{\sigma} {A[x/\alpha]}\ ]$.} 
% $\satisfiesA{M}{\sigma[x \mapsto o]}{x:C} \ \ \wedge \ \ \ \satisfiesA{M}{\sigma[x \mapsto o]}{A}$, \\
%\strut \hspace{1.3in}  \sd{for some $o$ such that $\GRelevant o \sigma$. } %, where $x$ is free in $\sigma$. }
\item
\label{cInternal}
$\satisfiesA{M}{\sigma}{\internal{\sdOct{\re}}}$ \ \ \ iff \ \ \   $\satisfiesA{M}{\sigma}{{\sdOct{\re}} : C} \ \wedge\ \ C \in M$
\item
\label{cExternal}
$\satisfiesA{M}{\sigma}{\external{\sdOct{\re}}}$ \ \ \ iff \ \ \   $\satisfiesA{M}{\sigma}{{\sdOct{\re}} : C} \ \wedge \ C \notin M$
\item
\label{cProtected}
$\satisfiesA{M}{\sigma}{\protectedFrom{\sdOct{\re}} {\sdOct{\re_{o}}}}$  \ \ \ iff \\
  $\exists \alpha, \alpha_{o}. [\ $
\begin{enumerate}
\item $\eval{M}{\sigma}{\sdOct{\re}}{\alpha} \ \ \ \wedge\ \ \  \eval{M}{\sigma}{\sdOct{\re_{o}}}{\alpha_{o}}$, \ \ \ \ \ \ and  
\item
\sdOct{$\alpha \neq \alpha_{o}$}, % \footnote{!!!! \  NOT THAT SURE HERE, but think so !}
\ \  \ \ \  and 
\item 
\sdOct{$\forall n\in\mathbb{N}. \forall f_1,...f_n.$\\
$
%\strut \hspace{1cm} 
[\ \ \interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha \ \wedge\ \forall k\!<\!n.\interpret{\sigma}{\alpha_{o}.f_1...f_k}\neq \alpha \ \
% $\\ $ \strut \hspace{5.5cm} \   
\ \  \Longrightarrow \ \ \satisfiesA{M} {\sigma} {\internal{{\alpha_{o}.f_1...f_{n-1}}}}\ \ ]$}
\end{enumerate}
\strut \hspace{.4cm} $]$
% The previous version 
%\begin{enumerate}
%\item $\satisfiesA{M}{\sigma}{x \neq z}$  and
%\item
%$\forall f_1,...f_n.[\ \interpret{\sigma}{z.f_1...f_n}=\interpret{\sigma}{x} \ \Longrightarrow \exists k<n.
%[\,\satisfiesA{M}{\sigma}{\internal{z.f_1...f_k}} \, ] \ ]$ and
%\item either
%\begin{enumerate}
%\item $\satisfiesA{M}{\sigma}{z \neq \this}$ or
%\item $\forall y.[y \in \sigma.\texttt{local}
%\Longrightarrow \satisfiesA{M}{\sigma}{(\internal{y} \wedge y \neq x) \vee \protectedFrom{x}{y}}]$
%\end{enumerate}
%\end{enumerate}
\item
$\satisfiesA{M}{\sigma} {\inside {\re}}$   \ \ \ iff \ \ \  
\sdOct{$\forall \alpha.[ \  \LRelevant {\alpha}  {\sigma}\ \Longrightarrow \ \  \satisfiesA{M}{\sigma}{\protectedFrom{\re} {\sdOct{\alpha}}}\ ] $}
\end{enumerate}
\end{definition}


\sdOct{\textbf{NOTE} in the def of  $\protectedFrom{\re}{\re_o}$, when enumerate the paths that go from $\re_o$ to $\re$, we exclude those that have already "visited" $\re$ earlier on. That is, we only consider the direct paths from $\re_o$ to $\re$. This is pretty much what "dominates" means- James you were right -- put it is a "relative" domination}

\sdOct{\textbf{NOTE} also, that the term $\re$ may mention ghost fields, but the paths $\alpha.f_1....f_n$ may not. We see that because the latter are interpreted in $\sigma$. That is, $\satisfiesA{M}{\sigma}{\sdOct{\alpha_o.f_1...f_n}=\alpha}$ is weaker than $\interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha$. TODO: write the latter as a lemma}

\sdOct{\textbf{NOTE} to reflect a bit more on (10)(b) from above}

\subsection{Lift -- revisited}

\renewcommand{\lift}[4]{{\mathcal L}ft( #1, #2, #3, #4 )}

\sdOct{The new definition of   $\lift {\_} {\_}  {\_}  {\_}$
has four arguments: the current module, the current assertion, the sub-assertion, and the actual parameters. It does not distinguish whether the arguments are external or internal. Moreover the arguments are complex expressions, $\re$, not variables.}



$\begin{array}{lcll}
\lift {M} {A} {A_1 \wedge A_2} {\overline {\re''}} & = & \lift {M} {A} {A_1} {\overline \re} \ \wedge \lift {M} {A} {A_2} {\overline \re}
\\
\lift {M} {A} {\re=\re'} {\overline {\re''}}  & = & {\re=\re'}  & \mbox{??? to check} 
\\
\lift{M} {A}  { \inside \re}  {\overline {\re''}}  & = &   \inside \re  & \mbox{if }  \ M \vdash A \rightarrow \re \neq  {\overline {\re''}} \\
 & = &   ???  & \mbox{otherwise}
\\
\lift{M} {A} { \protectedFrom \re  {\overline {\re'}} }  {\overline {\re''}}  & = &   \inside \re & \mbox{if } \ \sdN { {\overline {\re''}} \subseteq {\overline {\re'} }}
\\
   & = &   ???  & \mbox{otherwise}
\end{array}$

\sdN{\textbf{TO THINK} When we say $\lift {M} {A} {\re=\re'} {\overline {\re''}} = {\re=\re'} $ we do not consider whether $\re$ and $\re '$ are in scope in the new frame. We might decide to try and use ${\overline {\re''}} $ to determine that. Or, it may be the case that it does not matter whether  $\re$ and $\re '$ are in scope, since we only use what we had lifted in order to lower it again later.}

\sdN{\textbf{TO THINK}  Is the equation $\lift{M} {A}  { \inside \re}  {\overline {\re''}}  =  \inside \re$ if   $M \vdash A \rightarrow \re \neq  {\overline {\re''}}$ sound? } 
