 \begin{abstract}
 
 
 In today's complex software, internal, trusted, code  is tightly intertwined  
 with external, untrusted, code. %: external code
 %may call
% calls
% into internal code, internal code
% may call
% calls
% out to external code,
% and external code
 %  may then call back
%even calls back 
% into internal code.
% In particular, trusted  code may be called by external, unverified,
% untrusted code; moreover, it may call such external, unverified,
% untrusted code
By definition, internal code does not trust external code.
From an internal perspective, the effects of
outgoing calls to external code -- \emph{external calls} ---
are %in principle
necessarily
unknown and unlimited.

Nevertheless, the effects of external calls can be \emph{\tamed}
% , \ie reduced, \
if internal code % module %makes use of encapsulation and
is programmed defensively,
%\ie to prevent some effects from happening.
\ie to ensure particular effects cannot happen.
\Tamed effects allow us to prove that internal code
preserves assertions about internal and external objects,
even in the presence of outgoing calls and callbacks.
%
%  external calls will preserve some {why only some?} assertions.
%
%% {Given that this is the abstract I would skip the next two
%%   sentences.}
%% \kjx{skipped}
%% To \tame effects, one needs to use encapsulation (\eg private fields, no address forging, \etc). 
%% One may also employ  the OCAP (object capabilities) model, whereby 
%% % capabilities are transferable rights to perform one or more operations on a given object;
% access to the capability is  necessary for some  effect to  happen.
%Capabilities are unforgeable, and can only be acquired through explicit passing from caller to callee, or at object creation.
 % As a result, sharing of capabilities has to be carefully managed.
%

This paper
addresses the specification and verification of internal code,
using encapsulation and object capabilities to \tame effects.
We propose new assertions for access to capabilities,
new specifications for \tamed effects,
and a Hoare logic to verify that a module satisfies its \tamed
effects specification, even while making external calls.
We illustrate the approach though \susan{an automated,} running example,
and prove soundness of the Hoare logic.


 \forget{
%Our work
This paper
addresses the specification and verification of internal code
which uses encapsulation and object capabilities to \tame effects.
%{Are they assertions and specifications or assertion constructs
%and specification language?}
%kjx: shorter is better
We propose new assertions talking about access to capabilities,
new specifications describing \tamed effects,
%kjx howmany Hoare logics??
%a Hoare logic that can verify external calls,
and a Hoare logic that can verify that a module satisfies its \tamed
effects specification, even while making external calls.
We illustrate the approach though a running example,
and prove soundness of the Hoare logic.
%% -- something not yet sufficiently  tackled by the OCAP  literature.
%{\textbf {For the specification:}} To%  not being ``entitled'' to some effect, we give a means to guarantee  that lack of (eventual) access to certain capabilities ensures
%that certain effects will not take place.
% To reflect that the guarantees
%should hold in the presence of internal code calling and being called by external code, we 
%% are about eventual} effects we 
%propose {\emph{scoped invariants}}, where the notion of the future is  {constrained} by the currently executing method. 
%%We propose means to specify the preservation of such properties, and the meaning of being ``entitled'' to some effect. 
%To define the   management of sharing of capabilities, we propose the concept of  protected capability which guarantees  that access by external objects
% is controlled by the internal objects.
%  
%%  
%%  Our specification language can express that capabilities are necessary (rather than sufficient) conditions for certain effects
%%(thus going further than traditional object capabilities).
%% We propose 
%% With these ingredients, internal code may call external code in the knowledge that ...
%{\textbf {For the verification: }} We  propose Hoare logic inference rules   {to prove} that calls to external code are safe. 
%We also propose inference rules   {to prove}    that  {our} modules satisfy our specifications.
%We then  {demonstrate}  that a sound   Hoare logic augmented by the proposed rules is also sound. 
%We use a motivating example  and   prove its properties using our logic.
}

\end{abstract}

