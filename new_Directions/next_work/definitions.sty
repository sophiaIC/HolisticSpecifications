\ProvidesPackage{definitions}[2021/05/18 v1.0 chainmailDefs]

\usepackage{xspace}
\usepackage{tcolorbox}
\usepackage{calrsfs}
\usepackage{tikz}
\usepackage{listings}
\usetikzlibrary{arrows, positioning, decorations.pathmorphing}
\DeclareMathAlphabet{\pazocal}{OMS}{zplm}{m}{n}

\definecolor{hotpink}{rgb}{1.0, 0.41, 0.71}
%\definecolor{darkgreen}{rgb}{0.08, 0.39, 0.25}
\definecolor{darkgreen}{rgb}{0.01, 0.49, 0.31}
\definecolor{darkgreen}{rgb}{0.08, 0.39, 0.25}
\definecolor{lightseagreen}{rgb}{0.13, 0.7, 0.67}


\newcommand{\initialStateNode}[3]{
   \node[draw=red, label=above:#1] (#2) {#3};
}
\newcommand{\stateNode}[4]{
   \node[draw=red, label=above:#1] (#2) [#3] {#4};
}
\newcommand{\etcNode}[2]{
   \node[] (#1) [#2] {...};
}

\newtcolorbox{proofBox}[3][]
{
  colframe = #3,
  colback  = #2,
  #1,
}

\lstset{ % General setup for the package
	language=Java,
	basicstyle=\footnotesize\sffamily\ttfamily,
 	numberstyle=\tiny,
    numbers=left,
 	frame = bottomline,
	tabsize=4,
	columns=fixed,
	showstringspaces=false,
	showtabs=false,
	keepspaces,
	morekeywords={this, true, false, field, method, module, presumes, achieves, requires, ensures, PRE, POST, ghost, bool, int, constr, bool, int, confined, then, ENSURES, MODIFIES},
	commentstyle=\color{red},
	keywordstyle=\color{blue}
}

\lstdefinelanguage{Chainmail}{
  basicstyle=\footnotesize\sffamily\ttfamily,
  morekeywords={calls, external, internal, access, this, ENSURES, MODIFIES, PRE, POST, method, field, ghost, class, module, confined, void, if, then, else,
                from, onlyThrough, onlyIf, next, to, true, false, through, bool, int},
  sensitive=false,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\newcommand{\A}{Appdx.}

\newcommand{\Spec}[1]{\ensuremath{\boldmath{S}_{\prg{#1}}}\xspace} % {{\ensuremath{{\mathcal{S}}_{\prg{#1}}}}\xspace}
\newcommand{\Sadapt}{\Spec{to\_dcr\_thr\_call}}
%(S$_{\text{nxt\_red\_if\_tran}}$)\xspace}
\newcommand{\Scorrect}{\Spec{correct}\xspace} % {(S$_{\text{correct}}$)\xspace}
\newcommand{\SrobustA}{\Spec{robust$\_{\prg{1}}$}} %{(S$_{\text{robust}_1}$)\xspace}  % SD we should  not have subscripts in subscriptts!
\newcommand{\SrobustB}{\Spec{robust$\_{\prg{2}}$}} % {(S$_{\text{robust}_2}$)\xspace}
\newcommand{\SRobustNextAcc}{\Spec{nxt\_dcr\_if\_acc}\xspace}
\newcommand{\SRobustifAcc}{\Spec{to\_dcr\_if\_acc}\xspace}
\newcommand{\SRobustThroughAcc}{\Spec{to\_dcr\_thr\_acc}\xspace}
\newcommand{\SRobustNextCall}{\Spec{nxt\_dcr\_if\_call}\xspace}
\newcommand{\SRobustToCall}{\Spec{to\_dcr\_if\_call}\xspace}
\newcommand{\SRobustThroughCall}{\Spec{to\_dcr\_thr\_call}\xspace}
\newcommand{\SRobustIfAcc}{\Spec{to\_dcr\_if\_acc}\xspace}

\newcommand{\TwoStates}[2]{\ensuremath{\FirstState{#1}\,\SecondState{#2}}}
\newcommand{\OneStateQ}[2]{\ensuremath{\forall {#1}.\FirstState{#2}}}
\newcommand{\TwoStatesQ}[3]{\ensuremath{\forall {#1}.\FirstState{#2}\SecondState{#3}}}
\newcommand{\openBr}{{\llparenthesis}}
\newcommand{\closeBr}{{\rrparenthesis}}
\newcommand{\FirstState}[1]{\ensuremath{\openBr\, #1 \,\closeBr}}
\newcommand{\SecondState}[1]{\ensuremath{\openBr\, #1 \,\closeBr}}

\newcommand{\funcSpec}{functional specification\xspace}
\newcommand{\funcSpecs}{functional specifications\xspace}
\newcommand{\FuncSpecs}{Functional specifications\xspace}


\newcommand{\Sclassic}{\prg{FuncSpec}\xspace}
\newcommand{\SclassicP}{$\prg{FuncSpec}'$\xspace}
\newcommand{\Snecessity}{\prg{NecessitySpec}\xspace}

\newcommand{\ModParam}[1]{\prg{Mod}\ensuremath{_{\prg{#1}}}\xspace}
\newcommand{\ModA}{\ModParam{good}}
% \newcommand{\ModA}{\prg{Mod}\ensuremath{_\texttt{good}}\xspace}
\newcommand{\ModB}{\ModParam{bad}}
\newcommand{\ModC}{\ModParam{better}}
\newcommand{\ModD}{\ModParam{best}}
\newcommand{\ModExt}{\ModParam{ext}}


\newcommand{\internalO}{internal\xspace}  % for internal object 
\newcommand{\internalC}{internal\xspace}  % for internal call 
\newcommand{\internalM}{internal\xspace}   % for internal module
\newcommand{\externalM}{external\xspace}    % for external module
\newcommand{\externalC}{external\xspace} % for external call
\newcommand{\externalO}{external\xspace}  % for external object
\newcommand{\enclosed}{\texttt{confined}\xspace}  % for external object


%constrained reduction
\newcommand{\constrained}{\mathrel{\leadsto\ \!\!\!\!{\raisebox{1pt}{$\mathsmaller{\mathsmaller{\mathsmaller{\mathsmaller\rvert}}}$}}}}
\newcommand{\reduction}[4]{#1 ; #2,\ #3 \curvearrowright #4}
\newcommand{\redsymb}{\curvearrowright}
\newcommand{\reductions}[4]{#1 ; #2,\ #3\ \curvearrowright^* #4}
\newcommand{\exec}[3]{#1, #2 \leadsto\ #3}
\newcommand{\constrainedReduction}[4]{#1 ; #2 \bullet #3 \constrained #4}
\newcommand{\constrainedReductions}[4]{#1 ; #2 \bullet #3 \constrained^* #4}
\newcommand{\satisfies}[2]{#1 \models #2}
\newcommand{\stronger}[3]{#1\, \models\, #2\,  \sqsubseteq\, #3}  % \Rightarrow
\newcommand{\strongerI}[3]{#1 \vdash #2\, \sqsubseteq\, #3}
\newcommand{\strongerEq}[3]{#1 \models #2 \langle \equiv \rangle #3}
\newcommand{\strongerEqI}[3]{#1 \vdash #2 \langle \equiv \rangle #3}
\newcommand{\promises}[2]{{\ensuremath \vdash \ \ #1\ \   \kw{:}\ \  #2}}
%{{\ensuremath {Promiss(#1,#2)}}}
\newcommand{\lift}[2]{{\ensuremath {\mathcal{L}\!\mathit{ift}(#1,#2)}}}
\newcommand{\llower}[2]{{\ensuremath {{\mathcal{L}\!\mathit{ower}(#1,#2) }}}}
\newcommand{\preserve}[3]{{\ensuremath {Prsv(#1,#2,#3)}}}
%\newcommand{\pop}[3]{{\ensuremath {Pop(#1,#2,#3)}}}
 
\newcommand{\satisfiesA}[3]{\satisfies{#1 , #2}{#3}}
\newcommand{\notsatisfies}[2]{#1 \nvDash #2}
\newcommand{\eval}[4]{#1, #2, #3 \hookrightarrow #4}
\newcommand{\class}[2]{\textit{classOf}(#1, #2)}
\newcommand{\meth}[3]{\textit{Meth}(#1, #2, #3)}
\newcommand{\interpret}[2]{\lfloor #2 \rfloor_{#1}}
\newcommand{\initial}[1]{\textit{Initial}(#1)}
\newcommand{\extArising}[3]{\mathcal{A}\!\textit{rising}{\mathcal{E}\!\textit{xt}(#1, #2, #3)}}
\newcommand{\arising}[2]{\mathcal{A}\!\textit{rising}(#1, #2)}
\newcommand{\adapt}[2]{#1 \triangleleft #2}

\newcommand\trans{\mathlarger{\mathlarger \leadsto}}
\newcommand\intstep{\hspace{1.5mm}{\raisebox{3pt}{$\bullet$}}\hspace{-1.5mm}{\hookrightarrow}}
\newcommand\en{\hspace{1.5mm}{\raisebox{0pt}{$\bullet$}}\hspace{-4mm}{\hookrightarrow}}
\newcommand\oi{\hspace{1mm}{\raisebox{1pt}{$\bullet$}}\hspace{-1mm}{\trans}}
\newcommand\ot{\hspace{2mm}{\raisebox{1pt}{$\bullet$}}\hspace{-3mm}{\trans}}
\newcommand\otAlt{\hspace{2mm}{\raisebox{0.5pt}{$\bullet$}}\hspace{-2.75mm}{\trans}}
\newcommand\mut[3]{\langle #1\ \texttt{mut}\ #2.#3 \rangle}
\newcommand\gives[3]{\langle #1\ \texttt{gives}\ #2\ \texttt{to}\ #3 \rangle}
\newcommand\exposes[2]{#1\ \texttt{exposes}\ #2}
\newcommand\univ{U}
\newcommand\onlyIf[3]{{\color{blue}\texttt{from}}\ #1\ {\color{blue}\texttt{to}}\ #2\ {\color{blue}\texttt{onlyIf}}\ #3}
\newcommand\oiInternal[4]{#1\ {\color{blue}\texttt{to}}\ #2\ {\color{blue}\texttt{through}}\ #3\ {\color{blue}\texttt{onlyIf}}\ #4}
\newcommand\ensures[3]{#1,\ #2\ \en\ #3}
\newcommand\onlyThrough[3]{{\color{blue}\texttt{from}}\ #1\ {\color{blue}\texttt{to}}\ #2\ {\color{blue}\texttt{onlyThrough}}\ #3}
\newcommand\onlyIfSingle[3]{{\color{blue}\texttt{from}}\ #1\ {\color{blue}\texttt{next}}\ #2\ {\color{blue}\texttt{onlyIf}}\ #3}
\newcommand\onlyIfProof[4]{{\color{blue}\texttt{from}}\ #1\ \vdash\ #2,\ #3\ \texttt{only if}\ #4}
\newcommand\onlyThroughProof[4]{{\color{blue}\texttt{from}}\ #1\ \vdash\ #2,\ #3\ \texttt{only if}\ #4}
\newcommand\hoare[3]{\{#1\}\ #2\ \{#3\}}
\newcommand\hoareIf[4]{#1,\ #2,\ \{#3\}\ \intstep\ #4}
\newcommand\rtrns[3]{\{#1\}\ #2\ \texttt{returns}\ #3}
%\newcommand\ifthenelse[3]{\texttt{if}\ #1\ \texttt{then}\ #2\ \texttt{else}\ #3}

\newcommand\encapsulated[1]{\langle {\color{blue}\texttt{encapsulated}}\ #1 \rangle}
\newcommand\encapsulates[2]{\langle #1\ {\color{blue}\texttt{encapsulates}}\ #2 \rangle}
\newcommand\bencapsulated[1]{\langle {\color{blue}\texttt{encapsulated}_{\mathcal{B}}}\ #1 \rangle}
\newcommand\bencapsulates[2]{\langle #1\ {\color{blue}\texttt{encapsulates}_{\mathcal{B}}}\ #2 \rangle}
\newcommand\encapsulatesStrong[2]{\langle #1\ \texttt{encapsulates}_\texttt{strong}\ #2 \rangle}
\newcommand\encapsulatesMdl[1]{\langle \texttt{encapsulating}_\texttt{int}\ #1 \rangle}
\newcommand\calls[4]{\langle #1\ {\color{blue}\texttt{calls}}\ #2.#3(#4) \rangle}
\newcommand\changes[2]{\langle #1\ {\color{blue}\texttt{changes}}\ #2 \rangle}

\newcommand{\kw}[1]{\mathbf{#1}}
\renewcommand{\langle}{}
\renewcommand{\rangle}{}

\newcommand\access[2]{\langle #1\ {\color{blue}\texttt{access}}\ #2 \rangle}
\newcommand{\protectedFrom}[2]{{\ensuremath{\langle\, #1\, \kw{prt\!\!-\!\!frm}}\,  #2\rangle}}
%{\ensuremath{[\!\![ \,#1\, \mbox{from}\, #2]\!\!]^{\prg{prt}}}}
%{\ensuremath{\llparenthesis \, #1\, \rrparenthesis^{\prg{prt}} #2}}
\newcommand\inside[1] {{\ensuremath{\langle\, \kw{prt}}\, #1\, \rangle}}%{\ensuremath{\llparenthesis \, #1\, \rrparenthesis^{\prg{prt}}}}
% {\ensuremath{[\!\![ \,#1\, }]\!\!]^{\prg{prt}}}
\newcommand{\Relevant}[3]{\ensuremath{\,Reachbl(\,#1,#2,#3\,)}}
\newcommand{\LRelevant}[2]{\ensuremath{\,Loc\_Reachbl(\,#1,#2\,)}}
\newcommand{\GRelevant}[2]{\ensuremath{\,Glb\_Reachbl(\,#1,#2\,)}}
 

\newcommand\internal[1]{{\ensuremath{\langle\, \kw{intl}}\, #1\, \rangle}}
%{\ensuremath{[\!\![ \,#1\, ]\!\!]^{\prg{in}}}}
\newcommand\external[1]{{\ensuremath{\langle\, \kw{extl}}\, #1\, \rangle}}
% {\ensuremath{[\!\![ \,#1\, ]\!\!]^{\prg{ex}}}}
\newcommand\comprehension[2]{\{#1 | #2\}}
\newcommand\internalStep{\langle \texttt{internal step}\rangle}
\newcommand\I{\textit{Int}\xspace}
\newcommand{\Chainmail}{\textit{SpecX}\xspace}
%\newcommand{\textit{SpecW}\xspace}
\newcommand{\Loo}{\text{$\textit{LangX}$}\xspace}
\newcommand\new[2]{\texttt{new}\ #1(#2)}
\newcommand\return[1]{\texttt{return}\ #1}
\newcommand\this{\texttt{this}}
\newcommand\true{\texttt{true}}
\newcommand\false{\texttt{false}}
\newcommand\nul{\texttt{null}}
\newcommand\all[2]{\forall #1.[#2]}
\newcommand\ex[2]{\exists\ #1.[#2]}

\newcommand{\prg}[1]{{\texttt{#1}}}

\newcommand\encaps[1]{{\ensuremath Encaps(\, #1\, )}}
%%{\ensuremath \llparenthesis\, #1\, \rrparenthesis^{\texttt{encps}}}
\newcommand\intrnl[1]{\textit{Enc$_e$}(#1)}
\newcommand\givenA[2]{#1\ \Rightarrow\ #2}

\newcommand\proves[2]{#1\ \vdash\ #2}
\newcommand\hproves[4]{#1\ \vdash\ \{\,#2\, \} #3  \{\,#4\, \} }
\newcommand\hprovesTwoLines[4]{#1\ \vdash\ \{\,#2\, \} \\
~ \strut \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \  #3\\
~ \strut \ \ \ \ \ \ \ \ \ \ \ \ \ \   \{\,#4\, \} }
\newcommand{\leadstoOrig}[3]{\ensuremath{#1 \vdash #2 \leadsto {#3}}}
\newcommand{\leadstoOrigStar}[3]{\ensuremath{#1 \vdash #2 \leadsto^* {#3}}}
%%% more oper semantics %%%
\newcommand{\leadstoRec}[4]{\ensuremath{#1, #2 \leadsto_{#3} #4}}

\newcommand{\leadstoBounded}[4]{\ensuremath{#1, #3 \vdash {#2}  \leadsto #4}}
\newcommand{\notLeadstoBounded}[4]{\ensuremath{#1, #3 \nvdash {#2}  \leadsto #4}}
\newcommand{\notLeadstoBoundedStar}[4]{\ensuremath{#1, #3 \nvdash {#2}  \leadsto^* #4}}

\newcommand{\leadstoRecStar}[4]{\ensuremath{#1, #2  \leadsto^*_{#3} #4}}
\newcommand{\leadstoBoundedStar}[4]{\ensuremath{#1, #3 \vdash {#2}  \leadsto^* #4}}

\newcommand{\leadstoLoc}[4]{\ensuremath{#1, #2 \leadsto_{!#3} #4}}
\newcommand{\Final}[1]{\ensuremath{{\mathcal F}\!\mathit{inal}(#1)}}
\newcommand{\leadstoFin}[3]% {\ensuremath{#1, #2 \rightharpoondown \! \!\!\!\! ^{\rightharpoonup} {#3} }}
%{\ensuremath{#1, #2 \leadsto\!\! \!>\! \!> {#3} }}
{\ensuremath{#1, #2 \leadsto \!\!\!\! \vartriangleright {#3} }}
\newcommand{\Values}{\ensuremath{{\mathcal V}\!\mathit{al}}}

\newcommand\wrapped[1]{\texttt{inside}( #1 )}


\newcommand\IntSet{\mathbb{Z}}

\newcommand{\synbar}{\;\; | \;\;}
	
\newcommand{\red}[1]{
	\color{red}#1 \color{black}
}
\newcommand{\blue}[1]{
	\color{blue}#1 \color{black}
}
\newcommand{\green}[1]{
	\color{darkgreen}#1 \color{black}
}

\newcommand{\citeauthorwithyear}[1]{\citeauthor{#1} \citeyear{#1}}
\newcommand{\citeasnoun}[1]{\citeauthor{#1} [\citeyear{#1}]}

\newcommand{\SpecO}{\textit{Basic}$^{spec}$\xspace}
\renewcommand{\SpecO}{\textit{Assert}\xspace}  



%\renewcommand{\Loo}{\textit{L}$_{oo}^{typed}$\xspace}
\renewcommand{\Loo}{\ensuremath{{\mathcal L}{_{\tt {oo}}}{^{\tt {typed}}}}\xspace}
\renewcommand{\Loo}{\ensuremath{{{\tt {TooL}}}}\xspace}
\newcommand{\LangOO} {\ensuremath{{\mathcal L}{^{\tt {oo}}}}\xspace}
\newcommand{\SpecLang}{\ensuremath{{\mathcal L}{^{{spec}}}}\xspace}
%{{\ensuremath{\mathcal L}{^{{spec}}}}\xspace}
\newcommand{\AssertLang}{\ensuremath{{\mathcal L}{^{{assrt}}}}\xspace}
\newcommand{\Nec}{\textit{Necessity}\xspace}  

\newcommand{\ie}{\emph{i.e.}\xspace}  
\newcommand{\eg}{\emph{e.g.}\xspace}  
\newcommand{\cf}{\emph{c.f.}\xspace} 

\newtheorem{axiom}{Axiom}

\numberwithin{axiom}{section}
\newtheorem{example}{Example}
\numberwithin{example}{section}
%--------------------------------------------------------------------------------------------------	
	
% Syntax Construct
\makeatletter 




\newenvironment{syntax}
    {
    \begin{array}{lllr}
    }
    { 
    \end{array}
    }
    
\newcommand{\syntaxID}[2]{
		#1 & & & \text{\bf{#2}}\\
}
    
\newcommand{\syntaxInSet}[3]{
		#1 & \in & #2 & \text{\bf{#3}}\\
}

\newcommand{\syntaxElement}[3]{%
		#1 & ::= & #3 & \text{\bf{#2}} \\
			\@syntaxEntry
}

\newcommand\@syntaxEntry{\@ifnextchar\endSyntaxElement{\@syntaxElementEnd}{\@syntaxEntryCheck}}

\newcommand\@syntaxEntryCheck[1]{%
  \@syntaxEntryMake{\synbar #1}
  \@syntaxEntry
}
\newcommand\@syntaxEntryMake[1]{%
	& & #1 & \\
	}
\newcommand\@syntaxElementEnd[1]{
	\vspace*{-\bigskipamount}
	}
\makeatother


%--------------------------------------------------------------------------------------------------	
	
% Syntax Line
\makeatletter

\newcommand{\syntaxline}[1]{%
		#1 \@syntaxLineNext
}
\newcommand\@syntaxLineNext{\@ifnextchar\endsyntaxline{\@syntaxLineEnd}{\@syntaxLineCheck}}

\newcommand\@syntaxLineCheck[1]{%
  \@syntaxLineMake{#1}
  \@syntaxLineNext
}
\newcommand\@syntaxLineMake[1]{%
	\synbar #1
	}
\newcommand\@syntaxLineEnd[1]{}
\makeatother


%--------------------------------------------------------------------------------------------------	
	
% proof example

\makeatletter 

\newenvironment{proofexample}
    {
    \begin{minipage}{\textwidth}
    \tiny
    \begin{proofBox}{white}{black}
    }
    {
    \end{proofBox}
    \end{minipage}
    }
    
\newcommand{\leadstoUp}{\leadsto\!\!\succ}

\newcommand\hoareEx[3]{\noindent\{\ \texttt{#1}\ \}\\ \hspace*{5pt} \texttt{#2} \\ \hspace*{5pt} \{\ \texttt{#3}\ \}}
\newcommand\onlyIfEx[3]{\blue{from} \noindent\texttt{#1}\\ \hspace*{5pt} \blue{to} \texttt{#2} \\ \hspace*{5pt} \blue{onlyIf} \texttt{#3}}
\newcommand\onlyIfExAlt[3]{\blue{from} \noindent\texttt{#1}\\ \hspace*{5pt} \blue{to} \texttt{#2}  \hspace*{5pt} \blue{onlyIf} \texttt{#3}}
\newcommand\onlyIfSingleEx[3]{\blue{from} \noindent\texttt{#1}\\ \hspace*{5pt} \blue{next} \texttt{#2} \\ \hspace*{5pt} \blue{onlyIf} \texttt{#3}}
\newcommand\onlyIfSingleExAlt[3]{\blue{from} \noindent\texttt{#1}\\ \hspace*{5pt} \blue{next} \texttt{#2} \hspace*{5pt} \blue{onlyIf} \texttt{#3}}
\newcommand\onlyThroughEx[3]{\blue{from} \noindent\texttt{#1}\\ \hspace*{5pt} \blue{to} \texttt{#2} \\ \hspace*{5pt} \blue{onlyThrough} \texttt{#3}}
\newcommand\onlyThroughExAlt[3]{\blue{from} \noindent\texttt{#1}\\ \hspace*{5pt} \blue{to} \texttt{#2}  \hspace*{5pt} \blue{onlyThrough} \texttt{#3}}
\newcommand\case[2]{\textbf{Case #1:}\\ #2}

\newcommand{\proofstepwithrule}[2]{
	\begin{minipage}{0.75\textwidth}
		\hrulefill\\
		#1 \\
		\vspace{-1mm}
	\end{minipage} \hfill
	\begin{minipage}{0.2\textwidth}
		#2
	\end{minipage}	
}

\newcommand{\inferruleSD}[3]{
	\begin{array}{c}
		\strut \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ {{\mbox{#1}}}
		\\
		#2 \\
		\hline
		#3
	\end{array}
	}


\newcommand{\proofsteps}[1]{%
			\vspace{-1.5mm}
			\textbf{#1}:\\
%			\begin{minipage}{0.70\textwidth}
%%				\fbox{
%					\begin{minipage}{\textwidth}
%						#2
%					\end{minipage}
%%					}
%			\end{minipage} \hfill
%			\begin{minipage}{0.25\textwidth}
%				\rightline{#3}
%			\end{minipage}
			\@proofStep
}


\newcommand{\atom}{atom\xspace}
\newcommand{\atoms}{atoms\xspace}  
\newcommand{\pushSymbol}{\, {\triangledown}\, }  % {\bigtriangledown}  
\newcommand{\pushSymbolL}  {\bigtriangledown}  
\newcommand{\popSymbol}{\, {\vartriangle}\, }  %{\bigtriangleup} 
\newcommand{\popSymbolL}{\bigtriangleup} 
\newcommand{\Pushes}[3] {\ensuremath{  \overline{#2} \pushSymbolL  #1}}
\newcommand{\Pop}[2] {\ensuremath{ #1 \popSymbolL  #2}}
\newcommand{\Pops}[3] {\ensuremath{ #1,   \overline{#2} \popSymbolL  #3}}
\newcommand{\va}{\ensuremath{\upsilon}}
\newcommand{\PushA}[4] {\ensuremath{   {\overline{#3}} \vdash #2 \pushSymbol  #4  }}
\newcommand{\PushALong}[4] {\ensuremath{     {#3} \vdash #2  \pushSymbol  #4  }}
\newcommand{\PopA}[2]{  #1   \popSymbol #2}
\newcommand{\PopAA}[3]{ \PopA {#2} {#3}}
\newcommand{\footnoteSD}[1]{} % ignore for the time being

 %\newcommand{\PushAS}[2] {\ensuremath{ \overline{#1} \pushSymbol  #2}} % for assertionbs
%\newcommand{\PushASLong}[2] {\ensuremath{  #1  \pushSymbol #2}}
%\newcommand{\PushS}[2] {\ensuremath{ \overline{#1} \pushSymbol  #2}} % for states
%\newcommand{\PushSLong}[2] {\ensuremath{  #1  \pushSymbol #2}}
%\newcommand{\PopAS}[2] {\ensuremath{  \overline{#1}   \popSymbol #2}} % for assertionbs
%\newcommand{\PopASLong}[2] {\ensuremath{ #1   \popSymbol #2}}
%\newcommand{\PopS}[2] {\ensuremath{  \overline{#1}   \popSymbol #2}} % for states
%\newcommand{\PopSLong}[2] {\ensuremath{ #1   \popSymbol #2}}

% Same as above but reversed the order
\newcommand{\PushAS}[2] {\ensuremath{ {#2} \pushSymbolL   \overline{#1} }} % for assertionbs
\newcommand{\PushASLong}[2] {\ensuremath{  #2  \pushSymbolL #1}}
\newcommand{\PushS}[2] {\ensuremath{ \ {#2} \pushSymbol   \overline{#1} }} % for states
\newcommand{\PushSLong}[2] {\ensuremath{  #2  \pushSymbol #1}}
\newcommand{\PopAS}[2] {\ensuremath{   {#2}   \popSymbol \overline{#1} }} % for assertionbs
\newcommand{\PopASLong}[2] {\ensuremath{ #2   \popSymbol #1}}
\newcommand{\PopS}[2] {\ensuremath{   {#2}   \popSymbol  \overline{#1} }} % for states
\newcommand{\PopSLong}[2] {\ensuremath{ #2   \popSymbol #1}}


\renewcommand{\PopA}[3]{\ensuremath{#1}\vdash {#2}  \popSymbol {#3}}
\renewcommand{\PopAA}[3]{ \PopA {#1} {#2} {#3}}
\renewcommand{\preserve}[4]{ {#1},{#2}\vdash {#3} \triangleright {#4}}

\newcommand\@proofStep{\@ifnextchar\endproofsteps{\@proofstepEnd}{\@proofStepCheck}}

\newcommand\@proofStepCheck[1]{%
  \@proofStepMake{#1}
  \@proofStep 
}

\newcommand\@proofStepMake[1]{%
		#1 \\
	}
\newcommand\@proofstepEnd[1]{\vspace{-3mm}}

\makeatother
