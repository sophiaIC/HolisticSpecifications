

\section{The problem and our approach}
\label{s:outline}
 
In this Section we introduce our problem and outline our approach. 
 We build on, and expand the  example as in OOSPLA-22 and FASE. .. but note that we solve one more challenge than they, and that out approach is different.
%the \Nec specs (\S \ref{s:bankSpecEx}),
%   outline how we model the open world (\S\ref{s:concepts}), 
%give the main ideas of our proof system (\S\ref{s:approach})
%and   outline 
%how we use it to reason 
%about adherence to \Nec specifications  (\S\ref{s:all:outline:proof}).
 

 \subsection{Capabilities, and Emergent Behaviour} % of modules}
\label{s:bank}
Our example will demonstrate the need to consider the \emph{emergent behaviour} of modules. 
We will see three versions of a banking module, $\ModA$, $\ModB$, and $\ModC$.
All three modules allow withdrawal of  money only when supplied with the password of the account.
Moreover, in $\ModA$ the password is immutable, in $\ModB$ it is unconditionally mutable, while in $\ModC$ the password may be modified but only if supplied with the old password. 
Therefore, $\ModA$ and $\ModC$ are robust modules, while  $\ModB$ is not.

\noindent
\sdN{This example demonstrates the two concepts which are key in OCAP-based code:
\begin{description}
\item[Capabilities] What are the capabilities (here the password), what effects do the capabilities enable (here reduction of the money in an account), 
and who may eventually have access to the capability.
\item[Emergent Behaviour] What effects may become possible through the interplay of several methods from a module (here in $\ModC$, an external object which has no access to the password may modify the password, and then withdraw the money).
\end{description}}



%\fbox{\parbox{5.5in}{{\textbf{1st Challenge} We are looking for a specification language that expresses eventual access to capabilties, as well as the the emergent behaviour of modules.}}}% [14cm]{text in the box}}

\vspace{.1cm}

In the remainder of this subsection we   explain the example in some more detail:
We assume a  small, object oriented language with modules, with module-private fields
(readable/writeable only from other methods declared in the same module),  
and unforgeable and un-enumerable addresses.
Classes have a default constructor, which implicitly initializes all fields \sdN{of class type}  with the \prg{null} value,
\sdN{and all fields of \prg{int} type to \prg{0}}.
\sdN{Methods are module-private, unless defined as \prg{public} -- in this case they may be called by objects which do not belong to the same package, after dynamically checking that the types of the arguments correspond to the formal parameter types.}
   


\sdN{%We give three versions of a module which implements bank accounts. All three versions support the creation of accounts, and transfer of funds provided the correct password has been supplied. They only differ in the ability to modify the password. All three versions consists of an 
$\ModA$ consists of an empty class  \prg{Password} where each instance models a unique password}, and an \prg{Account} class with fields  password and  balance, an \prg{init} method to initialize the password, and  a \prg{transfer} method. 
An \prg{Account} is created with its \prg{balance} set to \prg{0}, and its password set to \prg{null}, \eg by executing \prg{acc = new Account}.
 After that, the password can be set to a new value,  \eg \prg{p=new Password;} \prg{acc.init(p);}. 
It is impossible to modify the  non-\prg{null} password of an account, and thus once a password has been set, the account cannot be ``tampered'' with, unless the password has been supplied.
 

%
% (Note that we assume private fields are accessible ``class-wide''.)
%
% (methods may read and write fields of any instance of a class)
%
%and that passwords are unforgeable and not enumerable (again as
%in Java, albeit without reflection).
%
% 


\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModA$        
  class Password
  
  class Account
    field balance:int 
    field pwd: Password
    public method transfer(dest:Account, pwd':Password) -> void
      if this.pwd==pwd'
        this.balance-=100
        dest.balance+=100
     public method init(pwd':Password) -> void
      if this.pwd==null
        this.pwd=pwd'
\end{lstlisting}
%
\noindent 
%We can capture the intended semantics of   \prg{transfer}  
%through  {a}  \funcSpec with pre- and post- conditions and \prg{MODIFIES} clauses as \emph{e.g.,} in \citeauthor{Leavens-etal07,dafny13}.
%The implementation of  \prg{transfer} in module  $\ModA$ meets
%this specification.
%
%\begin{lstlisting}[mathescape=true, frame=lines, language=Chainmail]
%$\Sclassic$  $\triangleq$
%   method transfer(dest:Account, pwd':Password) -> void  
%      ENSURES:
%            this.pwd$=$pwd' $\wedge$ this$\neq$dest  $\longrightarrow$  
%            this.balance$_{post} =$this.balance$_{pre}$-100 $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$+100
%      ENSURES:
%            this.pwd$\neq$pwd' $\vee$ this$=$dest  $\longrightarrow$ 
%            this.balance$_{post} =$this.balance$_{pre}$ $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$ 
%      MODIFIES:  this.balance, dest.balance        
%\end{lstlisting}
 
 \vspace{.1cm}
 
Now consider  module \ModB which allows any client to reset an account's password at any time, and \ModC which requires the existing password in order to change it.
  
  

\begin{tabular}{lll}
\begin{minipage}[b]{0.42\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModB$
  class Password
  
   class Account
    field balance:int 
    field pwd: Password 
    method transfer(..) ...
      ... as earlier ...
    public method init(...) ...
       ... as earlier ...
    public method set(pwd': Password)
      this.pwd=pwd'
\end{lstlisting}
\end{minipage}
&\ \ \  \ \   &%
\begin{minipage}[b]{0.45\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModC$
  class Password

  class Account
    field balance:int 
    field pwd: Password 
    public method transfer(..) 
      ... as earlier ...

   
    public method set(pwd',pwd'': Password)
      if (this.pwd==pwd') 
        this.pwd=pwd''
\end{lstlisting}
\end{minipage} 
\end{tabular}

\noindent
Although the \prg{transfer} method is the same in
all three modules, alternatives, % and each one satisfies \Sclassic,
code  {such as}
\\ 
$\ \strut \hspace{.2in} $ \prg{p=new Password;  acc.set(42); acc.transfer(rogue\_account,42)} 
\\ 
is enough to drain  \prg{acc} in \ModB without knowing the password.\footnote{CAREFUL: we had 
$\ \strut \hspace{.01in} $ \prg{an\_account.set(42); an\_account.transfer(rogue\_account,42)} but this was type incorrect!}
%
%This example demonstrates that we need to consider the 
\emph{Emergent behaviour} is key here: 
Even though the method \prg{transfer} in  \ModB is ``safe'' when considered in isolation, it is not safe when considered in conjunction with other methods from the same module. 
% We are therefore looking for a way to specify modules' emergent behaviour,  


\subsection{1st Challenge: Specifications for  Capabilities, and Emergent Behaviour}
\label{s:approach:necopers}

We need  a specification language that allows us to write a specification that rules out \ModB while permitting \ModA and
\ModC.  

For this we introduce two new ingredients into classic one-state assertions, and revisit and update the well-known concept of two state invariants. TODO-cite-s.\

The new ingredients are 1) the distinction between internal and external objects, and the concept of protection. TODO-explain both.
The two-state invatiants, ... explain.
Note that OOPLSA-22 instead uses    necessity operators, while mentioned in  \S \ref{intro:this:work}. 

 


 % \subsection{Bank Account -- the right specification}
\label{s:bankSpecEx}

We now {return to our quest for} a specification that rules out \ModB while permitting \ModA and
\ModC. 
%The catch is that the vulnerability present in \ModB is the result
%of  \emph{emergent} behaviour from the interactions of the \prg{set}
%and \prg{transfer} methods --- even though \ModC also has a
%\prg{set} method, it does not exhibit the unwanted interaction.
%This is exactly where a necessary condition can help:
%we want to avoid transferring money
%(or more generally, reducing an account's balance)
%\textit{without} the existing account password.  Phrasing the same condition
%the other way around % gives us a positive statement that still
%rules out the theft: that money \textit{can only} be
%transferred when the account's password is known.


In \Nec  syntax, and {recalling \S \ref{intro:this:work}, and \ref{s:approach:necopers},}
 
 \begin{tabular}{lcll}
$S_1$   &     $\triangleq$   & $\OneStateQ{\prg{a}:\prg{Account} } {\inside{\prg{a.password}}} $
 \\
 $S_2$   & $\triangleq$   &  $\TwoStatesQ {\prg{a}:\prg{Account}}  {\inside{\prg{a.password}}} {\inside{\prg{a.password}}}$
 \\
$S_3$ & $\triangleq$   &
  $\forall \prg{a}:\prg{Account},\prg{b}:\prg{int}.$\\
  &  &  $\FirstState{\inside{\prg{a.password}} \wedge \prg{a.balance}=\prg{b}} 
\  \SecondState{ \prg{a.balance}\geq \prg{b} }$
 \end{tabular}



 $S_1$ is not satisfied by any of the modules.
 $S_2$ is satisfied by ...  and ... 
 $S_3$ ....
 
 
%{\SrobustA does not fit the bill: all three modules   satisfy  it.
% % \SrobustA;  this demonstrates that \SrobustA is not strong enough. 
% But  \SrobustB does fit the bill: \ModA and \ModC satisfy \SrobustB, while \ModB does not.}
% 
%A critical point of \SrobustB % this \Nec specification 
%is that it is
%expressed in terms of observable effects (the account's balance is
%reduced: \prg{a.balance < bal}) and the shape of the heap 
%(external access to the password:
%$\external{\prg{o}}\ \wedge\ \access{\prg{o}}{\prg{a.pwd}}$) 
%rather than in terms of individual methods such as
%\prg{set} and \prg{transfer}.
%This gives our specifications the
%vital advantage that they can be used to constrain
%\jm[typo]{\textit{implementations}} of a bank account with a balance and a
%password, irrespective of the API it
%offers, the services it exports, or the dependencies on other parts of
%the system.
%
% This example also demonstrates that 
%adherence to   \Nec specifications is not monotonic:
%adding a method to a module does not necessarily preserve adherence to
%a specification, 
%and while separate methods may adhere to a  specification, their combination does
%not necessarily do so. 
%{For example, \ModA satisfies \SrobustB, while \ModB does not.}
%This is why we say that \Nec   specifications capture a module's \emph{emergent behaviour}. 
 

%\jm[TODO: in the proof later we need to mention that there is a difference between the overall proof (no mention of the methods), and the intermediate ones (that do mention the methods)]{}
\subsection{Reasoning about external calls}
\label{sec:how}

bla bla nbla .....

%{One might think that \SrobustB was not useful: normally, there will exist somewhere in the heap
%at least one external object  
%with access to the password --  if no such object existed, then \sdN{nobody} would be able to use the money of
%the account.
%And if such an object did exist, \sdN{then the premise of \SrobustB would not hold, and thus}
%the guarantee given by \SrobustB might seem vacuous.}
%
%{
%This is \emph{not} so: %there may exist  
%\sdN{in scopes   from which such external objects with access to the password
%are not (transitively) reachable, % . In such scopes,
%\SrobustB  guarantees that the balance of the account will not decrease.
%}
%We illustrate this through the following  code snippet:
 

\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{1}$
    class Account 
        ... as in $\ModB$ ...
        
    class Password
    
    class Payments
       field acc1, acc2: Account
       field pwd1, pwd2: Password
       
       method intialize( )
           acc1 := new Account
           acc1.set(pwd1);
           acc2.set(pwd2)
           acc1.balance := 200;
           acc2.balance := 300;
          
       method safe(untrusted:Object)
             acc1.transfer(acc2,pwd2);
             untrusted.payme(acc2);     // can only increase the balance of acc2

\end{lstlisting}
 
 
 Here we make an external call --    
 
 ?? Make a version where the classes Account and Password are encapsulated?

%{The method \prg{cautious} has as  argument an external object \prg{untrusted}, of unknown provenance.
%{It} creates a new \prg{Account} and initializes its password. 
%In the scope of  this method,  external objects with access to the password are reachable:
%thus,  during execution of  line 7, or   line {9} the balance may decrease.
%}
%
%{Assume that class \prg{Account} is from a module which satisfies \SrobustB. 
%Assume also that the code in line 7 does not leak the password to \prg{untrusted}. Then no external object
%reachable from the scope of execution of \prg{make\_payment} at line 8 has access to the password.
%Therefore, 
%even though we are calling   an untrusted object, \SrobustB guarantees that \prg{untrusted}
% will not be able to take any money out of  \prg{a}.
% }
% 
%\jm[]{
%A  proof sketch of the  safety provided by \SrobustB appears in Appendix \ref{app:safety}.
%}
%\sdN{Note that in this example, we have (at least) three modules: the internal module 
%which defies class \prg{Account} adhering to  \SrobustB, the  
%external module $\ModParam{1}$, and the external module which contains the class definition for \prg{untrusted}.
%Our methodology allows the external module, $\ModParam{1}$ to reason about its own code, and thus 
%pass \prg{a} to code from the second external module, without fear of losing money.}
%\sdN{In further work we want to make such arguments more generally applicable, and 
%extend Hoare logics to encompass such proof steps.}
%%\susan[I think this paragraph doesn't add, if anything it has a hostage to fortune. I would just remove it.
%% The purpose of the current paper is being able to express specifications like \SrobustB, and
%%and being able to prove adherence. In further work we want to develop logics to leverage such specifications, putting
%%informal arguments as the  one of this section onto formal foundations.
 
 and then a variant
 
 \begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{2}$
    class Account 
        ... as in $\ModB$ ...
        
    class Password
    
    class Payments
          
       method cautious(acc:Account, untrusted:Object)
       // PRE $\protectedFrom {\prg{a.p[assword}} {\prg{untrusted}}$
       untrusted.payme(acc2);   // can only increase the balance of acc2
        ...
\end{lstlisting}

TODO: There should be some code before \prg{acc1.transfer(acc2,..}
 
\subsection{Internal and external modules, objects, and calls}
\label{s:concepts}

%Our work concentrates on guarantees made in an \emph{open} setting; that is, a given module
%$M$ must be programmed so that 
%execution of $M$ together with \emph{any} \externalM 
%module $M'$ will uphold these guarantees. In the tradition of
%visible states semantics, we are  only interested in upholding the guarantees while 
%$M'$, the  \emph{\externalM} module, is executing. A module can
%temporarily break its own invariants,
%so long as the broken invariants are never visible externally.
%   
%We therefore distinguish between  \emph{\internalO}
%objects --- instances of classes defined in $M$ ---
%and \emph{\externalO} objects defined in any other module.
%We also distinguish between
%  \emph{\internalC} calls  (from either an internal or an external object)  made % from \externalO objects
% to \internalO objects and \emph{\externalC} calls made % from \externalC objects
% to \externalC objects. 
%{Looking at the code snippet from \S \ref{sec:how}, the call to \prg{set} on line 6 is an 
% internal call, while the call to \prg{make\_payment} is an external call -- from the external 
% object  \prg{this}  to the external object \prg{untrusted}.}
% 
% % We are less
%% interested in calls made from \internalO objects to \internalO objects, because we only need 
%% establish the guarantees when the \externalM module is executing. And we 
%%
%%
%Because we only require guarantees while 
%the  \externalM module  is executing,
%we develop an \emph{external states} semantics, where
% any internal calls are executed in one, large, step.
%With external steps semantics,  the executing object (\prg{this}) is always   external. 
%  In line  with other work in the literature \cite{Permenev, Grossman, Albert}, we currently forbid 
%  calls from internal to  external objects
%  -- further details on call-backs in \S\ref{s:related}. 
%
%{For the purposes of the current work we are only interested in one internal, and one external module.
%But the interested reader might ask: what if there is more than one external module?
%The answer is that from the internal module's viewpoint, all external modules are considered as one;
%for this we provide a module linking operator with  the expected semantics -- more details in Def. \ref{def:pair-reduce} and \S \ref{app:loo}. 
%But from the external module's viewpoint, there may be more than one external module: for example, in \S \ref{sec:how}, 
%module $\ModParam{1}$ is external to the module   implementing class \prg{Account}, and the module 
%implementing the class of \prg{untrusted} is external to
%$\ModParam{1}$.
%}

%\section{Encapsulation}
%\label{s:outline:encapsulation}
%\jm[]{\Nec depends upon the encapsulation of data, or more
%specifically the encapsulation of assertions about encapsulated 
%data. We say that an assertion $A$ is encapsulated by module $M$ if $A$ may only
%be invalidated through computation internal to $M$. 
%For example, the assertion \prg{a:Account $\wedge$ a.pwd = p} is
%encapsulated by \ModA (along with \ModB and \ModC) as 
%it requires a write to \prg{a.pwd} and thus may only be invalidated 
%by a call to a method belonging to \ModA.
%}
%
%\jm[]{
%Encapsulation is a topic that is well covered in the literature,
%and as such we build upon that existing work to derive these
%encapsulation guarantees. For the purposes of the examples in this
%paper we define a simple system inspired by confinement types~\cite{confined}, 
%but \Nec could just as easily be 
%}

\subsection{Our Contributions}

Our contributions are

\begin{enumerate}
\item
A new capability operator, $\protectedFrom {x} {y}$ 
\item
A new specification languages for emergent behaviour and
\item
A Hoare logic extension, which handles external calls
\item
A logic which proves adherence to out 
\end{enumerate}

 
