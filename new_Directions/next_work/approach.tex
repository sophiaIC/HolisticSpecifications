

\section{The problem and our approach}
\label{s:outline}
  
In this Section we introduce our problem  through an example and outline our approach.

   \subsubsection{Object Capabilities and Emergent Behaviour} % of modules}
\label{s:bank}
% In Sect.  \ref{s:approach:necopers} 
We \sdN{build}  on an example from \cite{XXXELang,FASE},  
to demonstrate  object capabilities as \emph{guards}, and the role of
  \emph{emergent behaviour}, \sd{and}
 then expand it %to also support 
 \sdN{with} calls from an internal to an external module.
%
We show three versions of a banking module, $\ModA$, $\ModB$, and $\ModC$. 
All three modules  {use the same method to} allow the withdrawal of money, only when supplied with the password of the account.
Moreover, in $\ModA$ the password is immutable, in $\ModB$ it is unconditionally mutable, while in $\ModC$ the password may be modified, but only if supplied with the old password. 


{Thus, in all three modules, the password is an object capability which \emph{enables} the withdrawal of the money. 
Moreover, in $\ModA$ and $\ModC$, the password also \emph{guards} the money.
Crucially however,  in $\ModB$ the password \emph{does not guard} the money. 
Using $\ModB$, it is possible to start in a state where the account's password is unknown, modify the password, and then withdraw the money. 
 This is not possible  in $\ModA$ and $\ModC$.
}

\emph{Guarding} is the crucial expectation that comes with object capabilities.
\footnoteSD{SAY THIS BETTER?} 
Hoare logics support the specification of    enabling of effects (through per-method PRE/POST-condition pairs), but not of guarding of effects.
The latter % specification of capabilities as guards 
requires per-module guarantees, as proposed, \eg,  in \cite{OOPSLA22}, and in also the current work.
\footnoteSD{BOLD! Birkedahl and Dreyer might scream!}
%
% \vspace{.1cm}
\noindent
Crucial for such specifications are  two key concepts:
\begin{description}
\item[Capabilities] What are the capabilities (here the password), what effects do the capabilities {guard} (here the money), 
and who is guaranteed not to obtain access to the capabilities.
\item[Emergent Behaviour] What effects may become possible through the interplay of several methods from a module  (here in ${\ModB}$  
{changing the password and then withdrawing}).
\end{description} 

\noindent
In this paper we address the following challenges:
\begin{description}
\item[1st Challenge -- Specification of Object Capabilities as Guards] How to specify that object capabilities are guards over effects while taking emergent behaviour into account?
\item[2nd Challenge -- Reasoning about external calls] How to verify that calls to external, unknown code, will not cause effects they are  ``not entitled'' to?
\item[3rd Challenge -- Verification of a module's adherence to its Specification] How to verify that modules adhere to their specifications?
\end{description}


\noindent In the remainder of this Section % Sections \ref{s:approach:necopers}, \ref{sec:how}, and \ref{sec:howThird} 
 we give a high level overview of our solution to these challenges.
But before doing that, we make the example more concrete. % and discuss internal/external modules.

 \subsubsection{Example} % \susan{\cancel{more Concretely}}}
\sdN{We work with} a  small, object oriented, class-based  language similar to Joe-E \cite{JoeE} with modules,   module-private fields
(\sdN{accessible} only from   methods \sdN{from} the same module),  
and unforgeable and un-enumerable addresses.
Classes have an \sdN{implicit} constructor, which   initializes all fields \sdN{with appropriate default values}.
%  {of class type}  with the \prg{null} value,
% {and all fields of \prg{int} type to \prg{0}}.
{\prg{Private} methods  \sdN{may be} called by objects of the same module,  while \prg{public}  methods  may be called by \emph{any} objects % which do not belong to the same module, 
% after dynamically checking that the 
\sdN{provided the dynamic types of the arguments are the same as} the formal parameter types.}
 \footnote{As in Joe-E, we leverage  module-based privacy to restrict propagation of capabilities, and reduce the need for reference monitors etc, \cf Sect 3 in  \cite{JoeE}.}   


{%We give three versions of a module which implements bank accounts. All three versions support the creation of accounts, and transfer of funds provided the correct password has been supplied. They only differ in the ability to modify the password. All three versions consists of an 
$\ModA$ consists of an empty class  \prg{Password} whose instances model  unique passwords}, and an \prg{Account} class with fields  \password~and  \balance, a \prg{set} method to initialize the password, and  a \prg{transfer} method. 
An \prg{Account} is created with its \balance~set to \prg{0}, and its \password~set to \prg{null}, \eg by executing \prg{acc = new Account}.
 After that, the password can be set to a new value,  \eg\,  \prg{p=new Password;} \prg{acc.set(p)}. 
It is impossible to modify the  non-\prg{null} password of an account, and thus, once a password has been set, the account's  {balance} {can be reduced only 
by parties with access to the account's password.}
%cannot be ``tampered'' with, unless the password has been supplied.
 

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModA$        
  class Password
  
  class Account
    field blnce:int 
    field pwd: Password
    public method transfer(dest:Account, pwd':Password, amt:int) -> void
      if this.pwd==pwd'
        this.blnce-=amt
        dest.blnce+=amt
     public method set(pwd':Password) -> void
      if this.pwd==null
        this.pwd=pwd'
\end{lstlisting}
%
\noindent 
%We can capture the intended semantics of   \prg{transfer}  
%through  {a}  \funcSpec with pre- and post- conditions and \prg{MODIFIES} clauses as \emph{e.g.,} in \citeauthor{Leavens-etal07,dafny13}.
%The implementation of  \prg{transfer} in module  $\ModA$ meets
%this specification.
%
%\begin{lstlisting}[mathescape=true, frame=lines, language=Chainmail]
%$\Sclassic$  $\triangleq$
%   method transfer(dest:Account, pwd':Password) -> void  
%      ENSURES:
%            this.pwd$=$pwd' $\wedge$ this$\neq$dest  $\longrightarrow$  
%            this.balance$_{post} =$this.balance$_{pre}$-100 $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$+100
%      ENSURES:
%            this.pwd$\neq$pwd' $\vee$ this$=$dest  $\longrightarrow$ 
%            this.balance$_{post} =$this.balance$_{pre}$ $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$ 
%      MODIFIES:  this.balance, dest.balance        
%\end{lstlisting}
 
%  \vspace{.1cm}
 
Now consider  module \ModB, which allows any client to reset an account's password at any time.  \ModC, on the other hand  requires the existing password in order to change it.
  
  

\begin{tabular}{lll}
\begin{minipage}[b]{0.42\textwidth}
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModB$
  class Password
  
   class Account
    field blnce:int 
    field pwd: Password 
    public method transfer(..) ...
      ... as earlier ...
     public method set(pwd': Password)
      this.pwd=pwd'
      $\ \ \ $
\end{lstlisting}
\end{minipage}
&\ \ \  \ \   &%
\begin{minipage}[b]{0.45\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModC$
  class Password

  class Account
    field blnce :int 
    field pwd: Password 
    public method transfer(..) 
      ... as earlier ...
    public method set(pwd',pwd'': Password)
      if (this.pwd==pwd') 
        this.pwd=pwd''
\end{lstlisting}
\end{minipage} 
\end{tabular}

\noindent
Although the \prg{transfer} method is the same in
all three modules,   % and each one satisfies \Sclassic,
code  {such as}
\\ 
$\ \strut \hspace{.2in} $ \prg{p=new Password;  acc.set(p); acc.transfer(rogue\_accnt,p,1000)} 
\\ 
is enough to drain  \prg{acc} in \ModB without knowing the password.\footnoteSD{CAREFUL: we had 
$\ \strut \hspace{.01in} $ \prg{an\_account.set(42); an\_account.transfer(rogue\_accnt,42)} but this was type incorrect!}
%
%This example demonstrates that we need to consider the 
\emph{Emergent behaviour} is key here: 
Even though the method \prg{transfer} in  \ModB is ``safe'' when considered in isolation, it is not safe when considered in conjunction with other methods from the same module. 
% We are therefore looking for a way to specify modules' emergent behaviour,  
%\susan{Do you want to say something about not possible to capture emergent behaviour using Hoare logic pre/post conditions that hold for individual methods? 
%{Good idea! I did it earlier on; Does it work?}}
   
\subsubsection{Internal and external modules, objects, and states}
 \label{s:concepts}

We are concerned with guarantees made in an \emph{open} setting; that is, a given module
$M$ must be programmed so that 
execution of $M$ together with \emph{any} number of external modules $\overline M$
will uphold these guarantees. % In the tradition of
%visible states semantics, we are  only interested in 
These guarantees must be upheld while 
 $\overline M$, the  \emph{\externalM} modules, are executing; in contrast, the internal module may 
temporarily break them,
so long as they %are it 
hold {upon entry to external modules.}\footnoteSD{Not quite true. How improve?} 
 
    
We therefore distinguish between  \emph{\internalO}
objects --- instances of classes defined in $M$ ---
and \emph{\externalO} objects defined in any other module.
We also distinguish between
  \emph{\internalC} and   \emph{\externalC} states - those whose receiver is internal or external respectively. 
 
  % % from \externalC objects
%  to \externalC objects. 
%{Looking at the code snippet from \S \ref{sec:how}, the call to \prg{set} on line 6 is an 
% internal call, while the call to \prg{make\_payment} is an external call -- from the external 
% object  \prg{this}  to the external object \prg{untrusted}.}
 
% % We are less
%% interested in calls made from \internalO objects to \internalO objects, because we only need 
%% establish the guarantees when the \externalM module is executing. And we 
%%
%%
%Because we only require guarantees while 
%the  \externalM module  is executing,
%we develop an \emph{external states} semantics, where
% any internal calls are executed in one, large, step.
%With external steps semantics,  the executing object (\prg{this}) is always   external. 
%  In line  with other work in the literature \cite{Permenev, Grossman, Albert}, we currently forbid 
%  calls from internal to  external objects
%  -- further details on call-backs in \S\ref{s:related}. 
%
%{For the purposes of the current work we are only interested in one internal, and one external module.
%But the interested reader might ask: what if there is more than one external module?
%The answer is that from the internal module's viewpoint, all external modules are considered as one;
%for this we provide a module linking operator with  the expected semantics -- more details in Def. \ref{def:pair-reduce} and \S \ref{app:loo}. 
%But from the external module's viewpoint, there may be more than one external module: for example, in \S \ref{sec:how}, 
%module $\ModParam{1}$ is external to the module   implementing class \prg{Account}, and the module 
%implementing the class of \prg{untrusted} is external to
%$\ModParam{1}$.
%}




%\fbox{\parbox{5.5in}{{\textbf{1st Challenge} We are looking for a specification language that expresses eventual access to capabilties, as well as the the emergent behaviour of modules.}}}% [14cm]{text in the box}}

%\vspace{.1cm}



\subsection{First Challenge: Specifications of Object Capabilities as Guards}
\label{s:approach:necopers}

%\susan{it sounds like capabilities and emergent behaviour are
%different things, perhaps Specifications for Capabilities including
%Emergent behaviour - or something similar. {Any better now?}}

Our specifications should describe {which effects are guarded by which capabilities}. 
In particular, lack of access to {a capability  should} guarantee  that {the effect guarded by that capability cannot happen.}
  {These guarantees should hold  in the context of   emergent behaviour.}   
For this, we propose two %a specification language for modules, which has two main novel ingredients.
{novel concepts}:

 
\begin{description}
\item[Protection] describes a lack of access to capabilities: An object $o$ is \emph{protected} from $o'$, formally $\protectedFrom {o} {o'}$,  if $o$ cannot obtain direct access to $o'$ unless an internal object affords that access. %to $o$. 
And $o$ is \emph{protected}, formally ${\inside{\prg{\it{o}}}}$, if $o$ is protected from all external objects transitively accessible from the currently executing method call. More in Def. \ref{def:chainmail-protection-from}, and \ref{def:chainmail-protection}.

\item[{Scoped invariants}] describe emergent behaviour:  {$\TwoStatesN  {\overline{x:C}}  {A}$} expresses that if a 
% SD: drop reachable, as we not define it here, and it is not that fundamental, I think
\sdN{state} $\sigma$ 
  satisfies ${\overline{x:C}}  \wedge A$, then all $\sigma$'s \emph{scoped} future  states will  {also} satisfy  {$A$}. 
The scoped future contains future states, including further method calls and returns, but {does not return} from the call active in $\sigma$ --  \cf. Def  \ref{def:shallow:term}.
% SD removed the below because it seems to talk both about the meaning of  {$\TwoStatesN  {\overline{x:C}}  {A}$}  and scoped future.
% I was confused when I read it
% in other words, the current call \emph{scopes} where \se{$A$} must hold -- more in Def 3.1. 
\sdM{We} consider executions of the internal module linked with any number of unknown, external modules,
-- \cf Sect. \ref{sect:execution}.
 For $\sigma$ and its scoped future   we only consider external states -- \cf Def \ref{def:necessity-semantics}.

\end{description}

 

\forget{
\kjx{not clear why these are ``two-state'' invariants - rather than
  $1+N$ states? \red{SD: ``two-state'' does bot mean that the states are immediately consecutive. Can you propose a better name}}
\kjx{seems $\protectedFrom {o} {o'}$ means $\exists i intl : \textrm{dominatesAllPathsFrom}(o)\textrm{To}(o')$ or something;
ditto  ${\inside{\prg{\it{o}}}}$ means 
    $\exists i intl : \textrm{dominatesAllPathsFrom}(topOfStack)\textrm{To}(o')$.
Not that I'm biased or anything.
 \red{SD: cI do not think so. We are asking for the penultimate element in the path. For example, if there is a path 1->2->3->4, and 2 is internal, and 3 is external, than your definition would say  that 4 is protected from 1, but with the def as given here it is not.
 \blue{SD:If we reversed the arrows, then indeed we could say that $\protectedFrom {o} {o'}$ iff the \textbf{set} of internal objects dominates all \textbf{reversed} paths from $o$ to $o'$. 
 Woulds that be more easily understandable than the current definition?
}}}}
 
 
With these concepts we can now write specifications which  rule  out \ModB while permitting \ModA and
\ModC, namely:\\
%
\label{s:bankSpecEx}
%{
% \begin{tabular}{lcll}
%
$\strut\ \ \ \ \ S_1\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{a}}}  
% $ \\
% $\strut\ \ \ \ \
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \    S_2\ \  \triangleq \ \ \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.pwd}}} $
 \\
 $\strut\ \ \ \ \ S_3\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account},\prg{b}:\prg{int}}  {\inside{\prg{a}} \wedge \prg{a.\balance}=\prg{b}}  $
\\
$\strut\ \ \ \ \ S_4\ \  \triangleq \ \ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.pwd}} \wedge \prg{a.\balance} \geq \prg{b} } $
 
% \end{tabular}
%}

\noindent
\sdN{They}
%specifications
 give the following guarantees: \ \   $S_1$:\   accounts are not leaked, 
\ \  $S_2$:\    passwords are not leaked,
\ \  $S_3$:\  the balance is not modified unless there is unprotected access to the account,  %while 
\ \ $S_4$:\   the balance does not decrease unless there is unprotected access to the password. \ \ 
% \\
 All three modules satisfy $S_1$ and $S_3$. $\ModA$ and $\ModC$ also satisfy $S_2$ and $S_4$, but $\ModB$ satisfies neither $S_2$ nor $S_4$.
 
 

 \forget{\vspace{.1cm}
 
 \noindent
 \textbf{NOTES} \notesep  Our specifications are expressed in terms of observable effects (\eg the password stays protected, the account's balance may increase), rather than in terms of individual methods (\eg\, \prg{set} or \prg{transfer}).
{This % gives our specifications the the vital advantage that our specifications can % be used to constrain
implies that they can characterize  any 
module with bank accounts which have a % {\textit{implementation}} of a bank account with a 
 \balance~and a \password -- even as ghost fields --}, irrespective of the API offered, services  exported, or  dependencies on other parts of the system.\footnoteSD{does this come from OOPSLA? if so we need to rephrase}
\notesep
Adherence to   specifications is not monotonic:
\sdN{Eg, while  \ModA satisfies $S_4$, the addition of \prg{set} lead to \ModB, which does not.}
% Adding a method to a module does not necessarily preserve such adherence,
% \eg adding method \prg{set} in module \ModB breaks 
%SD removed the below. When we changed the invaraints to have the same assertion re and post it no longer hel
\forget{, and while separate methods may adhere to a  specification, their combination does
not necessarily do so. 
{For example, \ModB's  \prg{tansfer} and \prg{set} satisfy $S_4$, but their interplay does not.}
%In this sense, and, similar to OOPSLA'22, our  specifications capture a module's \emph{emergent behaviour}. 
}
}

 
\subsection{Second Challenge: Reasoning about external calls}
\label{sec:how}

{ 
The challenge when calling a method on an external object, is that we have no specification for that method. 
However, as argued in the intro\footnoteSD{we need to indeed argue that in the intro}, our  module's emergent behaviour  specification together with knowledge about 
parameters' lack of access to capabilities %may be used to guarantee that   in order to restrict the possible side-effects of the external call.
can give us the guarantee that  {specific} guarded effects will not take  place.
}

 
 
Assume that {our internal module included the following class} \prg{Shop}. It exports a public method \prg{buy} whose formal parameter \prg{buyer} is an \prg{external}   object  with a method { \prg{payMe}}.
  

\begin{lstlisting}
class Shop
  field accnt : Account
  field invntry :  Inventory    
  public method buy(buyer: external, anItem: Item) -> void
    int price = anItem.price
    int oldBlnce = this.accnt.blnce
    buyer.payMe(this.accnt, price)
    if (this.accnt.blnce == oldBlnce+price)
       this.send(buyer,anItem)
    else
       buyer.tell("you have not paid me") 
    public method send(buyer: external anItem: Item) -> void  
       ...            
\end{lstlisting}
 

The critical point is line 7, where we call the method  \prg{payMe} on \prg{buyer}, passing the shop's account as an argument.
As \prg{buyer} is an external object, we have no method specification for \prg{payMe}. 
How can we reason about this external call?
More worryingly, is it possible that the \prg{buyer} will use this opportunity  to drain the shop's account?
 
 
 \vspace{.1cm}
 {Nevertheless, the call \emph{is} safe!} If the \prg{Account} comes from a module satisfying $S_4$, and  at the point of the call to \prg{buy} -- \ie at line 4 -- the \password~was protected from the \prg{buyer}, then %it is guaranteed that
 after the external call -- \ie after line 7 --  the shop's account's balance will not have decreased.
 
 {Proving this introduces new challenges: We want to  establish something like the Hoare triple\\
$\strut \ \ \ \ \ \ \ \ \ \ \  \{\  \ {\protectedFrom {\prg{this.\myAccount.pwd}} {\prg{buyer}}\ \wedge\ {\prg{this.\myAccount.\balance}}=\prg{b}    }\ \  \}$\\
$\strut \ \ \ \ \ \ \ \ \ \ \   \ \ \ \ \ \ \ \ \ \ \ \ {\ \prg{buyer.payMe(this.accnt,price)}   \ } $\\
$\strut \ \ \ \ \ \ \ \ \ \ \  \{\  \ \  {\prg{this.\myAccount.\balance}} \geq  \prg{b} \  \  \}$ 
}
\\
 {%We want to use $S_4$. 
To apply $S_4$, we need to establish  ${\inside {\prg{this.\myAccount.pwd}}}$, and  $\prg{this.\myAccount.\balance}\geq\prg{b}$. 
The latter can be done through the rule of consequence. 
But what about the former? 
We only know that $\protectedFrom {\prg{this.\myAccount.pwd}} {\prg{buyer}}$, but   need the stronger property  ${\inside {\prg{this.\myAccount.pwd}}}$.}

 {While  \prg{this.\myAccount.pwd} is not protected in the context of \prg{buy}, it \emph{is} protected in the context of the execution of \prg{payMe}: 
This is so, because the   accessible objects in the execution of \prg{payMe} are those accessible from \prg{buyer}.
We define the operator $\pushSymbolAA$ on assertions, which   translates an assertion from the viewpoint of the callee, to that of the caller:
 $\PushAS y A$   guarantees that $A$ will hold when the values of variables $\overline y$ have been pushed onto a new frame. In particular,   $\PushAS y {(\inside \re)} =  \protectedFrom \re {\overline {y} }$ for any term  $\re$ -- \cf Def. \ref{def:push},  and Lemma \ref{lemma:push:ass:state},
}

 {Below we show a simplified version of a Hoare logic rule %\ruleExtCallB\ from
dealing with external calls -- \cf. Fig.\ref{f:external:calls} }
 
 $\inferruleNoName  
 	{ 
   	   {\TwoStatesN {\overline {x:D}} {A}}\ \   \mbox{is part of $M$'s specification}
        }
	{   \triple { \    { \external{y_0}} \,     \wedge \,  \overline{x:D}\  \wedge\  {\PushAS {y}{A}}\ }  
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \    {\PushAS {y}{A}}  \ }
						\  \  ...
         }
$

%  \ruleExtCallB\, is our Hoare logic rule from Fig. \ref{f:external:calls}, which when verifies line 7 through application of $S_4$.

 

\forget{
\vspace{.1cm}

  \noindent
 \textbf{NOTES}
%\susan{You've never said how a holistic spec is used.{Does the para above not use the holistic spec?}}
% \notesep We   applied $S_4$ at the point of call in line 7, even   though  
% the pre-state in $S_4$ requires % r  is  in terms 
% a \emph{stronger} property than the one we have.
% Namely,   $S_4$ requires   the \password~to be protected, while we only know 
%  that the \password~is protected from the  \prg{buyer}.
%It is safe to apply $S_4$,  because from the point of view of the callee at line 7 the \password~is indeed protected -- \cf Def. \ref{def:push},   Lemma \ref{lemma:push:ass:state}, and the 
%  Hoare logic rule \ruleExtCallB in Fig.\ref{f:external:calls}
%   \notesep  If at the point of call of \prg{buy} the  password was not protected from the \prg{buyer}, then, of course, no guarantee can be made about the account's balance.
 \notesep Requiring that the account's password was protected from all external objects would be far too strong; if that were the case, then the account would not be useful for any payments.
 \notesep Requiring that the account's  password was protected at the time of the call of \prg{buy} would also be far too strong: our module cannot impose restrictions on the callers' external state  upon the call to \prg{buy}.
 \notesep 
 We could specify the method \prg{buy} through the pre-condition $\protectedFrom {\prg{a.pwd}} {\prg{buyer}} \wedge {\prg{a.\myAccount.\balance}}=\prg{b}$ which
 guarantees that $\prg{a.\myAccount.\balance}\geq \prg{b}$.  Note that this is a  direct conclusion of $S_4$; 
  as \prg{Shop} is part of our internal module, this specification is superfluous -- more in Ex. \ref{example:mprepost}.\footnote{TODO need to re-introduce spec inference in the main text}
 }
 
 
 \subsection{Third Challenge: Proving that a module adheres to its specification}
 \label{sec:howThird}
 
As we said already,  specification $\TwoStatesN{\overline{x:C}}{A}$ promises that any external state $\sigma'$ reachable through scoped execution staring at some external state $\sigma$ satisfying $A$ will also satisfy $A$. 
If $\sigma$ is executing a call to a public method of the module, then the external state $\sigma'$ may be reachable after the termination of that method, but also through further external calls made within that method.
 
\Eg if $\sigma$ was an external state executing a call to \prg{Shop::buy}, then $\sigma'$ could be an external state reachable 
after the return from \prg{Shop::buy}, but could also be reachable
during execution of the external call \prg{payMe}.

This means that we are  interested in the states before and after a method (or statements), but  also  in the external states reachable during execution of that method (or statements).
To accommodate this, we extend   traditional Hoare triples to quadruples of the form\\
 $\strut \ \hspace{4cm} \quadruple {A} {\, stmt\, }{A'} {A''}$\\  
 % These promise 
 promising that terminating execution of $stmt$ in  states satisfying $A$  reach    finals state satisfying $A'$, and any intermediate external states reachable during execution of $stmt$ satisfy    $A''$ -- \cf Def. \ref{def:hoare:sem}.

\vspace{.1cm}

We assume a  Hoare logic of  triples, and define an embedding into our quadruples. 
We then extend it with substructural rules, rules talking about protection, internal and external calls, 
and the module's adherence to its 
specification - more in Figs. \ref{f:underly} -  \ref{f:calls}. % \ref{f:wf}.
The full form of  the  earlier % Hoare logic
 rule %\ruleExtCallB\ 
% from Fig.\ref{f:external:calls}
 is:
 
 $\inferruleNoName  
 	{ 
   	   {\TwoStatesN {\overline {x:D}} {A}}\ \   \mbox{is part of $M$'s specification}
        }
	{   \quadruple { \    { \external{y_0}} \,     \wedge \,  \overline{x:D}\  \wedge\  {\PushAS {y}{A}}\ }  
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \    {\PushAS {y}{A}}  \ }
						{\ A \ }
         }
$
 
 \vspace{.2cm}
A module is well-formed, if  its invariants are well-formed,  all  its public methods preserve each of its invariants, and  all its methods satisfy their specifications - \cf  Fig.  \ref{f:wf}.
%
An invariant is well-formed if % the constituent assertion 
it is \emph{encapsulated}, \ie can only be invalidated by code from that module -- \cf Def. \ref{d:encaps}. 
%For example, in \ModA the assertion  \prg{a.balance}$\geq$\prg{b} is encapsulated, but it would not be encapsulated 
%% in a module \ModD   implements balances through a third party, openly accessible ledger 
%if balances were in an external, openly modifiable ledger -- \cf Ex. \ref{ex:not:encaps}.
% 
A method preserves an assertion   if it preserves it across its pre- and post-states and also during any intermediate external state.

\Eg to prove satisfaction of $S\_1$ and $S\_3$ for method \prg{Shop::buy} we  need to prove:
\\
% {\footnotesize{
$\strut \ \ \ \ \ \ \ \ \ \ \ \quadruple {A_1  \wedge \inside{\prg{a}} } {\ stmt\_b  \ } {\inside{\prg{a}}} { \inside{\prg{a}}} $
\\
%$\strut \ \ \ \ \ \   \ \  \quadruple {A_1  \wedge  \inside{\prg{a.\password}} } {\  stmt\_buy  \  } {\inside{\prg{a.\password}}}  {\inside{\prg{a.\password}}}$
%\\
$\strut \ \ \ \ \ \  \ \  \ \ \   \quadruple {A_2  \wedge  \inside{\prg{a}} \wedge  \prg{a.\balance}\!=\!{\prg{b}} } {\   stmt\_b  \  } {\inside{\prg{a}} \wedge  \prg{a.\balance}\!=\!\prg{b}}   
                         {  \inside{\prg{a}} \wedge  \prg{a.\balance}\!=\!\prg{b} }$
%\\
%$\strut \ \ \ \ \ \   \ \   \quadruple {A_2  \wedge  \inside{\prg{a.\password}} \wedge  \prg{a.\balance}\!\geq\!{\prg{b}} } {\  stmt\_buy  \  } {\inside{\prg{a.\password}} \wedge  \prg{a.\balance}\!\geq\!{\prg{b}}}  
%   { \inside{\prg{a.\password}}\wedge  \prg{a.\balance}\!\geq\!{\prg{b} }}$
% }}
\\
and similar for $S\_2$ and $S\_4$. Here we used   $stmt\_b$  as short for the method body of \prg{buy}, and $A_1 \triangleq \prg{this}:\prg{Shop}, \prg{buyer}:\prg{external}, \prg{anItem}:\prg{Item} \wedge \prg{a}:\prg{Accounct}$
and $A_2 \triangleq A_1 \wedge \prg{b}:\prg{int}$.
 
Quadruples are also used in method specifications, \eg we specify \prg{transfer} through
\\
$\strut \ \ \ \ \ \  \ \  \ \ \  { \mprepostLongN {A_3}{\prg{public}\ \prg{Account}}{\prg{transfer}}{params}{A_4} {true} }$
\\
%where we used 
with shorthands 
$params \triangleq$ \prg{dest:Account}, \prg{pwd':Password}, \prg{amt:int}, and 
$A_3  \triangleq$  $\prg{pwd'}=\prg{this.\password} \wedge \prg{dest}\neq \prg{this}$
$\wedge\, b, b':\prg{int}$
$\, \wedge\, \prg{this.\balance}=b$ 
$\, \wedge\,  \prg{dest.\balance}=b'$, 
 and $A_4 \triangleq$  
 $\prg{this.\balance}=b-\prg{amt} \wedge \prg{dest.\balance}=b'+\prg{amt}$.
% To prove  -- chop to avoid line
For this specification, we need to prove\\
$\strut \ \ \ \ \ \ \ \ \ \ \ \quadruple {\ \prg{this}:\prg{Account}\, \wedge\, params\, \wedge\, A_3  \  } {\ stmt\_{tr}  \ } {A_4} { true} $
\\
where $stmt\_{tr}$ is short for the body of  \prg{transfer}.



\vspace{.1cm}
Our extension preserves soundness of the  Hoare logic --  \cf    Def. \ref{def:hoare:sem}, % and  proofs in 
and  Thms.  \ref{l:triples:sound}, \ref{t:quadruple:sound}, \ref{thm:soundness}.
 

\forget{Notice that while we are concerned with \emph{necessary conditions for effects}, we prove adherence to \emph{sufficient conditions which guarantee the absence of effects.}
We have therefore taken a similar path to .... TODO ...
}
\footnoteSD{Do we want to talk about the challenges in the proof, and the fact that we reason using sufficient but have necessary in mind.}
\forget{The proof that the extended Hoare logic is sound is interesting, because we are arguing about the soundness of two interrelated systems: 
 the per-statement  Hoare logic, as well as the {entire} module's logic.
Moreover, we need to cater for the possibility that external calls eventually call public methods of the module, which in their turn make external calls etc.
For this we define a new measure of execution ...}


 
 %Because we only require guarantees while 
%the  \externalM module  is executing,
%we develop an \emph{external states} semantics, where
% any internal calls are executed in one, large, step.
%With external steps semantics,  the executing object (\prg{this}) is always   external. 
%  In line  with other work in the literature \cite{Permenev, Grossman, Albert}, we currently forbid 
%  calls from internal to  external objects
%  -- further details on call-backs in \S\ref{s:related}. 
%
%{For the purposes of the current work we are only interested in one internal, and one external module.
%But the interested reader might ask: what if there is more than one external module?
%The answer is that from the internal module's viewpoint, all external modules are considered as one;
%for this we provide a module linking operator with  the expected semantics -- more details in Def. \ref{def:pair-reduce} and \S \ref{app:loo}. 
%But from the external module's viewpoint, there may be more than one external module: for example, in \S \ref{sec:how}, 
%module $\ModParam{1}$ is external to the module   implementing class \prg{Account}, and the module 
%implementing the class of \prg{untrusted} is external to
%$\ModParam{1}$.
%}

 

\subsection{Our Contributions}

Our contributions are

\begin{enumerate}
\item
New capability assertions, $\protectedFrom {x} {y}$  and $\inside{x}$ 
\item
A new specification language for emergent behaviour  
\item
The adaptation operator  $\PushAS y A$  applicable on assertions
\item
A Hoare logic extension, which handles external calls
\item
A logic which proves adherence to our specification language
\item
Proofs, and a worked out example
\end{enumerate}
