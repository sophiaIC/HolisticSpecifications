

\section{The problem and our approach}
\label{s:outline}
  
In this Section we introduce our problem  through an example and outline our approach.

   \subsubsection{Object Capabilities and Emergent Behaviour} % of modules}
\label{s:bank}
% In Sect.  \ref{s:approach:necopers} 
We demonstrate  object capabilities as \emph{guards}, and the role of
  \emph{emergent behaviour}, building on an example from \cite{OOPSLA22,FASE}, and 
 expanding it to also support calls from an internal to an external module.

We show three versions of a banking module, $\ModA$, $\ModB$, and $\ModC$. 
All three modules  {use the same method to} allow the withdrawal of money, only when supplied with the password of the account.
Moreover, in $\ModA$ the password is immutable, in $\ModB$ it is unconditionally mutable, while in $\ModC$ the password may be modified, but only if supplied with the old password. 


{Thus, in all three modules, the password is an object capability which \emph{enables} the withdrawal of the money. 
Moreover, in $\ModA$ and $\ModC$, the password also \emph{guards} the money.
Crucially however,  in $\ModB$ the password \emph{does not guard} the money. 
Using $\ModB$, it is possible to start in a state where the account's password is unknown, modify the password, and then withdraw the money. 
 This is not possible  in $\ModA$ and $\ModC$.
}

\emph{Guarding} is the crucial expectation that comes with object capabilities.\footnoteSD{SAY THIS BETTER?} 
Hoare logics support the specification of    enabling of effects (through per-method PRE/POST-condition pairs), but not of guarding of effects.
The latter % specification of capabilities as guards 
requires per-module guarantees, as proposed, \eg,  in \cite{OOPSLA22}, and in also the current work.
\footnoteSD{BOLD! Birkedahl and Dreyer might scream!}
%
% \vspace{.1cm}
\noindent
Crucial for such specifications are  two key concepts:
\begin{description}
\item[Capabilities] What are the capabilities (here the password), what effects do the capabilities {guard} (here the money), 
and who is guaranteed not to obtain access to the capabilities.
\item[Emergent Behaviour] What effects may become possible through the interplay of several methods from a module  (here in ${\ModB}$  
{changing the password and then withdrawing}).
\end{description} 

\noindent
In this paper we address the following challenges:
\begin{description}
\item[1st Challenge -- Specification of Object Capabilities as Guards] How to specify that object capabilities are guards over effects while taking emergent behaviour into account?
\item[2nd Challenge -- Reasoning about external calls] How to verify that calls to external, unknown code, will not cause effects they are  ``not entitled'' to?
\item[3rd Challenge -- Verification of a module's adherence to its Specification] How to verify that modules adhere to their specifications?
\end{description}


\noindent In the remainder of this Section % Sections \ref{s:approach:necopers}, \ref{sec:how}, and \ref{sec:howThird} 
 we give a high level overview of our solution to these challenges.
But before doing that, we make the example more concrete. % and discuss internal/external modules.

 \subsubsection{Example} % \susan{\cancel{more Concretely}}}
We assume a  small, object oriented language with modules, with module-private fields
(readable/writeable only from other methods declared in the same module),  
and unforgeable and un-enumerable addresses.
Classes have a default constructor, which implicitly initializes all fields {of class type}  with the \prg{null} value,
{and all fields of \prg{int} type to \prg{0}}.
{Methods are module-private, unless defined as \prg{public} -- in this case they may be called by objects which do not belong to the same module, after dynamically checking that the types of the arguments correspond to the formal parameter types.}
   


{%We give three versions of a module which implements bank accounts. All three versions support the creation of accounts, and transfer of funds provided the correct password has been supplied. They only differ in the ability to modify the password. All three versions consists of an 
$\ModA$ consists of an empty class  \prg{Password} whose instances model  unique passwords}, and an \prg{Account} class with fields  \password~and  \balance, a \prg{set} method to initialize the password, and  a \prg{transfer} method. 
An \prg{Account} is created with its \balance~set to \prg{0}, and its \password~set to \prg{null}, \eg by executing \prg{acc = new Account}.
 After that, the password can be set to a new value,  \eg\,  \prg{p=new Password;} \prg{acc.set(p)}. 
It is impossible to modify the  non-\prg{null} password of an account, and thus, once a password has been set, the account's  {balance} {can be reduced only 
by parties with access to the account's password.}
%cannot be ``tampered'' with, unless the password has been supplied.
 

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModA$        
  class Password
  
  class Account
    field blnce:int 
    field pwd: Password
    public method transfer(dest:Account, pwd':Password, amt:int) -> void
      if this.pwd==pwd'
        this.blnce-=amt
        dest.blnce+=amt
     public method set(pwd':Password) -> void
      if this.pwd==null
        this.pwd=pwd'
\end{lstlisting}
%
\noindent 
%We can capture the intended semantics of   \prg{transfer}  
%through  {a}  \funcSpec with pre- and post- conditions and \prg{MODIFIES} clauses as \emph{e.g.,} in \citeauthor{Leavens-etal07,dafny13}.
%The implementation of  \prg{transfer} in module  $\ModA$ meets
%this specification.
%
%\begin{lstlisting}[mathescape=true, frame=lines, language=Chainmail]
%$\Sclassic$  $\triangleq$
%   method transfer(dest:Account, pwd':Password) -> void  
%      ENSURES:
%            this.pwd$=$pwd' $\wedge$ this$\neq$dest  $\longrightarrow$  
%            this.balance$_{post} =$this.balance$_{pre}$-100 $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$+100
%      ENSURES:
%            this.pwd$\neq$pwd' $\vee$ this$=$dest  $\longrightarrow$ 
%            this.balance$_{post} =$this.balance$_{pre}$ $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$ 
%      MODIFIES:  this.balance, dest.balance        
%\end{lstlisting}
 
%  \vspace{.1cm}
 
Now consider  module \ModB, which allows any client to reset an account's password at any time.  \ModC, on the other hand  requires the existing password in order to change it.
  
  

\begin{tabular}{lll}
\begin{minipage}[b]{0.42\textwidth}
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModB$
  class Password
  
   class Account
    field blnce:int 
    field pwd: Password 
    public method transfer(..) ...
      ... as earlier ...
     public method set(pwd': Password)
      this.pwd=pwd'
      $\ \ \ $
\end{lstlisting}
\end{minipage}
&\ \ \  \ \   &%
\begin{minipage}[b]{0.45\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModC$
  class Password

  class Account
    field blnce :int 
    field pwd: Password 
    public method transfer(..) 
      ... as earlier ...
    public method set(pwd',pwd'': Password)
      if (this.pwd==pwd') 
        this.pwd=pwd''
\end{lstlisting}
\end{minipage} 
\end{tabular}

\noindent
Although the \prg{transfer} method is the same in
all three modules,   % and each one satisfies \Sclassic,
code  {such as}
\\ 
$\ \strut \hspace{.2in} $ \prg{p=new Password;  acc.set(p); acc.transfer(rogue\_accnt,p,1000)} 
\\ 
is enough to drain  \prg{acc} in \ModB without knowing the password.\footnoteSD{CAREFUL: we had 
$\ \strut \hspace{.01in} $ \prg{an\_account.set(42); an\_account.transfer(rogue\_accnt,42)} but this was type incorrect!}
%
%This example demonstrates that we need to consider the 
\emph{Emergent behaviour} is key here: 
Even though the method \prg{transfer} in  \ModB is ``safe'' when considered in isolation, it is not safe when considered in conjunction with other methods from the same module. 
% We are therefore looking for a way to specify modules' emergent behaviour,  
%\susan{Do you want to say something about not possible to capture emergent behaviour using Hoare logic pre/post conditions that hold for individual methods? 
%{Good idea! I did it earlier on; Does it work?}}
   
\subsubsection{Internal and external modules, objects, and states}
 \label{s:concepts}

We are concerned with guarantees made in an \emph{open} setting; that is, a given module
$M$ must be programmed so that 
execution of $M$ together with \emph{any} number of external modules $\overline M$
will uphold these guarantees. % In the tradition of
%visible states semantics, we are  only interested in 
These guarantees must be upheld while 
 $\overline M$, the  \emph{\externalM} modules, are executing; in contrast, the internal module may 
temporarily break them,
so long as they %are it 
hold {upon entry to external modules.}\footnoteSD{Not quite true. How improve?} 
 
    
We therefore distinguish between  \emph{\internalO}
objects --- instances of classes defined in $M$ ---
and \emph{\externalO} objects defined in any other module.
We also distinguish between
  \emph{\internalC} and   \emph{\externalC} states - those whose receiver is internal or external respectively. 
 
  % % from \externalC objects
%  to \externalC objects. 
%{Looking at the code snippet from \S \ref{sec:how}, the call to \prg{set} on line 6 is an 
% internal call, while the call to \prg{make\_payment} is an external call -- from the external 
% object  \prg{this}  to the external object \prg{untrusted}.}
 
% % We are less
%% interested in calls made from \internalO objects to \internalO objects, because we only need 
%% establish the guarantees when the \externalM module is executing. And we 
%%
%%
%Because we only require guarantees while 
%the  \externalM module  is executing,
%we develop an \emph{external states} semantics, where
% any internal calls are executed in one, large, step.
%With external steps semantics,  the executing object (\prg{this}) is always   external. 
%  In line  with other work in the literature \cite{Permenev, Grossman, Albert}, we currently forbid 
%  calls from internal to  external objects
%  -- further details on call-backs in \S\ref{s:related}. 
%
%{For the purposes of the current work we are only interested in one internal, and one external module.
%But the interested reader might ask: what if there is more than one external module?
%The answer is that from the internal module's viewpoint, all external modules are considered as one;
%for this we provide a module linking operator with  the expected semantics -- more details in Def. \ref{def:pair-reduce} and \S \ref{app:loo}. 
%But from the external module's viewpoint, there may be more than one external module: for example, in \S \ref{sec:how}, 
%module $\ModParam{1}$ is external to the module   implementing class \prg{Account}, and the module 
%implementing the class of \prg{untrusted} is external to
%$\ModParam{1}$.
%}




%\fbox{\parbox{5.5in}{{\textbf{1st Challenge} We are looking for a specification language that expresses eventual access to capabilties, as well as the the emergent behaviour of modules.}}}% [14cm]{text in the box}}

%\vspace{.1cm}



\subsection{First Challenge: Specifications of Object Capabilities as Guards}
\label{s:approach:necopers}

%\susan{it sounds like capabilities and emergent behaviour are
%different things, perhaps Specifications for Capabilities including
%Emergent behaviour - or something similar. {Any better now?}}

Our specifications should describe {which effects are guarded by which capabilities}. 
In particular, lack of access to {a capability  should} guarantee  that {the effect guarded by that capability cannot happen.}
  {These guarantees should hold  in the context of   emergent behaviour.}   
For this, we propose two %a specification language for modules, which has two main novel ingredients.
{novel concepts}:

 
\begin{description}
\item[Protection] to describe a lack of access to capabilities: An object $o$ is \emph{protected} from $o'$, formally $\protectedFrom {o} {o'}$,  if $o$ cannot obtain direct access to $o'$ unless an internal object affords that access. %to $o$. 
And $o$ is \emph{protected}, formally ${\inside{\prg{\it{o}}}}$, if $o$ is protected from all external objects transitively accessible from the currently executing method call. More in Def. 3.5, 4.5 and 4.6.

\item[{Scoped invariants}] to describe emergent behaviour:  \sdN{$\TwoStatesN  {\overline{x:C}}  {A}$} expresses that if a reachable state $\sigma$ 
  satisfies ${\overline{x:C}}  \wedge A$, then all $\sigma$'s \emph{scoped} future  states will  {also} satisfy  {$A$}. The scoped future contains future states, including further method calls and returns, but {does not return} from the call active in $\sigma$ -- more in Def 5.3. 
In other words, the current call \emph{scopes} where \se{$A$} must hold -- more in Def 3.1. 
We consider executions of the internal module linked with any number of unknown, external modules -- \cf Sect. 2.2.
 For $\sigma$ and its scoped future   we only consider states whose receiver is \emph{external}. 

\end{description}

 

\forget{
\kjx{not clear why these are ``two-state'' invariants - rather than
  $1+N$ states? \red{SD: ``two-state'' does bot mean that the states are immediately consecutive. Can you propose a better name}}
\kjx{seems $\protectedFrom {o} {o'}$ means $\exists i intl : \textrm{dominatesAllPathsFrom}(o)\textrm{To}(o')$ or something;
ditto  ${\inside{\prg{\it{o}}}}$ means 
    $\exists i intl : \textrm{dominatesAllPathsFrom}(topOfStack)\textrm{To}(o')$.
Not that I'm biased or anything.
 \red{SD: cI do not think so. We are asking for the penultimate element in the path. For example, if there is a path 1->2->3->4, and 2 is internal, and 3 is external, than your definition would say  that 4 is protected from 1, but with the def as given here it is not.
 \blue{SD:If we reversed the arrows, then indeed we could say that $\protectedFrom {o} {o'}$ iff the \textbf{set} of internal objects dominates all \textbf{reversed} paths from $o$ to $o'$. 
 Woulds that be more easily understandable than the current definition?
}}}}
 
 
With these concepts we can now write specifications which  rule  out \ModB while permitting \ModA and
\ModC, namely:

\label{s:bankSpecEx}
{
 \begin{tabular}{lcll}

  $S_1$   & $\triangleq$   &  $\TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{a}}} $
 \\
 $S_2$   & $\triangleq$   &  $\TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.pwd}}} $
 \\
 $S_3$ & $\triangleq$   &
 $\TwoStatesN {\prg{a}:\prg{Account},\prg{b}:\prg{int}}  {\inside{\prg{a}} \wedge \prg{a.\balance}=\prg{b}}  $
\\
$S_4$ & $\triangleq$   &
 $ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.pwd}} \wedge \prg{a.\balance} \geq \prg{b} } $
 
 \end{tabular}
}

\noindent
 $S_1$ guarantees that the module does not leak accounts, 
 $S_2$ guarantees that the module does not leak passwords,
 $S_3$ guarantees that the balance is not modified unless there is unprotected access to the account, while 
 $S_4$ guarantees that the balance does not decrease unless there is unprotected access to the password.
 %
 All three modules satisfy $S_1$ and $S_3$. $\ModA$ and $\ModC$ also satisfy $S_2$ and $S_4$, but $\ModB$ satisfies neither $S_2$ nor $S_4$.
 
 
 \noindent
\textbf{NOTES} \notesep  Our specifications are expressed in terms of observable effects (\eg the password stays protected, the account's balance may increase), rather than in terms of individual methods (\eg\, \prg{set} or \prg{transfer}).
{This % gives our specifications the the vital advantage that our specifications can % be used to constrain
implies that they can charatcterize  any 
module with bank accounts which have a % {\textit{implementation}} of a bank account with a 
 \balance~and a \password -- even as ghost fields --}, irrespective of the API offered, services  exported, or  dependencies on other parts of the system.\footnoteSD{does this come from OOPSLA? if so we need to rephrase}
\notesep
{Adherence to   specifications is not monotonic:
Adding a method to a module does not necessarily preserve adherence to
a specification, and while separate methods may adhere to a  specification, their combination does
not necessarily do so. 
{For example, \ModB's  \prg{tansfer} and \prg{set} satisfy $S_4$, but their interplay does not.}
%In this sense, and, similar to OOPSLA'22, our  specifications capture a module's \emph{emergent behaviour}. 
}

 
\subsection{Second Challenge: Reasoning about external calls}
\label{sec:how}

{ 
The challenge when calling a method on an external object, is that we have no specification for that method. 
However, as argued in the intro\footnoteSD{we need to indeed argue that in the intro}, our  module's emergent behaviour  specification together with knowledge about 
parameters' lack of access to capabilities %may be used to guarantee that   in order to restrict the possible side-effects of the external call.
can give us the guarantee that \se{specific} guarded effects will not take  place.
}

 
 
Assume that {our internal module included the following class} \prg{Shop}. It exports a public method \prg{buy} whose formal parameter \prg{buyer} is an \prg{external}   object  with a method \sdN{ \prg{payMe}}.
The critical point is line 7, where we call the method  \prg{payMe} on \prg{buyer}, and pass them the shop's account.
Is it possible that the buyer will use this opportunity  to drain the shop's account?
  

\begin{lstlisting}
class Shop
  field accnt : Account
  field invntry :  Inventory    
  public method buy(buyer: external, anItem: Item) -> void
    int price = anItem.price
    int oldBlnce = this.accnt.blnce
    buyer.payMe(this.accnt, price)
    if (this.accnt.blnce == oldBlnce+price)
       this.send(buyer,anItem)
    else
       buyer.tell("you have not paid me") 
    public method send(buyer: Object, anItem: Item) -> void  
       ...            
\end{lstlisting}
 
\noindent
 
If the \prg{Account} comes from a module that satisfies $S_4$, and if at the point of the call to \prg{buy} -- \ie at line 4 -- the \password~was protected from the \prg{buyer}, then it is guaranteed that after the external call -- \ie after line 7 --  the shop's account's balance will not have decreased.
{The corresponding Hoare logic rule, which applying  $S_4$ would verify line 7, appears in Fig. 10.}

 

\vspace{.1cm}

  \noindent
 \textbf{NOTES}
%\susan{You've never said how a holistic spec is used.{Does the para above not use the holistic spec?}}
 \notesep We   applied $S_4$ at the point of call in line 7, even   though  
 the pre-state in $S_4$ requires % r  is  in terms 
 a \emph{stronger} property than the one we have.
 Namely,   $S_4$ requires   the \password~to be protected, while we only know 
  that the \password~is protected from the  \prg{buyer}.
It is safe to apply $S_4$,  because from the point of view of the callee at line 7 the \password~is indeed protected -- \cf Fig, 5,   Lemma 4.7, and the 
  Hoare logic rule in Fig.10.
   \notesep  If at the point of call of \prg{buy} the  password was not protected from the \prg{buyer}, then, of course, no guarantee can be made about the account's balance.
 \notesep Requiring that the account's password was protected from all external objects would be far too strong; if that were the case, then the account would not be useful for any payments.
 \notesep Requiring that the account's  password was protected at the time of the call of \prg{buy} would also be far too strong: our module cannot impose restrictions on the callers' external state  upon the call to \prg{buy}.
 \notesep 
 We could specify the method \prg{buy} through the pre-condition $\protectedFrom {\prg{a.pwd}} {\prg{buyer}} \wedge {\prg{a.\myAccount.\balance}}=\prg{b}$ which
 guarantees that $\prg{a..\myAccount.\balance}\geq \prg{b}$.  Note that this is a  direct conclusion of $S_4$; 
  as \prg{Shop} is part of our internal module, this specification is superfluous -- more in Example \ref{example:mprepostl}.
 
 \subsection{Third Challenge: Proving that a module adheres to its specification}
 \label{sec:howThird}
 
{In order to prove that a module adheres to its specification, we need to prove that all  private methods satisfy their  PRE/POST post-conditions, and that all public methods satisfy the module's two-state invariants combined with their PRE/POST conditions -- if any.
This means that we need Hoare logic rules to reason about, among other things, protection.}

{For our work, we assume an underlying sound Hoare logic for {our} language, and extend it with rules about protection, external calls, and the module's adherence to its 
specification - more in Figs. 7-11.
We prove that the extended Hoare logic is sound.
}

{Notice that while we are concerned with \emph{necessary conditions for effects}, we prove adherence to \emph{sufficient conditions which guarantee the absence of effects.}
We have therefore taken a similar path to .... TODO ...
}

 {The proof that the extended Hoare logic is sound is interesting, because we are arguing about the soundness of two interrelated systems: 
 the per-statement  Hoare logic, as well as the \susan{entire} module's logic.
Moreover, we need to cater for the possibility that external calls eventually call public methods of the module, which in their turn make external calls etc.
For this we define a new measure of execution ...}


 
 %Because we only require guarantees while 
%the  \externalM module  is executing,
%we develop an \emph{external states} semantics, where
% any internal calls are executed in one, large, step.
%With external steps semantics,  the executing object (\prg{this}) is always   external. 
%  In line  with other work in the literature \cite{Permenev, Grossman, Albert}, we currently forbid 
%  calls from internal to  external objects
%  -- further details on call-backs in \S\ref{s:related}. 
%
%{For the purposes of the current work we are only interested in one internal, and one external module.
%But the interested reader might ask: what if there is more than one external module?
%The answer is that from the internal module's viewpoint, all external modules are considered as one;
%for this we provide a module linking operator with  the expected semantics -- more details in Def. \ref{def:pair-reduce} and \S \ref{app:loo}. 
%But from the external module's viewpoint, there may be more than one external module: for example, in \S \ref{sec:how}, 
%module $\ModParam{1}$ is external to the module   implementing class \prg{Account}, and the module 
%implementing the class of \prg{untrusted} is external to
%$\ModParam{1}$.
%}

 

\subsection{Our Contributions}

Our contributions are

\begin{enumerate}
\item
New capability assertions, $\protectedFrom {x} {y}$  and $\inside{x}$ 
\item
A new specification language for emergent behaviour  
\item
A Hoare logic extension, which handles external calls
\item
A logic which proves adherence to our specification language
\item
Proofs, and a worked out example
\end{enumerate}
