 \newcommand{\pwd}{key}

\renewcommand{\password}{key\xspace}




We introduce the problem  through an example, and outline our
approach.  We work with a  small, class-based object-oriented, sequential language similar to Joe-E \cite{JoeE} with modules,   module-private fields
({accessible} only from   methods {from} the same module),
and unforgeable, un-enumerable addresses.
We distinguish between  \emph{\internalO}
objects --- instances of our internal module $M$'s classes ---
and \emph{\externalO} objects defined in
\emph{any} number of external modules $\overline M$\footnote{We use the notation $\overline z$ for a sequence of $z$, \ie for $z_1,z_2,...z_n$ }.~ 
{\prg{Private} methods  {may only be} called by objects of the same
  module,  while \prg{public}  methods  may be  by \emph{any}
  object with a reference to the method receiver, {and with
  actual arguments of  dynamic types that match} the declared formal parameter types.} 
\footnote{As in Joe-E, we leverage  module-based privacy to restrict propagation of capabilities, and reduce the need for reference monitors etc, \cf Sect 3 in  \cite{JoeE}.}   

 \label{s:concepts}
 
We are concerned with guarantees made in an \emph{open} setting; % thatis, 
Our internal module
$M$ must be programmed so that 
  execution of $M$  together with \emph{any} unknown, arbitrary, external modules $\overline M$
% it was "its execution, together ... "SD thinks that the comma  was misleading
will satisfy these guarantees --
%$M$ must ensure these guarantees are satisfied
%These guarantees must  satisfied
%whenever the
% $\overline M$  \emph{\externalM} modules are executing,
%yet 
without relying on any assumptions about $\overline M$'s code
(beyond the programming language's semantics) 
\footnote{
This is a critical distinction from e.g.\
cooperative approaches such as rely/guarantee
\cite{relyGuarantee-HayesJones-setss2017,relyGuarantee-vanStaden-mpc2015}.}.
% SD chopped the next sentence. I think  the uninformed reader will be surpised, and the knowledgeable reader will find out soon enough
% The internal module may break these guarantees temporarily,
% so long as they {are reestablished} before (re)entry to an external module.
  
 

\subsection*{\prg{Shop} -- illustrating limited effects}  
\label{sec:how}
\label{sec:shop}

% I think we can skip the next sentence3. We said it all earlier, and will say it again later
%The challenge when calling a method on an external object, is that we have no specification for that method. 
% For illustration, 
Consider the following, internal, module \Mshop, % which also includes the 
containing classes \prg{Item}, \prg{Shop}, \prg{Account}, and \prg{Inventory}. 
Classes  {\prg{Inventory} and \prg{Item} have the expected functionality. 
\prg{Account}s hold a balance and have a \password. 
Access to an \prg{Account},  allows one  to pay money into it, 
and  access to an account  and its \password, allows one to withdraw money from it.
% Implementations of such a class  appear in the next section.
}
 \prg{Shop}  has  a public method \prg{buy} whose formal parameter \prg{buyer} is an \prg{external}   object. 
 % SD chopped  with a method { \prg{pay}.}} 

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module M$_{shop}$
  ...   
  class Shop
    field accnt:Account, invntry:Inventory, clients:external      
    public method buy(buyer:external, anItem:Item)
      int price = anItem.price
      int oldBlnce = this.accnt.blnce
      $\red{\mbox{buyer.pay(this.accnt, price)}}$      
      if (this.accnt.blnce == oldBlnce+price)  
         this.send(buyer,anItem)
      else
         buyer.tell("you have not paid me")      
    private method send(buyer:external, anItem:Item)  
       ...         
\end{lstlisting}
 
 

The critical point is the external call on line 8,   {where the \prg{Shop} asks the \prg{buyer} to pay the price of that item,
by calling  \prg{pay} on \prg{buyer} and passing the \prg{Shop}'s account as an argument.
% somebody had written " \prg{Shop}'s account" but SD thinks it has to be  \prg{Shop}'s account
As \prg{buyer} is an external object, the module \Mshop has no method specification for \prg{pay}, and no 
certainty about what its implementation %knowledge of what the implementation of \prg{pay} 
might do. 
% \se{with \prg{this.accnt}}.  % SD: no, because  also with other things.
}

{What are the possible effects of that external call?}
{The \prg{Shop} hopes, % but cannot be sure,
 that at line 9  it  will have received money; but 
it wants to be certain  that the \prg{buyer} cannot use this opportunity to access the 
shop's account to drain its money.

Can \prg{Shop}  be certain?} Indeed, if

\vspace{.05cm}
\begin{enumerate}[(A)]
\item   Prior to the call of  \prg{buy}, the \prg{buyer}  has no eventual access to the account's \password, \ \ \ \emph{----} and
\item  \Mshop ensures that 
\begin{enumerate}[(a)]
\item access to keys is not leaked to external objects, \ \ \ \emph{----} and
\item    that  funds cannot be withdrawn unless the external entity responsible for the withdrawal has eventual access to the account's \password,
\end{enumerate}
\ \  \ \ \ \emph{----} then
\item  The external  call on line 8 will not result  in a decrease in the shop's account balance.
\end{enumerate}



%\vspace{.3cm}
\noindent
The remit of this paper is to provide specification and verification tools that support arguments like the one above.
This raised the following three questions:\  1$^{st}$:  A specification language which describes access to capabilities and limited effects,\ 
2$^{nd}$: A  Hoare Logic for adherence to such specifications,  \ 3$^{rd}$:    A  Hoare Logic for external calls.

%\begin{description}
%\item[\ \ \ \ \  1$^{st}$ Remit:]  \ A specification language which describes access to capabilities and limited effects,
%
%\item[\ \ \ \ \   2$^{nd}$ Remit:]  A  Hoare Logic for adherence to such specifications,
%
%\item[\ \ \ \ \  3$^{rd}$ Remit:]  A  Hoare Logic for external calls.
%\end{description}

%We continue our example with three versions of the module, some of which satisfy (B) from above, and some of which do not

% In our example, we relied on two yet-to-be-defined concepts: (1) ``eventual access'' and (2) limited effects (e.g., no money withdrawn unless certain conditions are met).
%Therefore, we need to address the following three challenges: 
%\begin{description}
%\item[\ \ \ \ \  1$^{st}$ Challenge] The specification   of ``eventual  access''. 
%
%\item[\ \ \ \ \   2$^{nd}$ Challenge] The specification of limited effects, 
%
%\item[\ \ \ \ \  3$^{rd}$ Challenge] A  Hoare Logic for external calls, and for adherence to limited effect specifications.
%\end{description}



%\vspace{.2cm}
%\noindent
% \textbf{NOTE}  \sdN{Replacing the argument by a wrapper to the account which allows payments but forbids withdrawals,    would be ineffectual in \taming} the  effects on line 9. 
%What  if the % nece\tame the effects because
% \prg{buyer} had access to the account and its \password  \emph{before} the call to \prg{pay}? 
%\se{I don't understand the point here. Are you saying a wrapper might prevent a buyer who has legitimate access to an account from getting it?}
%\sdN{SD: The point I am trying to make is that: \  if before the call to \prg{pay}, the \prg{buyer} had access to the account and its keyword, and when we call \prg{pay} instead of 
%\prg{this.accnt} we pass the wrapper, then the \prg{buyer} would still be able to steal money from \prg{this.accnt}.
%Does this make sense? Shall we drop that point?}
 
 
\subsection{1$^{st}$ Question: Specification Language} 

We want to give a formal meaning to the guarantee that for some effect, $E$, and an object $o_c$ which is the capability for $E$:

\vspace{.1cm}

  \begin{minipage}{.05\textwidth}
   \textbf{(*)}
\end{minipage}
\hfill
\begin{minipage}{.95\textwidth}
\begin{flushleft}
$E$ can be caused only  by external objects calling methods on internal objects, \\
and only if the causing object has access  to $o_c$. 
\end{flushleft}
\end{minipage}

\vspace{.1cm}

%\begin{quote}
%(*)   \ \ \ \ \ $E$ can be caused only  by external objects calling methods on internal objects, \\
%$\strut \ $ \ \ \ \ \  \ \ \ and only if the causing object has access  to $o_c$.   
% \end{quote}

\noindent 
The first task is to describe that effect  $E$ took place. We can do that by finding some aseertion $A$ which is invalidated by $E$. Then, (*) can be described by something like:

\vspace{.1cm}

  \begin{minipage}{.05\textwidth}
   \textbf{(**)}
\end{minipage}
\hfill
\begin{minipage}{.95\textwidth}
\begin{flushleft}
If $A$ holds \  and \     no external access to  $o_c$ \ \ \ \ then\  \ \  \ $A$ holds in the future. 
\end{flushleft}
\end{minipage}

\vspace{.1cm}


\noindent 
We now need to determine the meaning of "no external access to  $o_c$", and of "$A$ in the future.

In a first attempt we could say that "no external access to  $o_c$" means  that no external object exists, nor will any external objects be created.
% \begin{customquote}
%(V1) \ \ \ $A\ \wedge\ $  no external access to  $o_c$ \ \ is an invariant.
% \end{quote}
 However, this is too strong; it defines away the problem we are aiming to solve.

In a second attempt, we could say that "no external access to  $o_c$" means that no external object has access to $o_c$, nor will ever get access to $o_c$. This is also too strong, as it would preclude $E$ from ever happening, while our remit is that $E$ may happen but only under certain conditions. 

This discussion indicates that the lack of external access to $o_c$ is not a global property, and that the future in which  $A$ will hold is not be permanent. 
Instead,  they are both defined from the viewpoint of the current point of execution.
The current point of execution is characterized by the activation frames\footnote{An activation frame, or frame for short. consists of a variable map and a continuation -- the statements that remain to be executed.} on the call stack, and the heap. 
We are interested in external objects reachable from the current frame\footnote{the frame corresponding to the currently executing method}, and  in the future states scoped by the current frame: 

\vspace{.1cm}

  \begin{minipage}{.05\textwidth}
   \textbf{(***)}
\end{minipage}
\hfill
\begin{minipage}{.95\textwidth}
\begin{flushleft}
\ If $A$ holds \  and \  no external objects \emph{reachable from current frame}  have access to $o_c$, \\  
\   and\   no  internal objects pass $o_c$ to external objects,  \\
\ then \ \ \  \ $A$ holds in  \emph{the future scoped} from the current frame.   
\end{flushleft}
\end{minipage}

\vspace{.1cm}
 

We formalize "no external objects  reachable from the current frame have access" through the concept of \emph{protection}, 
and "the future scoped from the current frame" through  the concept of \emph{scoped invariants}. 
We discuss these concepts in more detail in \S \ref{sect:approach:protection}, and \ref{sect:approach:scoped}


\subsubsection{Protection}
\label{sect:approach:protection}


 \begin{description}
\item[Protection] 
%Object $o$ is \emph{protected  from} $o'$, formally $\protectedFrom {o} {o'}$,  
%% if the penultimate object on \se{every} path from $o$ to $o'$  is internal.
%\sdNew{if no external object transitively accessible from $o$ has direct access to $o'$.}
Object $o$ is \emph{protected}, formally ${\inside{\prg{\it{o}}}}$,  
if no external object transitively accessible from the current frame\footnote{An object is transitively accessible from a frame if
 there exists a sequence of field accesses leading from one of the variables in the frame  to that object.} 
has direct access to $o$. 
\\
Object $o$ is \emph{protected  from} $o'$, formally $\protectedFrom {o} {o'}$,  
if no external object transitively accessible from $o'$ has direct access to $o'$.
More in Def. \ref{def:chainmail-protection-from}.  
 \end{description}
 
%\noindent
%Protection  thus depends on the heap topology as well as on the contents of the current frame -- \eg~
%  Fig. \ref{fig:ProtectedBoth}. 

%Protection  thus depends on the heap topology as well as on the contents of the current frame -- \eg~
%\cf Fig. \ref{fig:ProtectedBoth}. %  object $o_7$ is not protected in the middle pane, but is protected in the right pane.


 
\begin{figure}[tbh]
\begin{tabular}{|c|c|c|}
\hline
\resizebox{3.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prfC.png}
} 
&
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prtFirst.png}
}
&
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prtSecond.png}
}
\\
\hline
protected from object $o_2$
&
protected  with current frame $\phi_1$
&
protected  with current frame $\phi_2$
\\
\hline \hline
\end{tabular}
\caption{\textit{Protected from and Protected}. Pink and green squares are external and internal objects, respectively. Connecting straight arrows  indicate fields. Blue boxes are frames on the stack. Protected objects are  highlighted in yellow. 
 The left pane shows a heap with objects $o_1$-$o_9$.
 Here  $o_1$, $o_4$, $o_5$ and $o_9$ 
are protected from $o_2$. 
 The middle pane {shows the same heap and a stack with frame  $\phi_1$} whose receiver,   \prg{this},  points to $o_1$. Here 
 $o_1$, $o_2$, $o_4$, $o_5$ and $o_9$  are protected. 
 The right pane {shows the configuration after pushing frame  $\phi_2$}, whose receiver,  \prg{this},  and local variable, \prg{x}, point to $o_3$ and  $o_7$, respectively.
 Here $o_3$ and $o_7$ are protected, in addition  to  the objects protected in the previous pane.
}
   \label{fig:ProtectedBoth}
 \end{figure}
 
If the  internal module  never passes $o$ to  external objects (\ie never leaks $o$) and  $o$ is protected, then $o$ will remain protected during execution of the current method and all the methods \emph{it} calls.
However, it need not be protected during execution of the method calling the current method, nor after termination of the current method.   
This discussion leads us to  scoped invariants.
%Going back to the original question, if $o_{c}$ is protected,  and $o_{c}$ is never leaked to external objects, 
%then  effect  $E$ is guaranteed not to occur. % , \se{unless caused by internal code}.

\subsubsection{Scoped Invariants}
%\subsection{2$^{nd}$ Challenge: Specification of limited effects}

\label{sect:approach:scoped}
%How can we express the guarantee that effects are limited?  
% In particular, when effects can be the outcome of the execution of more than one method? 
% Traditional,  {per-method} PRE/POST conditions {cannot guarantee} %specifications cannot express guarantees
%  that two or more of our methods won't interact to produce an unlimited effect. 
We build on the concept of history invariants \cite{liskov94behavioral,usinghistory,Cohen10} and define:

\begin{description}
\item[{Scoped invariants}]  
{$\TwoStatesN  {\overline{x:C}}  {A}$} expresses that if a {state} $\sigma$ 
 has objects $\overline x$ of class $\overline C$, and satisfies $A$, then all $\sigma$'s \emph{scoped  future  states} will  {also} satisfy  {$A$}. 
The scoped future contains all  states which can be reached through any steps, including further method calls and returns, but stopping before returning  from the call active in $\sigma$ \footnote{{Here lies the difference to history invariants, which consider \emph{all} future states, including returning from the call active in $\sigma$.}}  --  \cf Def  \ref{def:shallow:term}.
{For} $\sigma$ and its scoped future   we only consider external states\footnote{States with external receivers, \ie which execute external code} -- \cf Def \ref{def:necessity-semantics}.
\end{description}


 \begin{figure}[htb]
\begin{tabular}{|c|}
\hline  % \\
\hspace{2cm}
\resizebox{6.6cm}{!}{
\includegraphics[width=\linewidth]{diagrams/preserves2.png}  
}
\hspace{2cm}
\\
\hline
\end{tabular}
   \caption{\textit{Illustrating  scoped invariants}.
Green and pink  disks represent  internal and external states.
Horizontal arrows represent execution within the same method; up-arrows represent method calls; down-arrows represent method returns.
% \\
\ \ \ \  Thus, the scoped future of $\sigma_6$ includes all states in the diagram, and the scoped future of $\sigma_8$ consists of $\sigma_9$, $\sigma_{10}$,  $\sigma_{11}$,  $\sigma_{12}$,   $\sigma_{13}$,  
and $\sigma_{14}$, and does not include, \eg,  $\sigma_{15}$, or $\sigma_{19}$.
\\
The invariant   ${\TwoStatesN {\overline {x:C}} {A_0}}$   guarantees that $A_0$ will be preserved from $\sigma_8$ to $\sigma_{13}$,
 but \emph{not} from  $\sigma_8$ to $\sigma_{15}$, or $\sigma_{19}$.
 It also guarantees that $A_0$ will be preserved from $\sigma_6$ to $\sigma_{17}$,
but \emph{not} from  $\sigma_6$ to $\sigma_{11}$, as $\sigma_{11}$ is an internal state.
}
 \label{fig:illusrPreserve} 
 \end{figure}

\subsubsection{Examples}    
    
\label{s:bank}

\begin{example}
\label{s:bankSpecEx}
The following scoped invariants\\
$\strut \SPSP\ \ \   S_1\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account}}  {\inside{\prg{a}}} $ 
\hspace{1.1cm}
$\strut  \SPSP\ \ \   S_2\ \  \triangleq \ \ \TwoStatesN  {\prg{a}:\prg{Account}}  {\inside{\prg{a.key}}} $ 
% \\
%$\strut  \SPSP   S_3\ \  \triangleq \ \ \TwoStatesN {\prg{a}:\prg{Account},\prg{b}:\prg{int}}  {\inside{\prg{a}} \wedge \prg{a.\balance}=\prg{b}}  $
\\
$\strut  \SPSP\ \ \   S_3\ \  \triangleq \ \ \TwoStatesN{ \prg{a}:\prg{Account},\prg{b}:\prg{int} } {\inside{\prg{a.key}} \wedge \prg{a.\balance} \geq \prg{b} } $ 
% \end{tabular}
%}

\noindent
%specifications
 guarantee that   accounts are not leaked  ($S_1$), \ \ keys are not leaked  ($S_2$), \ \ the balance does not decrease unless there is unprotected access to the key  ($S_3$).
 % $\strut  \SPSP  S_1$:\   accounts are not leaked,  \hspace{1.1cm}
%$\strut   \SPSP S_2$:\    keys are not leaked,\\
%%$\strut \SPSP  S_3$:\  the balance is not modified unless there is unprotected access to the account,  \\%while 
%$\strut \SPSP  S_3$:\   the balance does not decrease unless there is unprotected access to the key.  
%
\end{example} 
 \vspace{.005cm}

 
\noindent
This example illustrates two crucial properties of our   invariants. Namely, they are

 \begin{customquote}
% {\textbf{\sdN{Scoped invariants are} \emph{conditional}}:} 
\noindent
%{$\bullet$}
\emph{Conditional}:   They ensure that assertions are \emph{preserved}, but unlike object invariants, they do not guarantee that they always hold.
\ \Eg   \prg{buy} cannot assume $\inside{a.\prg{key}}$ holds on entry, but   guarantees that if it holds on entry, then  it will still hold on exit.

\noindent
%{$\bullet$}
\emph{Scoped}:     They are preserved during execution of a certain method, but \emph{not} after return from that method.
In fact, it is \emph{expected} that at some point after completion the invariant will not hold:
\ \Eg   even in  $\inside{a.\prg{key}}$ holds currently, it is expected that some external object accessible 
from a  frame deeper down in the current stack will have direct access to ${a.\prg{key}}$ -- if this were not so, then $a$ would not be usable for payments. 
Therefore, at some future point, after enough frames have been popped from the stack,  $\inside{a.\prg{key}}$ will no longer hold. 
 \end{customquote}
 
 \begin{example}
 We   now use the features from the previous section to specify methods. 

{\sprepostShort
		{\strut \ \ \ \ S_4} 
		{   \protectedFrom{\prg{this}.\prg{\myAccount}.\prg{key}} {\prg{buyer}} \wedge \prg{this}.\prg{\myAccount}.\prg{\balance}=b
		 }
		{\prg{public Shop}} {\prg{buy}} {\prg{buyer}:\prg{external}, \prg{anItem}:\prg{Item} }
		{ 
		  %\protectedFrom{\prg{this}.\prg{\myAccount}.\prg{key}} {\prg{buyer}} \wedge 
		  \prg{this}.\prg{\myAccount}.\prg{\balance}\geq b
		} 
		}

\noindent
$S_4$  guarantees that if the  key was protected from \prg{buyer} before the call, then the balance will not decrease. 
\footnote{We ignore the ... for the time being.}
 It does \emph{not} guarantee \prg{buy} will only be called when $\protectedFrom{\prg{this}.\prg{\myAccount}.\prg{key}} {\prg{buyer}}$ holds: 
as a  public method,  \prg{buy}  can be invoked by external code that ignores all specifications.
\end{example}

% \vspace{.05cm}

\begin{example}
We illustrate the meaning of our specifications  using three  versions of a class \prg{Account}  from  \cite{OOPSLA22} 
as part of our internal module \Mshop. 
To differentiate, we rename \Mshop  as $\ModA$,  $\ModB$, or $\ModC$. 
All use the same \prg{transfer} method for withdrawing money.
%All use the same method \prg{transfer} to  withdraw money, only when supplied with the key.
%\forget{All versions {use the same method \prg{transfer} to} allow  withdrawal of money, only when supplied with the key to the account.
%All use the same method \prg{transfer} to  withdraw money, only when supplied with the key.}
% removed class Key -- it does not need to be internal 
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModA$      
  class Shop   ... as earlier ...
  class Account
    field blnce:int 
    field key:Key
    public method transfer(dest:Account, key':Key, amt:nat)
       if (this.key==key')   this.blnce-=amt; dest.blnce+=amt
     public method set(key':Key)
       if (this.key==null)  this.key=key'
\end{lstlisting}

Now consider  modules \ModB and \ModC which differ from \ModA only in their \prg{set} methods. Whereas \ModA 's key is immutable, \ModB allows any client to reset an account's key at any time, and \ModC requires the existing key in order to change it.
  

\begin{tabular}{lll}
\begin{minipage}[b]{0.40\textwidth}

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\ModB$
public method set(key':Key)
  this.key=key'
\end{lstlisting}
\end{minipage}
&\ \ \  \ \   &%
\begin{minipage}[b]{0.48\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
$\ModC$
public method set(key',key'':Key)
  if (this.key==key')  this.key=key''
\end{lstlisting}
\end{minipage} 
\end{tabular}

{Thus, in all three modules, the key is a capability which \emph{enables} the withdrawal of the money. 
Moreover, in $\ModA$ and $\ModC$, the key
{is a capability} used to  \emph{tame} withdrawal of money, preventing those without it from getting the money from the account.}
Crucially,  in $\ModB$ the key \emph{does not tame} withdrawal of money.
Using $\ModB$, it is possible to start in a state where the account's key is unknown, modify the key, and then withdraw the money. 
Code  {such as}
\\ 
$\ \strut \hspace{.2in} $ \prg{k=new Key;  acc.set(k); acc.transfer(rogue\_accnt,k,1000)} 
\\ 
is enough to drain  \prg{acc} in \ModB without knowing the \password.\footnoteSD{CAREFUL: we had 
$\ \strut \hspace{.01in} $ \prg{an\_account.set(42); an\_account.transfer(rogue\_accnt,42)} but this was type incorrect!}
 %
% \emph{Emergent behaviour} is key here: 
Even though % the method 
\prg{transfer} in  \ModB is ``safe'' when considered in isolation, it is not safe when considered in conjunction with other methods from the same module. 

%Modules 
$\ModA$ and $\ModC$ satisfy $S_2$ and $S_3$, while $\ModB$ satisfies neither. None satisfies $S_1$, because  \prg{pay} leaks an \prg{Account}.

\end{example}
 
\forget{% for the time being at least
{ \noindent
 Our specifications are  in terms of the complete module, rather than per-method.
 They talk about externally observable effects (\eg the key stays protected), 
 % the account's balance may increase), 
 rather than about  individual methods (\eg\, \prg{set}). %  or \prg{transfer}).
{Thus,   they can characterize  any 
module with  accounts which have a % {\textit{implementation}} of a bank account with a 
 \balance~and a \password -- even as ghost fields --}  irrespective of the API offered.
} }% , services  exported, or  dependencies on other parts of the system.\footnoteSD{does this come from OOPSLA? if so we need to rephrase}
%\notesep
%Adherence to   specifications is not monotonic:
%{Eg, while  \ModA satisfies $S_3$, the addition of \prg{set} lead to \ModB, which does not.}
%% Adding a method to a module does not necessarily preserve such adherence,
%% \eg adding method \prg{set} in module \ModB breaks 
%%SD removed the below. When we changed the invaraints to have the same assertion re and post it no longer hel
%\forget{, and while separate methods may adhere to a  specification, their combination does
%not necessarily do so. 
%{For example, \ModB's  \prg{tansfer} and \prg{set} satisfy $S_3$, but their interplay does not.}
%%In this sense, and, similar to OOPSLA'22, our  specifications capture a module's \emph{emergent behaviour}. 


  
  \subsection{2$^{nd}$ Question:  A Hoare logic for adherence to specifications}  
 \label{sec:howSecond}

Our scoped invariants give rise to a Hoare logic of quadruples, rather than the classical triples.
Namely, 
  {$\TwoStatesN  {\overline{x:C}}  {A}$} expresses that if an external {state} $\sigma$ 
% with objects $\overline x$ of class $\overline C$ 
 satisfies $\overline {x:A} \wedge C$, then all its \emph{scoped} external future  states will  {also} satisfy  {$A$}. 
\Eg if $\sigma$ was an external state executing a call to \prg{Shop::buy}, then a \emph{scoped} external future  state
 could be an external state reachable  after the return from \prg{Shop::buy}, but could also be reachable
during execution of the external call \prg{pay}.
This means that we are also interested in the states the external states reachable \emph{during} execution of  statements. 
To accommodate this, we extend   traditional Hoare triples to quadruples of  form\\
 $\strut \ \hspace{4cm} \quadruple {A} {\, stmt\, }{A'} {A''}$\\  
 promising that if a state satisfies $A$ and executes $stmt$, any terminating state will satisfy $A'$, and 
 and  any intermediate external states reachable during execution of $stmt$ satisfy    $A''$ -- \cf Def. \ref{def:hoare:sem}.
 
\vspace{.05cm}

To develop our logic, we   assume  an  underlying   Hoare logic  of  triples, 
$ M \vdash_{ul} \{ \ A\ \} {\ stmt\ }\{\ A'\ \} $,
which does not {have} the concept of protection, nor deals with external calls.
We then extend this logic through  
substructural rules,   rules about protection,  an embedding into our quadruples, and rules about external calls.
For the former see the following, slightly simplified, rules and 
% and allow method specifications which also talk about intermediate external states.
% We  extend it through   substructural rules,  and  
 \cf Figs. \ref{f:underly} -  \ref{f:calls}.
 We discuss the latter in \S \ref{sec:howThird}.
% and some such rules below.


{\footnotesize{
$
\begin{array}{lclcl}
\inferruleNoName 
	{ 
	 	
	}  	 
	{	 
 	\hproves  {M}  
	                {  true  }  
 			   {\  u = \prg{new}\ C \ }
 			   {\  \inside{u}\  } 
	} 
& &
\inferruleNoName 
	{
	 M \vdash_{ul} \{ \ A\ \} {\ stmt\ }\{\ A'\ \} 
	}  
	{ \hproves  {M}  {A} {\ stmt\ }{A'} }
	& &
\inferruleNoName 
	{  
	\hproves{M}  {A} {\ stmt \ } {A'} 
	}
	{\hprovesN{M}  {A} {\ stmt \ } {A'} {A''} }
\end{array}
$
}}

A module is well-formed, if  its invariants are well-formed,    its public methods preserve   its invariants, and  all  methods satisfy their specifications - \cf  Fig.  \ref{f:wf}.
%An invariant is well-formed if   it is \emph{encapsulated}, \ie can only be invalidated by internal code
%-- \cf Def. \ref{d:encaps}. 
%A method preserves an assertion   if it preserves it   from pre- to  post-states and also in any intermediate external state.
% Our extension preserves soundness of the  Hoare logic --  \cf   
% Thms.  \ref{l:triples:sound},  \ref{thm:soundness}.
%
%
%\vspace{.4cm}
%
%
%
%
%
%
%\
\Eg to prove  that method \prg{Shop::buy} preserves the invariants from {$S_3$}  we  need to prove:
\\
{ \footnotesize{
%$\strut \ \ \ \ \ \ \ \ \ \ \ \quadruple {A_1  \wedge \inside{\prg{a}} } {\ stmt\_b  \ } {\inside{\prg{a}}} { \inside{\prg{a}}} $
%\\
%$\strut \ \ \ \ \ \   \ \  \quadruple {A_1  \wedge  \inside{\prg{a.\password}} } {\  stmt\_buy  \  } {\inside{\prg{a.\password}}}  {\inside{\prg{a.\password}}}$
%\\
%$\strut \ \ \ \ \ \  \ \  \ \ \   \quadruple {A_1  \wedge  \inside{\prg{a.key}} \wedge  \prg{a.\balance}\!=\!{\prg{b}} } {\   stmt\_b  \  } {\inside{\prg{a.key}} \wedge  \prg{a.\balance}\!=\!\prg{b}}   
%                         {  \inside{\prg{a,key}} \wedge  \prg{a.\balance}\!=\!\prg{b} }$
%\\
$\strut \ \ \ \ \ \   \ \   \quadruple {A_0  \wedge  \inside{\prg{a.\password}} \wedge  \prg{a.\balance}\!\geq\!{\prg{b}} } {\  stmt\_buy  \  } {\inside{\prg{a.\password}} \wedge  \prg{a.\balance}\!\geq\!{\prg{b}}}  
   { \inside{\prg{a.\password}}\wedge  \prg{a.\balance}\!\geq\!{\prg{b} }}$
}}
\\
%and similar for {$S_3$}. 
Here we used   
with  $A_0 \triangleq $  {\footnotesize{
\prg{this}:\prg{Shop}, \prg{buyer}:\prg{external}, \prg{anItem}:\prg{Item}, \prg{a}:\prg{Account}$
$, \prg{b}:\prg{int}}} and $stmt\_{buy}$  as short for  the body of \prg{buy}.
 
% \vspace{.2cm}
%Quadruples are also used in method specifications, \eg we specify \prg{transfer} through
%\\
%$\strut \ \ \ \ \ \  \ \  \ \ \  { \mprepostLongN {A_3}{\prg{public}\ \prg{Account}}{\prg{transfer}}{params}{A_4} {true} }$
%\\
%with shorthands  $params \triangleq$ \prg{dest:Account}, \prg{key':Key}, \prg{amt:nat}, and 
%$A_3  \triangleq$  $\prg{key'}=\prg{this.\password} \wedge \prg{dest}\neq \prg{this}$
%$\wedge\, b, b':\prg{int}$
%$\, \wedge\, \prg{this.\balance}=b$ 
%$\, \wedge\,  \prg{dest.\balance}=b'$, 
% and $A_4 \triangleq$  
% $\prg{this.\balance}=b-\prg{amt} \wedge \prg{dest.\balance}=b'+\prg{amt}$.
%For this specification, we need to prove\\
%$\strut \ \ \ \ \ \ \ \ \ \ \ \quadruple {\ \prg{this}:\prg{Account}\, \wedge\, params\, \wedge\, A_3  \  } {\ stmt\_{tr}  \ } {A_4} { true} $
%\\
%where $stmt\_{tr}$ is short for the body of  \prg{transfer}.

 
 \vspace{.1cm}
 
   \subsection{3$^{rd}$ Question:  A Hoare logic for external calls}  
 \label{sec:howThird}
 
We consider  the  verification of $S_4$. 
The challenge is how to reason  about the external call on line 8 (from \prg{buy} in \prg{Shop}). 
We need to establish a Hoare triple of the form:

  \begin{minipage}{.05\textwidth}
   \textbf{(1)}
\end{minipage}
\hfill
\begin{minipage}{.95\textwidth}
\begin{flushleft}
$\{\  \ { \external{\prg{buyer}}} \ \wedge\ {\protectedFrom {\prg{this.\myAccount.key}} {\prg{buyer}}\ \wedge\ {\prg{this.\myAccount.\balance}}= b    }\ \  \}$\\
$\ \ \ \ \ \ \ \ \ \ \ \ {\ \prg{buyer.pay(this.accnt,price)}   \ } $\\
$  \{\  \ \  {\prg{this.\myAccount.\balance}} \geq  b \  \  \}\ .... $ 
\end{flushleft}
\end{minipage}
 
The intuitive reasoning is as follows: if the shop's account's key is protected from \prg{buyer} (\ (A ) from earlier\ ), and the module satisfies $S_3$ (\ (B) from earlier\ ), then after the call, the account's balance will not decrease  (\ (C )from earlier\ ).
%
However, application of $S_3$ is not straightforward. 
%While $S_3$ preserves ${\inside{\prg{a.key}}} \wedge ...$,
%Application of $S_3$ 
It requires ${\inside{\prg{a.key}}} \wedge ...$,  but  the call's precondition only guarantees $\protectedFrom{\prg{this.\myAccount.key}}{\prg{buyer}}$. 
%To apply $S_3$, we would need to know ${\inside{\prg{this.\myAccount.key}}}$, but we only know $\protectedFrom{\prg{this.\myAccount.key}}{\prg{buyer}}$.


%, while we  need the stronger property  ${\inside {\prg{this.\myAccount.key}}}$. 

While we do not know whether \prg{a.key} is protected during  execution of \prg{buy}\footnote{For instance, one of the clients may have access to it.}, we can be certain it is protected during execution of \prg{pay}.  This is so, because the objects accessible during \prg{pay} are those visible from its arguments (\ie \prg{buyer} and \prg{price}).
% \footnote{Generally, more objects are protected from the viewpoint of the \sue{callee} than from that of the caller -- \cf  Fig. \ref{fig},}

%To express this difference, 
We define the adaptation operator $\FIXSymbolA$, which translates an assertion from the viewpoint of the callee (the called function) to that of the caller. 
Specifically, $\PushAS y A$ ensures that $A$ holds when the variables $\overline{y}$ (where $\overline{y}$ stands for $y_1, ..., y_n$) have been pushed onto a new frame -- see Lemma \ref{lemma:push:ass:state}.
 {Below  a  Hoare logic rule  dealing with external calls - \cf. Fig.\ref{f:external:calls}.} % where $\overline y$ stands for $y_1$,,, $y_n$ -
 
 \begin{minipage}{.05\textwidth}
   \textbf{(2)}
\end{minipage}
\hfill
\begin{minipage}{.95\textwidth}
\begin{flushleft}
 $\inferruleNoName  
 	{ 
   	   {\TwoStatesN {\overline {x:D}} {A}}\ \   \mbox{is part of $M$'s specification}
        }
	{    \hprovesN{M} 
						{ \    { \external{y_0}} \,     \wedge \,  \overline{x:D}\  \wedge\ {\PushASLong {{(y_0,\overline {y})}}  {A}}  \ } 
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \   {\PushASLong {{(y_0,\overline {y})}}  A}  \ }
						{\  A \   }         }
$
\end{flushleft}
\end{minipage}

 \noindent
We take   $y_0 \triangleq \prg{buyer}$,\  $\overline {x : D}\triangleq \prg{a}:\prg{Account},\prg{b}:\prg{int}$, 
\ $A \triangleq  \inside{\prg{a.\pwd}}\wedge \prg{a.\balance}\geq \prg{b}$, \ 
$m \triangleq \prg{pay}$,\ and $\overline {y} \triangleq \prg{this.accnt},\prg{price}$. 
\\
Moreover, $\PushAS y {\inside \re} = \protectedFrom \re {\overline{y}}$ for any term $\re$ and variables $\overline y$ 
-- see  Def. \ref{def:push}.
Therefore:\\
   {\small{$\strut \ \ \ \PushASLong {\{\prg{buyer},\prg{this.\myAccount},\prg{price}\}}  {(\inside {\prg{this.\myAccount.key}})}$}} \ = 
    \begin{flushright}
 {\small{$\strut \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \   \protectedFrom {\prg{this.\myAccount.key}} {(\prg{buyer},\prg{this.\myAccount},\prg{price})}$}}.
 \end{flushright}
 
 \noindent
 The type information gives us that:\\
  {\small{$\strut \ \ \ \protectedFrom {\prg{this.\myAccount.key}} {\prg{this.\myAccount}}\ = true \ =  \protectedFrom {\prg{this.\myAccount.key}} {\prg{price}}$}}\\
  Hence\\
  {\small{$\strut \ \ \ \protectedFrom {\prg{this.\myAccount.key}} {(\prg{buyer},\prg{this.\myAccount},\prg{price})}$ 
 \ = \  $\protectedFrom {\prg{this.\myAccount.key}} {\prg{buyer}}$.}} \\
We use the above, we apply the external method call inference rule \textbf{(2)}  and obtain \textbf{(1)}.
 %
 

 
\subsection*{Summary}

In our threat model, external objects can execute arbitrary code, invoke any public internal methods,  potentially access any other external object, and may collude with one another in any conceivable way.
The external code may be written in the same or a different programming language than the internal code -- all we need is that the platform protects direct external read/write of  the internal private fields, while allowing indirect manipulation through calls of public methods.
Our specifications are conditional: while they do not guarantee that specific effects will never occur, they  ensure that the effects will only happen if specific conditions were met. % prior to the execution of the external code.



The conditional, scoped,  nature of our invariants might raise the question of their usefulness.
 Indeed, scoped invariants are not meant to guarantee that effects will never happen. 
 But they do guarantee that effects will only happen in contexts where specified conditions are stratified.
 For example,   $a.\prg{\balance}$ may very well decrease in the future, but will only do so in contexts where some external object has direct access to  $a.\prg{key}$. 
 Ensuring this, is the remit of the internal module.
 % something good does hold. 
 % Nevertheless, they do give the guarantee that something good does not get broken.
 
 
The key ingredients of our work are: a) the concepts of protection ( $\inside {x}$) and $\protectedFrom {x} {y}$), b) \scoped invariants (${\TwoStatesN {\overline {x:D}} {A}}$), and c) the adaptation operator ($\FIXSymbolA$).
In the remaining sections, we discuss all this in more detail.

% \vspace{0.1cm}
% \noindent
 

 
\footnoteSD{Do we want to talk about the challenges in the proof, and the fact that we reason using sufficient but have necessary in mind.}
\forget{The proof that the extended Hoare logic is sound is interesting, because we are arguing about the soundness of two interrelated systems: 
 the per-statement  Hoare logic, as well as the {entire} module's logic.
Moreover, we need to cater for the possibility that external calls eventually call public methods of the module, which in their turn make external calls etc.
For this we define a new measure of execution ...}


 

 



 
 
