
\section{Proving Adherence to \SpecLang Specifications}

\subsection{Semantics of  a Hoare Triples -- Soundness of Hoare Logic}

We will develop a  Hoare logic with judgments of the form  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ which promise that execution of the expression $e$ in a configuration with satisfies $A$ will lead to a configuration that satisfied $A'$. 


\begin{axiom}
We assume a judgment of the form $M \vdash A$, which had the property that\\
\strut \hspace{5cm} $M \vdash A $ \ \ \ \ implies \ \ \ \ $M \vDash A$
\end{axiom}


\subsection {Assertion Encapsulation}
\label{s:encaps-proof}

{
{\SpecLang proofs  hinge on the fact that some assertions cannot be invalidated unless some 
} internal (and thus known)
computation took place. 
{We refer to this property as \emph{Assertion Encapsulation},}
}
formally $M\ \vDash  \encaps{A}$, which states that 
 assertion $A$ is encapsulated by module $M$.


\subsubsection{Semantics of Assertion Encapsulation}

{An assertion $A$  is  encapsulated by a module $M$ under condition $A'$,
if in all possible states which arise from execution of module $M$ with any other external module $M_{ext}$, and which satisfy $A'$, 
the validity of $A$} 
{ can only be changed via computations internal to that module} -- \emph{i.e.},  via a call to
a method from $M$, i.e.,
calls to objects defined in $M$ but accessible from the
outside.


\begin{definition}[Assertion Encapsulation]
\label{def:encapsulation}
An assertion $A$ is \emph{encapsulated} by module $M$ and assertion $A'$, written as
\begin{itemize}
 \item     $M\ \vDash \encaps{A}$
 \end{itemize}
if, for all external modules $M_{ext}$, and all states $\sigma$, $\sigma'$
such that $\arising{M_{ext}}{M}{\sigma}$, {and variables $\overline{x}$ and objects $\overline{o}$}:

\begin{itemize}
 \item
  $\satisfiesA{M}{\sigma}{A}$,  \ \ \ \   $\overline{x}=Free(A)$, \  \  \ \ $\overline{o}=\sigma(\overline{x})$,\ \ \ \ $\reduction{M_{ext}}{M}{\sigma}{\sigma'}$, \ \ \ ${M},{\sigma'[\overline{y}\mapsto{\overline{o}}]}\not\vDash{A}$
 \end{itemize}

implies

 \begin{itemize}
 \item   $\exists y,\,m,\, \overline{y} .[\ \sigma.\prg{cont}= y.m(\overline{y})\ \wedge\  \satisfiesA{M}{\sigma}{\internal{y}} \ ]
$
 \end{itemize}
\end{definition}

Revisiting the examples from \S~\ref{s:outline}, % we can see
both \ModB and \ModC encapsulate   the  equality of the \prg{balance} of an account to some value \prg{bal}: 
Namely, this equality can only be invalidated through calling  methods on internal objects.
 
{On the other hand, assume two further modules, $Mod_{ul}$ and $Mod_{pl}$: both these modules use ledgers to keep a map between accounts and their balances, which export functions that allow the update of this map. In $Mod_{ul}$ the ledger is \emph{not} protected, while in $Mod_{pl}$ the ledger \emph{is} protected. Then, in the former, the and the balance of an account is \emph{not} encapsulated, and in the latter it  \emph{is} encapsulated. } 
%
\\
\strut \hspace{1cm}
$\ModB\ \vDash\ \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm}
$\ModC\ \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm} {$Mod_{ul}\ \not\vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}
\\
\strut \hspace{1cm} {$Mod_{pl}\  \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}

\noindent
{Note that in the above, the term \prg{a.balance} is a ghost field.}



The property that a variable is protected from another one is not encapsulated, but  the property that a variable is protected \emph{is} encapsulated, regardless of the module. Note also, that  encapsulation of an assertion does not imply encapsulation of its negation; 
 for example,  ${\inside{x}}$ is encapsulated (as per below), but $\neg  {\inside{x}}$ is not.


\begin{lemma}
For any module $M$, and variables $x$ and $y$:
\begin{enumerate} 
\item $M \vDash \encaps{\inside{x}}$
\item $M \not\vDash {\encaps{\neg\inside{x}}}$
\item $M \not\vDash {\encaps{\protectedFrom{x}{z}}}$
\item $M \vDash A \rightarrow A' \ \ \wedge\ \  M \vDash  \encaps{A}$ \ \ implies \ \ $M \vDash  \encaps{A'}$.
\end{enumerate}
\end{lemma}

\begin{proof} Sketches:

(1) because if $y$ is protected, and since the fields are all private ... the only way .. 
\\
(2) Take a state where $\neg\inside{x}$ and that there is only external object that has access to $x$, and that this object becomes no longer accessible -- eg through field override. That means that we now have  $\inside{x}$.
\\
(3) it is always possible that another external object $z'$ has unprotected access to $x$; if $z'$ has access to $z$, then it can give it access to $x$ without invoking am internal method. (3) as a counterexample, 
\\
(4) Use that $M \vDash A \rightarrow A'$ implies $M \vDash \neg A'  \rightarrow \neg  A$. BUT CAREFUL, TODO! with the potential of non-termination on assertions!!
\end{proof}
%The key consequence of soundness is that -- SD dropped; it is   not a consequence of soundness!

\subsubsection{Deriving  Assertion Encapsulation}

{In general},  code that does not contain 
calls to a {given} module is guaranteed not to invalidate any assertions encapsulated by that module.
 Assertion encapsulation has been used in proof systems to {address}   the  {frame} problem
 \cite{objInvars,encaps}. 

We  do not mandate how this property should be derived -- instead, we rely on a judgment 
$M\ \vdash  \encaps{A}$ provided by some external system. \footnoteSD{This is simpler than the oopsla-33 setting}
Thus, \SpecLang is parametric over the derivation of the encapsulation
     judgment; in fact, several ways to do that are possible \cite{TAME2003,ownEncaps,objInvars}. For example,
 the appendices of
    \cite{necessityFull} present a 
	%Appendix~\ref{s:encap-proof} and
    %Figure~\ref{f:asrt-encap}  we present a 
    rudimentary system that is sufficient to support our example
    proof.  


%As we have already stated at the beginning of this section,
%encapsulation is a deep topic that is well studied in the literature, 
%and is not the focus of this paper. For now, we simply assume the existence 
%of a proof system for encapsulation as it is secondary to the central topic 
%of this paper. We need only assert that such an algorithmic proof system 
%must be sound (Definition \ref{lem:encap-soundness}).
%% \susan[I commented out what was there as I thought it was repetious]
%% {We are assuming the existence of a proof system for encapsulation and only need to assert that such an algorithmic proof system nust be sound.}
%% The construction of the algorithmic system is not central to our work,
%% because, as we shall see in later sections, our logic 
%% does not rely on the specifics of an encapsulation algorithm, only its soundness.

Like OOPSLA 22 Our logic does not {deal with, nor} rely on, the specifics of  how   encapsulation
{is derived}.
  % model, 
{Instead, it relies} on an encapsulation judgment and expects it to be sound:

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A$:\\

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ $ implies $\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{definition}




\subsubsection{Types for Assertion Encapsulation}
\label{types}
TODO: something simple ere 

\subsection{Assertion Inference}




\subsection{Weaker/Stronger Specifications}

We assume   the existence of a function $HS$ which allows us to look up the holistic specification of a module. 
In Figure \ref{fig:si} we   define a judgment $\stronger M S  {S'}$ which expresses that the specification $S$ is stronger than the specification $S'$ under module $M$.  

\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lclclcl}
\inferrule [HS-1]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_1}
	}
&  & 
\inferrule [HS-2]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_2}
	}
	&  & 
\inferrule [HS-3]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_2 \wedge S_1}
	}
&  & 
\inferrule [HS-4]
	{ 
	{\strongerI M {S_1}  {S_3}}
	}
	{\strongerI M {S_1 \wedge S_2}  {S_3 \wedge S_2}
	}
\\
\end{array}
\\
\\	
\inferrule [HS-5]
	{ \\ 
	M \vdash ({\overline {x:C}} \wedge A_1) \rightarrow A_1' \ \hspace{.5cm} M \vdash ({\overline {x:C}} \wedge A_2') \rightarrow A_2 }
	{\strongerI M   {\TwoStatesQ {\overline {x:C}} {A_1'}{A_2'} }   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2} }
	}		
\end{array}
$
\label{fig:si}
\caption{Specification Implication}
\end{figure}

\begin{lemma}
For all modules $M$, and specifications $S$ and $S'$, we have that\\
\strut \hspace{2cm} $\strongerI M  S  {S'}    \ \ \ \ \Longrightarrow\ \ \ \ \stronger M S {S'}'$
\end{lemma}

We now define what it means for a module $M$ to promise a specification $S$:

\begin{definition}
Given module $M$ snd specification $S$:

\strut \hspace{2cm} $\promises M S$ \ \ \ \  iff \ \ \ \  $\strongerI M {HS(M)} S$
\end{definition}

Notice, that $\promises M S$ is only based on the spec of $M$, and does not guarantee that indeed $M$ satisfies $S$.

%\subsection{Proving method bodies while using  \AssertLang specifications}
%\label{s:classical-proof}
% 
%We now develop a Hoare logic, which can prove assertions of the from \\
%\strut \hspace{1cm} $\hproves{M}{A}{\prg{s}}{A'}$.\\
%where \prg{s} is a statement in \Loo, and $A$ and $A'$ are assertions in \AssertLang.
%
%The challenges here are 1) that \AssertLang assertions support, on top of the classical features, also ??what-shall-we-call-them? protection features, and 2) we need to reason about calls to external modules.
%
%
%We assume that there exists some
%proof system  that   allows us to prove 
% specifications of the form  $\hproves{M}{A}{\prg{s}}{A'}$.
%{We further assume that such a proof system is sound, i.e. that 
%if xxx TODO 
%% if $\hproves{M}{\hoare{P}{\prg{res = x.m($\overline{z}$)}}{Q}}$, then 
%% for every program state $\sigma$ that satisfies $P$, the execution of the method call \prg{x.m($\overline{z}$)}
% % esults in a program state satisfying $Q$.}
% We then expand the proof rules as follows ....
 


\subsection{Reasoning about protection}
We expand that logic with rules about protection, as in Fig. \ref{f:protection}. Essentially, the only what that the "protection" of an object can decrease is if we call an eternal method, and pass it an internal object as argument. This is then covered by the rule in Fig. \ref{f:external:calls}.

\begin{figure}[hbt]
$
\begin{array}{c}
\inferrule[\sc{prot-1}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge \ \internal y }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\sc{prot-1}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge \ \internal v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-2}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\  \wedge\ \internal {y'} \ \wedge\  x \neq y'}
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

	\inferrule[\sc{prot-3}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\  \protectedFrom{x}{y'} }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%	\inferrule[\sc{prot-2}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge\ \external v\ \wedge\  z\neq v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\


%	\inferrule[\sc{prot-4}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{v}\ \wedge\ \external z\  }
%						{\ z=v\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-4}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\ z \neq \this}
						{\ y =y'.f\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\textsc{prot-5}]
%	{}
%	{\hproves{M}
%			{}
%	}
\end{array}
$
\caption{Protection Logic \sdN{-- the rules will probably change; Julian is working on this}}
\label{f:protection}
\end{figure}

 

Explanations: \textsc{xxxl} states that   yyy

\subsection{Hoare Logic -- substructural rules}

We assume that $M \vdash_{ul} \{ A \} s \{ A' \}$ is a judjement that comes with the underlying programming language.  On top this, we define our extension, with shape ${   \hproves{M}  {A} s {A'}}$. The rules for this extension appear in Figures \ref{f:protection}, \ref{f:calls} and \ref{f:substructural}.


\sdN{
\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lcl}
\inferrule[\sc{extend}]
	{ M \vdash_{ul} \{ \ A\ \} s \{\ A'\ \} }
	{\hproves{M}  {A} s {A'} }
	& &
\inferrule[\sc{combine}]
	{  \hproves{M}  {A_1} s {A_1'}  \ \ \  \hproves{M}  {A_2} s {A_2'} }
	{ \hproves{M}  {A_1 \wedge A_2 } s {A_1' \wedge A_2'} }
%\end{array}
\\
\\
\inferrule[\sc{sequ}]
	{  \hproves{M}  {A} {s_1} {A''}  \ \ \  \hproves{M}  {A''} {s_2} {A'} }
	{ \hproves{M}  {A } {s_1; s_2}  {A'} }
& &
\inferrule[\sc{consequ}]
	{ M \vdash A \rightarrow A'' \ \ \  {\hproves{M}  {A''} s {A'''} } \ \ \ M \vdash A''' \rightarrow A'  }
	{\hproves{M}  {A} s {A'} }
 \end{array}
  \end{array}
 $
\caption{From Underlying to Extended Hoare Ligic}
\label{f:substructural}
\end{figure}
}
 
\subsection{Reasoning about calls}

We now show how to reason about method calls, internal as well as external

\begin{figure}[hbt]
$\begin{array}{c}
\sdN{
\inferruleSD{\hspace{4.7cm} [\sc{IntCall}]}
	{ 
	   	M, C, m  :  (\, A_1, \ A_2\, )\ \ \  \ \ \ \ \ fv(A_1)=\overline x
          		}
	{   \hproves{M} 
						{ \ {\internal{y}}  \wedge  y:C  \ \wedge \ A_1[(y, \overline y)/\overline x] \  }
						{ \ u:= y.m(\overline y)\  }
						{ \  A_2[(y, \overline y)/\overline x, u/result ]  \ }	
}
}
\\
\\
\sdN{{
\inferruleSD{\hspace{4.7cm} [\sc{ExtCall1}]}
	{ 
         	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
   	}
	{   \hproves{M} 
						{ \ {  \external{z}  } \ \wedge\ \overline {x:C}\ \wedge\ A_1 \  }
						{ \ u:= z.m(\overline y)\  }
						{ \  A_2  \ }	
}
}}
\\
\\
\sdN{{
\inferruleSD{\hspace{4.7cm} [\sc{ExtCall2}]}
	{ 
   	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
           \\
		\PushALong M  A  {(z,\overline y)} (\  { {\overline {x:C}}\ {\wedge\ A_1}} \  )	\ \ \ \ \ \ \ \ \ \ \ \    
		\PopA  {(z,\overline y)}  {A_2} {A_2'}   
		}
	{   \hproves{M} 
						{ \ {  \external{z}  }\ \wedge\ A\  }
						{ \ u:=z.m(\overline y)\  }
						{ \  A_2'  \ }	
}
}}
\\
\\
\begin{array}{lcl}
\sdN{
\inferruleSD{  [\sc{Call1}]}
	{ 
	{ ~ \strut ~ }
	}
	{   \hproves{M}  { \ x=x'\  } 	{ \ u:= y.m(\overline y)\  } { \  x=x'\ }	 }
}
& &
\sdN{
\inferruleSD{ [\sc{Call2}]}
	{ 
		{ ~ \strut ~ }
	}
	{   \hproves{M}  { \ x\neq x'\  } { \ u:=y.m(\overline y)\  } { \  x\neq x'\ }	}
}
\end{array}
\end{array}
$
\caption{Internal and External Calls Logic}
\label{f:calls}
\label{f:external:calls}
\end{figure}

\sdN{in Fig. \ref{f:external:calls} we use 	$ M, C, m  :  (\, P, \ Q\, )  $ to indicate that the declaration of method $m$ for class $C$ in module $M$ includes the per-post-condition pair  $(\, P, \ Q\, ) $.}

\sdN{
\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lclcl}
\inferrule [PU-1]
	{  
	\\	
	}
	{
	  \PushA M  {e}  {y}  {e}  
	}
&  & 
\inferrule [PU-2]
	{ 
	  \PushA M  A  {y}  {A'}
	}
	 {
	  \PushA {M}  {\neg A } {y}  {\neg A' }  
	}
&  & 
\inferrule [PU-3]
	{ 
	  \PushA M  A  {y}  {A'} \ \ x\notin \overline y
	}
	 {
	  \PushA {M} { \forall x.[A] } {y}  { \forall x.[A'] }
	}
\\ \\
\end{array}
\\
\\
\begin{array}{lcl}
\inferrule [PU-3]
	{ 
	{ \PushA M  {A_1}  {y}  {A_1'} }\ \ \ \  { \PushA M  {A_2}  {y}  {A_2'} }
	}
	{  \PushA  M {(A_1 \wedge A_2)}  {y} {(A_1' \wedge A_2')}
	}
& &
\inferrule [PU-5]
	{  
	\\	
	}
	{
	  \PushA M  {( \inside x)}  {y}  {( \inside x)} 
	}
\\ \\  
\inferrule [PU-6]
	{  
	\overline y \subseteq \overline u\ \ \ \  \  \ \ \ x\notin  \overline y	
	}
	{
	  \PushA M  {(\protectedFrom x {\overline {u}}) }  {y}  { (\inside x)} 
	}
& &
\inferrule [PU-7]
	{  
	\\ % \overline y \subseteq \overline u \ \ \ x\notin  \overline y	
	}
	{
	  \PushA M  {(\protectedFrom x {\overline {u}} )}  {y}  {(\protectedFrom x {\overline {u}}) } 
	}
\\ \\
\end{array}
%\\
% Wrong format
%\\
%\inferrule[PU-8]
%	{  
%	M \vdash A \rightarrow A'  \ \ \ \  \  \  \PushA M {A'} y  {A''} \ \ \ \ \ \  M \vdash {A''} \rightarrow {A'''}
%	}
%	{
%	  \PushA M  {A }  {y}  {A'''}
%	}
\end{array}
$
\label{fig:si}
\caption{The judgement  $\PushA M  {A }  {y}  {A'}$}
\end{figure}
}


\sdN{
\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lclcl}
\inferrule [PO-1]
	{  
	\\	
	}
	{
	  \PopAA {\overline y}   {e}     {e}  
	}
&  & 
\inferrule [PO-2]
	{ 
	  \PopAA  {\overline y}  A    {A'}
	}
	 {
	  \PopAA {\overline y}    {\neg A }  {\neg A' }  
	}
	&  & 
\inferrule [PO-3]
	{ 
	{ \PopAA {\overline y}  {A_1}    {A_1'} }\ \ \ \  { \PopAA {\overline y}  {A_2}    {A_2'} }
	}
	{  \PopAA  {\overline y} {(A_1 \wedge A_2)}     {(A_1' \wedge A_2')}
	}
\\
\\
\sdN{
\inferrule [PO-4]
	{  
	\\	
	}
	{
	  \PopAA {\overline y}  {\inside x}    {(\protectedFrom x {\overline {y}})}
	}
}
&  & 
\inferrule [PO-5]
	{  
	\\
	}
	{
	  \PopAA  {\overline y} {(\protectedFrom x {\overline {u}})}    {(\protectedFrom x {\overline {u}})}  
	}
 &  & 
 \\ \\
\end{array}
%wrong fornt
% \inferrule[PO-7]
%	{  
%	M \vdash A \rightarrow A'  \ \  \  \  \PopAA  M {A'}    {A''} \ \ \ \  M \vdash {A''} \rightarrow {A'''}
%	}
%	{
%	  \PopAA M  {A }     {A'''}
%	}
\end{array}
$
\label{fig:si}
\caption{The judgement  $\PopAA {\overline y}   {A }     {A'}$}
\end{figure}
}

\newpage 

vvv

\newpage

vvv

\newpage

%\newcommand{\PushAS}[2] {\ensuremath{ \overline{#1} \pushSymbol  #2}} % for assertionbs
%\newcommand{\PushASLong}[2] {\ensuremath{  #1  \pushSymbol #2}}
%\newcommand{\PushS}[2] {\ensuremath{ \overline{#1} \pushSymbol  #2}} % for states
%\newcommand{\PushSLong}[2] {\ensuremath{  #1  \pushSymbol #2}}
%\newcommand{\PopAS}[2] {\ensuremath{  \overline{#1}   \popSymbol #2}} % for assertionbs
%\newcommand{\PopASLong}[2] {\ensuremath{ #1   \popSymbol #2}}
%\newcommand{\PopS}[2] {\ensuremath{  \overline{#1}   \popSymbol #2}} % for states
%\newcommand{\PopSLong}[2] {\ensuremath{ #1   \popSymbol #2}}

% Same as above but reversed the order
\newcommand{\PushAS}[2] {\ensuremath{ {#2} \pushSymbol   \overline{#1} }} % for assertionbs
\newcommand{\PushASLong}[2] {\ensuremath{  #2  \pushSymbol #1}}
\newcommand{\PushS}[2] {\ensuremath{ \ {#2} \pushSymbol   \overline{#1} }} % for states
\newcommand{\PushSLong}[2] {\ensuremath{  #2  \pushSymbol #1}}
\newcommand{\PopAS}[2] {\ensuremath{   {#2}   \popSymbol \overline{#1} }} % for assertionbs
\newcommand{\PopASLong}[2] {\ensuremath{ #2   \popSymbol #1}}
\newcommand{\PopS}[2] {\ensuremath{   {#2}   \popSymbol  \overline{#1} }} % for states
\newcommand{\PopSLong}[2] {\ensuremath{ #2   \popSymbol #1}}

\subsection{Alternative Presentation for external call}

In the below, the push- and pop- relations on assertions have now become functions,   \sdN{namely\\
 $ \strut \ \ \ \ \ \   \pushSymbol : Vars \times Assert \rightarrow Assert $, \  and\  $\popSymbol : Vars \times Assert \rightarrow Assert $. }


We get the below, which is elegant, but
perhaps deceptively simple.

$
\\
\sdN{{
\inferruleSD{\hspace{4.7cm} [\sc{ExtCall2Alternative}]}
	{ 
   	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
        }
	{   \hproves{M} 
						{ \ {  \external{y_0}  }\ \wedge \ \PushAS  {y} {( \overline {x:C}  \ \wedge\ A_1)} \   }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \ \PopAS  {y} { A_2}  \ }	
}
}}
\\
\\
$

\noindent 
We now define the two  operators  \\
 $ \strut \ \ \ \ \ \   \pushSymbol : Vars \times Assert \rightarrow Assert $, \  and\  $\popSymbol : Vars \times Assert \rightarrow Assert $  \\
 as below



$
\begin{array}{c}
\begin{array}{lclcl}
\\ \\
\PushAS y  e\  =\  e & & \PushAS y   {(A_1  \wedge  A_2)}\   =\   \PushAS y  { A_1}  \wedge   \PushAS y  {A_2}  & & 
 \PushAS y { (A_1 \vee  A_2)}\  = \  \PushAS y {A_1}  \wedge  \PushAS y {A_2}  \\
... & & ... &  & ... 
 \\
& &  \sdN{\PushAS y {\inside x}  \ = \ \protectedFrom x {\overline {y} \ \wedge\ x\neq y_o} }
%  \\
& &   \PushAS y {(\protectedFrom x {\overline {y'}})} \ = \ \protectedFrom x {(\overline {y'}\setminus \overline {y})} 
  \\
  \\
\PopAS y  e\  =\  e & & \PopAS y   {(A_1  \wedge  A_2)}\   =\   \PopAS y  { A_1}  \wedge   \PopAS y  {A_2}  & & 
 \PopAS y { (A_1 \vee  A_2)}\  = \   \PopAS y {A_1}  \wedge   \PopAS y {A_2}  \\
... & & ... &  & ... 
 \\
& &  \sdN{ \PopAS y {\inside x}  \ = \ \protectedFrom x {\overline {y} \ \wedge\ x\neq y_o} }
%  \\
& &   \PopAS y {(\protectedFrom x {\overline {y'}})} \ = \ \protectedFrom x {(\overline {y'}\setminus \overline {y})} 
  \\
  \\
  \\
\end{array}
\end{array}
$

\vspace{.2cm}
\blue{ I am perplexed that it seems that $ \PushAS {y} {A}=\PopAS {y} {A}$. More thinking needed}

\vspace{.2cm}

We write $\PushS {y} {\sigma}$ for the set of states that is the result of pushing the values of $\overline y$,
and for 
 And then the corresponding lemma says something related but sightly different than Lemma \ref{lemma:lifts} and \ref{lemma:lowers} from earlier:



\sdN{
\begin{lemma} 
For any states  $\sigma$, $\sigma'$, assertion $A$,  and variables $\overline x$, $\overline y$, $\overline z$ disjoint with one another,  and such that 
% $\overline x \notin \sigma$ and 
$fv(A)\subseteq \overline x$:
\begin{itemize}
 \item
$M, \sigma \models \PushAS {y} {A}\ \ \wedge \ \ \sigma'\in\PushS {y} {\sigma} \ \ \   \Longrightarrow  \ \ \ \ M, \sigma'[\overline{x \mapsto {\interpret {\sigma} {x}}} ] \models {   A} $
\item
$M, \sigma   \models A \ \ \ \wedge \ \ \sigma'\in\PopSLong {(\overline y, \overline {z})} {\sigma} \ \ \ \Longrightarrow  \ \ \ \ M, \sigma'[\overline{x \mapsto {\interpret {\sigma} {x}}} ]  \models \PopAS  {y} {A}$
\end{itemize}
\end{lemma}
}

\vspace{.2cm}
\textbf{Question} Shall we use the notation $\sigma s[ \overline{x \mapsto v}]$ where $ \sigma s$ is a set of states, to indicate the set of states from $\sigma s$ to which we applied the substitution?
And shall we use the notation 
$M, \overline \sigma s \models A$ when $\sigma-s$ is a set of states, and  $M, \overline \sigma \models A$ for all $\sigma \in \sigma s$?
 If we did adopt  such a notation,  then we could  simplify the first part of the  lemma from above as below:

\begin{itemize}
 \item
$M, \sigma \models \PushAS {y} {A}\ \ \ \ \ \ \   \Longrightarrow  \ \ \ \ M,  (\PushS {y} {\sigma})[\overline{x \mapsto {\interpret {\sigma} {x}} } ] \models A$
\end{itemize}
 

\noindent
And we could also simplify the second part as
\begin{itemize}
 \item
$M, \sigma   \models\  A \  \ \ \ \Longrightarrow  \ \ \ \ M,  (\PopSLong  {(\overline y, \overline {z})} {\sigma})[\overline{x \mapsto {\interpret {\sigma} {x}} } ] \models  \PushAS  {y} {A}$
\end{itemize}

Or, perhaps as 

\begin{itemize}
 \item
$M, {\PushSLong {(\overline y, \overline z)} \sigma }   \models\  A \  \ \ \ \Longrightarrow  \ \ \ \ M,  \sigma[\overline{x \mapsto {\interpret {\sigma} {x}} } ] \models  \PushAS  {y} {A}$
\end{itemize}

\vspace{.2cm}
{\red{
I am copying the old lemmas here for easy comparison

  \begin{lemma}
Take any  module $M$, states $\sigma$, $\sigma'$, assertions $A$, $A'$,    variables $\overline x$ and $\overline z$, where
 $fv(A') \subseteq \overline x$, and $ \overline x \notin \sigma'$.
 If
\begin{itemize}
\item
  $ \satisfiesA {M} {\sigma}  {A$
  \item
  $\PushA M A {z} (\overline {x : C}} \wedge A')$  
  \item
  $\Pushes {\sigma} {\interpret {\sigma} {z}} {\sigma'}$ 
 \end{itemize}  
 then
 \begin{itemize}
\item
$ { \satisfiesA {M} {\sigma'[\overline {x \mapsto {\interpret \sigma x}}]}  {\overline {x : C} \wedge A'}}$
\end{itemize}
 
\end{lemma}
 }}
 
 {\red{
  \begin{lemma}
Take any  module $M$, states $\sigma$, $\sigma'$, assertions $A$, $A'$,  
  and variables $\overline x$ and $\overline z$, where
 $fv(A') \subseteq \overline x$, and $ \overline x \notin \sigma'$. If 
 \begin{itemize}
\item
$ \satisfiesA {M} {\sigma'[\overline {x \mapsto {\interpret {\sigma} x}}] }  {\overline {x : C} \wedge A'} $
\item
$\PopA  {\overline y}  {A'}  A$  
\item
$\Pops {y}   {\sigma'} {\sigma}$. 
  \end{itemize}

 then
\begin{itemize}
\item
$ { \satisfiesA {M} {\sigma}  {\overline {x : C} \wedge A}}$
\end{itemize}

\end{lemma}
}}


\newpage 

\subsection{Proving \SpecLang Specifications}

\subsubsection{Deriving sub-specifications}


\label{s:module-proof}

\begin{figure}[thb]
%\footnotesize
$
\begin{array}{c}
\inferrule [Two-State]
	{
	\\\\
	M \vdash \encaps{\overline {x:C}\, \wedge \, A}
	\\\\
	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
				% \strut \hspace{3cm}
				\ \  {\hproves{M}{ \overline{x:C}\ \wedge \ A\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A\ }} \ \parallel \  A 
	}
	{
	M\ \vdash\ {\TwoStatesQ {\overline {x:C}} {A} {A} }
	}
\\\\
\inferrule [External-Safe]
	{
		A_{ois}=\overline{\OneStateQ{\overline {y:C}}{A''}}\ \mbox{all object invariants in } HS(M)\ \ \ \ \ \ \ \  A_{strng}=A_{ois}\wedge A' 
		\\\\
 		 \hproves{M} {A_{strng} } {\ s\ } {\ A\ } \
 		\\\\ 	
				\forall  s', z, m.[\ \ 
				 (\  s = s'; z.m(\_); \_\ \wedge \ 
				  \hproves{M} {A_{strng}\ } {\ s'\ } {\  \external{z}\  }  \ \ \
				  \Longrightarrow\ \ \ \hproves{M}{A_{strng} } {\ s'\ } {\ A\ } \ \ ]
	}
	{
	{\hproves{M}{ A'}   {\ s\ } {\ A\ } }\  \parallel \  A   
	}
%\\\\ 
%\inferrule [One-State]
%	{
% 	M \vdash \encaps{\overline {x:C}\, \wedge \, A}
% 	\\\\
% 	\forall \mbox{ public } D. [\ \hproves{M}{\forall \overline{x:C}.[A]} {\ y=\prg{new}\ D\ } {\ \forall \overline{x:C}.[A]\ }	\ ]
%   \\\\
% 	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{ with } \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
%%				% \strut \hspace{3cm}
% 			\ \  {\hproves{M}{ \forall \overline{x:C}.[A]\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ \forall \overline{x:C}.[A]\ }} \ \parallel \  {\forall \overline{x:C}.[A]} 
%	}
%	{
%	M\ \vdash\ \OneStateQ{\overline {x:C}}{A}
%	}
\\\\
\begin{array}{lcl}
\inferrule[Weaken]
{
M \vdash S \\ \strongerI M S {S'}
}
{
M \vdash S'
}
&\ \ \  &
\inferrule[Multi]
	{
	M\ \vdash\ S 
	\\
	M\ \vdash\ S' 
	}
	{
	M\ \vdash\ S \wedge S'
	}
\end{array}

\end{array}
$
\caption{Inferring that module satisfies its specification}
\label{f:module:invariats}
\end{figure}

TODO: Does the consequence rule require that the assertions are encapsulated? And if an assertion is encapsulated, is its consequence also encapsulated?

The rules also require that the variables in the quatifiers do not appear in the bodies, and are disjoint from the parameters.
TODO explain. Also, we only look at the methods exported from the module.  Also, we ned to add some dynamic type checking to the language, ie the method call crashes if actual params do not fir the formal types. OR we type them all as \prg{Object}.

TODO: shall we drop one-state invariants? Do not know how to prove them here. But they are in the spirit of capabilities literature.

%\subsection{Soundness of the \SpecLang Logic}
%
% 
%\label{s:soundness}
%
%We will now prove soundness of the  \SpecLang Logic. For this, we will first prove soundness of our extended Hoare logic.
%
%
%\begin{lemma}
%Assuming a sound \SpecO proof system, $\proves{M}{A}$, and  and
%a sound encapsulation inference system, $\proves{M}{\encaps{A}}$. Then:
%\begin{itemize}
%\item
%The inference system  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$  defined in the previous section is sound.
%\end{itemize}
%\end{lemma}
%
%\begin{proof}
%Take arbitrary modules  $M$, $M'$, expression $e$,  assertions $A$, $A'$ and $A''$ and assume
%\begin{enumerate}
%\item
% $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ 
% \item
% $M,\sigma \ \models \ A$
% \item
%$ \sigma.cont$=$e$ 
%\item
%$M\circ M', \sigma \leadsto^* \sigma' \ \ \wedge\ \ \sigma'.cont$ is a value
%\end{enumerate}
%We want to show that
%\begin{enumerate}
%\item
%$M,\sigma' \ \models \ A' $
%\end{enumerate}
%The proof proceeds by induction over a lexicographic ordering over the tuples $(M, A, e, A', \sigma, \sigma')$ This ordering is the tuple of ($m_{cl}$, $m_{ext}$), where 
%$m_{cl}$ is the length of the maximal sequence of proof steps in "classical Hoare logic, ie excluding a step {\sc{ExtCall}} involved in proving that  ie excluding a step {\sc{ExtCall}}, and the $m_{ext}$ is the number of external calls that occurred ... {TODO: this needs to be refined!}
%
%\end{proof}

For the proof of soundness we will use the following two lemmas that give guarantees about preservation of properties when pushing new frames onto the stack, and when popping frames from the stack. We use the notation $\sigma \bullet \phi$ to indicate that the frame $\phi$ has been pushed on top of the ...\footnoteSD{{these lemmas could also appear earlier ... or later}}

 
\begin{lemma}
For any module $M$, assertion $A$, variables $\overline x$, and variables $\overline x$,  % values $\overline v$, 
and any continuation, $cont$, and any states $\sigma$ and $\sigma'$ where 
$\sigma=(\psi,h)$, and $\sigma'=(((\overline {z \mapsto \sigma(x)}), cont)\cdot \psi, h)$,  
we have

\begin{itemize}
\item
$M,\sigma\ \models\  A$  \ \ implies \ \  $M,\sigma' \ \models\  \lift {A} {\overline x}   $
\item
$M,\sigma'\ \models\  A$  \ \ implies \ \  $M,\sigma  \ \models\  \llower  {A}  {\overline   x} $ 
\end{itemize}
\end{lemma}
\begin{proof}
in the next section
% by induction on the derivation of $\proves{M}{S}$.
\end{proof}


 