

\section{The problem and our approach}
\label{s:outline}
 
In this Section we outline the problem and our approach:  
We  introduce  our running example, the Bank Account (\S\ref{s:bank}),  
introduce our specification language, ....  give ...
%the \Nec specs (\S \ref{s:bankSpecEx}),
%   outline how we model the open world (\S\ref{s:concepts}), 
%give the main ideas of our proof system (\S\ref{s:approach})
%and   outline 
%how we use it to reason 
%about adherence to \Nec specifications  (\S\ref{s:all:outline:proof}).
 

 \subsection{Bank Account -- three modules}
\label{s:bank}

We express  our example in  small, object oriented language with modules, where fields are private 
(that is, they are readable/writeable only from other methods declared in the same module), and where addresses are 
unforgeable and un-enumerable.
Moreover, each class a default constructor, which implicitly initializes all fields with the \prg{null} value \footnote{TODO what about \prg{int}. 
Also, we need that methods are dynamically type-checked before the external call -- I think -- or even the call from the external. }
  
\vspace{.1cm}

We build on, and expand the  example as in OOSPLA-22 and FASE. We give three versions of a module which implements bank accounts; tywo verison Module \ModA consists of an empty 
\prg{Password} class where each instance models a unique password, and an \prg{Account} class with a password, and a balance, an \prg{init} method to 
initialize the password, and 
a
\prg{transfer} method. 
%
% (Note that we assume private fields are accessible ``class-wide''.)
%
% (methods may read and write fields of any instance of a class)
%
%and that passwords are unforgeable and not enumerable (again as
%in Java, albeit without reflection).
%
% 


\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $\ModA$        
  class Password
  
  class Account
    field balance:int 
    field pwd: Password
    method transfer(dest:Account, pwd':Password) -> void
      if this.pwd==pwd'
        this.balance-=100
        dest.balance+=100
     method init(pwd':Password) -> void
      if this.pwd==null
        this.pwd=pwd'
\end{lstlisting}
%
\noindent 
%We can capture the intended semantics of   \prg{transfer}  
%through  {a}  \funcSpec with pre- and post- conditions and \prg{MODIFIES} clauses as \emph{e.g.,} in \citeauthor{Leavens-etal07,dafny13}.
%The implementation of  \prg{transfer} in module  $\ModA$ meets
%this specification.
%
%\begin{lstlisting}[mathescape=true, frame=lines, language=Chainmail]
%$\Sclassic$  $\triangleq$
%   method transfer(dest:Account, pwd':Password) -> void  
%      ENSURES:
%            this.pwd$=$pwd' $\wedge$ this$\neq$dest  $\longrightarrow$  
%            this.balance$_{post} =$this.balance$_{pre}$-100 $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$+100
%      ENSURES:
%            this.pwd$\neq$pwd' $\vee$ this$=$dest  $\longrightarrow$ 
%            this.balance$_{post} =$this.balance$_{pre}$ $\wedge$ dest.balance$_{post} =$dest.balance$_{pre}$ 
%      MODIFIES:  this.balance, dest.balance        
%\end{lstlisting}
 
 In this implementation, an \prg{Account} is created with its \prg{balance} set to \prg{0}, and its password set to \prg{null}.
 After that, the password can be set to a new value, eg by executing \prg{a = new Account;} \prg{p=new Password;} \prg{a.init(p);}. 
 From then on, anybody who has access to \prg{a} may transfer money into it; but in order to transfer money out of \prg{a}, one needs to
 also have access to \prg{p}. Therefore, xxxx 
 
 \vspace{.1cm}
 
Now consider the following modules:
\ModB allows any client to reset an account's password at any time;
\ModC requires the existing password in order to change it.
  
  

\begin{tabular}{lll}
\begin{minipage}[b]{0.42\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModB$
  class Password
  
   class Account
    field balance:int 
    field pwd: Password 
    method transfer(..) ...
      ... as earlier ...
    method init(...) ...
       ... as earlier ...
    method set(pwd': Password)
      this.pwd=pwd'
\end{lstlisting}
\end{minipage}
&\ \ \  \ \   &%
\begin{minipage}[b]{0.45\textwidth}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModC$
  class Password

  class Account
    field balance:int 
    field pwd: Password 
    method transfer(..) 
      ... as earlier ...
    
    
    method set(pwd',pwd'': Password)
      if (this.pwd==pwd') 
        this.pwd=pwd''
\end{lstlisting}
\end{minipage} 
\end{tabular}

Although the \prg{transfer} method is the same in
all three alternatives, % and each one satisfies \Sclassic,
code  {such as}
\\ 
$\ \strut \hspace{.2in} $ \prg{p=new Password;  acc.set(42); acc.transfer(rogue\_account,42)} 
\\ 
is enough to drain  \prg{acc} in \ModB without knowing the password.\footnote{CAREFUL: we had 
$\ \strut \hspace{.01in} $ \prg{an\_account.set(42); an\_account.transfer(rogue\_account,42)} but this was type incorrect!}

This example demonstrates that we need to consider the \emph{emergent behaviour}: even though the method \prg{transfer} in  \ModB when considered in isolation is ``safe'', it is not safe, 
when considered in conjunction with other methods from the same module. We are therefore looking for a way to specify modules 


\subsection{Holistic Specifications revisited}
\label{s:approach:necopers}

We need  a specification language that allows us to write a specification that rules out \ModB while permitting \ModA and
\ModC.  

For this we introduce two new ingredients into classic one-state assertions, and revisit and update the well-known concept of two state invariants. TODO-cite-s.\

The new ingredients are 1) the distinction between internal and external objects, and the concept of protection. TODO-explain both.
The two-state invatiants, ... explain.
Note that OOPLSA-22 instead uses    necessity operators, while mentioned in  \S \ref{intro:this:work}. 

 


 % \subsection{Bank Account -- the right specification}
\label{s:bankSpecEx}

We now {return to our quest for} a specification that rules out \ModB while permitting \ModA and
\ModC. 
%The catch is that the vulnerability present in \ModB is the result
%of  \emph{emergent} behaviour from the interactions of the \prg{set}
%and \prg{transfer} methods --- even though \ModC also has a
%\prg{set} method, it does not exhibit the unwanted interaction.
%This is exactly where a necessary condition can help:
%we want to avoid transferring money
%(or more generally, reducing an account's balance)
%\textit{without} the existing account password.  Phrasing the same condition
%the other way around % gives us a positive statement that still
%rules out the theft: that money \textit{can only} be
%transferred when the account's password is known.


In \Nec  syntax, and {recalling \S \ref{intro:this:work}, and \ref{s:approach:necopers},}
 
 \begin{tabular}{lcll}
$S_1$   &     $\triangleq$   & $\OneStateQ{\prg{a}:\prg{Account} } {\inside{\prg{a.password}}} $
 \\
 $S_2$   & $\triangleq$   &  $\TwoStatesQ {\prg{a}:\prg{Account}}  {\inside{\prg{a.password}}} {\inside{\prg{a.password}}}$
 \\
$S_3$ & $\triangleq$   &
  $\forall \prg{a}:\prg{Account},\prg{b}:\prg{int}.$\\
  &  &  $\FirstState{\inside{\prg{a.password}} \wedge \prg{a.balance}=\prg{b}} 
\  \SecondState{ \prg{a.balance}\geq \prg{b} }$
 \end{tabular}



 $S_1$ is not satisfied by any of the modules.
 $S_2$ is satisfied by ...  and ... 
 $S_3$ ....
 
 
%{\SrobustA does not fit the bill: all three modules   satisfy  it.
% % \SrobustA;  this demonstrates that \SrobustA is not strong enough. 
% But  \SrobustB does fit the bill: \ModA and \ModC satisfy \SrobustB, while \ModB does not.}
% 
%A critical point of \SrobustB % this \Nec specification 
%is that it is
%expressed in terms of observable effects (the account's balance is
%reduced: \prg{a.balance < bal}) and the shape of the heap 
%(external access to the password:
%$\external{\prg{o}}\ \wedge\ \access{\prg{o}}{\prg{a.pwd}}$) 
%rather than in terms of individual methods such as
%\prg{set} and \prg{transfer}.
%This gives our specifications the
%vital advantage that they can be used to constrain
%\jm[typo]{\textit{implementations}} of a bank account with a balance and a
%password, irrespective of the API it
%offers, the services it exports, or the dependencies on other parts of
%the system.
%
% This example also demonstrates that 
%adherence to   \Nec specifications is not monotonic:
%adding a method to a module does not necessarily preserve adherence to
%a specification, 
%and while separate methods may adhere to a  specification, their combination does
%not necessarily do so. 
%{For example, \ModA satisfies \SrobustB, while \ModB does not.}
%This is why we say that \Nec   specifications capture a module's \emph{emergent behaviour}. 
 

%\jm[TODO: in the proof later we need to mention that there is a difference between the overall proof (no mention of the methods), and the intermediate ones (that do mention the methods)]{}
\subsection{Reasoning about external calls}
\label{sec:how}

bla bla nbla .....

%{One might think that \SrobustB was not useful: normally, there will exist somewhere in the heap
%at least one external object  
%with access to the password --  if no such object existed, then \sdN{nobody} would be able to use the money of
%the account.
%And if such an object did exist, \sdN{then the premise of \SrobustB would not hold, and thus}
%the guarantee given by \SrobustB might seem vacuous.}
%
%{
%This is \emph{not} so: %there may exist  
%\sdN{in scopes   from which such external objects with access to the password
%are not (transitively) reachable, % . In such scopes,
%\SrobustB  guarantees that the balance of the account will not decrease.
%}
%We illustrate this through the following  code snippet:
 

\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{1}$
    class Account 
        ... as in $\ModB$ ...
        
    class Password
    
    class Payments
       field acc1, acc2: Account
       field pwd1, pwd2: Password
       
       method intialize( )
           acc1 := new Account
           acc1.set(pwd1);
           acc2.set(pwd2)
           acc1.balance := 200;
           acc2.balance := 300;
          
       method safe(untrusted:Object)
             acc1.transfer(acc2,pwd2);
             untrusted.payme(acc2);     // can only increase the balance of acc2

\end{lstlisting}
 
 
 Here we make an external call --    
 
 ?? Make a version where the classes Account and Password are encapsulated?

%{The method \prg{cautious} has as  argument an external object \prg{untrusted}, of unknown provenance.
%{It} creates a new \prg{Account} and initializes its password. 
%In the scope of  this method,  external objects with access to the password are reachable:
%thus,  during execution of  line 7, or   line {9} the balance may decrease.
%}
%
%{Assume that class \prg{Account} is from a module which satisfies \SrobustB. 
%Assume also that the code in line 7 does not leak the password to \prg{untrusted}. Then no external object
%reachable from the scope of execution of \prg{make\_payment} at line 8 has access to the password.
%Therefore, 
%even though we are calling   an untrusted object, \SrobustB guarantees that \prg{untrusted}
% will not be able to take any money out of  \prg{a}.
% }
% 
%\jm[]{
%A  proof sketch of the  safety provided by \SrobustB appears in Appendix \ref{app:safety}.
%}
%\sdN{Note that in this example, we have (at least) three modules: the internal module 
%which defies class \prg{Account} adhering to  \SrobustB, the  
%external module $\ModParam{1}$, and the external module which contains the class definition for \prg{untrusted}.
%Our methodology allows the external module, $\ModParam{1}$ to reason about its own code, and thus 
%pass \prg{a} to code from the second external module, without fear of losing money.}
%\sdN{In further work we want to make such arguments more generally applicable, and 
%extend Hoare logics to encompass such proof steps.}
%%\susan[I think this paragraph doesn't add, if anything it has a hostage to fortune. I would just remove it.
%% The purpose of the current paper is being able to express specifications like \SrobustB, and
%%and being able to prove adherence. In further work we want to develop logics to leverage such specifications, putting
%%informal arguments as the  one of this section onto formal foundations.
 
 and then a variant
 
 \begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
module $\ModParam{2}$
    class Account 
        ... as in $\ModB$ ...
        
    class Password
    
    class Payments
          
       method cautious(acc:Account, untrusted:Object)
       // PRE $\protectedFrom {\prg{a.p[assword}} {\prg{untrusted}}$
       untrusted.payme(acc2);   // can only increase the balance of acc2
        ...
\end{lstlisting}

TODO: There should be some code before \prg{acc1.transfer(acc2,..}
 
\subsection{Internal and external modules, objects, and calls}
\label{s:concepts}

%Our work concentrates on guarantees made in an \emph{open} setting; that is, a given module
%$M$ must be programmed so that 
%execution of $M$ together with \emph{any} \externalM 
%module $M'$ will uphold these guarantees. In the tradition of
%visible states semantics, we are  only interested in upholding the guarantees while 
%$M'$, the  \emph{\externalM} module, is executing. A module can
%temporarily break its own invariants,
%so long as the broken invariants are never visible externally.
%   
%We therefore distinguish between  \emph{\internalO}
%objects --- instances of classes defined in $M$ ---
%and \emph{\externalO} objects defined in any other module.
%We also distinguish between
%  \emph{\internalC} calls  (from either an internal or an external object)  made % from \externalO objects
% to \internalO objects and \emph{\externalC} calls made % from \externalC objects
% to \externalC objects. 
%{Looking at the code snippet from \S \ref{sec:how}, the call to \prg{set} on line 6 is an 
% internal call, while the call to \prg{make\_payment} is an external call -- from the external 
% object  \prg{this}  to the external object \prg{untrusted}.}
% 
% % We are less
%% interested in calls made from \internalO objects to \internalO objects, because we only need 
%% establish the guarantees when the \externalM module is executing. And we 
%%
%%
%Because we only require guarantees while 
%the  \externalM module  is executing,
%we develop an \emph{external states} semantics, where
% any internal calls are executed in one, large, step.
%With external steps semantics,  the executing object (\prg{this}) is always   external. 
%  In line  with other work in the literature \cite{Permenev, Grossman, Albert}, we currently forbid 
%  calls from internal to  external objects
%  -- further details on call-backs in \S\ref{s:related}. 
%
%{For the purposes of the current work we are only interested in one internal, and one external module.
%But the interested reader might ask: what if there is more than one external module?
%The answer is that from the internal module's viewpoint, all external modules are considered as one;
%for this we provide a module linking operator with  the expected semantics -- more details in Def. \ref{def:pair-reduce} and \S \ref{app:loo}. 
%But from the external module's viewpoint, there may be more than one external module: for example, in \S \ref{sec:how}, 
%module $\ModParam{1}$ is external to the module   implementing class \prg{Account}, and the module 
%implementing the class of \prg{untrusted} is external to
%$\ModParam{1}$.
%}

%\section{Encapsulation}
%\label{s:outline:encapsulation}
%\jm[]{\Nec depends upon the encapsulation of data, or more
%specifically the encapsulation of assertions about encapsulated 
%data. We say that an assertion $A$ is encapsulated by module $M$ if $A$ may only
%be invalidated through computation internal to $M$. 
%For example, the assertion \prg{a:Account $\wedge$ a.pwd = p} is
%encapsulated by \ModA (along with \ModB and \ModC) as 
%it requires a write to \prg{a.pwd} and thus may only be invalidated 
%by a call to a method belonging to \ModA.
%}
%
%\jm[]{
%Encapsulation is a topic that is well covered in the literature,
%and as such we build upon that existing work to derive these
%encapsulation guarantees. For the purposes of the examples in this
%paper we define a simple system inspired by confinement types~\cite{confined}, 
%but \Nec could just as easily be 
%}

\subsection{Our Contributions}

Our contributions are

\begin{enumerate}
\item
A new capability operator, $\protectedFrom {x} {y}$ 
\item
A new specification languages for emergent behaviour and
\item
A Hoare logic extension, which handles external calls
\item
A logic which proves adherence to out 
\end{enumerate}

 
