\section{Appendix to Section \ref{sect:proofSystem} -- Proving Open Calls and Adherence to \SpecLang Specifications} \label{app:proof}


\subsection{Preliminaries: Specification Lookup,  Renamings, Underlying Hoare Logic}

Definition \ref{d:promises} is broken down as follows:  $S_1 \txtin  S_2$ says that $S_1$ is textually included in $S_2$; \ \ $S \thicksim S'$ says that $S$ is a safe renaming of $S'$; \ \   $\promises M S$ says that $S$ is a safe renaming of one of the specifications given for $M$. 
 
In particular, a safe renaming of  ${ \TwoStatesN {\overline {x:C}} {A}  }$ can replace any of the variables $\overline x$.  
A safe renaming  of ${\mprepostN{A_1}{p\ D}{m}{y}{D}{A_2} {A_3}}$  can replace  the formal parameters ($\overline y$) by actual parameters  ($\overline {y'}$) but requires the actual parameters  not to include \prg{this}, or \prg{res}, (\ie $\prg{this}, \prg{res}\notin \overline{y'}$). -- %The latter requirement 
Moreover, it can replace  the free variables which do not overlap with the formal parameters or the receiver ( $\overline{x}=\fv(A_1)\setminus\{{\overline y},\prg{this}\}$).

\begin{definition}
For a module $M$ and a specification $S$, we define:
\label{d:promises}
\begin{itemize}
\item
$S_1 \txtin  S_2  \ \ \ \triangleq\ \ \   S_1 \txteq  S_2$, or  $S_2 \txteq  S_1 \wedge S_3$, or $S_2\txteq S_3 \wedge S_1$,  or   $S_2 \txteq S_3 \wedge  S_1 \wedge S_4$ for some $S_3$, $S_4$.
\item
$S  \thicksim  S'$ \ \ \  is defined by cases

\begin{itemize}
\item
$ { \TwoStatesN {\overline {x:C}} {A}  }   \thicksim  { \TwoStatesN {\overline {x':C}} {A'[\overline{x'/x}]} } $
\item
$ {\mprepostN{A_1}{p\ D}{m}{y}{D}{A_2} {A_3}}  \thicksim
 {\mprepostN{A_1'}{p\ D}{m}{y'}{D}{A_2'} {A_3'}} $
  \\
 $\strut \hspace{2cm}    \ \  \triangleq\ \ \  A_1 = A_1'[\overline{y/y'}][\overline{x/x'}], \ \ A_2 = A_2'[\overline{y/y'}][\overline{x/x'}], \ \ A_3 = A_3'[\overline{y/y'}][\overline{x/x'}], \ \ \wedge$\\
 $\strut \hspace{2cm}\ \ \ \ \ \ \ \ \ \prg{this}, \prg{res}\notin \overline{y'}, \ \ \overline{x}=\fv(A_1)\setminus\{{\overline y},\prg{this} \} $
  \end{itemize} 
  
 \item  
 $\promises M  S \ \ \ \triangleq
 \ \ \ \exists S'.[ \ \ S'  \txtin \SpecOf M\ \ \wedge\ \ S' \thicksim S \ \ ]$
  \end{itemize} 
  \end{definition} 
  
The restriction on renamings of method specifications that  the actual parameters should not to include \prg{this}  or \prg{res} 
 is necessary because \prg{this} and \prg{res}  denote different objects from the point of the caller  than from the point of the callee.
It means that we are not able to verify a method call whose actual parameters include \prg{this} or \prg{res}. 
This is not a serious restriction: we can encode any such method call by preceding it with assignments to fresh local variables, \prg{this'}:=\prg{this}, and   \prg{res'}:=\prg{res}, and using \prg{this'} and \prg{res'} in the call.

 

\begin{example}
\label{e:rename}
The specification  from  Example \ref{example:mprepostl} can be renamed as 

\small
{
   {\sprepost
		{\strut \ \ \ \ \ \ \ \ \ S_{9r}} 
		{  a1:\prg{Account}, a2: \prg{Account}\wedge  \inside{a1}\wedge  \inside{a2.\prg{key}} }
		{\prg{public Account}} {\prg{set}} {\prg{nKey}:\prg{Key}}
		{   \inside{a1}\wedge  \inside{a2.\prg{key}} }
}}

\end{example}

\begin{axiom}
\label{ax:ul}
{Assume   Hoare logic with judgements % of the form 
\ $M \vdash_{ul} \{ A \} stmt \{ A' \}$, 
with  $\Stable{A}$,  $\Stable{A'}$. }
\end{axiom}

\subsection{Types}
\label{types}

The rules in Fig. \ref{f:types} allow triples to talk about the types 
Rule {\sc{types-1}} promises that types of local variables do not change.
Rule {\sc{types-2}} generalizes {\sc{types-1}} to any statement, provided that  there already exists a triple for that statement.

\begin{figure}[tht]
$
\begin{array}{c}
 \begin{array}{lcl}
\inferrule[\sc{types-1}]
	{  stmt \ \mbox{contains no method call} \\
	stmt  \ \mbox{contains   no assignment to $x$}}
	{\hproves{M}  {x:C} {\ stmt\ }{x:C} }
\\
\\
% THIS RULE IS NOT SOUND -- we need to adapt it
%{
\inferrule[\sc{types-2}]
	{ \hprovesN{M}  {A} {\ s\ }  {A'} {A''}  }
	{\hprovesN{M}  {x:C \wedge A} {\ s\ }  {x:C\wedge A'} {A''}}
% \end{array}
\end{array}
\end{array}
 $
\caption{Types}
\label{f:types}
\end{figure}


In {\sc{types-1}} we restricted to statements which do not contain method calls  in order to make lemma   \ref{l:no:meth:calls}  valid.

 
\subsection{Second Phase - more}
We present the remaining rules of the second phase:

\begin{figure}[htb]
$
\begin{array}{c}
\begin{array}{lcl}
\inferruleSD{[\sc{combine}]}
	{  \begin{array}{l}
	\hprovesN{M}  {A_1} {\ s\ } {A_2}  {A} \\ % \hspace{1.4cm}  
	\hprovesN{M}  {A_3} {\ s\ } {A_4} {A}
	\end{array}
	}
	{ \hprovesN{M}  {A_1 \wedge A_3 }{\ s\ } {A_2 \wedge A_4} {A} }
& &
\inferruleSD{[\sc{sequ}]}
	{  \begin{array}{l} 
	\hprovesN{M}  {A_1} {\ s_1\ } {A_2}  {A}  \\ % \hspace{1.4cm} 
	\hprovesN{M}  {A_2} {\ s_2\ } {A_3} {A}
	\end{array}
	}
	{   \hprovesN{M}  {A_1   }{\ s_1; \, s_2\ } {  A_3} {A} }
\end{array}
\\ \\
\inferruleSD{ \hspace{3cm} [\sc{consequ}]}
	{
%	\begin{array}{l}
	 { \hprovesN  {M}  {A_4} {\, s\, } { A_5} {A_6}  }
	 \hspace{1.4cm} 
	 M \vdash A_1 \rightarrow A_4 
	 \hspace{1.4cm} 
	{ M \vdash A_5   \rightarrow  A_2  }
	 \hspace{1.4cm}   
	{  M \vdash A_6 \rightarrow A_3 }
%	\end{array}
	}
	{   \hprovesN{M}  {A_1 }{\ s\ } {A_2} {A_3} }
  \end{array}
 $
 \vspace{-.5cm}
\caption{Hoare Quadruples -    substructural rules }
\label{f:substructural:app}
\end{figure}


%
%
%The rules {\sc{Call\_Int}} and {\sc{Call\_Int\_Adapt}}   are weaker forms of  the  rule {\sc{Call\_Int\_Combine}} given here. 
%Even though  {\sc{Call\_Int\_Combine}} is sound, we did not include it in the presented system, for the sake of simplicity and separation of concerns.
%A similar stronger rule can be expressed for {\sc{Call\_Ext}} and  for {\sc{Call\_Ext\_Adapt}}.
% \\
%$
%{\begin{array}{c}
%  \inferruleSD  {\hspace{4.7cm} [\sc{Call\_Int\_Combine}]}
% 	{
% 	  	\begin{array}{c}
% 		  \promises  M { \mprepostN  {A_{1a} \wedge A_{1r} }  {p\ C} {m} {y} {C} { A_{2a} \wedge A_{2r}}   {A_3}  }
%		\\
%		A_1'\txteq    A_{1a}[y_0/\prg{this}]  \wedge {\PushAS {y}{A_{1r}[y_0/\prg{this}]}}
%		\\
%		A_2'\txteq    A_{2a}[u/res,y_0/\prg{this}]  \wedge {\PushAS {y}{A_{2r}[u/res,y_0/\prg{this}]}}\
%       	\end{array}
% 		}
% 	{  \hprovesN {M} 
%						{ \  y_0:C, {\overline {y:C}} \wedge A_1' \ }  
%						{ \ u:=y_0.m(y_1,.. y_n)\    }
%						{ \ A_2'\ }
%						{  \  A_3 \ }	
%      }
%\end{array}
%}

\vspace{1cm} Finally, we discuss the proof

\beginProof{l:no:meth:calls}
By induction on the rules in Fig. \ref{f:underly}.

\completeProof 
 
