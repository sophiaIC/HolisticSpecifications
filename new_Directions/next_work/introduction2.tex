%\se{You use 'some effects' as the opposite of 'uncertain/unknown effects'. I think the effects shouldn't be some effects, but certain effects or specific effects. Some has the feel of randomness (but who knows which) which isn't meant}
%kjx fixed

\section{Introduction}
\label{s:intro}

\paragraph{External calls}
%
% In today's complex software, internal, trusted, code  is tightly intertwined  with external, unverified, untrusted, code:
% External code may   call  functions from the internal code.
%And internal code  may call  functions from the  external  code -- we call these   \emph{external calls}. 
%This tight intertwining   introduces a high degree of uncertainty.
%
In today's complex software, internal, trusted, code  is tightly intertwined  
with external, untrusted, code: external code
 %may call
calls
into internal code, internal code
% may call
calls
out to external code 
and external code
 %  may then call back
even calls back 
into internal code --- all within the same call chain.

%To  reduce  that uncertainty, programmers employ  
%\emph{encapsulation  features}
% (\eg   modules, private fields and methods, ownership types, memory safety, capability safety,  etc, \cite{private}),
%and \emph{encapsulation  programming patterns} (\eg wrappers, proxies, membranes, object capabilities etc, \cite{mebranes}).
%Such  features and patterns were first introduced in the 70s, and widely improved, employed, and studied since.\footnote{AUTHORS: careful, though; they were studied in a less adversary situation -- there was little worry of the untrusted code, Can we say this?}
%
%Encapsulation features have been  used in   verification of internal, non-intertwined code  \cite{Muller, Leino}.
%Verification of code employing such  features to help reduce the uncertainty in intertwined code
%has only recently  been studied \cite{xxx} -- Dreyer, Devriese, Mackay,  
%
%%The subject of this work is the specification  and verification of properties of internal code which 
%% reduces the uncertainty 
%% through the 
%%employs objects capabilities to reduce the uncertainty when intertwined with external, unknown code. 
%%

This paper addresses reasoning about \emph{external calls} --- when
trusted internal code calls out to untrusted, unknown external code.
This reasoning is hard because by ``external code'' we mean untrusted
code where we don't have a specification, cannot trust that the
code implements any specification we might have, indeed where the
external code may even be written by an attacker trying to subvert or
destroy the whole system.  Worse still, external code can call back
into internal code as part of the same call chain.
%
External code may be written years or decades after the core 
trusted system was released --- software plugins for audio and video
editors have lasted for more than thirty years, and new
trusted retrocomputing hosts (``emulators'')
can run code for machines back to the Manchester 
Baby \cite{MAME-SSEM}, where source code is long lost in the bits of
history \cite{Smalltalk-bits}.
 
~

\begin{tabular}{lll}
\begin{minipage}{.45\textwidth}
The code sketch to the right  illustrates the problem.  An internal, trusted, module $M_{intl}$  has methods \prg{m1} and \prg{m2}.
Parameter  \prg{untrst} % in \prg{m2} 
 is an external object. 
The outgoing external call on line  6 is the challenge:
What effects can it have?
What 
if  \prg{untrst} then calls back into $M_{intl}$, \eg  by calling  \prg{m1}?
\end{minipage}
& \ \  \   &
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $M_{intl}$        
  method m1 ..
    ...  $\mbox{trusted code}$ ...  
  method m2(untrst:external) 
    ... $\mbox{trusted code}$ ...
    untrst.unkn(this) // external call    
    ... $\mbox{trusted code}$ ...
\end{lstlisting}
\end{minipage}
\end{tabular}

 
 

\paragraph{\Tamed effects}  In practice, not all external calls will have unlimited effects.
 \sdN{If the programming language supports encapsulation (\eg private
 fields, ownership, no forging of addresses, no direct memory access \etc) then internal modules can be
 written \emph{defensively} \cite{MillerPhD}, to ensure that external
 calls \sdN{cannot cause effects} on internal components.} %  can cause effects only if some conditions specific to that effect are met.
For example a defensive implementation of the DAO  \cite{DAO} can ensure (a)
  % that an external object cannot cause
% the reduction of the balance of the DAO unless the causing object is one of the DAO's account holders; moreover, an external object should not cause 
 that its overall balance %of the DAO 
 is sufficient to cover the sum of the balances of its individual
 accounts, and
 concomitantly (b) that its overall balance can only be reduced along
 with one or more of its account balances, and (c) only with the 
 permission the each account's signatory.
 

% We  use the term \emph{\tamed  effects} for  effects which \sdN{may be caused by an external object, but only under certain conditions specific to that effect
\red{We say that a module has \emph{\tamed an effect}, when
 an outgoing external call cannot cause that effect.}
% can be guaranteed not to cause  % are not possible at external calls. 
%\footnote{
(While the literature has studied external
calls \cite{vanproving,cerise-jacm2024,vmsl-pldi2023,ddd},  to our
knowledge there is no accepted term for a component's exposure to external
effects \cite{NobPotVitECOOP98}, rather many papers 
borrow terms like ``robustness'' or ``robust safety'' from the security
literature \cite{gordonJefferyRobustSafety,robustSafetyPatrignani,abate2019journey}
%}
)
\Tamed effects %is important, because it 
reduce the uncertainty integral to an outgoing external
call \sdN{-- \eg with \tamed effects, we can ensure some properties established
before an outgoing call will still be valid after it.}

\sdN{
 Some \tamed effects depend only on internal state, \eg 
  (a) and (b) above depend only upon the DAO's overall balance,
  and the balance of each of its internal, subsidary, accounts.
  (A call to manipulate an account with a DAO is always an internal call.)
Other \tamed effects can also depend on the state of external
  objects, \eg  (c) above also depends on accounts' signatories, and
  those signatories are necessarily external to the DAO, and thus its
  subsidiary accounts. 
Reasoning about  taming the \emph{internal} effects of internal
  calls typically requires only an adaptation of
  techniques\footnote{is there a name for such reasoning techiques?
  egotrip? biochip? penmanship? internship? wysiwyp?}
from reasoning about object
  invariants \cite{Meier,Summers,Muler}.
  Reasoning about  taming the \emph{external} effects of external calls
requires rather more --- thus the topic of this paper.}

\paragraph{Effects \tamed by capabilities} To \tame  effects in their code, programmers can employ  the object capability model (OCAP)\cite{MillerPhD} --
 or capability model for short. 
Capabilities are transferable rights to perform one or more operations on a given object.
Capabilities are  \sdN{ \emph{necessary conditions} for effects:}   
 callers can only cause effects when they possess the necesary capabilities.
We say a module has \emph{\tamed an effect by a capability} if the
effect can only be caused by an external object with the requisite
capability. 
For example. a signatory may only withdraw funds from a DAO --- \ie decrease the
balance of their DAO subsidiary account --- if they have a ``withdraw''
capability for that particular account in that particular DAO.
%
%of a bank account (whether positive or negative)  only if the causing object  can obtain access to that account.}
%  moreover,
% an external object may cause a  reduction of  the balance 
% of a bank account   only if the causing object  can obtain access to that account's password.
 %is in procession of the account's credentials.
 % of \tamed effect.    
%
%The subject of this paper is how to characterize the possible effects at the point of the external call.
%
%\paragraph{Program Development for \tamed effects} %To \emph{develop} programs with \tamed effects, programmers have to employ
%needs to employ 
% encapsulation features and \emph{encapsulated properties}.
% \footnote{We use the term encapsulated property for a property which can only invaliated through through one or more calls to a module's public methods}
%\footnote{AUTHORS: All terms used in this section have been used with many different meanings. 
%We must warn the reader that we use our own meanings here. 
%Do not know where to say that.}
%Using these, the programmer can preserve the module's internal invariants  even in the presence of external calls,
%can rule out some effects altogether (\eg it is impossible for an account's balance to be negative), and
%can ensure that effects are tamed.
%
\footnote{
\red{I think this comment is good bit comes too early. Where should it go?}
\se{I think it is fine here - it is entirely understandable and makes your statements more concrete.}
\sdN{Often, the guarantees given by \tamed effects  are  hypothetical: In general there is no guarantee  that the untrusted object  (\eg \prg{untrst} in line 6 above) has no access to the capability. \emph{If} the untrusted object has no access to the corresponding capability, then the effect can be excluded; but otherwise, it cannot be excluded.\footnote{AUTHORS: Can this sentence be made elegant.}. But what \emph{can} be excluded, is that the capability will be leaked.}
\kjx{I wil put this on my list to come back to (first thing on that list)}
}
 
% \vspace{.1cm}
\paragraph{Our remit: Specification and Verification  for  \tamed effects}  
We want to reason about  code which \tames effects,  \sd{especially
effects \tamed by  capabilities.} 
How can we specify effects to be \tamed? How can we \emph{prove}
that %a program\
a module has indeed \tamed the effects we've specified?
Can we follow a systematic discipline to
prove our modules have successfuly \tamed the effects?
Can we embed proofs in a Hoare logic,
rather constructing proofs that are 
specific to each problem?\footnote{
\kjx{ALTERNATIVELY:
\paragraph{Our remit: Specification and Verification  for  \tamed effects}  
In this paper we demonstrate how to reason about  code which \tames effects,  \sd{especially
effects \tamed by  capabilities.} 
We can specify effects to be \tamed, 
and then we can \emph{prove} that a module has indeed \tamed the effects we've specified.
We follow a systematic discipline to prove our modules have successfully \tamed effects,
so our proofs are embedded in a Hoare logic, rather constructing proofs that are specific to each problem.
}}

%%%KJX alternative version 

~

Recent work has developed logics to prove properties of programs employing object capabilities.\footnote{albeit not necessarily with a focus on \tamed effects.}
\citet{ddd} develop a logic to prove that   code employing object
capabilities as encapsulation features preserve invariants for
intertwined code, but in the absence of external calls. Relying on
dark side techniques from separation logic, they intend their proofs
e.g.\ to support library components that can be reused in different
contexts --- which is implicitly support in our distinction between
external and internal code.
 \footnote{\red{TO CHECK}\kjx{I have looked at it - good enough for
 me.}}
 
 \citet{dd} work with Kripke logical relations describing
program semantics, which can describe and verify invariants
about multi-object structures and the availability and exercise of
object capabilities.  \citeauthor{dd} propose and solve several
problems involving external calls, 
but require proofs specific to each individual problem,
rather than a systematic Hoare logic. Similarly,
\citet{vmsl-pldi2023} deploy seperation logics, the IRIS framework
\cite{iris-jfp2018}, and mechanistic metamathematics
to prove properties of programs involving external calls, but again
with problem-specific proofs, rather than a systematiclogic.


Since external calls may in turn call any number of internal, public methods, 
it is crucial  to prove that \taming of effects is preserved by the module's 
\emph{emergent} behaviour, \ie any intertwining of external code with calls to internal, public methods.
%\footnote{Properties which rely on the type system, are of course preserved, but what about more semantic properties?}
%xxxOOPSLA-22-workshop
\citet{CassezFQ24} 
does this by replacing the external call through an unbounded number of calls to the module's public method.
\citet{FASE} instead proposes holistic specifications to describe a module's emergent behaviour. 
\citet{OOPSLA22} proposes a specification language for a module's emergent behaviour, and a tailor-made Hoare logic to prove that modules which do not contain external calls adhere to such specifications.
%They propose a taylor-made proof for an external call.



%We argue that in order to \emph{prove} that effects are \tamed,
%we need a way to specify the conditions necessary for that effect, 
%and a way to prove that the   module in its entirety preserves this \taming.
%In order to prove that the module in its entirety preserves this \taming, 
% \vspace{.2cm} 
% Thus, no work so far has tackled Hoare logics which support external calls as well as \tamed effects.

\paragraph{This paper's \sdN{contributions}} % In this paper we propose 
\sdN{1) a specification language to describe \taming of effects,
2) assertions to describe access to capabilities, 
3) a Hoare logic which can reason about external calls,
4) a Hoare logic which can prove that modules satisfy \tamed effects specifications,
5) Proofs of soundness,
6) A worked illustrative example 
}
\susan{Can a Hoare logic reason/prove? I prefer a Hoare logic for reasoning/proving .... Also shouldn't 2 come before 1 or possibly be merged? }
\kjx{How many DIFFERENT HOARE LOGICS WE GOT??}

 \paragraph{Structure of this paper}
Sect.\ \ref{s:outline}   outlines the main ingredients of our approach in terms of an example, and explains the main contributions.
Sect.\ \ref{s:underlying} outlines a simple object-oriented language used for our work, which in Sect. \ref{s:auxiliary} is augmented with some auxiliary concepts needed for our study.
Sect.\ \ref{s:assertions}, and Sect \ref{sect:spec}  give syntax and semantics of  assertions, and  specifications.
Sect.\ \ref{sect:proofSystem} develops Hoare triples and quadruples to prove external calls, and that a module adheres to \tamed effects specifications.
Sect.\ \ref{sect:sound:proofSystem} outlines a proof of soundness of
the Hoare logic. Finally, Sect.\ \ref{sect:related} discusses related
work. For the absence of a conclusion, we offer neither explanation
nor apology, but trust this careful attention to POPL tradition will
endear our work to the referees.
 
 
%Our specifications reflect modules' emergent behaviour,
% We also develop  Hoare logics to reason about modules containing external calls.

% \vspace{.8cm}
% \red{I want to also make these points, but do not know where. The points are overlapping,  and need  polishing:} 
% \begin{enumerate}
% \item
% \Tamed effects are essential when reasoning about intertwined code, but have not yet been widely studied -- esp. the competition has not crystalliuzed their need. We have, but have not given them a name. Perhaps the tamed effects should appear even earlier?
% \item
%\Tamed effects rely on conditions which are not under the control of the module. 
%For example, the module may require that the credentials are shown before it reduces the balance, but it cannot control which external objects have access to the credentials. 
%\item
%\label{reduced}
%The competition's effects  are not flexible enough. 
%They rely on only exposing a reduced version of the module's interface:
%For example, Birkedahl'22   prove -- by  hand -- that the stack's depth with remain the same, but only because the interface of their module does not expose a \prg{pop} method. 
%Such an assumption is too strong. 
%A module which did not support methods to reduce the stack are not as interesting or useful ... \red{here would be better to talk of balance and accounts}.
%What we want to have is modules with a rich interface, which expose different parts  of their interface to different external objects.
%\item
%One might think that it is possible to ensure that access to an object only goes through a reduced interface (as in point  \ref{reduced}).
%Namely, an internal object $o_1$ may create a proxy object $o_2$ to itself, which only exposes the reduced interface, and then pass $o_2$ as  argument to an external object $o_3$ .
%However, this does not guarantee that $o_3$ does not have a different route to $o_1$, which does not pass through the proxy $o_2$
%\item
%\Tamed effects \emph{have} to be hypothetical. \footnote{ (or context-dependent)}.  
%Some external objects will have access to the capability, and others will not. 
%We can gaurantee that without the relevant capability the effect will not happen, and also the capabilities will not be leaked. 
%But we can never guarantee that the capability is not present.
%\item
%In the context of OCAP, we need to reflect not only whether an external object has direct access (through a field, aor method  argumet) to the capability, but also, whether an external object may eventually obtain  direct access to the capability,
%% Eg they say that the interface does not provide a method to reduce the balance; then the reduction will not happen.
%\item
%\Tamed effects should take emergent behaviour into account. 
%They should hold over any number of execution steps, and not just over one particular method call. 
%For example \tamed effects should preclude  a module which does require the credentials in order to reduce the balance, but leaks the credentials. Therefore, per-method specifications are not sufficient.
%\end{enumerate}
%
%\red{TODO} Explain OCAP; introduce the challenge of the external word; reasoning and works by Devries, Birkedahl, Vechev, and ours.
%Include in that in OCAPs the capabilities act as guards. 
%That this has been tackled in FASE/OOPSLA'22 and gets better tackled here
%Also the difference between necessary and sufficient.
%And relation to POPL'23 paper; perhaps also some of recent work by Toby 

%Overall structure -- I do not know in what  order though.
%
%1) In today's complex world,  internal calls external and external calls internal
%
%2) To mitigate the risk, we introduced encapsulation ... ownership, private, etc etc 
%
%
%3) The OCAP model proposes capabilties .... def from OCAP. This means that capabilty is enabler -- sufficient condtion, 
%
%4)  However, a better understanding is that capability is guard, ie necessary condition. This has been recognized at OOPSLA 2022.
%
%
%5) We need to develop robust software, so that external calls do not do not have unwarranted effects ( check what term do Birkedahl et al use ).
%
%6) When we reason about external calls we can consider all possible calls back into the nmodule (2022 work), or even better 
%  have a spec of the complete module. OOSPLA did the spec but could not do the reasoning. 
%
%7) Emergent behaviour; to describe this, we need specs about complete module. Earlier work in that vein: two state invariants from the 02's. , temporal loghics, and FASE, OOPSLA
%-- competititon does not do.



%reason in the external world is not only about preservation of simple invariants; it is about reasoning about possible effects. These are reduced/increased through the availability of capabilities.
%
%The "others" tackle the problem of the ambient authority in a 1-step manner, eg there is a module, and if it exports a capability this capability may be used. For example, xxxx 
%
%FASE/OOPSLA support unrestricted ambient authority, but not the reasoning part. For example, xxxx
%
%In this paper, we support unrestricted ambient authority, and also reasoning. We are inspired by the work in FASE/OOSPLA, but with the following differences
%
%1) replace the temporal operators of FASE/necessity operators of oopsla by 2-state spec-s 
%
%2) when reasoning about a module's adherence to a 2-state spec, replace the xxx rules from OOPSLA by just one rule -- inspired by Infeasibility logic
%
%3) add one Hoare logic rule to reason about calls to external call; and add Hoare logic rules that reason about the accessibility of objects from other objects


