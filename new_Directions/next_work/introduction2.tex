\section{Introduction}
\label{s:intro}

\paragraph{External calls} In today's complex software, internal, trusted, code  is tightly intertwined  with external, unverified, untrusted, code:
External code may   call  functions from the internal code.
And internal code  may call  functions from the  external  code -- we call these   \emph{external calls}. 
%This tight intertwining   introduces a high degree of uncertainty.

%To  reduce  that uncertainty, programmers employ  
%\emph{encapsulation  features}
% (\eg   modules, private fields and methods, ownership types, memory safety, capability safety,  etc, \cite{private}),
%and \emph{encapsulation  programming patterns} (\eg wrappers, proxies, membranes, object capabilities etc, \cite{mebranes}).
%Such  features and patterns were first introduced in the 70s, and widely improved, employed, and studied since.\footnote{AUTHORS: careful, though; they were studied in a less adversary situation -- there was little worry of the untrusted code, Can we say this?}
%
%Encapsulation features have been  used in   verification of internal, non-intertwined code  \cite{Muller, Leino}.
%Verification of code employing such  features to help reduce the uncertainty in intertwined code
%has only recently  been studied \cite{xxx} -- Dreyer, Devriese, Mackay,  
%
%%The subject of this work is the specification  and verification of properties of internal code which 
%% reduces the uncertainty 
%% through the 
%%employs objects capabilities to reduce the uncertainty when intertwined with external, unknown code. 
%%

This paper addresses reasoning about  external calls.
As we have neither a specification nor the code of  the called external method, we cannot know the exact  effect of an external call.
And as execution of that external call may call back into the internal code, it seems as if the \sdN{range of} possible effects of the external call is unlimited.
 
\vspace{.1cm}

\begin{tabular}{lll}
\begin{minipage}{.45\textwidth}
The code sketch to the right  illustrates the point:  An internal, trusted, module $M_{intl}$  has methods \prg{m1} and \prg{m2}.
Parameter  \prg{untrst} % in \prg{m2} 
 is an external object. 
The external call on line  6 is the challenge:
What effects can it have?
What 
if that call later on calls back into $M_{intl}$, \eg  by calling  \prg{m1}?
\end{minipage}
& \ \  \   &
\begin{minipage}{.5\textwidth}
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
module $M_{intl}$        
  method m1 ..
    ...  $\mbox{trusted code}$ ...  
  method m2(untrst:external) 
    ... $\mbox{trusted code}$ ...
    untrst.unkn(this) // external call    
    ... $\mbox{trusted code}$ ...
\end{lstlisting}
\end{minipage}
\end{tabular}


 
 

\paragraph{\Tamed effects}  Nevertheless, not all external calls have unlimited effects:
 \sdN{If the programming language supports some form of encapsulation (\eg private fields, no forging of addresses, \etc), then the internal module can be written so as to ensure that external calls \sdN{cannot cause certain effects.}} %  can cause effects only if some conditions specific to that effect are met.
For example, \sdN{(*) the  DAO can be implemented so as to ensure
  % that an external object cannot cause
% the reduction of the balance of the DAO unless the causing object is one of the DAO's account holders; moreover, an external object should not cause 
 that its  balance %of the DAO 
 will never become become less than the sum of the valances of the accounts it is holding \cite{DAO},  
 and  (**)  so  that its  balance will not be reduced  unless the causing, external, object is one of  its account holders.}
 

% We  use the term \emph{\tamed  effects} for  effects which \sdN{may be caused by an external object, but only under certain conditions specific to that effect
\red{We say that a module has \emph{\tamed effects}, when exteranl calls cannot cause  \emph{certiain}  effects.}
% can be guaranteed not to cause  % are not possible at external calls. 
\footnote{
While the literature has studied external calls \cite{Lars},  to our knowledge, it does not have a term for that concept.}
\Tamed effects %is important, because it 
reduce  the uncertainty at the point of the external call \sdN{-- \eg with \tamed effects, some properties established before the external call will still be valid after it.}

\sdN{
 Some \tamed effects are independent  on the state of the external objects. \eg 
  (*)  does not depend on the state of external objects,
Other \tamed effects  depend of the state of the external objects, \eg  (**) from above,
Reasoning about the former  \tamed effects requires usually an adaptation of techniques from object invariants \cite{Meier,Summers,Muler},
but reasoning about the latter requires more.} 

\paragraph{Effects \tamed by capabilities} To \tame  effects in their code, programmers often employ  the object capability model (OCAP)\cite{Miller} --
 or capability model for short. 
Capabilities are transferable rights to perform one or more operations on a given object.
Thus, capabilities are  \sdN{ \emph{necessary conditions} for effects:   
 callers can make the effect   happen, only if they have access to the corresponding capability.
We say that an effect is \tamed by a capability, if it can be caused by an external object only if the latter has access to a capability.
For example, an external object may cause a change   in the balance 
of a bank account (whether positive or negative)  only if the causing object  can obtain access to that account.}
%  moreover,
% an external object may cause a  reduction of  the balance 
% of a bank account   only if the causing object  can obtain access to that account's password.
 %is in procession of the account's credentials.
 % of \tamed effect.   
%
%The subject of this paper is how to characterize the possible effects at the point of the external call.
%
%\paragraph{Program Development for \tamed effects} %To \emph{develop} programs with \tamed effects, programmers have to employ
%needs to employ 
% encapsulation features and \emph{encapsulated properties}.
% \footnote{We use the term encapsulated property for a property which can only invaliated through through one or more calls to a module's public methods}
%\footnote{AUTHORS: All terms used in this section have been used with many different meanings. 
%We must warn the reader that we use our own meanings here. 
%Do not know where to say that.}
%Using these, the programmer can preserve the module's internal invariants  even in the presence of external calls,
%can rule out some effects altogether (\eg it is impossible for an account's balance to be negative), and
%can ensure that effects are tamed.
% %
 
\footnote{
\red{I think this comment is good bit comes too early. Where should it go?}
\sdN{Often, the guarantees given by \tamed effects  are  hypothetical: In general there is no guarantee  that the untrusted object  (\eg \prg{untrst} in line 6 above) has no access to the capability. \emph{If} the untrusted object has no access to the corresponding capability, then the effect can be excluded; but otherwise, it cannot be excluded.\footnote{AUTHORS: Can this sentence be made elegant.}. But what \emph{can} be excluded, is that the capability will be leaked.}
 }
 
% \vspace{.1cm}
\paragraph{Our remit: Specification and Verification  for  \tamed effects}  
We want to reason about  code which \tames effects,  \sd{including effects \tamed by  capabilities.}
How  to specify such \tamed effects? How to \emph{prove} that %a program's 
effects are, indeed, \tamed?
Can we follow a systematic discipline to develop these proofs,
e.g.\ embodied in  a Hoare logic, rather constructing proofs that are 
specific to each problem?
 
Recent work has developed logics to prove properties of programs employing object capabilities.\footnote{albeit not necessarily with a focus on \tamed effects.}
Dreyer OOPSLA'18 develop a logic to prove that   code employing object capabilities as encapsulation features preserve invariants for intertwined code, but in the absence of external calls. 
 \footnote{\red{TO CHECK}}.
Devriese - 17? also develop xx logic for object capabilties and code
invariants, they propose interesting problems for external calls,
but can only prove these properties through problem-specific proofs
rather than a systematic Hoare logic. Similarly, 
Birkedahl-PLDI'23  proves a property of an external call, but again with
problem-specific approach, rather than a systematic approach.


Since external calls may in turn call any number of internal, public methods, 
it is crucial  to prove that \taming of effects is preserved by the module's 
\emph{emergent} behaviour, \ie any intertwining of external code with calls to internal, public methods.
\footnote{Properties which rely on the type system, are of course preserved, but what about more semantic properties?}
xxx-OOPSLA-22-workshop does this by replacing the external call though an unbounded number of calls to the module's public method.
 FASE instead proposes holistic specifications to describe   module's emergent behaviour. 
 OOPLSA'22 proposes a xxx-specification language for a module's emergent behaviour, and  tailor-made Hoare logic to prove that modules which do not contain external call adhere to such specifications.
%They propose a taylor-made proof for an external call.



%We argue that in order to \emph{prove} that effects are \tamed,
%we need a way to specify the conditions necessary for that effect, 
%and a way to prove that the   module in its entirety preserves this \taming.
%In order to prove that the module in its entirety preserves this \taming, 
% \vspace{.2cm} 
% Thus, no work so far has tackled Hoare logics which support external calls as well as \tamed effects.

\paragraph{This paper's \sdN{contributions}} % In this paper we propose 
\sdN{1) a specification language to to describe \taming of effects,
2) assertions to describe access to capabilities, 
3) a Hoare logic which can reason about external calls,
4) a Hoare logic which can prove that modules satisfy \tamed effects specifications,
5) Proofs of soundness,
6) A worked illustrative example 
}


 \paragraph{Structure of this paper}
Sect \ref{s:outline}   outlines the main ingredients of our approach in terms of an example, and explains the main contributions.
Sect \ref{s:underlying} outlines a simple object-oriented language used for our work, which in Sect. \ref{s:auxiliary} is augmented with some auxiliary concepts needed for our study.
Sect \ref{s:assertions}, and Sect \ref{sect:spec}  give syntax and semantics of  assertions, and  specifications.
Sect. \ref{sect:proofSystem} develops Hoare triples and quadruples to prove external calls, and that a module adheres to \tamed effects specifications.
Sect. \ref{sect:sound:proofSystem} outlines a proof of soundness of the Hoare logic. 
 
 
 
%Our specifications reflect modules' emergent behaviour,
% We also develop  Hoare logics to reason about modules containing external calls.

% \vspace{.8cm}
% \red{I want to also make these points, but do not know where. The points are overlapping,  and need  polishing:} 
% \begin{enumerate}
% \item
% \Tamed effects are essential when reasoning about intertwined code, but have not yet been widely studied -- esp. the competition has not crystalliuzed their need. We have, but have not given them a name. Perhaps the tamed effects should appear even earlier?
% \item
%\Tamed effects rely on conditions which are not under the control of the module. 
%For example, the module may require that the credentials are shown before it reduces the balance, but it cannot control which external objects have access to the credentials. 
%\item
%\label{reduced}
%The competition's effects  are not flexible enough. 
%They rely on only exposing a reduced version of the module's interface:
%For example, Birkedahl'22   prove -- by  hand -- that the stack's depth with remain the same, but only because the interface of their module does not expose a \prg{pop} method. 
%Such an assumption is too strong. 
%A module which did not support methods to reduce the stack are not as interesting or useful ... \red{here would be better to talk of balance and accounts}.
%What we want to have is modules with a rich interface, which expose different parts  of their interface to different external objects.
%\item
%One might think that it is possible to ensure that access to an object only goes through a reduced interface (as in point  \ref{reduced}).
%Namely, an internal object $o_1$ may create a proxy object $o_2$ to itself, which only exposes the reduced interface, and then pass $o_2$ as  argument to an external object $o_3$ .
%However, this does not guarantee that $o_3$ does not have a different route to $o_1$, which does not pass through the proxy $o_2$
%\item
%\Tamed effects \emph{have} to be hypothetical. \footnote{ (or context-dependent)}.  
%Some external objects will have access to the capability, and others will not. 
%We can gaurantee that without the relevant capability the effect will not happen, and also the capabilities will not be leaked. 
%But we can never guarantee that the capability is not present.
%\item
%In the context of OCAP, we need to reflect not only whether an external object has direct access (through a field, aor method  argumet) to the capability, but also, whether an external object may eventually obtain  direct access to the capability,
%% Eg they say that the interface does not provide a method to reduce the balance; then the reduction will not happen.
%\item
%\Tamed effects should take emergent behaviour into account. 
%They should hold over any number of execution steps, and not just over one particular method call. 
%For example \tamed effects should preclude  a module which does require the credentials in order to reduce the balance, but leaks the credentials. Therefore, per-method specifications are not sufficient.
%\end{enumerate}
%
%\red{TODO} Explain OCAP; introduce the challenge of the external word; reasoning and works by Devries, Birkedahl, Vechev, and ours.
%Include in that in OCAPs the capabilities act as guards. 
%That this has been tackled in FASE/OOPSLA'22 and gets better tackled here
%Also the difference between necessary and sufficient.
%And relation to POPL'23 paper; perhaps also some of recent work by Toby 

%Overall structure -- I do not know in what  order though.
%
%1) In today's complex world,  internal calls external and external calls internal
%
%2) To mitigate the risk, we introduced encapsulation ... ownership, private, etc etc 
%
%
%3) The OCAP model proposes capabilties .... def from OCAP. This means that capabilty is enabler -- sufficient condtion, 
%
%4)  However, a better understanding is that capability is guard, ie necessary condition. This has been recognized at OOPSLA 2022.
%
%
%5) We need to develop robust software, so that external calls do not do not have unwarranted effects ( check what term do Birkedahl et al use ).
%
%6) When we reason about external calls we can consider all possible calls back into the nmodule (2022 work), or even better 
%  have a spec of the complete module. OOSPLA did the spec but could not do the reasoning. 
%
%7) Emergent behaviour; to describe this, we need specs about complete module. Earlier work in that vein: two state invariants from the 02's. , temporal loghics, and FASE, OOPSLA
%-- competititon does not do.



%reason in the external world is not only about preservation of simple invariants; it is about reasoning about possible effects. These are reduced/increased through the availability of capabilities.
%
%The "others" tackle the problem of the ambient authority in a 1-step manner, eg there is a module, and if it exports a capability this capability may be used. For example, xxxx 
%
%FASE/OOPSLA support unrestricted ambient authority, but not the reasoning part. For example, xxxx
%
%In this paper, we support unrestricted ambient authority, and also reasoning. We are inspired by the work in FASE/OOSPLA, but with the following differences
%
%1) replace the temporal operators of FASE/necessity operators of oopsla by 2-state spec-s 
%
%2) when reasoning about a module's adherence to a 2-state spec, replace the xxx rules from OOPSLA by just one rule -- inspired by Infeasibility logic
%
%3) add one Hoare logic rule to reason about calls to external call; and add Hoare logic rules that reason about the accessibility of objects from other objects


