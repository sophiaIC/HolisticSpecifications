\newcommand{\extract}[1]{\ensuremath{{\mathcal I}\!nvs(#1)}}

\begin{lstlisting}
class Shop

  fld myAccount : Account
  fld inventory : Inventory
    
  void buy(buyer: Object, anItem: Item)
    int price = anItem.price
    int oldBalance = this.myAccount.balance
    buyer.payMe(myAccount,price)
    if (this.myAccount.balance == oldBalance+price)
       this.send(buyer,anItem)
    else
       buyer.tell("you have not paid me")  
             
\end{lstlisting}


\section{Proving Adherence to \SpecLang Specifications}


We will develop a  Hoare logic with judgments of the form  $M\ \vdash\  \{\, A \,  \}\ s\  \{\, A' \, \}$. These promise, as usual, that execution of statement $s$ in a state satisfying $A$ will lead to a state satisfying $A'$. 





\subsection {Assertion Encapsulation}
\label{s:encaps-proof}

{
Proofs of adherence to {\SpecLang specifications  hinge on the expectation that some, 
specific, assertions cannot be invalidated unless some 
} internal (and thus known) computation took place. 
{We call such assertions   \emph{encapsulatied},}
}
formally $M\ \vDash  \encaps{A}$.
%  which states that  assertion $A$ is encapsulated by module $M$.


\subsubsection{Semantics of Assertion Encapsulation}

{An assertion $A$  is  encapsulated by a module $M$%  under condition $A'$,
if in all possible states which arise from execution of module $M$ with any other  module $\Mtwo$,%  and which satisfy $A'$, 
the validity of $A$}  {can only be changed via computations internal to that module}.
% -- \emph{i.e.},  via a call to a method from $M$, i.e., calls to objects defined in $M$ but accessible from theoutside.


\begin{definition}[An assertion $A$ is \emph{encapsulated} by module $M$ ] $~$ \\
\label{def:encapsulation}
%\begin{enumerate}
% \item     $M\ \vDash \encaps{A}$
%\\
%if, 
%\\
%for all  modules $\Mtwo$,  states $\sigma$, $\sigma'$
%such that $\arising{M\madd\Mtwo}{\sigma}$, { variables $\overline{x}$ and addresses $\overline{\alpha}$}:
%\begin{itemize}
% \item
%  $\satisfiesA{M}{\sigma}{A}$,  \ \ \ \   $\overline{x}=Free(A)$, \  \  \ \  $\satisfiesA{M}{\sigma}{\external{\prg{this}}}$, \ \ \ \ \ $\leadstoOrig  {M\madd\Mtwo}  {\sigma}{\sigma'}$, \ \ \ 
%  ${M},{\sigma'}\not\vDash{A[\overline {{\interpret \sigma x}x}]}$
% \\
%\mbox{iff} 
%\\
% \item   $\exists y,\,m,\, \overline{y} .[\ \sigma.\prg{cont}= y.m(\overline{y});\_ \ \wedge\  \satisfiesA{M}{\sigma}{\internal{y}} \ ]
%$
% \end{itemize}
% \end{enumerate}

\red{$ % \begin{equation}
    M\ \vDash \encaps{A}\ \   \mbox{iff}  \ \   
    \begin{cases}
     \forall \Mtwo, \sigma, \sigma', \overline{x} \mbox{ with } \overline{x}=Free(A):\\
   \ \ \ \  [\ \ \  \arising{M\madd\Mtwo}{\sigma}\ \wedge \  \satisfiesA{M}{\sigma}{(A \ \wedge\ \external {\prg{this})}}\  \wedge\  \leadstoOrig  {M\madd\Mtwo}  {\sigma}{\sigma'}\\
    \ \ \ \ \ \   \ \ \ \Longrightarrow\\
    \ \ \ \ \ \  \  {M},{\sigma'}\models{A[{\overline {{\interpret \sigma x}/x}}]} \ \  ]
    \end{cases}
 $% \end{equation}
  \end{definition}
}
 
\footnote{\textbf{Aside} In the definition above we used the unbounded execution,  $\leadstoOrig  {M\madd\Mtwo}  {\sigma}{\sigma'}$;  however, the extension of the definition would have been the same if we had used bounded execution, $\leadstoBounded {M\madd\Mtwo}  {\sigma}{\sigma'}$ instead. TODO: write a lemma and also write a lemma for multiple steps}
 
Revisiting the examples from \S~\ref{s:outline}, % we can see
both \ModB and \ModC encapsulate   the   assertion %  \prg{balance} of an account. %to some value \prg{bal}: 
%Namely, 
$a:\prg{Account}\wedge a.\prg{balance}=b$. % can only be invalidated through internal  methods.  %on internal objects.
 %
{Now, assume two further modules, $\ModParam{ul}$ and $\ModParam{pl}$, both of which  use ledgers to mapping accounts and their balances, and export functions that update of this map. In $Mod_{ul}$ the ledger is \emph{not} protected, while in $Mod_{pl}$ the ledger \emph{is} protected. Then, in the former, the balance of an account is \emph{not} encapsulated, and in the latter it  \emph{is} encapsulated. } 
%
\\
\strut \hspace{1cm}
$\ModB\ \vDash\ \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm}
$\ModC\ \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm} {$\ModParam{ul}\ \not\vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}
\\
\strut \hspace{1cm} {$\ModParam{pl}\  \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}

\noindent
{Note that in $\ModParam{ul}$ and $\ModParam{pl}$, the term \prg{a.balance} is a ghost field.}



In any module, relative protection % (a variable is protected from another one) 
is not encapsulated, but  absolute protection is.
 Note  that  encapsulation of an assertion does not imply encapsulation of its negation; 
 for example,  ${\inside{x}}$ is encapsulated (as per below), but $\neg  {\inside{x}}$ is not.


\begin{lemma}
For any module $M$, and variables $x$ and $y$:
\begin{enumerate} 
\item $M \vDash \encaps{\inside{x}}$
\item $M \not\vDash {\encaps{\neg\inside{x}}}$
\item $M \not\vDash {\encaps{\protectedFrom{x}{y}}}$
\item $M \vDash A \rightarrow A' \ \ \wedge\ \  M \vDash  \encaps{\red{A'}}$ \ \ implies \ \ $M \vDash  \encaps{A}$.
\end{enumerate}
\end{lemma}

%\begin{proof} Sketches:
%
%(1) because if $y$ is protected, and since the fields are all private ... the only way .. 
%\\
%(2) Take a state where $\neg\inside{x}$ and that there is only external object that has access to $x$, and that this object becomes no longer accessible -- eg through field override. That means that we now have  $\inside{x}$.
%\\
%(3) it is always possible that another external object $z'$ has unprotected access to $x$; if $z'$ has access to $z$, then it can give it access to $x$ without invoking am internal method. (3) as a counterexample, 
%\\
%(4) Use that $M \vDash A \rightarrow A'$ implies $M \vDash \neg A'  \rightarrow \neg  A$. BUT CAREFUL, TODO! with the potential of non-termination on assertions!!
%\end{proof}
%%The key consequence of soundness is that -- SD dropped; it is   not a consequence of soundness!

\subsubsection{Deriving  Assertion Encapsulation}

{In general},  code that does not contain 
calls to a {given} module is guaranteed not to invalidate any assertions encapsulated by that module.
 Assertion encapsulation has been used in proof systems to {address}   the  {frame} problem
 \cite{objInvars,encaps}. 

We  do not mandate how this property should be derived -- instead, we rely on a judgment 
$M\ \vdash  \encaps{A}$ provided by some external system. \footnoteSD{This is simpler than the oopsla-33 setting}
Thus, \SpecLang is parametric over the derivation of the encapsulation
     judgment; in fact, several ways to do that are possible \cite{TAME2003,ownEncaps,objInvars}. For example,
 the appendices of
    \cite{necessityFull} present a 
	%Appendix~\ref{s:encap-proof} and
    %Figure~\ref{f:asrt-encap}  we present a 
    rudimentary system that is sufficient to support our example
    proof.  


%As we have already stated at the beginning of this section,
%encapsulation is a deep topic that is well studied in the literature, 
%and is not the focus of this paper. For now, we simply assume the existence 
%of a proof system for encapsulation as it is secondary to the central topic 
%of this paper. We need only assert that such an algorithmic proof system 
%must be sound (Definition \ref{lem:encap-soundness}).
%% \susan[I commented out what was there as I thought it was repetious]
%% {We are assuming the existence of a proof system for encapsulation and only need to assert that such an algorithmic proof system nust be sound.}
%% The construction of the algorithmic system is not central to our work,
%% because, as we shall see in later sections, our logic 
%% does not rely on the specifics of an encapsulation algorithm, only its soundness.

Like OOPSLA 22 Our logic does not {deal with, nor} rely on, the specifics of  how   encapsulation
{is derived}.
  % model, 
{Instead, it relies} on an encapsulation judgment and expects it to be sound:

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A$:\\

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ $ implies $\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{definition}



%
%\subsubsection{Types for Assertion Encapsulation}
%\label{types}
%TODO: something simple ere 

% \subsection{Assertion Inference}







\subsection{Weaker/Stronger Specifications}

We assume   the existence of a function $HS$ which allows us to look up the holistic specification of a module. 
In Figure \ref{fig:si} we   define a judgment $\stronger M S  {S'}$ which expresses that the specification $S$ is stronger than the specification $S'$ under module $M$.  


\begin{lemma}
For all modules $M$, and specifications $S$ and $S'$, we have that\\
\strut \hspace{2cm}-\ \ \  $\strongerI M  S  {S'}    \ \ \ \ \Longrightarrow\ \ \ \ \stronger M S {S'}'$\\
\strut \hspace{2cm}-\ \ \  $M \vdash S \equiv S'    \ \ \ \ \Longrightarrow\ \ \ \ M \models S \equiv {S'}'$
\end{lemma}

In   Fig.  \ref{fig:si} in the appendix we define the judgment  $\strongerI M  S  {S'} $.
We now define what it means for a module $M$ to promise a specification $S$:

\begin{definition}
Given module $M$ snd specification $S$:

\strut \hspace{2cm} $\promises M S$ \ \ \ \  iff \ \ \ \  $\strongerI M {HS(M)} S$
\end{definition}

Notice, that $\promises M S$ is only based on the spec of $M$, and does not guarantee that indeed $M$ satisfies $S$.


%\subsection{Proving method bodies while using  \AssertLang specifications}
%\label{s:classical-proof}
% 
%We now develop a Hoare logic, which can prove assertions of the from \\
%\strut \hspace{1cm} $\hproves{M}{A}{\prg{s}}{A'}$.\\
%where \prg{s} is a statement in \Loo, and $A$ and $A'$ are assertions in \AssertLang.
%
%The challenges here are 1) that \AssertLang assertions support, on top of the classical features, also ??what-shall-we-call-them? protection features, and 2) we need to reason about calls to external modules.
%
%
%We assume that there exists some
%proof system  that   allows us to prove 
% specifications of the form  $\hproves{M}{A}{\prg{s}}{A'}$.
%{We further assume that such a proof system is sound, i.e. that 
%if xxx TODO 
%% if $\hproves{M}{\hoare{P}{\prg{res = x.m($\overline{z}$)}}{Q}}$, then 
%% for every program state $\sigma$ that satisfies $P$, the execution of the method call \prg{x.m($\overline{z}$)}
% % esults in a program state satisfying $Q$.}
% We then expand the proof rules as follows ....
 


\subsection{Reasoning about protection}
We expand that logic with rules about protection, as in Fig. \ref{f:protection}. Essentially, the only what that the "protection" of an object can decrease is if we call an eternal method, and pass it an internal object as argument. This is then covered by the rule in Fig. \ref{f:external:calls}.

\begin{figure}[hbt]
$
\begin{array}{c}
\inferrule[\sc{prot-1}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge \ \internal y }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\sc{prot-1}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge \ \internal v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-2}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\  \wedge\ \internal {y'} \ \wedge\  x \neq y'}
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

	\inferrule[\sc{prot-3}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\  \protectedFrom{x}{y'} }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%	\inferrule[\sc{prot-2}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge\ \external v\ \wedge\  z\neq v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\


%	\inferrule[\sc{prot-4}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{v}\ \wedge\ \external z\  }
%						{\ z=v\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-4}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\ z \neq \this}
						{\ y =y'.f\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\textsc{prot-5}]
%	{}
%	{\hproves{M}
%			{}
%	}
\end{array}
$
\caption{Protection Logic \sdN{-- the rules will probably change; Julian is working on this}}
\label{f:protection}
\end{figure}


Explanations: \textsc{xxxl} states that   yyy

\subsection{Hoare Logic -- substructural rules}

We assume that $M \vdash_{ul} \{ A \} s \{ A' \}$ is a judgement that comes with the underlying programming language.  On top this, we define our extension, with shape ${   \hproves{M}  {A} s {A'}}$. The rules for this extension appear in Figures \ref{f:protection}, \ref{f:calls} and \ref{f:substructural}.

 
\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lcl}
\inferrule[\sc{extend}]
	{ M \vdash_{ul} \{ \ A\ \} {\ s\ }\{\ A'\ \} }
	{\hproves{M}  {A} {\ s\ }{A'} }
	& &
\inferrule[\sc{combine}]
	{  \hproves{M}  {A_1} {\ s\ } {A_1'}  \ \ \  \hproves{M}  {A_2} {\ s\ } {A_2'} }
	{ \hproves{M}  {A_1 \wedge A_2 }{\ s\ } {A_1' \wedge A_2'} }
%\end{array}
\\
\\
\inferrule[\sc{sequ}]
	{  \hproves{M}  {A} {\ s_1\ } {A''}  \ \ \  \hproves{M}  {A''} {\ s_2\ } {A'} }
	{ \hproves{M}  {A } {\ s_1; \ s_2\ }  {A'} }
& &
\inferrule[\sc{consequ}]
	{ M \vdash A \rightarrow A'' \ \ \  {\hproves{M}  {A''} {\ s\ } {A'''} } \ \ \ M \vdash A''' \rightarrow A'  }
	{\hproves{M}  {A} {\ s\ } {A'} }
\\ \\
\sdN{
\inferrule[\sc{types}]
	{   }
	{\hproves{M}  {x:C} {\ s\ }  {x:C} }
}
 \end{array}
  \end{array}
 $
\caption{From Underlying to Extended Hoare Logic}
\label{f:substructural}
\end{figure}
 

 
 
 
\subsection{Reasoning about calls}

\sdN{When we reason about external calls, we need to  ensure that all proof obligations imposed by the module's spec are met.
For this, we define in Def. \ref{def:extract}, the function $\extract{\_}$, which turns the holistic specification of a module into a 
global invariant. Notice that the two state invariant is turned into one assertion, with free variables.
This global invariant is assumed before any public method, and  has to be satisfied before any external call, and at the end of any public method.}

\label{s:module-proof}


\begin{definition}
text text text 
\label{def:extract}
%\begin{figure}
$
\begin{array}{clcl}
& \extract{ \OneStateQ{\overline {x:C}}{A} }  & \triangleq & \forall \overline{x}.[ \, \overline {x:C} \rightarrow A \, ]
\\
& \extract{ \TwoStatesQ{\overline {x:C}}{A}{A} }  & \triangleq & \overline {x:C} \wedge A  
\\
& \extract{ S_1 \wedge S_2 } & \triangleq & \extract{ S_1} \, \wedge S_2 \,  \extract{ S_2 }
\\
&  \extract{ M }  & \triangleq &  \extract{ HS(M) }
\end{array}
$
%\caption{Extracting proof obligations out of  module specifications -- we require implicitly that all variables are different}
%\label{f:extract}
%\end{figure}
\end{definition}

 \begin{example}
 \label{example:extract}
  Take a module $M$ with classes $D$ and $E$, and holistic specification:\\
$\strut \ \ \  \ \ \ \ \ \ HS(M)= \OneStateQ{d:D}{d.f\geq 300} \wedge  \TwoStatesQ{e:E,i:int}{e.f\geq i} {e.f\geq i} $. 
\\
This module's global invariant is:\\
$\strut \ \ \  \ \ \ \ \ \ \extract{M}  = \forall d.[d:D \rightarrow d.f\geq 300]\ \wedge \  [ e:Int \wedge i:int \wedge e.f \geq i]$
\\
Note that $d$ is universally quantified, while $e$ and $i$ are free in that assertion.
 \end{example}

\sdN{We now consider the logic for calls.
In  Fig. \ref{f:internal:alias:calls}  we   reason about calls to internal methods, and also about the preservation of 
alienist/non-aliasing.}

Rule {\sc{IntCall}} is standard.  We use  the notation
$ M, C, m  :  (\, P, \ Q\, )  $ to indicate that the declaration of method $m$ for class $C$ in module $M$ includes the per-post-condition pair  $(\, P, \ Q\, ) $. 



\sdN{Rules  {\sc{CallAndAlias}}  and  {\sc{CallNonAlias}} say that calls preserve aliasing, resp. non-aliasing, between variables, ie they preserve $x=x$ resp. $x\neq x$. These two rules apply to internal as well as external calls. When the callee's receiver is external, they make the extra requirement that  $\PushAS {y}{\extract{M}}$ -- we  will discuss this requirement together with the discussion of Fig. \ref{f:external:calls}.     Note that $x=x'$ expresses that $x$ and $x'$ are aliases, while  $u\txteq x$ expresses that $u$ and $x$ are textually the same --
the latter is stronger, i.e.   $x\txteq u$ implies $x=u$. 
% It is possible that variables are aliases, without being textually the same, i.e. it is possible to have $x=x'$ while $u\not\equiv x'$. 
 As $...\equiv ...$ is a textual assertion, and thus  state-independent,  it is a side-condition of the rules and is  not part of the Hoare triple's precondition.
}


\small{
\begin{figure}[hbt]
$\begin{array}{c}
%\begin{array}{ll}
\inferruleSD{\hspace{4.7cm} [\sc{IntCall\_WithSpec}]}
	{ 
	   	M, C, m  :  (\, A_1, \ A_2\, )\ \ \  \ \ \ \ \ fv(A_1)=\overline x
          		}
	{   \hproves{M} 
						{ \ {\internal{y_0}}  \wedge  y:C  \ \wedge \ A_1[\overline y/\prg{this},\overline x] \  }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \  A_2[ u/result,\overline y/\prg{this},\overline x]  \ }	
}
\\
\\
\inferruleSD{\hspace{4.7cm}  [{\sc{CallAndAlias}}}
	{ 
	{   x \txtneq u\txtneq x'  }
	}
	{   \hproves{M}  { \ x=x'\   \wedge \ ({\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}})\  }	{ \ u:=y_0.m(y_1,.. y_n)\  } { \  x=x'\ }	 }

\\ \\ 
\inferruleSD{\hspace{4.7cm} [{\sc{CallNonAlias}}]}	
{ 
		{ \ x \txtneq u \txtneq x'\   }
	}
	{   \hproves{M}   { \ x\neq x'\   \wedge \ ({\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}})\  } { \ u:=y_0.m(y_1,.. y_n))\  } { \  x\neq x'\ }	 }
\\
\\
\end{array}
$
\caption{Logic for Internal Calls, and  for Aliasing around Calls }
\label{f:internal:alias:calls}
\end{figure}
}


\sdN{We now move to the discussion of  external calls. For all external calls we require that the module's invariants hold before the external call.
This is enforced through the requirement ${\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}}$ in rules
{\sc{CallAndAlias}} and {\sc{CallNonAlias}} in  Fig. \ref{f:internal:alias:calls}, and the precondition part  
 $\PushAS {y}{\extract{M}}$ in all rules in Fig.  \ref{f:external:calls}. }


\sdN{Looking more closely, we notice  that we do not require that invariants hold (ie ${\extract{M}}$), but require that they will hold after the method call has been pushed on the stack, (ie $  \PushAS {y}{\extract{M}}$). We use the  assertion push-function $\pushSymbol$   defined earlier in Figure \ref{f:Push}.}
%We use the  assertion push-function $\pushSymbol$ with  signature\\
% $ \strut \ \ \ \ \ \   \pushSymbol : Vars \times Assert \rightarrow Assert $,\\
Remember that the assertion $\PushAS y A$ is \emph{hypothetical}: if a state satisfies $\PushAS y A$, then after pushing
onto that state a frame which contained the values  of $\overline y$, assertion $A$ will hold, and conversely,   if a state satisfies  $A$ with a top frame containing the  values of $\overline y, \overline z$, then  after popping that frame, the state  satisfies assertion  $\PushAS y A$ (cf. llemma \ref{lemma:push:ass:state}).
 
 \sdN{In rule {\sc{ExtCall}} we   ensure that the module's invariants are preserved by the external call. } \sdN{Notice that while  {\sc{CallAndAlias}}, {\sc{CallNonAlias}}, {\sc{ExtCall\_WithSpec\_Weak}} and {\sc{ExtCall\_WithSpec\_Weak}}    include 
 $\PushAS y {A_1}$ in their precondition,  they do not include it in the postcondition. A variation where was  $\PushAS y {A_1}$ in the postcondition is admissible, as it would be the outcome of the combination of these rules with  {\sc{ExtCall}} through the application of {\sc{Consequ}}.}
 
\sdN{The precondition of {\sc{ExtCall\_WithSpec\_Weak}} is stronger than that of {\sc{ExtCall}}. It makes use of one of the  module's  promises: Here $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, i.e. that  $\overline {x:C} \ \wedge\ A_1$ can only lead to $A_2$. 
% Moreover, the call's precondition requires  $\overline {x:C} \wedge \PushAS y {A_1}$. 
 Therefore, by lemma \ref{lemma:push:ass:state}.\ref{lemma:push:ass:state:one}, right after pushing a frame with $\overline y$, ie right after  entering the external call, $\overline {x:C}$ and  $A_1$ hold. `Therefore, by the semantics of $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, at the end of the external call,  $\overline {x:C} \wedge A_2$ will hold. This, together with  lemma \ref{lemma:push:ass:state}.\ref{lemma:push:ass:state:two} gives that after popping the frame, ie after  exiting the external call, $\PushAS y {A_1}$ will hold.}


\sdN{The precondition of {\sc{ExtCall\_WithSpec\_Strong}} is stronger than that of {\sc{ExtCall\_WithSpec\_Weak}}: it also requires $A_1$. Therefore, the module's promise, $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, guarantees that after exiting the external call, $A_2$ will hold.}
 





\small{
\begin{figure}[hbt]
$\begin{array}{c}
\inferruleSD{\hspace{4.7cm} [\sc{ExtCal}]}
	{ 
   	 
        }
	{   \hproves{M} 
						{ \    { \external{y_0} }\,     \wedge \,  \PushAS {y}{\extract{M}}\   }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \    \PushAS {y}{\extract{M}}   \ }	
}
\\
\\
\inferruleSD{\hspace{4.7cm} [\sc{ExtCall\_WithSpec\_Weak}]}
	{ 
   	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
        }
	{   \hproves{M} 
						{ \    { \external{y_0} }\, \wedge \, \overline {x:C}  \, \wedge \,  \PushAS  {y}{  A_1} \,   \wedge \,  \PushAS {y}{\extract{M}}\   }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \ \PushAS  {y} { A_2}     \ }	
}
\\
\\
\inferruleSD{\hspace{4.7cm}[\sc{ExtCall\_WithSpec\_Strong}]}
	{        	
	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
   	}
	{   \hproves{M} 
						{ \  {\external{y_0}  } \, \wedge\, \overline {x:C}\, \wedge\,  \PushAS  {y} { A_1} \, \wedge\,  A_1\, \wedge\,  \PushAS {y}{\extract{M}}\   \  }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \  \ \PushAS  {y} { A_2}\,  \wedge\, A_2 \  }	
}\
\\
\end{array}
$
\caption{Logic for External Calls}
\label{f:external:calls}
\end{figure}
}




\subsection{Proving \SpecLang Specifications}

We now define the judgment $\vdash M$, which says that module $M$ has been proven to satisfy its specification.

$
\\ \\
\begin{array}{l}
\inferruleSD {  ~ \strut \hspace{3cm} {\sc{Module\_Well\_Formed}}}
{
\begin{array}{l} 
\forall  D\in M,  m   \textit{ with } \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}      \\
       %\textit{internal methods }
        ~ \strut \hspace{0.5cm} m \textit{ private}  \\ 
            ~ \strut \hspace{0.9cm} \textit{ for all its  specs } A_{pre},  A_{post}:\\ 
             ~\strut \hspace{2cm}
 					   {\hproves{M} { \ \prg{this}:\prg{D}\, \wedge\, \overline{y:D}\, \wedge\, A_{pre}\  } {\ s\ } {\ A_{post} \ } }\\
      ~ \strut \hspace{0.5cm} m \textit{ public}  \\ 
           ~ \strut \hspace{2cm}  { \hproves {M} {\ \prg{this}:\prg{D} \wedge\ \overline{y:D}   \ \wedge \ \PushAS {y} {\extract{M} } } {\ s\ } {\ \PushAS {y}{\extract{M}} } } \\
        ~ \strut \hspace{0.9cm} \textit{ and for all its  specs } A_{pre},  A_{post}:\\ 
             ~\strut \hspace{2cm}   
              ~ \strut \hspace{2cm}  { \hproves {M} {\ \prg{this}:\prg{D} \wedge\ \overline{y:D}  \ \wedge \ \PushAS {y} {\extract{M} } \ \wedge \ A_{pre}\ } {\ s\ } {\ A_{post} }  }
\end{array}
}					  					  
{   
	\ \vdash\ M \ 
}
\end{array}
$

%	}
%\\\\

\footnoteSD{\red{QUESTIONS: }

\begin{enumerate}
\item 
Can we express what Fig \ref{f:calls} does, but more streamlined? -- SD has no ideas here  :-(
\item
In the rule for $\vdash M$,   I wonder whether we should be using ${\extract{M}}$ rather than $\PushAS {y} {\extract{M}}$. -- SD thinks this is only a matter of more thinking
\item
Do we want to forbid private methods to make external calls -- see Sect \ref{s:privateMs}? If we do that, then we need to extend the oper semantics and the inference rules in trivial, and boring ways...
\item
In  Fig \ref{f:calls} I wonder whether there are also stronger versions, where we require ${\extract{M}}$ rather than $\PushAS {y} {\extract{M}}$, pretty much as in the difference between {\sc{ExtCall\_WithSpec\_Weak}}  and the other rule, {\sc{ExtCall\_WithSpec\_Strong}}. But this would blow up the rules even more! 
\item
 Does the consequence rule require that the assertions are encapsulated? And if an assertion is encapsulated, is its consequence also encapsulated? TODO - EASY
\item
All rules require that the variables in the quantifiers do not appear in the meathod bodies, and are disjoint from the parameters.
TODO explain -EASY. 
\item  We need to add some dynamic type checking to the language, ie the public method call crashes if the actual params do not fit the formal types. Thisi is only for convenience; we cloud type them all as \prg{Object}, and crash by hand. TODO - EASY
\item
Do we need "modifies" or "does not modify" clauses too? Or can we assume that the underlying HL does this implicitly? For example, does\\
$\strut \ \ \  \hproves{M}  {a:Account \wedge p:Password \wedge a.passwd=p} {stmts}  {a.passwd=p}$\\ (with $a$ and $p$  free in $stmts$),  implicitly promise that no account's password has been modified? Shall we require the underlying logic to support such judgments -- say that if it has modifies clauses, or SL, it could do that?\\
Such an approach might solve the "late binding" issues mentioned below.
\end{enumerate}
 }

\subsection{Examples}

\begin{example}[Specification for Payments Module]
Consider the following three specs. They are equivalent, \ie $S_1 \equiv S_2 \equiv S_3$

$\begin{array}{lcl}
S_1& \ = \ &  \TwoStatesQ {a: Account}{ \inside {a} } {  \inside {a}  }\\
& & \wedge \\
& &  \TwoStatesQ {a: Account}{ \inside {a.password} } {  \inside {a.password}  }\\
& & \wedge\\
& & \forall {a: Account, p: Password}\FirstState{ (\inside {a}\vee\inside {a.password}) \wedge a.password=p \wedge a.balance=r  } \\
& & \strut \hspace{3.5cm} 
                     \SecondState {  a.password=p \wedge a.balance=r   }
\\
\end{array}
$

$\begin{array}{lcl}
S_2& \ = \ &  \TwoStatesQ {a: Account}{ \inside {a} } {  \inside {a}  }\\
& & \wedge \\
& &  \TwoStatesQ {a: Account}{ \inside {a.password} } {  \inside {a.password}  }\\
& & \wedge\\
& & \forall {a: Account, p: Password}\FirstState{ (\inside {a}\vee\inside {a.password}) \wedge a.password=p \wedge a.balance=r  }\\
& & \strut \hspace{3.5cm} 
                     \SecondState{ (\inside {a}\vee\inside {a.password}) \wedge a.password=p \wedge a.balance=r  }
\\
\end{array}
$

$\begin{array}{lcl}
S_3& \ = \ &  \TwoStatesQ {a: Account}{ \inside {a} } {  \inside {a}  }\\
& & \wedge \\
& &  \TwoStatesQ {a: Account}{ \inside {a.password} } {  \inside {a.password}  }\\
& & \wedge\\
& & \forall {a: Account, p: Password}\FirstState{ \inside {a}  \wedge a.password=p \wedge a.balance=r  } \\
& & \strut \hspace{3.45cm} 
                     \SecondState {  \inside {a}  \wedge a.password=p \wedge a.balance=r   }
                     \\
                     & & \wedge\\
& & \forall {a: Account, p: Password}\FirstState{   \inside {a.password} \wedge a.password=p \wedge a.balance=r  } \\
& & \strut \hspace{3.45cm} 
                     \SecondState { \inside {a.password}  \wedge a.password=p \wedge a.balance=r  }
\end{array}
$

\end{example}

\subsubsection{Method Specs for the $pay$ method, as in OOPSLA}

\newcommand{\SP}{~\strut \ \ \ \ \ \ \ \ \ }
Consider a public method in class $Account$, defined as \\
$\strut \ \ \  void\  pay(a: Account, p:Password, j: int)\{ \ if\ ( this.passwrd== p)\ .....\  \}$
\\
This method could have the following "classical" spec
\\ 
$\SP---\ PP1:$\\
$\SP PRE:\ \ \ p',p'' : Password \ \wedge \ this.password=p'  $
\\
$\SP POST: \ \  this.password=p'  $
\\
$\SP---\ PP2:$\\
$\SP PRE:\ \ \ this \neq a\  \wedge \ this.password=p   \ \wedge \ this.balance=b \ \wedge\ a.balance=b'$
\\
$\SP POST: \ \   this.balance=b-j \ \wedge\ a.balance=b'+j$
\\







This method will have the same specifications as in OOPSLA. And note that $a'$ does not appear in the signature or the body of $pay$.  \\ 
$\SP---\ PP1:$\\
$\SP PRE:\ \ \ a': Account \ \wedge \  p' : Password \ \wedge \ a'.password=p' $
\\
$\SP POST: \ \ a'.password=p' $
\\
$\SP ---\ PP2:$\\
$\SP PRE:\ \ \ a':Account \ \wedge\ k: Int \ \wedge  a'\neq a, this\ \wedge\  a'.balance = k \ \ $\\
$\SP POST:\ \   a'.balance = k \ \ $
\\
$\SP ---\ PP3:$ \\
$\SP PRE: \ \ p=this.password \ \wedge\ i,k:Int \ \wedge \ this.balance=i \ \wedge \ a.balance=k\ \wedge a\neq this$
\\
$\SP POST:\ \  this.balance=i-j \ \wedge\  a.balance = i+j \ \ $\\
$\SP ---\ PP4:$\\
$\SP PRE:\ \ \ ( p\neq this.password\, \vee\, a=this)\  \wedge \  a':Account \ \wedge\ k: Int\   \wedge\  a'.balance = k $\\
$\SP POST: \ \ a'.balance=k$

It would be nice if we were able to avoid having to write $PP1$ and $PP2$ explicitly, esp. as when we add stuff like the bank, etc, these specs will grow even more. Adopting \prg{modifies}-clauses or SL would be an approach to that.


\subsubsection{Method Specs for a public method whose body makes an external call}
 The method \prg{buy} contains an external call, and is meant to demonstrate the new power of our system. Assume that \prg{buy}
 is part of a further class \prg{Shop}.   Assume also that \prg{Item} is a class in my module, and that it has a field \prg{price}.
 % From the type system, we could deduce that $\OneStateQ{a:Account,anItem:Item}{\protectedFrom {a.password}{anItem}
 
\begin{lstlisting}
class Shop

    fld myAccount : Account
    fld inventory : Inventory
    
    void buy(buyer: Object, anItem: Item)
        int price = anItem.price
        int oldBalance = this.myAccount.balance
        buyer.Payment(myAccount,price)
        if (this.myAccount.balance == oldBalance+price)
            this.inventory.remove(anItem)
            buyer.send(anItem)
       else
             buyer.tell("you have not paid me")  
             
\end{lstlisting}

The specifications below guarantee that protection of an account's password from $buyer$ is preserved, and if a password is protected from $buyer$, then its balance cannot decrease ($PP10$). Moreover, protection from $buyer$ of an account different than the shop's account is preserved, and if an account is protected from buyer, then it balance will remain the same.
\noindent
$\SP ---\ PP10:$\\
$\SP PRE:\ \ \ a': Account \ \wedge \ \protectedFrom {a'.password}{buyer} \ \wedge \  k:int \ \wedge \ a'.balance=k$\\
$\SP POST: \ \ a'.balance \geq k \ \wedge\  \protectedFrom {a'.password}{buyer} $
\\
$\SP ---\ PP11:$\\
$\SP PRE:\ \ \ a': Account \ \wedge \ (\protectedFrom {a'}{buyer} \wedge a'\neq this.myAccount) \ \wedge \  k:int \ \wedge \ a'.balance=k$\\
$\SP POST: \ \ a'.balance = k \ \wedge\  \protectedFrom {a'}{buyer} $

\vspace{.2cm}
QUESTION: Are there more to the spec? 

TODO explain what are the additional guarantees that we are making vs, eg the guarantees made by $S_4$. Not sure there are any, actually when we apply the $\PushAS {\_} {\_}$ operator to the module's spec, ...

\subsubsection{What to check}
This example illustrates what we need to check when:

Take a moddule $M$ with classes $D$ and $E$, and holistic specification:\\
$\strut \ \ \  HS(M)= \OneStateQ{d:D}{d.f\geq 300} \wedge  \TwoStatesQ{e:E,i:int}{e.f\geq i} {e.f\geq i} $,\\
Then, when we extract the ???would be nice to have a name! ??? we obtain\\
$\strut \ \ \   \extract{M}  = \forall d.[d:D \rightarrow d.f\geq 300]\ \wedge \  [ e:Int \wedge i:int \wedge e.f \geq i]$

\paragraph{Public Methods}
Assume that $D$ has a public method  with formal parameter $y:E$, and body $s$. Then, we have to prove\\
$\strut \ \ \  \hprovesTwoLines {M} {this:D \wedge y:E \wedge  \forall d.[d:D \rightarrow d.f\geq 300]\ \wedge\  \  [ e:E \wedge i:int \wedge e.f \geq i]\ } {s}
{\forall d.[d:D \rightarrow d.f\geq 300]\ \wedge\  \  [ e:E \wedge i:int \wedge e.f \geq i]\ }$

\vspace{.1cm}

In the table below, we show various bodies for $s$ and discuss whether they satisfy the requirment; We assume that z1, and z2 are   external. And we assume that $E$ has a filed $nxt$ also of class $E$.

\begin{tabular}{lclcl}
$s$ is & & satisfies? &  & comment\\
\hline  
 this.f = 200  &\ \  & NO\\
  this.f = 200; this.f = this.f+100  & & YES\\
  this.f = 200;\   \textbf{z1.m()};  \ this.f = this.f+100  & & NO\\
  y.f = y.f+1   & & YES   \\
  y.f = y.f-1   & & NO & \ \  &  \\
 y.nxt.i = y.nxt.i -1   & & NO\\
 e1=new E; e1.f=7 & & YES\\
 e1=new E; e1.f=7; \   \textbf{z1.m()};  \ e1.f=3 &  & YES & & surprising?\\
  e1=new E; e1.f=7; \  \textbf{z1.m()};  \ e1.f=3  \textbf{z2.m()};  e1.f=2 &  & YES & & surprising?\\
 \hline
\end{tabular}

\paragraph{Private Methods}
\label{s:privateMs}
We have a design choice with private methods, namely: Either A) we do not allow private methods to make external calls, or B) We rethink type checking of
private methods. 

Namely, continue our example from earlier, and assume a public and a private method $m\_public$, and $m\_private$ in class $E$, and bodies\\
\begin{tabular}{clclcl}
VERSION\_1\\
& m\_public & & this.f=this.f+1; m\_private; this.f:=this.f-1 \\
& m\_private & &\textbf{z1.m()};\\
VERSION\_2\\
& m\_public & & this.f=this.f-1; m\_private; this.f:=this.f+1 \\
& m\_private & &\textbf{z1.m()};\\
VERSION\_3\\
& m\_public & & this.f=this.f+101; m\_private; this.f:=this.f+1 \\
& m\_private & &this.f=this.f-1; \textbf{z1.m()};
\end{tabular}

If we go with A) we forbid VERSION\_1 as well as VERSION\_2. If we go with B) we allow  VERSION\_1 and forbid VERSION\_2.
%\end{figure}
%\begin{figure}[thb]
%%\footnotesize
%$
%\begin{array}{c}
%\inferrule [Two-State]
%	{
%	\\\\
%	M \vdash \encaps{\overline {x:C}\, \wedge \, A_1  } \ \ \ \ \ \ \ \ \ \ \ M \vdash \encaps{\overline {x:C}\, \wedge \, A_2}
%	\\\\
%	\sdN{OSS(M)=A_{os}}
%	\\\\\
%	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
%					  \strut \hspace{3.5cm} {\hproves{M}{ \overline{x:C}\ \wedge \ A_1\ \wedge \ \sdN{A_{os}} \wedge \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A_2\ }} \ \parallel \  A_2 \wedge A_{os}
%}
%	{
%	M\ \vdash\ {\TwoStatesQ {\overline {x:C}} {A_1} {A_2} }
%	}
%\\\\
%\\\\
%\inferrule [One-State]
%	{
%		 M \vdash \encaps{\overline {x:C}\, \wedge \, A } 
%			%        A_{os} %=\overline{\OneStateQ{\overline {y:C}}{A''}}\ 
%		% \mbox{\ conjunction of all one state invariants in } HS(M)   
%		\\ \\ 
%		\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
%					  \strut \hspace{4.5cm}  {\hproves{M}{ \overline{x:C}\ \wedge \ A\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A\ }} \ \parallel \  A 
%}
%	{  
%	         M\ \vdash \ \OneStateQ{\overline {y:C}}{A} 
%	}
%\\\\
%\inferrule [Intrm]
%	{
%		\\ \\
%		A_{os} %=\overline{\OneStateQ{\overline {y:C}}{A''}}\ 
%		\mbox{\ conjunction of all one state invariants in } HS(M)    
%		\\\\
% 		 \hproves{M} { \ A_1\ \wedge\ A_{os}\ } {\ s\ } {\ A_2\ \wedge\ A_{os}\  } \
% 		\\\\ 	
%				\forall  s', z, m.[\ \  \
%				   s \equiv s'; z.m(\_); \_\ \wedge \ 
%				  \hproves{M} {\ A_1 \wedge \ A_{os}\ } {\ s'\ } {\  \external{z}\  } \\ \\
%				  \strut \hspace{6.5cm}
%				  \Longrightarrow\ \ \ \hproves{M}{\ A_1 \wedge A_{os} \ }{\ s'\ } {\ A_2 \wedge A_{os}  \ } \ \ ]
%	}
%	{  
%	         { \hproves{M}{\ A_1\ }   {\ s\ } {\ A_2\ } }  \parallel \  A_2   
%	}
%\\\\
%\begin{array}{lcl}
%\inferrule[Weaken]
%{
%M \vdash S \\ \strongerI M S {S'}
%}
%{
%M \vdash S'
%}
%&\ \ \  &
%\inferrule[Multi]
%	{
%	M\ \vdash\ S 
%	\\
%	M\ \vdash\ S' 
%	}
%	{
%	M\ \vdash\ S \wedge S'
%	}
%\end{array}
%
%\end{array}
%$
%\caption{Inferring that module satisfies its specification}
%\label{f:module:invariats}
%\end{figure}



%\end{figure}
%\begin{figure}[thb]
%%\footnotesize
%$
%\begin{array}{c}
%\inferrule [Two-State]
%	{
%	\\\\
%	M \vdash \encaps{\overline {x:C}\, \wedge \, A_1  } \ \ \ \ \ \ \ \ \ \ \ M \vdash \encaps{\overline {x:C}\, \wedge \, A_2}
%	\\\\
%	\sdN{OSS(M)=A_{os}}
%	\\\\\
%	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
%					  \strut \hspace{3.5cm} {\hproves{M}{ \overline{x:C}\ \wedge \ A_1\ \wedge \ \sdN{A_{os}} \wedge \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A_2\ }} \ \parallel \  A_2 \wedge A_{os}
%}
%	{
%	M\ \vdash\ {\TwoStatesQ {\overline {x:C}} {A_1} {A_2} }
%	}
%\\\\
%\\\\
%\inferrule [One-State]
%	{
%		 M \vdash \encaps{\overline {x:C}\, \wedge \, A } 
%			%        A_{os} %=\overline{\OneStateQ{\overline {y:C}}{A''}}\ 
%		% \mbox{\ conjunction of all one state invariants in } HS(M)   
%		\\ \\ 
%		\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
%					  \strut \hspace{4.5cm}  {\hproves{M}{ \overline{x:C}\ \wedge \ A\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A\ }} \ \parallel \  A 
%}
%	{  
%	         M\ \vdash \ \OneStateQ{\overline {y:C}}{A} 
%	}
%\\\\
%\inferrule [Intrm]
%	{
%		\\ \\
%		A_{os} %=\overline{\OneStateQ{\overline {y:C}}{A''}}\ 
%		\mbox{\ conjunction of all one state invariants in } HS(M)    
%		\\\\
% 		 \hproves{M} { \ A_1\ \wedge\ A_{os}\ } {\ s\ } {\ A_2\ \wedge\ A_{os}\  } \
% 		\\\\ 	
%				\forall  s', z, m.[\ \  \
%				   s \equiv s'; z.m(\_); \_\ \wedge \ 
%				  \hproves{M} {\ A_1 \wedge \ A_{os}\ } {\ s'\ } {\  \external{z}\  } \\ \\
%				  \strut \hspace{6.5cm}
%				  \Longrightarrow\ \ \ \hproves{M}{\ A_1 \wedge A_{os} \ }{\ s'\ } {\ A_2 \wedge A_{os}  \ } \ \ ]
%	}
%	{  
%	         { \hproves{M}{\ A_1\ }   {\ s\ } {\ A_2\ } }  \parallel \  A_2   
%	}
%\\\\
%\begin{array}{lcl}
%\inferrule[Weaken]
%{
%M \vdash S \\ \strongerI M S {S'}
%}
%{
%M \vdash S'
%}
%&\ \ \  &
%\inferrule[Multi]
%	{
%	M\ \vdash\ S 
%	\\
%	M\ \vdash\ S' 
%	}
%	{
%	M\ \vdash\ S \wedge S'
%	}
%\end{array}
%
%\end{array}
%$
%\caption{Inferring that module satisfies its specification}
%\label{f:module:invariats}
%\end{figure}


%\subsection{Soundness of the \SpecLang Logic}
%
% 
%\label{s:soundness}
%
%We will now prove soundness of the  \SpecLang Logic. For this, we will first prove soundness of our extended Hoare logic.
%
%
%\begin{lemma}
%Assuming a sound \SpecO proof system, $\proves{M}{A}$, and  and
%a sound encapsulation inference system, $\proves{M}{\encaps{A}}$. Then:
%\begin{itemize}
%\item
%The inference system  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$  defined in the previous section is sound.
%\end{itemize}
%\end{lemma}
%
%\begin{proof}
%Take arbitrary modules  $M$, $M'$, expression $e$,  assertions $A$, $A'$ and $A''$ and assume
%\begin{enumerate}
%\item
% $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ 
% \item
% $M,\sigma \ \models \ A$
% \item
%$ \sigma.cont$=$e$ 
%\item
%$M\circ M', \sigma \leadsto^* \sigma' \ \ \wedge\ \ \sigma'.cont$ is a value
%\end{enumerate}
%We want to show that
%\begin{enumerate}
%\item
%$M,\sigma' \ \models \ A' $
%\end{enumerate}
%The proof proceeds by induction over a lexicographic ordering over the tuples $(M, A, e, A', \sigma, \sigma')$ This ordering is the tuple of ($m_{cl}$, $m_{ext}$), where 
%$m_{cl}$ is the length of the maximal sequence of proof steps in "classical Hoare logic, ie excluding a step {\sc{ExtCall}} involved in proving that  ie excluding a step {\sc{ExtCall}}, and the $m_{ext}$ is the number of external calls that occurred ... {TODO: this needs to be refined!}
%
%\end{proof}



 