\section{Proving Adherence to \SpecLang Specifications}

\subsection{Semantics of  a Hoare Triples -- Soundness of Hoare Logic}

We will develop a  Hoare logic with judgments of the form  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ which promise that execution of the expression $e$ in a configuration with satisfies $A$ will lead to a configuration that satisfied $A'$. 
%{
%\begin{definition}[Semantics of Hoare triples and quadruples]
%
%For modules $M$, and assertions $A$, $A'$ and $A''$ we define the semantics of Hoare-triples, 
% $M\ \models\  \{\, A \,  \}\ e\  \{\, A' \, \}$, and Hoare quadruples, $M\ \models\  \{\, A \,  \}\ e\  \{\, A' \, \}\, \parallel\, A''$, as follows:
%\begin{itemize}
%\item
%$M\ \models\  \{\, A \,  \}\ e\  \{\, A' \, \}\, \parallel\, A''$ \\
% iff \\
% for a all $M_{ext}$, for all $\sigma$ such that $\sigma \in Arising ...$ \\
%$M,\sigma \ \models \ A  \ \wedge\  
%\sigma.cont$=$e \ \wedge\  M\circ M_{ext}, \sigma \leadsto^* \sigma'$  
%\\
%$\Longrightarrow$ \\
%$M_{int},\sigma' \ \models \ A'' \ \wedge\  (\ \sigma'.cont$ is a value $\ \Longrightarrow\ $$M_{int},\sigma' \ \models \ A'\ ). $
%\end{itemize}
%\end{definition}
%}
%
%\subsection{Hoare Rules}
%\label{s:inference}
%
%Note that $M_{int}\ \models\  \{\, A \,  \}\ e\  \{\, A' \, \}\, \parallel\, A''$  does {\emph not} imply that $M_{int}\ \models\  \{\, A \,  \}\ e\  \{\, A' \, \}$

%In this Section we provide a proof system for constructing 
%proofs of the \SpecLang specifications defined in \S \ref{s:holistic-guarantees}.
%Such proofs consist of 
% three parts:  
%\begin{description} 
%\item[(Part 1)]
%Proving Assertion Encapsulation (\S \ref{s:encaps-proof})
%\item[(Part 2)]
%Proving that   method bodies adhere to specifications written in \AssertLang (\S \ref{s:classical-proof})
%\item[(Part 3)]
%Proving that modules adhere to \SpecLang specifications (\S \ref{s:module-proof})
%\end{description}
%
%Part 1 is, to a certain extent, orthogonal to the main aims of our work;
%in this paper we propose a simple approach based on the type system, while also acknowledging that 
%better solutions are possible.
%For Parts 2-3, we 
%TODO
% came up with the key ideas outlined in  \S \ref{s:approach}, which we
% develop in more detail in \S \ref{s:classical-proof}-\S \ref{s:emergent-proof}.}

\begin{axiom}
We assume a judgment of the form $M \vdash A$, which had the property that\\
\strut \hspace{5cm} $M \vdash A $ \ \ \ \ implies \ \ \ \ $M \vDash A$
\end{axiom}


\subsection {Assertion Encapsulation}
\label{s:encaps-proof}

{
{\SpecLang proofs  hinge on the fact that some assertions cannot be invalidated unless some 
} internal (and thus known)
computation took place. 
{We refer to this property as \emph{Assertion Encapsulation},}
}
formally $M\ \vDash  \encaps{A}$, which states that 
 assertion $A$ is encapsulated by module $M$.


\subsubsection{Semantics of Assertion Encapsulation}

{An assertion $A$  is  encapsulated by a module $M$ under condition $A'$,
if in all possible states which arise from execution of module $M$ with any other external module $M_{ext}$, and which satisfy $A'$, 
the validity of $A$} 
{ can only be changed via computations internal to that module} -- \emph{i.e.},  via a call to
a method from $M$, i.e.,
calls to objects defined in $M$ but accessible from the
outside.


\begin{definition}[Assertion Encapsulation]
\label{def:encapsulation}
An assertion $A$ is \emph{encapsulated} by module $M$ and assertion $A'$, written as
\begin{itemize}
 \item     $M\ \vDash \encaps{A}$
 \end{itemize}
if, for all external modules $M_{ext}$, and all states $\sigma$, $\sigma'$
such that $\arising{M_{ext}}{M}{\sigma}$, {and variables $\overline{x}$ and objects $\overline{o}$}:

\begin{itemize}
 \item
  $\satisfiesA{M}{\sigma}{A}$,  \ \ \ \   $\overline{x}=Free(A)$, \  \  \ \ $\overline{o}=\sigma(\overline{x})$,\ \ \ \ $\reduction{M_{ext}}{M}{\sigma}{\sigma'}$, \ \ \ ${M},{\sigma'[\overline{y}\mapsto{\overline{o}}]}\not\vDash{A}$
%\item $\overline{x}=Free(A)$, $\overline{o}=\sigma(\overline{x})$
%\item $\reduction{M_{ext}}{M}{\sigma}{\sigma'}$   
%\item ${M},{\sigma'[\overline{y}\mapsto{\overline{o}}]}\not\vDash{A}$
 \end{itemize}

implies

 \begin{itemize}
 \item   $\exists y,\,m,\, \overline{y} .[\ \sigma.\prg{cont}= y.m(\overline{y})\ \wedge\  \satisfiesA{M}{\sigma}{\internal{y}} \ ]
$
 \end{itemize}
\end{definition}

Revisiting the examples from \S~\ref{s:outline}, % we can see
both \ModB and \ModC encapsulate   the  equality of the \prg{balance} of an account to some value \prg{bal}: 
Namely, this equality can only be invalidated through calling  methods on internal objects.
 
{On the other hand, assume two further modules, $Mod_{ul}$ and $Mod_{pl}$: both these modules use ledgers to keep a map between accounts and their balances, which export functions that allow the update of this map. In $Mod_{ul}$ the ledger is \emph{not} protected, while in $Mod_{pl}$ the ledger \emph{is} protected. Then, in the former, the and the balance of an account is \emph{not} encapsulated, and in the latter it  \emph{is} encapsulated. } 
%
\\
\strut \hspace{1cm}
$\ModB\ \vDash\ \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm}
$\ModC\ \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm} {$Mod_{ul}\ \not\vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}
\\
\strut \hspace{1cm} {$Mod_{pl}\  \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}

\noindent
{Note that in the above, the term \prg{a.balance} is a ghost field.}



The property that a variable is protected from another one is not encapsulated, but  the property that a variable is protected \emph{is} encapsulated, regardless of the module. Note also, that  encapsulation of an assertion does not imply encapsulation of its negation; 
 for example,  ${\inside{x}}$ is encapsulated (as per below), but $\neg  {\inside{x}}$ is not.


\begin{lemma}
For any module $M$, and variables $x$ and $y$:
\begin{enumerate} 
\item $M \vDash \encaps{\inside{x}}$
\item $M \not\vDash {\encaps{\neg\inside{x}}}$
\item $M \not\vDash {\encaps{\protectedFrom{x}{z}}}$
\item $M \vDash A \rightarrow A' \ \ \wedge\ \  M \vDash  \encaps{A}$ \ \ implies \ \ $M \vDash  \encaps{A'}$.
\end{enumerate}
\end{lemma}

\begin{proof} Sketches:

(1) because if $y$ is protected, and since the fields are all private ... the only way .. 
\\
(2) Take a state where $\neg\inside{x}$ and that there is only external object that has access to $x$, and that this object becomes no longer accessible -- eg through field override. That means that we now have  $\inside{x}$.
\\
(3) it is always possible that another external object $z'$ has unprotected access to $x$; if $z'$ has access to $z$, then it can give it access to $x$ without invoking am internal method. (3) as a counterexample, 
\\
(4) Use that $M \vDash A \rightarrow A'$ implies $M \vDash \neg A'  \rightarrow \neg  A$. BUT CAREFUL, TODO! with the potential of non-termination on assertions!!
\end{proof}
%The key consequence of soundness is that -- SD dropped; it is   not a consequence of soundness!

\subsubsection{Deriving  Assertion Encapsulation}

{In general},  code that does not contain 
calls to a {given} module is guaranteed not to invalidate any assertions encapsulated by that module.
 Assertion encapsulation has been used in proof systems to {address}   the  {frame} problem
 \cite{objInvars,encaps}. 

We  do not mandate how this property should be derived -- instead, we rely on a judgment 
$M\ \vdash  \encaps{A}$ provided by some external system. \footnote{This is simpler than the oopsla-33 setting}
Thus, \SpecLang is parametric over the derivation of the encapsulation
     judgment; in fact, several ways to do that are possible \cite{TAME2003,ownEncaps,objInvars}. For example,
 the appendices of
    \cite{necessityFull} present a 
	%Appendix~\ref{s:encap-proof} and
    %Figure~\ref{f:asrt-encap}  we present a 
    rudimentary system that is sufficient to support our example
    proof.  


%As we have already stated at the beginning of this section,
%encapsulation is a deep topic that is well studied in the literature, 
%and is not the focus of this paper. For now, we simply assume the existence 
%of a proof system for encapsulation as it is secondary to the central topic 
%of this paper. We need only assert that such an algorithmic proof system 
%must be sound (Definition \ref{lem:encap-soundness}).
%% \susan[I commented out what was there as I thought it was repetious]
%% {We are assuming the existence of a proof system for encapsulation and only need to assert that such an algorithmic proof system nust be sound.}
%% The construction of the algorithmic system is not central to our work,
%% because, as we shall see in later sections, our logic 
%% does not rely on the specifics of an encapsulation algorithm, only its soundness.

Like OOPSLA 22 Our logic does not {deal with, nor} rely on, the specifics of  how   encapsulation
{is derived}.
  % model, 
{Instead, it relies} on an encapsulation judgment and expects it to be sound:

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A$:\\

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ $ implies $\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{definition}




\subsubsection{Types for Assertion Encapsulation}
\label{types}
TODO: something simple ere 

\subsection{Assertion Inference}




\subsection{Weaker/Stronger Specifications}

We assume   the existence of a function $HS$ which allows us to look up the holistic specification of a module. 
In Figure \ref{fig:si} we   define a judgment $\stronger M S  {S'}$ which expresses that the specification $S$ is stronger than the specification $S'$ under module $M$.  

\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lcl}
\inferrule [HS-1]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_1}
	}
&  & 
\inferrule [HS-2]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_2}
	}
\\
\\
\inferrule [HS-rename-1]
	{ \\\\
	\strongerI M S {\OneStateQ {\overline {x:C}} {A} }
	\\
	\overline {y} \mbox{ free in } A
	}
	{\strongerI M S {\OneStateQ {\overline {y:C}} {A[\overline y/\overline x]} }
	}
&  & 
\inferrule [HS-rename-2]
	{ \\\\
	\strongerI M S {\TwoStatesQ {\overline {x:C}} {A} {A'} }
	\\
	\overline {y} \mbox{ free in } A, A'
	}
	{\strongerI M S {\TwoStatesQ {\overline {y:C}} {A[\overline y/\overline x]} {A'[\overline y/\overline x]} }
	}

\\
\\
\inferrule [HS-3]
	{ \\ 
	M \vdash (\overline {x:C} \wedge A) \rightarrow A' }
	{\strongerI M  {\OneStateQ {\overline {x:C}} {A} }  {\OneStateQ {\overline {x:C}} {A'} } }
	&  &
\inferrule [HS-4]
	{ \\ }
	{\strongerI M {\OneStateQ {\overline {x:C}} {A} } {\TwoStatesQ {\overline {x:C}} {A} {A} }
	}
\end{array}
\\
\\	
\inferrule [HS-5]
	{ \\ 
	M \vdash ({\overline {x:C}} \wedge A_1) \rightarrow A_1' \ \hspace{.5cm} M \vdash ({\overline {x:C}} \wedge A_2') \rightarrow A_2 }
	{\strongerI M   {\TwoStatesQ {\overline {x:C}} {A_1'}{A_2'} }   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2} }
	}		
\end{array}
$
\label{fig:si}
\caption{Specification Implication}
\end{figure}

\begin{lemma}
For all modules $M$, and specifications $S$ and $S'$, we have that\\
\strut \hspace{2cm} $\strongerI M  S  {S'}    \ \ \ \ \Longrightarrow\ \ \ \ \stronger M S {S'}'$
\end{lemma}

We now define what it means for a module $M$ to promise a specification $S$:

\begin{definition}
Given module $M$ snd specification $S$:

\strut \hspace{2cm} $\promises M S$ \ \ \ \  iff \ \ \ \  $\strongerI M {HS(M)} S$
\end{definition}

Notice, that $\promises M S$ is only based on the spec of $M$, and does not guarantee that indeed $M$ satisfies $S$.

%\subsection{Proving method bodies while using  \AssertLang specifications}
%\label{s:classical-proof}
% 
%We now develop a Hoare logic, which can prove assertions of the from \\
%\strut \hspace{1cm} $\hproves{M}{A}{\prg{s}}{A'}$.\\
%where \prg{s} is a statement in \Loo, and $A$ and $A'$ are assertions in \AssertLang.
%
%The challenges here are 1) that \AssertLang assertions support, on top of the classical features, also ??what-shall-we-call-them? protection features, and 2) we need to reason about calls to external modules.
%
%
%We assume that there exists some
%proof system  that   allows us to prove 
% specifications of the form  $\hproves{M}{A}{\prg{s}}{A'}$.
%{We further assume that such a proof system is sound, i.e. that 
%if xxx TODO 
%% if $\hproves{M}{\hoare{P}{\prg{res = x.m($\overline{z}$)}}{Q}}$, then 
%% for every program state $\sigma$ that satisfies $P$, the execution of the method call \prg{x.m($\overline{z}$)}
% % esults in a program state satisfying $Q$.}
% We then expand the proof rules as follows ....
 


\subsection{Reasoning about protection}
We expand that logic with rules about protection, as in Fig. \ref{f:protection}. Essentially, the only what that the "protection" of an object can decrease is if we call an eternal method, and pass it an internal object as argument. This is then covered by the rule in Fig. \ref{f:external:calls}.

\begin{figure}[hbt]
$
\begin{array}{c}
\inferrule[\sc{prot-1}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge \ \internal y }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\sc{prot-1}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge \ \internal v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-2}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\  \wedge\ \internal {y'} \ \wedge\  x \neq y'}
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

	\inferrule[\sc{prot-3}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\  \protectedFrom{x}{y'} }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%	\inferrule[\sc{prot-2}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge\ \external v\ \wedge\  z\neq v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\


%	\inferrule[\sc{prot-4}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{v}\ \wedge\ \external z\  }
%						{\ z=v\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-4}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\ z \neq \this}
						{\ y =y'.f\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\textsc{prot-5}]
%	{}
%	{\hproves{M}
%			{}
%	}
\end{array}
$
\caption{Protection Logic}
\label{f:protection}
\end{figure}

TO-DISCUSS 1)Should f it be $\in HS(M)$ or something more general. ie can it be implied from .. ? Premise of  \textsc{prot-3} may be too strong!
2) What about the universally quantified $\overline x$? 3)  Note that $y'$ and $y$ talk of a different variable.
 

Explanations: \textsc{xxxl} states that   yyy
  
 
\subsection{Reasoning about calls}

We now show how to reason about external calls

\begin{figure}[hbt]
\begin{mathpar}
% the below are speacil cases of the last one
%\inferrule[\sc{ExtCall-1}]
%{ 
%	      \\\\
%		M \vdash A\ \rightarrow \  ( \  \external \{ z, z', z''\}\ \wedge\ \internal x \ \wedge\  \ y:C \ \wedge \ 
%  x\neq y \
%  \wedge\ \protectedFrom {y} {\{z,z',z''\} }\ )
%	\\\\ 
%	\promises M   {\TwoStatesQ {\overline {y:C}} {\inside y}{\inside y}} 
%		}
%	{\hproves{M} 
%						{ A }
%						{ \ z.m(z',x)\  }
%						{ \protectedFrom {y} {\{z,z',z''\} } }
%	}\\ \\
%\inferrule[\sc{ExtCall-2}]
%	{ 
%	      \\\\
%		M \vdash A\ \rightarrow \  ( \  \external \{ z, z', z''\}\ \wedge\ \internal x \ \wedge\  \ y:C \ \wedge \   x\neq y.f \
%  \wedge\ \protectedFrom {y.f} {\{z,z',z''\} }\ )
%		\\\\ 
%	\promises M   {\TwoStatesQ {\overline {y:C}} {\inside y.f}{\inside y.f}} 
%		}
%	{\hproves{M} 
%						{ A }
%						{ \ z.m(z',x)\  }
%						{ \protectedFrom {y.f} {\{z,z',z''\} } }
%	}
%\ \\
\inferruleSD{[\sc{ExtCall}]}
	{ 
		 M \vdash A\ \rightarrow \ \red{ {\external{z}}  }
		  \\
   	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
           \\
		M \vdash {\lift A  {\{z,\overline {u}\}}  {\overline y}} \  \rightarrow \ (\  \red{ {\overline {x:C}}\ {\wedge\ A_1}} \  )	 
		}
	{   \hproves{M} 
						{ \ A\  }
						{ \ z.m(\overline u)\  }
						{ \  \llower {A_2}{(z,\overline y)} \ \wedge\ { \preserve  A  {(z,\overline y)} M }  \ }	
}
\end{mathpar}
\caption{Internal and External Calls Logic}
\label{f:external:calls}
\end{figure}

$\begin{array}{lcll}
\lift {v=v'} {\overline  y}  & = & v=v' 
\\
\lift {x.f=v} {\overline y} & = & x.f=v 
\\
\lift{ \inside x}  {\overline  y}  & = &   \inside x 
\\
\lift{\protectedFrom x {\overline {u}} }  {\overline  y}  & = &   \inside x & \mbox{if } { x\not\in \overline{y}}
\\
   & = &   \prg{true} & \mbox{otherwise}

\\
\lift {A_1 \wedge A_2} {\overline   y}  & = & \lift { A_1} {\overline y}    \ \wedge \lift {A_2} {\overline y}  
\\
\lift {\neg A} {\overline z} {\overline y}  & = & \neg (\lift {A} {\overline y}  )& \mbox{if  $A$ is protection-free}
\\
  & = &  \prg{true} & \mbox{otherwise}
\\
\lift {\forall \overline{x:C}.[ A ]} {\overline   y}  & = & \forall \overline{x:C}.[ \lift A  {\overline y}  ] & 
\\
\lift {\exists \overline{x:C}.[ A ]} {\overline  y}  & = & \exists \overline{x:C}.[ \lift A  {\overline y}   ] & 
\end{array}
$

$\begin{array}{lcll}
\\
\\
\llower {v=v'} {\overline   y}   & = & v=v' 
\\
\llower {x.f=v} {\overline   y}  & = & x.f=v 
\\
\llower{ \inside x}  {\overline   y}  & = &   \prg{true}
\\
\llower{ \protectedFrom x {\overline {u}} }  {\overline   y}  & = &     \protectedFrom x {\overline {u}}  
\\
\llower {A_1 \wedge A_2} {\overline   y}  & = & \llower { A_1} {\overline   y} \ \wedge\ \llower {A_2}   {\overline   y} 
\\
\llower {\neg A}  {\overline   y}  & = & \neg (\llower  {A} {\overline   y} ) & \mbox{if  $A$ is protection-free}
\\
  & = &  \prg{true} & \mbox{otherwise}
\\
\llower {\forall \overline{x:C}.[ A ]} {\overline   y}   & = & \forall \overline{x:C}.[ \llower A   {\overline   y} ] & 
\\
\llower {\exists \overline{x:C}.[ A ]} {\overline   y}  & = & \exists \overline{x:C}.[ \llower A  {\overline   y} ] & 
\end{array}
$

{\small{
$\begin{array}{lcll}
\\
\\
\preserve {v=v'} {\overline  y} M  & = &  v=v' 
\\
\preserve {x.f=v} {\overline  y} M & = & x.f=v  & \mbox{if} \ \ \promises M   {\TwoStatesQ {\overline {x':C},x:D} {x.f = v \wedge A_1}{x.f=v}} 
\\ 
& & & \mbox{and} \ \ M \vdash {\lift A  {\overline   y}} \  \rightarrow \ (\, {\overline {x:D}} \wedge A_1\, )
\\
   & = &   \prg{true} & \mbox{otherwise}
   \\
\preserve  { \inside x}  {\overline   y}  M & = &   \inside x 
\\
\preserve  { \protectedFrom x {\overline {u}} }  {\overline z} {\overline y} M  & = &   { \protectedFrom x {\overline {u}} }  & \mbox{if} \ \ \promises M   {\TwoStatesQ {\overline {x':C},x:D} {x.f = v \wedge A_1}{x.f=v}} 
\\ 
& & & \mbox{and} \ \ M \vdash {\lift A  {\overline  y}} \  \rightarrow \ (\, {\overline {x:D}} \wedge A_1\, )
\\
   & = &   \prg{true} & \mbox{otherwise}

\\
\preserve  {A_1 \wedge A_2} {\overline  y}  M & = & \preserve { A_1}  {\overline y}  M \ \ \wedge \\
& &  \preserve { A_2}  {\overline   y}  M
\\
\preserve  {\neg A}{\overline  y}  M   & = & \neg (\preserve {A} {\overline   y}  M)& \mbox{if  $A$ is protection-free}
\\
  & = &  \prg{true} & \mbox{otherwise}
\\
\preserve {\forall \overline{x:C}.[ A ]} {\overline   y}  M   & = & \forall \overline{x:C}.[ \preserve A  {\overline  y}  M ] & 
\\
\preserve {\exists \overline{x:C}.[ A ]} {\overline  y}  M   & = & \exists \overline{x:C}.[ \preserve A {\overline   y}  M  ] & 
\end{array}
$
}}

\subsection{Proving \SpecLang Specifications}

\subsubsection{Deriving sub-specifications}


\label{s:module-proof}

\begin{figure}[thb]
%\footnotesize
$
\begin{array}{c}
\inferrule [Two-State]
	{
	\\\\
	M \vdash \encaps{\overline {x:C}\, \wedge \, A}
	\\\\
	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
				% \strut \hspace{3cm}
				\ \  {\hproves{M}{ \overline{x:C}\ \wedge \ A\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A\ }} \ \parallel \  A 
	}
	{
	M\ \vdash\ {\TwoStatesQ {\overline {x:C}} {A} {A} }
	}
\\\\
\inferrule [External-Safe]
	{
		A_{ois}=\overline{\OneStateQ{\overline {y:C}}{A''}}\ \mbox{all object invariants in } HS(M)\ \ \ \ \ \ \ \  A_{strng}=A_{ois}\wedge A' 
		\\\\
 		 \hproves{M} {A_{strng} } {\ s\ } {\ A\ } \
 		\\\\ 	
				\forall  s', z, m.[\ \ 
				 (\  s = s'; z.m(\_); \_\ \wedge \ 
				  \hproves{M} {A_{strng}\ } {\ s'\ } {\  \external{z}\  }  \ \ \
				  \Longrightarrow\ \ \ \hproves{M}{A_{strng} } {\ s'\ } {\ A\ } \ \ ]
	}
	{
	{\hproves{M}{ A'}   {\ s\ } {\ A\ } }\  \parallel \  A   
	}
\\\\ 
\inferrule [One-State]
	{
 	M \vdash \encaps{\overline {x:C}\, \wedge \, A}
 	\\\\
 	\forall \mbox{ public } D. [\ \hproves{M}{\forall \overline{x:C}.[A]} {\ y=\prg{new}\ D\ } {\ \forall \overline{x:C}.[A]\ }	\ ]
   \\\\
 	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{ with } \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
%				% \strut \hspace{3cm}
 			\ \  {\hproves{M}{ \forall \overline{x:C}.[A]\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ \forall \overline{x:C}.[A]\ }} \ \parallel \  {\forall \overline{x:C}.[A]} 
	}
	{
	M\ \vdash\ \OneStateQ{\overline {x:C}}{A}
	}
\\\\
\begin{array}{lcl}
\inferrule[Weaken]
{
M \vdash S \\ \strongerI M S {S'}
}
{
M \vdash S'
}
&\ \ \  &
\inferrule[Multi]
	{
	M\ \vdash\ S 
	\\
	M\ \vdash\ S' 
	}
	{
	M\ \vdash\ S \wedge S'
	}
\end{array}

\end{array}
$
\caption{Inferring that module satisfies its specification}
\label{f:module:invariats}
\end{figure}

TODO: Does the consequence rule require that the assertions are encapsulated? And if an assertion is encapsulated, is its consequence also encapsulated?

The rules also require that the variables in the quatifiers do not appear in the bodies, and are disjoint from the parameters.
TODO explain. Also, we only look at the methods exported from the module.  Also, we ned to add some dynamic type checking to the language, ie the method call crashes if actual params do not fir the formal types. OR we type them all as \prg{Object}.

TODO: shall we drop one-state invariants? Do not know how to prove them here. But they are in the spirit of capabilities literature.

%\subsection{Soundness of the \SpecLang Logic}
%
% 
%\label{s:soundness}
%
%We will now prove soundness of the  \SpecLang Logic. For this, we will first prove soundness of our extended Hoare logic.
%
%
%\begin{lemma}
%Assuming a sound \SpecO proof system, $\proves{M}{A}$, and  and
%a sound encapsulation inference system, $\proves{M}{\encaps{A}}$. Then:
%\begin{itemize}
%\item
%The inference system  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$  defined in the previous section is sound.
%\end{itemize}
%\end{lemma}
%
%\begin{proof}
%Take arbitrary modules  $M$, $M'$, expression $e$,  assertions $A$, $A'$ and $A''$ and assume
%\begin{enumerate}
%\item
% $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ 
% \item
% $M,\sigma \ \models \ A$
% \item
%$ \sigma.cont$=$e$ 
%\item
%$M\circ M', \sigma \leadsto^* \sigma' \ \ \wedge\ \ \sigma'.cont$ is a value
%\end{enumerate}
%We want to show that
%\begin{enumerate}
%\item
%$M,\sigma' \ \models \ A' $
%\end{enumerate}
%The proof proceeds by induction over a lexicographic ordering over the tuples $(M, A, e, A', \sigma, \sigma')$ This ordering is the tuple of ($m_{cl}$, $m_{ext}$), where 
%$m_{cl}$ is the length of the maximal sequence of proof steps in "classical Hoare logic, ie excluding a step {\sc{ExtCall}} involved in proving that  ie excluding a step {\sc{ExtCall}}, and the $m_{ext}$ is the number of external calls that occurred ... {TODO: this needs to be refined!}
%
%\end{proof}

For the proof of soundness we will use the following two lemmas that give guarantees about preservation of properties when pushing new frames onto the stack, and when popping frames from the stack. We use the notation $\sigma \bullet \phi$ to indicate that the frame $\phi$ has been pushed on top of the ...\footnote{{these lemmas could also appear earlier ... or later}}

 
\begin{lemma}
For any module $M$, assertion $A$, variables $\overline x$, and variables $\overline x$,  % values $\overline v$, 
and any continuation, $cont$, and any states $\sigma$ and $\sigma'$ where 
$\sigma=(\psi,h)$, and $\sigma'=(((\overline {z \mapsto \sigma(x)}), cont)\cdot \psi, h)$,  
we have

\begin{itemize}
\item
$M,\sigma\ \models\  A$  \ \ implies \ \  $M,\sigma' \ \models\  \lift {A} {\overline x}   $
\item
$M,\sigma'\ \models\  A$  \ \ implies \ \  $M,\sigma  \ \models\  \llower  {A}  {\overline   x} $ 
\end{itemize}
\end{lemma}
\begin{proof}
in the next section
% by induction on the derivation of $\proves{M}{S}$.
\end{proof}


 