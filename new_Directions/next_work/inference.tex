

\section{Proving Adherence to \SpecLang Specifications}
\label{sect:proofSystem}

We will now develop an inference system to prove that a module % is well-formed $\vdash M$, \ie that a module 
satisfies its specification. This is done in three phases.
\red{TODO: refer to what we said in approach section}

In the first phase we develop a logic of triples ${\hproves{M}  {A} {\ s\ }{A'} }$, which have the expected meaning, \ie 
(*) execution of statement $s$ in a state satisfying \sdN{the \emph{precondition}}  $A$ will lead to a state satisfying  \sdN{the \emph{postcondition}}  $A'$.
These tuples only apply to statements $s$ that  do not contain method calls  (even internal calls) -- this is so, because method calls may contain calls to external methods, and therefore can only be described through quadruples.
Our triples extend an underlying Hoare logic  (${M \vdash_{ul}  \{A\} {\ s\ } \{A'\} }$) and  introduce new judgements  which talk about protection.

In the second phase we develop a logic of quadruples ${\hprovesN{M}  {A} {\ s\ }{A'} {A''}}$. These promise, as usual, that (*) 
In addition, they promise that (**) any intermediate external states reachable during execution of that statement will satisfy the invariant  $A'''$.  
\sdN{We call $A''$ the \midcond.}
 We incorporate all triples from the first phase,       
introducing invariants, give the usual substructural rules, and deal with method calls. 
For method calls we use the methods' specs, and in addition, for public methods we use the fact that they preserve the module's invariants. 
For call to external  methods, we can only use the fact that they preserve the module's invariants. 
 
In the third phase, we prove adherence to each of the specifications. 
For method specifications we prove that the body maps the precondition to the postcondition and preserves the method's invariant. 
For module invariants we prove that they  are preserved by all public methods of the module.

\vspace{.1cm}
Before describing these three phases, we introduce some preliminaries.


\subsection{Preliminaries: Specification Lookup, Assertion Stability  and  Encapsulation}


We will be using the notation $\promises M S$ to indicate that $S$ is part of the module's specification

\begin{definition}
\label{d:encaps}
 $\promises M S\ \ \ \triangleq\ \ \ S \txtin \SpecOf M  $
 \\
 where  \sdN{ for specifications $S_1$ and $S_2$, we write $S_1 \txtin   S_2$  when $S_2 \txteq  S_1$, or  $S_2 \txteq  S_1 \wedge S_3$, or $S_2\txteq S_3 \wedge S_1$,  or   $S_2 \txteq S_3 \wedge  S_1 \wedge S_4$ for some $S_3$, $S_4$.}
 \end{definition} 

\red{TODO: motivate better}
Assertions which do not contain the requirement $\inside{\_}$ are called {\emph {stable}}. 
Such assertions are stable against pushing and popping of frames.

% An assertion is {\emph {stable}}, written as $\Stable A$ if it does not contain $\inside {\re}$ assertions:
\begin{definition}
\label{def:Basic}
%\begin{figure}[hbt]
[$\Stable{\_}$] assertions: %  defined below

$
\begin{array}{c}
 \Stable {\inside{\re}}  \triangleq  false
 \\
 \begin{array}{lll}
 \Stable  {A_1  \wedge  A_2}  \triangleq     \Stable  { A_1}  \wedge    \Stable  {A_2}    
 \ \  &  
 \Stable  {\forall x:C.A}   \triangleq   \Stable  {A} \ \ 
 &   
  \Stable  {\neg A}    \triangleq   \Stable A
%\\ \\
%  \Stable {\protectedFrom \re {\overline {u}}} &  \triangleq& true 
%& & 
%  \Stable  {\internal \re} &  \triangleq & true  %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
%& &
%    \Stable {\re} &  \triangleq&   true %    \PushAS y  {(\internal \re)} &  \triangleq & {\internal \re}
%\\  \\
%   \Stable {(\re:C)} &  \triangleq&   true
 \end{array}
 \\ 
   \Stable {\protectedFrom \re {\overline {u}}} \ = \   
  \Stable  {\internal \re}  \ = \   %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
    \Stable {\re} \ = \     
     \Stable {\re:C}\   \triangleq \    true
%\end{array}
\end{array}
$
% \caption{The $\pushSymbolAA$  operator  } 
\label{f:Basic}
%\end{figure}
\end{definition}

\begin{lemma}
For all $\sigma$, $A$ and $\overline \alpha$.

\begin{itemize}
\item $ fv(A)=\emptyset\ \wedge\ \Stable{A}\ \ \ \  \Longrightarrow \ \  \ \  [\ \ M, \sigma \models A \ \Longleftrightarrow \ \  M,\PushS \alpha \sigma \models A\ \ ]$
\end{itemize}
\end{lemma}

{
Proofs of adherence to {\SpecLang specifications  hinge on the expectation that some, 
specific, assertions cannot be invalidated unless some 
} internal (and thus known) computation took place. 
{We call such assertions   \emph{encapsulated}.}
}
We give a judgementt,  $M\ \vdash  \encaps{A}$, and define its meaning as $M\ \models  \encaps{A}$.


\begin{figure}[thb]
$
\begin{array}{l}
\begin{array}{lclcl}
\inferruleSDNarrow 
{~ \strut  {\sc{Enc\_1}}}
{  
\begin{array}{l}
M; \Gamma \vdash \re : \prg{intl} \\
M; \Gamma \vdash \encaps{\re}; \Gamma
\end{array}
}
{
M; \Gamma \vdash \encaps{\re.f}; \Gamma
}
& &
\inferruleSDNarrow 
{~ \strut  {\sc{Enc\_2}}}
{  
\\
M; \Gamma \vdash \encaps{\re}; \Gamma 
}
{
M; \Gamma \vdash \encaps{\inside{\re}}; \Gamma
}
& &
\inferruleSDNarrow 
{~ \strut  {\sc{Enc\_3}}}
{  
\\
M; \Gamma \vdash \encaps{\re}; \Gamma 
}
{
M; \Gamma \vdash \encaps{\re:C}; \Gamma
}
\\ \\ 
\inferruleSDNarrow 
{~ \strut  {\sc{Enc\_4}}}
{  
\\
M; \Gamma, {x:C} \vdash \encaps {A}; \Gamma' 
}
{
M; \Gamma \vdash \encaps {\forall {x:C}. A}; \Gamma
}
&   &
\inferruleSDNarrow 
{~ \strut  {\sc{Enc\_5}}}
{   
\begin{array}{l}
M; \Gamma \vdash \encaps{A}; \Gamma'\\  \Stable A
\end{array}
}
{
M; \Gamma \vdash \encaps{ \neg A}; \Gamma'  
}
&    &
\inferruleSDNarrow 
{~ \strut  {\sc{Enc\_6}}}
{  
\begin{array}{l}
M; \Gamma \vdash \encaps{A_1}; \Gamma''   \\
  M; \Gamma'' \vdash \encaps{ A_2}; \Gamma' 
  \end{array} 
}
{
M; \Gamma \vdash \encaps{A_1 \wedge A_2}; \Gamma'
}
\end{array}
\end{array}
$
\caption{The judgment $M; \Gamma \vdash \encaps  {A}; \Gamma'$}
\label{f:encaps}
\end{figure}
 

% \subsubsection{Semantics of Assertion Encapsulation}

{An assertion $A$  is  encapsulated by a module $M$  if in all possible states which arise from execution of module $M$ with any other  module $\Mtwo$, the validity of $A$}  {can only be changed via computations internal to that module}.
 

\begin{definition}[An assertion $A$ is \emph{encapsulated} by module $M$] $~$ \\
\label{def:encapsulation}
\begin{itemize}
\item 
$M \vdash \encaps{A}  \ \   \triangleq  \ \  \exists \Gamma.[\ M; \emptyset \vdash \encaps{A}; \Gamma\ ]$ \ \  as defined in Fig. \ref{f:encaps}.
\item
$ % \begin{equation}
    M\ \models \encaps{A}\ \   \triangleq  \ \   
    \begin{cases}
     \forall \Mtwo, \sigma, \sigma',  \overline{\alpha}, \overline{x} \mbox{ with } \overline{x}=Free(A)\\ % , \mbox{and }  \arising{M\madd\Mtwo}{\sigma}:\\
   \ \ \ \  [\ \ \  \satisfiesA{M}{\sigma}{({A[{\overline {\alpha/x}}]} \ \wedge\ \externalexec)}\  \wedge\ \sdN{ \leadstoBounded {M\madd\Mtwo}  {\sigma}{\sigma'}} % \\    \ \ \ \ \ \   \ \ \ 
   \ \ \Longrightarrow\ \ 
  %  \ \ \ \ \ \  \ 
   {M},{\sigma'}\models{A[{\overline {\alpha/x}}]} \ \  ]
    \end{cases}
 $% \end{equation}
 \end{itemize}
  \end{definition}

\noindent
\textbf{Aside} \sdN{If the definition above used the more general execution, $\leadstoOrig  {M\madd\Mtwo}  {\sigma}{\sigma'}$, rather than the scoped execution,  $\leadstoBounded {M\madd\Mtwo}  {\sigma}{\sigma'}$, then fewer assertions would have been encapsulated.}
\footnote{\sdN{Assertions like    $\inside {x.f}$ would not be encapsulated.
Consider, \eg, a heap $\chi$, with objects $1$, $2$, $3$ and $4$, where  $1$, $2$ are external, and $3$, $4$ are internal, and  $1$ has fields pointing to $2$ and $4$, and $2$ has a field pointing to $3$, and $3$ has a field $f$ pointing to $4$. Take  state $\sigma$=$(\phi_1\!\cdot\!\phi_2,\chi)$, where $\phi_1$'s receiver is $1$,  $\phi_2$'s receiver is $2$,   and there are no local variables. 
We have  $...\sigma\models \externalexec \wedge \inside {3.f}$. 
We  return from the most recent all, 
getting  $\leadstoOrig  {...}  {\sigma}{\sigma'}$ where $\sigma'=(\phi_1,\chi)$; and have   $...,\sigma'\not\models  \inside {3.f}$.
}}

 
% Revisiting the examples from \S~\ref{s:outline}, % we can see
%Namely, 

\begin{example}
\label{ex:not:encaps}
For an assertion $A_{bal}\  \triangleq\ a:\prg{Account}\wedge a.\prg{balance}=b$, % can only be invalidated through internal  methods.  %on internal objects.
and modules \ModB and  \ModC  from \S~\ref{s:outline}, we have  \ \ \ $\ModB\ \models\ \encaps{ A_{bal} }$, \ \ \ and \ \ \ $\ModB\ \models\ \encaps{ A_{bal} }$.
\end{example}


\begin{example} Assume   further modules, $\ModD$ and $\ModE$,  which  use ledgers mapping  accounts to their balances, and export functions that update this map. In  $\ModD$ the ledger is  part of the \sdN{internal} module, %\emph{not} protected, while 
while in $\ModE$ it is part of the  \sdN{external} module.
Then  \ \ $\ModD \ \not\models\encaps{ A_{bal}} $, \ \  and \ \ $\ModE  \models \encaps{ A_{bal}} $.
Note that in both $\ModD$ and $\ModE$, the term \prg{a.balance} is a ghost field. 
\end{example}

\begin{note} Relative protection % (a variable is protected from another one) 
is not encapsulated, (\eg $M \not\models {\encaps{\protectedFrom{x}{y}}}$), even though    absolute protection is
(\eg $M \models \encaps{\inside{x}}$).
Encapsulation of an assertion does not imply encapsulation of its negation; 
 for example,  $M \not\models {\encaps{\neg\inside{x}}}$.
\end{note}


 
%\begin{proof} Sketches:
%
%(1) because if $y$ is protected, and since the fields are all private ... the only way .. 
%\\
%(2) Take a state where $\neg\inside{x}$ and that there is only external object that has access to $x$, and that this object becomes no longer accessible -- eg through field override. That means that we now have  $\inside{x}$.
%\\
%(3) it is always possible that another external object $z'$ has unprotected access to $x$; if $z'$ has access to $z$, then it can give it access to $x$ without invoking am internal method. (3) as a counterexample, 
%\\
%(4) Use that $M \models A \rightarrow A'$ implies $M \models \neg A'  \rightarrow \neg  A$. BUT CAREFUL, TODO! with the potential of non-termination on assertions!!
%\end{proof}
%%The key consequence of soundness is that -- SD dropped; it is   not a consequence of soundness!

%\subsubsection{Deriving  Assertion Encapsulation}
%
%{In general},  code that does not contain 
%calls to a {given} module is guaranteed not to invalidate any assertions encapsulated by that module.
% Assertion encapsulation has been used in proof systems to {address}   the  {frame} problem
% \cite{objInvars,encaps}. 
%
%We  do not mandate how this property should be derived -- instead, we rely on a judgment 
%$M\ \models  \encaps{A}$ provided by some external system. \footnoteSD{This is simpler than the oopsla-33 setting}
%Thus, \SpecLang is parametric over the derivation of the encapsulation
%     judgment; in fact, several ways to do that are possible \cite{TAME2003,ownEncaps,objInvars}. For example,
% the appendices of
%    \cite{necessityFull} present a 
%	%Appendix~\ref{s:encap-proof} and
%    %Figure~\ref{f:asrt-encap}  we present a 
%    rudimentary system that is sufficient to support our example
%    proof.   Like OOPSLA 22 Our logic does not {deal with, nor} rely on, the specifics of  how   encapsulation
%{is derived}.
%{Instead, it relies} on an encapsulation judgment and expects it to be sound:
%

{\red{TODO}: Say that there are more ways to define the encaps judgement. ALSO: show the rule for the ghostfields. }

\begin{lemma}[Encapsulation Soundness]
\label{lem:encap-soundness}
% A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
For all modules $M$, and assertions $A$: 

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ \Longrightarrow\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{lemma}


 \subsubsection{Well-formed specs}
{ \red{TODO}} Need to say encapsulated 

% PROBABLY NOT NEEDED -- KEEP PROVISIONALLY
%\subsection{Weaker/Stronger Specifications}
%
%In   Fig.  \ref{fig:si} in the appendix we define the judgment  $\strongerI M  S  {S'} $, which expresses that the specification $S$ is stronger than the specification $S'$ under module $M$.  
%
%
%\begin{lemma}
%For all modules $M$, and specifications $S$ and $S'$, we have that
%\begin{itemize}
%\item
% $\strongerI M  S  {S'}    \ \ \ \ \Longrightarrow\ \ \ \ \stronger M S {S'}'$ 
%\item
% $\vdash M S \equiv {S'}    \ \ \ \ \Longrightarrow\ \ \ \ \strongerEq M S {S'}$
%\end{itemize}
%\end{lemma}
%
%
%We assume a specification look-up function $\specs {\_}$ which returns the specification of a module $M$.
%We now define what it means for a module $M$ to promise a specification $S$:
%
%\begin{definition}
%Given module $M$ and specification  $S$: %, $S'$:
%\begin{itemize}
%\item
%$\promises M S$ \ \ \ \  iff \ \ \ \  ${\strongerI M {\specs M} {S}}$
%\end{itemize}
%\end{definition}
%
%\noindent
%Note that $\promises M S$ is based on the {\emph{specification} of $M$, and does \emph{not} guarantee that  $M$ satisfies $S$.

\subsection{First Phase: Triples}

In  Fig. \ref{f:underly} we introduce our triples, of the form ${   \hproves{M}  {A} s {A'}}$. 
These promise, as expected, that any execution of $s$ in a state that satisfies $A$ leads to a state that satisfies $A'$.
These tuples only apply to statements that do not contain method calls.

 
\subsubsection{Extending an underlying Hoare Logic}


\begin{figure}[tht]
$
\begin{array}{c}
% \begin{array}{lcl}
\inferrule[\sc{extend}]
	{ M \vdash_{ul} \{ \ A\ \} {\ stmt\ }\{\ A'\ \} \ \ \  stmt  \ \mbox{contains no method call} }
	{\hproves{M}  {A} {\ stmt\ }{A'} }
%	& &
\\
\inferrule[\sc{types-1}]
	{  stmt \ \mbox{contains no method call, and no assignment to $x$} }
	{\hproves{M}  {x:C} {\ stmt\ }{x:C} }
% \end{array}
\\
	{\red{\inferruleSD{\hspace{2.3cm} [\sc{prot-1}]}
	{   stmt \ \mbox{contains no method call, and no assignment to $z$}
	\\
	{\hproves{M}  {\re = z} {\ stmt\ }{ \re=z} }
	}
	{\hproves{M} 
						{\  \inside{\re}  \ }
						{\  stmt \ }
						{\  \inside{\re}\ }
	}
	}}
% this onw ia wronf!!!
%\\
%	{\sdN{\inferruleSD{\hspace{2.3cm} [\sc{prot-2}]}
%	{   stmt \ \mbox{contains no method call, and no assignment to $z$ or $z'$}
%	\\
%	{\hproves{M}  {\re = z \wedge \re' = z'} {\ stmt\ }{\re = z \wedge \re' = z'} }
%	}
%	{\hproves{M} 
%						{\  \protectedFrom{\re}{\re'}  \ }
%						{\  stmt \ }
%						{\  \ \protectedFrom{\re}{\re'}\ }
%	}
%	}}
\\
\\
\\
\mbox{\sdN{We had this rule, but I believe  that it is not sound when $y$=$z$, or $x$=$y$}}
\\
      {\inferruleSD{\hspace{5.3cm} [\sc{prot-????}]}
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z} \ }
						{\ y =y'.f\ }
						{\ \protectedFrom{x}{z}\ }
	}
}

\\
\\
\sdN{\mbox{Is his rule is subsumed by {\sc{Prot-1}}}}
\\
       {\inferruleSD{\hspace{5.3cm} [\sc{prot-???}]}
	{ }
	{\hproves{M} 
						{\  \inside{x}\ \wedge \   \protectedFrom{x}{y'} \ }
						{\ y.f=y'\ }
						{\  \inside{x}\ }
	}
}	
\\
\\
        {\inferruleSD{\hspace{5.3cm} [\sc{prot-4}]}
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z} \ \wedge \   \protectedFrom{x}{y'} }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z} \ }
	}
}	 
\end{array}
 $
\caption{Hoare triples -- incorporating underlying logic, types and protection}
\label{f:underly}
\label{f:protection}
\end{figure}



\begin{axiom}
\label{ax:ul}
\sdN{Assume   Hoare logic with judgements % of the form 
\ $M \vdash_{ul} \{ A \} s \{ A' \}$, \ 
so that $\Stable{A}$ and $\Stable{A'}$. }
\end{axiom}

% On top this, we define our extension, with shape ${   \hproves{M}  {A} s {A'}}$. 
With rule {{\sc{extend}} in Fig. \ref{f:underly},  any assertion $M \vdash_{ul} \{ A \} s \{ A' \}$  whose statement does not contain a method call, and which 
can be proven in the underlying Hoare logic, to also be proven in our logic.

% The rules for this extension appear in Figures \ref{f:protection}, \ref{f:calls} and \ref{f:substructural}.

Moreover, rule {\sc{types-1}} promises that types of local variables do not change. The restriction to statements that do not contain method calls will be discussed with rule {\sc{types-2}} in the next section.

 

 \subsubsection{Reasoning about protection}

{
In Fig. \ref{f:protection} we also give rules about the preservation of protection.
In \textsc{Prot-1}, if $y$ is internal, then no new external object becomes locally reachable, and therefore $ \inside{x}$ is preserved;
similarly, if the rhs of the assignment ($y'.f$) is not an alias of $x$, then no new unprotected route to $x$ is introduced, and therefore  $ \inside{x}$ is preserved.
In \textsc{Prot-2}, the assignment $y=y'.f$ does not create a new route from $z$ to $x$, and therefore  $\protectedFrom{x}{z}$ is preserved.
In \textsc{Prot-3}, if $x$ is protected from $y'$, then the assignment $y.f=y'$ does not create a new unprotected route   to $x$, and therefore  $\inside {x}$ is preserved.
Similarly, in \textsc{Prot-4}, if $x$ is protected from $y'$, then the assignment $y.f=y'$ does not create a new unprotected route  to $x$, and therefore   $\protectedFrom{x}{z}$ is preserved.
}

Moreover, "protection" of an object can decrease is if we call an eternal method, and pass it an internal object as argument. This is then covered by the rule in Fig. \ref{f:external:calls}.

\begin{lemma}
\label{l:no:meth:calls}
If ${\hproves{M}  {A} {\ s\ }{A'} }$, then $s$ contains no method calls.
\end{lemma}
  


\begin{figure}[htb]
$
\begin{array}{c}
% \begin{array}{lcl}
\inferrule[\sc{Mid}]
	{\hproves{M}  {A} {\ s\ }{A'} }
	{\hprovesN{M}  {A} {\ s\ }{A'} {A''} }
\\
\\
% THIS RULE IS NOT SOUND -- we need to adapt it
%{
\inferrule[\sc{types-2}]
	{ \hprovesN{M}  {A} {\ s\ }  {A'} {A''}  }
	{\hprovesN{M}  {x:C \wedge A} {\ s\ }  {x:C\wedge A'} {A''}}
%}
% \end{array}
% \\
% \\
 \\
 \\
\inferrule[\sc{combine}]
	{  \hprovesN{M}  {A_1} {\ s\ } {A_2}  {A} \hspace{1.4cm}  \hprovesN{M}  {A_3} {\ s\ } {A_4} {A}}
	{ \hprovesN{M}  {A_1 \wedge A_3 }{\ s\ } {A_2 \wedge A_4} {A} }
\\
\\
\inferrule[\sc{sequ}]
	{  \hprovesN{M}  {A_1} {\ s_1\ } {A_2}  {A}  \hspace{1.4cm} \hproves{M}  {A_2} {\ s_2\ } {A_3} {A}}
	{   \hprovesN{M}  {A_1   }{\ s_1; \, s_2\ } {  A_3} {A} }
\\ \\
\inferrule[\sc{consequ}]
	{
%	\begin{array}{l}
	 { \hprovesN  {M}  {A_2} {\, s\, } { A_3 } {A_4}  }
	 \\
	 M \vdash A_1 \rightarrow A_2 
	 \hspace{1.4cm} 
	{ M \vdash A_3   \rightarrow  A_5  }
	 \hspace{1.4cm}   
	{  M \vdash A_4  \rightarrow A_6 }
%	\end{array}
	}
	{   \hprovesN{M}  {A_2 }{\ s\ } {A_5 } {A_6} }
  \end{array}
 $
\caption{Hoare Quadruples - incorporating Hoare triples and substructural rules }
\label{f:substructural}
\end{figure}

\subsection{Second Phase: Quadruples}

\subsubsection{Introducing mid-conditions, and substructural rules}
Fig. \ref{f:substructural} introduces quadruple rules of the from ${\hprovesN{M}  {A} {\ s\ }{A'} {A''} }$ which do not deal with method calls.

Rule {\sc{mid}} embeds  triples  ${\hproves{M}  {A} {\ s\ }{A'} }$  into quadruples ${\hprovesN{M}  {A} {\ s\ }{A'} {A''} }$; this is sound, because $s$ is guaranteed not to contain method calls (by lemma \ref{l:non:meth:calss})\footnote{The restriction to statements which do not contain method calls in rule {\sc{types-1}} was imposed so as to make this lemma valid}, and therefore its execution is guaranteed not to reach any external states.

 
The remaining rules in Fig. \ref{f:substructural} apply to \emph{any} statements -- even those containing method calls.
 Rule {\sc{types-2}} generalizes {\sc{types-1}} to any statement, provided that  there already exists a triple for that statement.
Rule {\sc{combine}} combines two quadruples for the same statement into one.
Rule   {\sc{sequ}}is the usual rule  for statement sequences  adapted to quadruples.
% SD: at the moment the below is not needed
%{\sdN{Rule   {\sc{consequ}} is more interesting, because it employs a new inference, {\red{$\inferd$}}, rather than  the usual inference, $\rightarrow$.
%For stable assertions, $\rightarrow$ and $\inferd$ behave the same way -- more  in section 
%} }



\subsubsection{Reasoning about   calls}
is described in Fig. \ref{f:internal:calls}. {\sc{Call\_Int}}  and {\sc{Call\_Int\_Adapt}}  or internal methods, whether public or private;  \  {\sc{Call\_Ext}} 
and {\sc{Call\_Ext\_Adapt}} for  external methods.


% {We now move to the discussion of  external calls. For all external calls we require that the module's invariants hold before the external call.
%This is enforced through the requirement ${\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}}$ in rules
%{\sc{CallAndAlias}} and {\sc{CallNonAlias}} in  Fig. \ref{f:internal:alias:calls}, and the precondition part  
% $\PushAS {y}{\extract{M}}$ in all rules in Fig.  \ref{f:external:calls}. }
%
%
%{Looking more closely, we notice  that we do not require that invariants hold (ie ${\extract{M}}$), but require that they will hold after the method call has been pushed on the stack, (ie $  \PushAS {y}{\extract{M}}$). We use the  assertion push-function $\pushSymbol$   defined earlier in Figure \ref{f:Push}.}
%Remember that the assertion $\PushAS y A$ is \emph{hypothetical}: if a state satisfies $\PushAS y A$, then after pushing
%onto that state a frame which contained the values  of $\overline y$, assertion $A$ will hold, and conversely,   if a state satisfies  $A$ with a top frame containing the  values of $\overline y, \overline z$, then  after popping that frame, the state  satisfies assertion  $\PushAS y A$ (cf. llemma \ref{lemma:push:ass:state}).
% 
% {In rule {\sc{ExtCall}} we   ensure that the module's invariants are preserved by the external call. } {Notice that while  {\sc{CallAndAlias}}, {\sc{CallNonAlias}}, {\sc{ExtCall\_WithSpec\_Weak}} and {\sc{ExtCall\_WithSpec\_Weak}}    include 
% $\PushAS y {A_1}$ in their precondition,  they do not include it in the postcondition. A variation where was  $\PushAS y {A_1}$ in the postcondition is admissible, as it would be the outcome of the combination of these rules with  {\sc{ExtCall}} through the application of {\sc{Consequ}}.}
% 
%{The precondition of {\sc{ExtCall\_WithSpec\_Weak}} is stronger than that of {\sc{ExtCall}}. It makes use of one of the  module's  promises: Here $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, i.e. that  $\overline {x:C} \ \wedge\ A_1$ can only lead to $A_2$. 
%% Moreover, the call's precondition requires  $\overline {x:C} \wedge \PushAS y {A_1}$. 
% Therefore, by lemma \ref{lemma:push:ass:state}.\ref{lemma:push:ass:state:one}, right after pushing a frame with $\overline y$, ie right after  entering the external call, $\overline {x:C}$ and  $A_1$ hold. `Therefore, by the semantics of $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, at the end of the external call,  $\overline {x:C} \wedge A_2$ will hold. This, together with  lemma \ref{lemma:push:ass:state}.\ref{lemma:push:ass:state:two} gives that after popping the frame, ie after  exiting the external call, $\PushAS y {A_1}$ will hold.}
%
%
%{The precondition of {\sc{ExtCall\_WithSpec\_Strong}} is stronger than that of {\sc{ExtCall\_WithSpec\_Weak}}: it also requires $A_1$. Therefore, the module's promise, $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, guarantees that after exiting the external call, $A_2$ will hold.}
 





\begin{figure}[htb]
$\begin{array}{c}
 \inferruleSD{\hspace{4.7cm} [\sc{Call\_Int}]}
	{
	   	\begin{array}{l}
		\promises  M {\mprepostN{A_1}{p\ C}{m}{y}{C}{A_2} {A_3}}  
          	\end{array}
		}
	{  \hprovesN {M} 
						{ \  y_0:C,\overline {y:C} \wedge  A_1[y_0/\prg{this}] \ }
						 { \ u:=y_0.m(y_1,.. y_n)\    }
					         { A_2[ u/res,y_0/\prg{this}] } 
						{   A_3  }	
}
 \\
\\
{ \inferruleSD{\hspace{4.7cm} [\sc{Call\_Int\_Adapt}]}
	{
	   	\begin{array}{l}
		\promises  M {\mprepostN{A_1}{p\ C}{m}{y}{C}{A_2} {A_3}}  
          	\end{array}
		}
	{  \hprovesN {M} 
						{ \  y_0:C, \overline {y:C} \wedge {\PushAS {y}{A_1[y_0/\prg{this}]}}  \ }  
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{  { \PushAS {y}{A_2[ u/res,y_0/\prg{this}]}}   }
						{   A_3  }	
}
}
\\
\\
{\red{  \inferruleSD  {\hspace{4.7cm} [\sc{Call\_Int\_Combine}]}
 	{
 	  	\begin{array}{c}
 		  \promises  M { \mprepostN  {A_{1a} \wedge A_{1r} }  {p\ C} {m} {y} {C} { A_{2a} \wedge A_{2r}}   {A_3}  }
		\\
		A_1'\txteq    A_{1a}[y_0/\prg{this}]  \wedge {\PushAS {y}{A_{1r}[y_0/\prg{this}]}}
		\\
		A_2'\txteq    A_{2a}[u/res,y_0/\prg{this}]  \wedge {\PushAS {y}{A_{2r}[u/res,y_0/\prg{this}]}}\
       	\end{array}
 		}
 	{  \hprovesN {M} 
						{ \  y_0:C, {\overline {y:C}} \wedge A_1' \ }  
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \ A_2'\ }
						{  \  A_3 \ }	
      }
}
}
\\
 \\ 
 \inferruleSD{\hspace{4.7cm} [\sc{Call\_Ext}]}
 	{ 
   	 \promises M   {\TwoStatesN {\overline {x:C}} {A}} 
        }
	{   \hprovesN{M} 
						{ \    \sdN{ \external{y_0}} \,     \wedge \,  \overline{x:C}\  \wedge\ \sdN{{A}}\ }  
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \   \sdN{{A}}  \ }
						{\  A \   }	
}
\\
 \\ 
 \inferruleSD{\hspace{4.7cm} [\sc{Call\_Ext}\_Adapt]}
 	{ 
   	 \promises M   {\TwoStatesN {\overline {x:C}} {A}} 
        }
	{   \hprovesN{M} 
						{ \    \sdN{ \external{y_0}} \,     \wedge \,  \overline{x:C}\  \wedge\ \sdN{\PushAS {y}{A}}\ }  
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \   \sdN{\PushAS {y}{A}}  \ }
						{\  A \   }	
}

\end{array}
$
\caption{Hoare Quadruples for Internal and External Calls}
\label{f:internal:calls}
\label{f:external:calls}
\label{f:calls}
\end{figure}
% }}

\sdN{ {\sc{Call\_Int}} is as expected:  
We look up the method's specification,   require the precondition, and guarantee the postcondition and midcondiition after the relevant renamings.
%: $ {\mprepostN{A_1}{\prg{private} C}{m}{y}{C}{A_2} {A_3}}  $  promises that if $m$ starts in a state that satisfies $A_1$, then  its execution will lead to a state that satisfies $A_2$, and
% that during its execution, $A_3$  any reachable scoped external state will satisfy $A_3$. Notice that in the post condition ($A_2$) we replace the $result$ by the left hand side of the assignment ($u$).
For {\sc{Call\_Int\_Adapt}} we require a weaker pre-condition ($  \PushAS {y}{A_1}$  rather than $A_1$) and also ensure a weaker post-condition ($\PushAS {y}{A_2}$, rather than $A_2$).
Remember that $  \PushAS {y}{A_1}$ guarantees that $A_1$ held before popping the callee's frame (ie $  \PushAS {y}{A_1}$);
%Looking more closely, we notice  that {\sc{IntCall}} does not require the method's precondition ($A_1$) to hold before the call, but instead requires that it will hold after the method call has been pushed on the stack, (ie $  \PushAS {y}{A_1}$).
%Similarly, after the call it does not guarantee the method's post condition ($A_2$), but instead guarantees that it held before popping the calllee's frame (ie $  \PushAS {y}{A_1}$).
%Remember that the assertion $\PushAS y A$ is \emph{hypothetical}: if a state satisfies $\PushAS y A$, then after pushing
%onto that state a frame which contained the values  of $\overline y$, assertion $A$ will hold, and conversely,   if a state satisfies  $A$ with a top frame containing the  values of $\overline y, \overline z$, then  after popping that frame, the state  satisfies assertion  $\PushAS y A$ 
cf.  lemma \ref{lemma:push:ass:state}).
Moreover, the call has the same \midcond,   here $A_3$, as the specification of the method.
 {\sc{Call\_Int}} is applicable whether the method is public or private.
}


%\sdN{For public methods,  {\sc{Call\_Pub}},  we consider the module's invariants. If the module promises to preserve $A$, \ie if  $\promises M   {\TwoStatesN {\overline {x:D}} {A}}$, and if the adapted versiob of $A$, \ie   $  \PushAS {y}{A}$ holds before the call, then it also holds after the call. Moreover, $A$ is also a \midcond of the call.
%As for {\sc{Call\_Int}},  the calls pre- and post are weaker than the invariants, here  $  \PushAS {y}{A}$  rather than $A$. 
%Notice that we used the method's spec only to find whether it was public, and did not make use of its pre-post, or mid-condition, $A_1$, $A_2$ and $A_3$.
%We could however use them by applying {\sc{Call\_Int}} any number of times, as well as {\sc{Call\_Pub}} again any number of times, and combining through {\sc{Combine}}
%}

\sdN{For external methods,  {\sc{Call\_Ext}}, we consider the module's invariants. If the module promises to preserve $A$, \ie if  $\promises M   {\TwoStatesN {\overline {x:D}} {A}}$, and   $A$  holds before the call, then it also holds after and during the call. }
In  {\sc{Call\_Ext\_adapt}}, we require a weaker version,  \ie that   $  \PushAS {y}{A}$ holds before the call. Then the 
weaker version also holds after the call. Moreover, $A$ is also a \midcond of the call.
}


\vspace{.1cm}
\red{
\noindent
\textbf{Implicit renamings} In the three rules above we follow a form of Barendregt convention:  In  {\sc{Call\_Int}} and  {\sc{Call\_Ext}} we assume, wlog, that the formal and actual parameters have the same names ($\overline y$) -- this is as if  the formal parameters were consistently  renamed in $A_1$, $A_2$ and $A_3$. 
We also assume wlog, that the variables $\overline x$ and $\overline y$ are pairwise disjoint -- if they were not, then  l $\overline x$ could be consistently renamed in $A$.
Finally, the variables  $\overline x$ from ${\TwoStatesN {\overline {x:D}} {A}}$ can be renamed, so as to allow the specification to be applied to any object.
}
 
\subsubsection{Aliasing and Calls}

TODO: revisit that section

%{Rules  {\sc{CallAndAlias}}  and  {\sc{CallNonAlias}} say that calls preserve aliasing, resp. non-aliasing, between variables, ie they preserve $x=x$ resp. $x\neq x$. These two rules apply to internal as well as external calls. When the callee's receiver is external, they make the extra requirement that  $\PushAS {y}{\extract{M}}$ -- we  will discuss this requirement together with the discussion of Fig. \ref{f:external:calls}.     Note that $x=x'$ expresses that $x$ and $x'$ are aliases, while  $u\txteq x$ expresses that $u$ and $x$ are textually the same --
%the latter is stronger, i.e.   $x\txteq u$ implies $x=u$. 
%% It is possible that variables are aliases, without being textually the same, i.e. it is possible to have $x=x'$ while $u\not\equiv x'$. 
% As $...\equiv ...$ is a textual assertion, and thus  state-independent,  it is a side-condition of the rules and is  not part of the Hoare triple's precondition.
%}
%
%
%\small{
%\begin{figure}[hbt]
%$\begin{array}{c}
%\inferruleSD{\hspace{4.7cm}  [{\sc{CallAndAlias}}}
%	{ 
%	{   x \txtneq u\txtneq x'  }
%	}
%	{   \hproves{M}  { \ x=x'\   \wedge \ ({\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}})\  }	{ \ u:=y_0.m(y_1,.. y_n)\  } { \  x=x'\ }	 }
%
%\\ \\ 
%\inferruleSD{\hspace{4.7cm} [{\sc{CallNonAlias}}]}	
%{ 
%		{ \ x \txtneq u \txtneq x'\   }
%	}
%	{   \hproves{M}   { \ x\neq x'\   \wedge \ ({\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}})\  } { \ u:=y_0.m(y_1,.. y_n))\  } { \  x\neq x'\ }	 }
%\\
%\\
%\end{array}
%$
%\caption{Logic for Aliasing around Calls }
%\label{f:internal:alias:calls}
%\end{figure}
%}




\subsection{Third phase: Proving adherence to Module Specifications}
\label{sect:wf}

In Fig. \ref{f:wf} we  define the judgment $\vdash M$, which says that % module $M$ 
$M$ has been proven to be well formed. 
%has been proven to satisfy its specification.



\begin{figure}[thb]
$
\begin{array}{l}
\begin{array}{lcl}
\inferruleSDNarrow 
{~ \strut  {\sc{WellFrm\_Mod}}}
{  M \vdash \SpecOf {M}
}
{
\vdash M  
}
& \hspace{0.7cm} &
\inferruleSDNarrow 
{~ \strut   {\sc{Comb\_Spec}}}
{  
M \vdash S_1 \hspace{1cm}  M \vdash S_2
}
{
M \vdash S_1 \wedge S_2
}
\end{array}
\\
\\
\inferruleSD 
{~ \strut \hspace{6.5cm} {\sc{method}}}
{  
 \prg{mBody}(m,D,M)=p \ (\overline{y:D})\{\  stmt \ \}  %\ \ \vee \ \   \prg{mBody}(m,D,M)=\prg{public} \ \overline{x:C}\{\  stmt \ \}       
    \\
  {\hprovesN{M} { \ \prg{this}:\prg{D}, \overline{y:D}\, \wedge\, A_1\  } {\ stmt\ } {\ A_2 \ }   {A_3} } 
}
{
M \vdash {\mprepostN {A_1}{p\ D}{m}{y}{D}{A_2} {A_3} }
}
\\
\\
\inferruleSD 
{~ \strut \hspace{6.5cm} {\sc{invariant}}}
{  
\begin{array}{l}
\forall  D,  m:\ \ \  \ \  \prg{mBody}(m,D,M)=\prg{public} \ (\overline{y:C})\{\  stmt \ \}      \ \ \Longrightarrow  
    \\
   ~ \strut \hspace{0.7cm}  \ \ \ \  \  %SD chop: do not know whay I had added \ A_{inv} \triangleq \overline{x:C}\, \wedge\, A
%  \\
%  ~ \strut \hspace{1.7cm} \ \ \ \ \  \ \ \ 
 {\hprovesN{M} { \ \prg{this}:\prg{D}, \overline{y:D}\, \wedge\, \neg\inside{this}\wedge\overline{ \neg\inside{y}}\, \wedge\, \overline{x:C}\, \wedge\,  A\  } {\ stmt\ } {\ A\ } {\ A \ }  }\ \ \ \ \  \ \  
\end{array}
}
{
M \vdash \TwoStatesN{ \overline{x:C}} {A}
}
\end{array}
$
\caption{Methods' and Modules' Adherence to Specification}
\label{f:wf}
\end{figure}

%$\begin{array}{lclcl}
%PRE(A_1 \wedge A_2} \trangleq PRE(A_1) \wedge PRE(A_2} & PRE{\protectedFrom \re \re
%
%\sdN{{\sc{WellFrm\_Mod}} and 
% {\sc{Comb\_Spec}} together say that a module is well formed if it satisfies each conjunct of its specification.
% }
% 
 \sdN{{\sc{Method}} says that  a module satisfies a method specification if the method body satisfies the corresponding pre-, post- and \midcond.
 }
 \sdN{{\sc{Invariant}} says that  a module satisfies an invariant specification $\TwoStatesN{ \overline{x:C}} {A}$,  if the method body of each public method
 has $A$ as its  pre-, post- and \midcond.}
 
 \vspace{.1cm}
\red{
\noindent
\textbf{Implicit renamings} Again, we follow a form of Barendregt convention: In  {\sc{Method}}  we assume, wlog, that no free variable  in $A_1$   clashes with a variable  in $stmt$.
In {\sc{Invariant}} we assume, wlog, that none of
 $\overline x$ clash with  $\overline y$ or a variable  in $stmt$.}
% : Any of $\overline x$  which clashes with $\ovelrine y$ or a variable  in $stmt$,   gets implicitly renamed  in the proof that $ {\hprovesN{M} { \ \prg{this}:\prg{D}\, \wedge\, \overline{y:D}\,  \overline{x:C}\, \wedge\,  \wedge\,  A\  } {\ stmt\ } {\ A\ } {\ A \ }  } $


 
\footnoteSD{{QUESTIONS: }

\begin{enumerate}
\item 
Can we express what Fig \ref{f:calls} does, but more streamlined? -- SD has no ideas here  :-(
\item
In the rule for $\models M$,   I wonder whether we should be using ${\extract{M}}$ rather than $\PushAS {y} {\extract{M}}$. -- SD thinks this is only a matter of more thinking
\item
Do we want to forbid private methods to make external calls -- see Sect \ref{s:privateMs}? If we do that, then we need to extend the oper semantics and the inference rules in trivial, and boring ways...
\item
In  Fig \ref{f:calls} I wonder whether there are also stronger versions, where we require ${\extract{M}}$ rather than $\PushAS {y} {\extract{M}}$, pretty much as in the difference between {\sc{ExtCall\_WithSpec\_Weak}}  and the other rule, {\sc{ExtCall\_WithSpec\_Strong}}. But this would blow up the rules even more! 
\item
 Does the consequence rule require that the assertions are encapsulated? And if an assertion is encapsulated, is its consequence also encapsulated? TODO - EASY
\item
All rules require that the variables in the quantifiers do not appear in the meathod bodies, and are disjoint from the parameters.
TODO explain -EASY. 
\item  We need to add some dynamic type checking to the language, ie the public method call crashes if the actual params do not fit the formal types. Thisi is only for convenience; we cloud type them all as \prg{Object}, and crash by hand. TODO - EASY
\item
Do we need "modifies" or "does not modify" clauses too? Or can we assume that the underlying HL does this implicitly? For example, does\\
$\strut \ \ \  \hproves{M}  {a:Account \wedge p:Password \wedge a.passwd=p} {stmts}  {a.passwd=p}$\\ (with $a$ and $p$  free in $stmts$),  implicitly promise that no account's password has been modified? Shall we require the underlying logic to support such judgments -- say that if it has modifies clauses, or SL, it could do that?\\
Such an approach might solve the "late binding" issues mentioned below.
\end{enumerate}
 }




 
