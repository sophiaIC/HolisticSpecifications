
\section{Proving Adherence to \SpecLang Specifications}

\subsection{Semantics of  a Hoare Triples -- Soundness of Hoare Logic}

We will develop a  Hoare logic with judgments of the form  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ which promise that execution of the expression $e$ in a configuration with satisfies $A$ will lead to a configuration that satisfied $A'$. 


\begin{axiom}
We assume a judgment of the form $M \vdash A$, which had the property that\\
\strut \hspace{5cm} $M \vdash A $ \ \ \ \ implies \ \ \ \ $M \vDash A$
\end{axiom}


\subsection {Assertion Encapsulation}
\label{s:encaps-proof}

{
{\SpecLang proofs  hinge on the fact that some assertions cannot be invalidated unless some 
} internal (and thus known)
computation took place. 
{We refer to this property as \emph{Assertion Encapsulation},}
}
formally $M\ \vDash  \encaps{A}$, which states that 
 assertion $A$ is encapsulated by module $M$.


\subsubsection{Semantics of Assertion Encapsulation}

{An assertion $A$  is  encapsulated by a module $M$ under condition $A'$,
if in all possible states which arise from execution of module $M$ with any other external module $M_{ext}$, and which satisfy $A'$, 
the validity of $A$} 
{ can only be changed via computations internal to that module} -- \emph{i.e.},  via a call to
a method from $M$, i.e.,
calls to objects defined in $M$ but accessible from the
outside.


\begin{definition}[Assertion Encapsulation]
\label{def:encapsulation}
An assertion $A$ is \emph{encapsulated} by module $M$ and assertion $A'$, written as
\begin{itemize}
 \item     $M\ \vDash \encaps{A}$
 \end{itemize}
if, for all external modules $M_{ext}$, and all states $\sigma$, $\sigma'$
such that $\arising{M_{ext}}{M}{\sigma}$, {and variables $\overline{x}$ and objects $\overline{o}$}:

\begin{itemize}
 \item
  $\satisfiesA{M}{\sigma}{A}$,  \ \ \ \   $\overline{x}=Free(A)$, \  \  \ \ $\overline{o}=\sigma(\overline{x})$,\ \ \ \ $\reduction{M_{ext}}{M}{\sigma}{\sigma'}$, \ \ \ ${M},{\sigma'[\overline{y}\mapsto{\overline{o}}]}\not\vDash{A}$
 \end{itemize}

implies

 \begin{itemize}
 \item   $\exists y,\,m,\, \overline{y} .[\ \sigma.\prg{cont}= y.m(\overline{y})\ \wedge\  \satisfiesA{M}{\sigma}{\internal{y}} \ ]
$
 \end{itemize}
\end{definition}

Revisiting the examples from \S~\ref{s:outline}, % we can see
both \ModB and \ModC encapsulate   the  equality of the \prg{balance} of an account to some value \prg{bal}: 
Namely, this equality can only be invalidated through calling  methods on internal objects.
 
{On the other hand, assume two further modules, $Mod_{ul}$ and $Mod_{pl}$: both these modules use ledgers to keep a map between accounts and their balances, which export functions that allow the update of this map. In $Mod_{ul}$ the ledger is \emph{not} protected, while in $Mod_{pl}$ the ledger \emph{is} protected. Then, in the former, the and the balance of an account is \emph{not} encapsulated, and in the latter it  \emph{is} encapsulated. } 
%
\\
\strut \hspace{1cm}
$\ModB\ \vDash\ \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm}
$\ModC\ \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm} {$Mod_{ul}\ \not\vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}
\\
\strut \hspace{1cm} {$Mod_{pl}\  \vDash \encaps{ \prg{a}:\prg{Account}\ \wedge \prg{a.balance}=\prg{bal}}$}

\noindent
{Note that in the above, the term \prg{a.balance} is a ghost field.}



The property that a variable is protected from another one is not encapsulated, but  the property that a variable is protected \emph{is} encapsulated, regardless of the module. Note also, that  encapsulation of an assertion does not imply encapsulation of its negation; 
 for example,  ${\inside{x}}$ is encapsulated (as per below), but $\neg  {\inside{x}}$ is not.


\begin{lemma}
For any module $M$, and variables $x$ and $y$:
\begin{enumerate} 
\item $M \vDash \encaps{\inside{x}}$
\item $M \not\vDash {\encaps{\neg\inside{x}}}$
\item $M \not\vDash {\encaps{\protectedFrom{x}{z}}}$
\item $M \vDash A \rightarrow A' \ \ \wedge\ \  M \vDash  \encaps{A}$ \ \ implies \ \ $M \vDash  \encaps{A'}$.
\end{enumerate}
\end{lemma}

\begin{proof} Sketches:

(1) because if $y$ is protected, and since the fields are all private ... the only way .. 
\\
(2) Take a state where $\neg\inside{x}$ and that there is only external object that has access to $x$, and that this object becomes no longer accessible -- eg through field override. That means that we now have  $\inside{x}$.
\\
(3) it is always possible that another external object $z'$ has unprotected access to $x$; if $z'$ has access to $z$, then it can give it access to $x$ without invoking am internal method. (3) as a counterexample, 
\\
(4) Use that $M \vDash A \rightarrow A'$ implies $M \vDash \neg A'  \rightarrow \neg  A$. BUT CAREFUL, TODO! with the potential of non-termination on assertions!!
\end{proof}
%The key consequence of soundness is that -- SD dropped; it is   not a consequence of soundness!

\subsubsection{Deriving  Assertion Encapsulation}

{In general},  code that does not contain 
calls to a {given} module is guaranteed not to invalidate any assertions encapsulated by that module.
 Assertion encapsulation has been used in proof systems to {address}   the  {frame} problem
 \cite{objInvars,encaps}. 

We  do not mandate how this property should be derived -- instead, we rely on a judgment 
$M\ \vdash  \encaps{A}$ provided by some external system. \footnoteSD{This is simpler than the oopsla-33 setting}
Thus, \SpecLang is parametric over the derivation of the encapsulation
     judgment; in fact, several ways to do that are possible \cite{TAME2003,ownEncaps,objInvars}. For example,
 the appendices of
    \cite{necessityFull} present a 
	%Appendix~\ref{s:encap-proof} and
    %Figure~\ref{f:asrt-encap}  we present a 
    rudimentary system that is sufficient to support our example
    proof.  


%As we have already stated at the beginning of this section,
%encapsulation is a deep topic that is well studied in the literature, 
%and is not the focus of this paper. For now, we simply assume the existence 
%of a proof system for encapsulation as it is secondary to the central topic 
%of this paper. We need only assert that such an algorithmic proof system 
%must be sound (Definition \ref{lem:encap-soundness}).
%% \susan[I commented out what was there as I thought it was repetious]
%% {We are assuming the existence of a proof system for encapsulation and only need to assert that such an algorithmic proof system nust be sound.}
%% The construction of the algorithmic system is not central to our work,
%% because, as we shall see in later sections, our logic 
%% does not rely on the specifics of an encapsulation algorithm, only its soundness.

Like OOPSLA 22 Our logic does not {deal with, nor} rely on, the specifics of  how   encapsulation
{is derived}.
  % model, 
{Instead, it relies} on an encapsulation judgment and expects it to be sound:

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A$:\\

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ $ implies $\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{definition}




\subsubsection{Types for Assertion Encapsulation}
\label{types}
TODO: something simple ere 

\subsection{Assertion Inference}




\subsection{Weaker/Stronger Specifications}

We assume   the existence of a function $HS$ which allows us to look up the holistic specification of a module. 
In Figure \ref{fig:si} we   define a judgment $\stronger M S  {S'}$ which expresses that the specification $S$ is stronger than the specification $S'$ under module $M$.  

\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lclclcl}
\inferrule [HS-1]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_1}
	}
&  & 
\inferrule [HS-2]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_2}
	}
	&  & 
\inferrule [HS-3]
	{ \\
	}
	{\strongerI M {S_1 \wedge S_2}  {S_2 \wedge S_1}
	}
&  & 
\inferrule [HS-4]
	{ 
	{\strongerI M {S_1}  {S_3}}
	}
	{\strongerI M {S_1 \wedge S_2}  {S_3 \wedge S_2}
	}
\\
\end{array}
\\
\\	
\inferrule [HS-5]
	{ \\ 
	M \vdash ({\overline {x:C}} \wedge A_1) \rightarrow A_1' \ \hspace{.5cm} M \vdash ({\overline {x:C}} \wedge A_2') \rightarrow A_2 }
	{\strongerI M   {\TwoStatesQ {\overline {x:C}} {A_1'}{A_2'} }   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2} }
	}		
\end{array}
$
\label{fig:si}
\caption{Specification Implication}
\end{figure}

\begin{lemma}
For all modules $M$, and specifications $S$ and $S'$, we have that\\
\strut \hspace{2cm} $\strongerI M  S  {S'}    \ \ \ \ \Longrightarrow\ \ \ \ \stronger M S {S'}'$
\end{lemma}

We now define what it means for a module $M$ to promise a specification $S$:

\begin{definition}
Given module $M$ snd specification $S$:

\strut \hspace{2cm} $\promises M S$ \ \ \ \  iff \ \ \ \  $\strongerI M {HS(M)} S$
\end{definition}

Notice, that $\promises M S$ is only based on the spec of $M$, and does not guarantee that indeed $M$ satisfies $S$.

%\subsection{Proving method bodies while using  \AssertLang specifications}
%\label{s:classical-proof}
% 
%We now develop a Hoare logic, which can prove assertions of the from \\
%\strut \hspace{1cm} $\hproves{M}{A}{\prg{s}}{A'}$.\\
%where \prg{s} is a statement in \Loo, and $A$ and $A'$ are assertions in \AssertLang.
%
%The challenges here are 1) that \AssertLang assertions support, on top of the classical features, also ??what-shall-we-call-them? protection features, and 2) we need to reason about calls to external modules.
%
%
%We assume that there exists some
%proof system  that   allows us to prove 
% specifications of the form  $\hproves{M}{A}{\prg{s}}{A'}$.
%{We further assume that such a proof system is sound, i.e. that 
%if xxx TODO 
%% if $\hproves{M}{\hoare{P}{\prg{res = x.m($\overline{z}$)}}{Q}}$, then 
%% for every program state $\sigma$ that satisfies $P$, the execution of the method call \prg{x.m($\overline{z}$)}
% % esults in a program state satisfying $Q$.}
% We then expand the proof rules as follows ....
 


\subsection{Reasoning about protection}
We expand that logic with rules about protection, as in Fig. \ref{f:protection}. Essentially, the only what that the "protection" of an object can decrease is if we call an eternal method, and pass it an internal object as argument. This is then covered by the rule in Fig. \ref{f:external:calls}.

\begin{figure}[hbt]
$
\begin{array}{c}
\inferrule[\sc{prot-1}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge \ \internal y }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\sc{prot-1}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge \ \internal v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-2}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\  \wedge\ \internal {y'} \ \wedge\  x \neq y'}
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

	\inferrule[\sc{prot-3}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\  \protectedFrom{x}{y'} }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%	\inferrule[\sc{prot-2}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{z}\ \wedge\ \external v\ \wedge\  z\neq v }
%						{\ v=v'\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\


%	\inferrule[\sc{prot-4}]
%	{ }
%	{\hproves{M} 
%						{\ \protectedFrom{x}{v}\ \wedge\ \external z\  }
%						{\ z=v\ }
%						{\ \protectedFrom{x}{z}\ }
%	}
%	\\\\

	\inferrule[\sc{prot-4}]
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z}\ \wedge\ z \neq \this}
						{\ y =y'.f\ }
						{\ \protectedFrom{x}{z}\ }
	}
	\\\\

%\inferrule[\textsc{prot-5}]
%	{}
%	{\hproves{M}
%			{}
%	}
\end{array}
$
\caption{Protection Logic \sdN{-- the rules will probably change; Julian is working on this}}
\label{f:protection}
\end{figure}


Explanations: \textsc{xxxl} states that   yyy

\subsection{Hoare Logic -- substructural rules}

We assume that $M \vdash_{ul} \{ A \} s \{ A' \}$ is a judjement that comes with the underlying programming language.  On top this, we define our extension, with shape ${   \hproves{M}  {A} s {A'}}$. The rules for this extension appear in Figures \ref{f:protection}, \ref{f:calls} and \ref{f:substructural}.

 
\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lcl}
\inferrule[\sc{extend}]
	{ M \vdash_{ul} \{ \ A\ \} {\ s\ }\{\ A'\ \} }
	{\hproves{M}  {A} {\ s\ }{A'} }
	& &
\inferrule[\sc{combine}]
	{  \hproves{M}  {A_1} {\ s\ } {A_1'}  \ \ \  \hproves{M}  {A_2} {\ s\ } {A_2'} }
	{ \hproves{M}  {A_1 \wedge A_2 }{\ s\ } {A_1' \wedge A_2'} }
%\end{array}
\\
\\
\inferrule[\sc{sequ}]
	{  \hproves{M}  {A} {\ s_1\ } {A''}  \ \ \  \hproves{M}  {A''} {\ s_2\ } {A'} }
	{ \hproves{M}  {A } {\ s_1; \ s_2\ }  {A'} }
& &
\inferrule[\sc{consequ}]
	{ M \vdash A \rightarrow A'' \ \ \  {\hproves{M}  {A''} {\ s\ } {A'''} } \ \ \ M \vdash A''' \rightarrow A'  }
	{\hproves{M}  {A} {\ s\ } {A'} }
\\ \\
\sdN{
\inferrule[\sc{types}]
	{   }
	{\hproves{M}  {x:C} {\ s\ }  {x:C} }
}
 \end{array}
  \end{array}
 $
\caption{From Underlying to Extended Hoare Logic}
\label{f:substructural}
\end{figure}
}
 
\subsection{Reasoning about calls}

In  Fig. \ref{f:external:calls}  we show how to reason about method calls, internal as well as external.  Rules  {\sc{Call1}} and {\sc{Call2}} apply to internal as well as external calls, while rule \sc{IntCall}} applies to internal calls, and rules {\sc{ExtCall1}} and rule {\sc{ExtCall2}} apply to external calls.

\sdN{The rules {\sc{Call1}} and {\sc{Call2}} say that calls preserve aliasing, resp. non-aliasing, between variables, ie they preserve $x=x$ resp. $x\neq x$. Note that $x=x'$ expresses that $x$ and $x'$ are aliases, while  $u\equiv x$ expresses that $u$ and $x$ are textually the same.  It is possible that variables are aliases, without being textually the same, i.e. it is possible to have $x=x'$ while $u\not\equiv x'$. As $u\equiv z$ is a textual assertion, and thus  state-independent , it is a premise of the rules and not part of the Hoare triple's precondition.
}

Rule {\sc{IntCall}} is standard.  We use  the notation
$ M, C, m  :  (\, P, \ Q\, )  $ to indicate that the declaration of method $m$ for class $C$ in module $M$ includes the per-post-condition pair  $(\, P, \ Q\, ) $. 

 
\sdN{In the rules for external calls,  {\sc{ExtCall1}} and {\sc{ExtCall2}}, we use the  assertion push-function $\pushSymbol$ with  signature\\
 $ \strut \ \ \ \ \ \   \pushSymbol : Vars \times Assert \rightarrow Assert $,\\
 defined in Figure \ref{f:Push}. The assertion $\PushAS y A$ is \emph{hypothetical}: if a state satisfies $\PushAS y A$, then after pushing
onto that state a frame which contained the values  of $\overline y$, assertion $A$ would hold. This is expressed in lemma \ref{lemma:push:ass:state}, part \ref{lemma:push:ass:state:one}. Conversely,   if a state satisfies  $A$ after a top frame containing the  values of $\overline y, \overline z$ has been pushed, then 
after popping that frame, the state  satisfies assertion  $\PushAS y A$ . This is expressed in lemma \ref{lemma:push:ass:state},  part \ref{lemma:push:ass:state:two}. }

\sdN{The rules {\sc{ExtCall1}} and {\sc{ExtCall2}} require  that the module  promises $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, i.e. that  $\overline {x:C} \ \wedge\ A_1$ can only lead to $A_2$. Moreover, the call's precondition requires  $\overline {x:C} \wedge \PushAS y {A_1}$. Therefore, by lemma \ref{lemma:push:ass:state}.\ref{lemma:push:ass:state:one}, right after pushing a frame with $\overline y$, ie right after  entering the external call, $\overline {x:C}$ and  $A_1$ hold. `Therefore, by the semantics of $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, at the end of the external call,  $\overline {x:C} \wedge A_2$ will hold. This, together with  lemma \ref{lemma:push:ass:state}.\ref{lemma:push:ass:state:two} gives that after popping the frame, ie after  exiting the external call, $\PushAS y {A_1}$ will hold.}


\red{The precondition and postcondition of   rule {\sc{ExtCall2}} are strictly stronger than  those in  {\sc{ExtCall1}}: In addition to $\overline {x:C} \wedge \PushAS y {A_1}$, the precondition also requires $A_1$. Therefore, the module's promise, $  {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}$, guarantees that after exiting the external call, $A_2$ will hold.
}


\begin{figure}[hbt]
$\begin{array}{c}
\begin{array}{ll}
\inferruleSD{ [{\sc{Call1}]}}
	{ 
	{  u\not\equiv x \ \ \ \ \ \   u\not\equiv x'\  }
	}
	{   \hproves{M}  { \ x=x'\   } 	{ \ u:=y_0.m(y_1,.. y_n)\  } { \  x=x'\ }	 }

 &  
\inferruleSD{ [\sc{Call2}]}
	{ 
		{ \ u\not\equiv x\ \ \ \ \  \ u\not\equiv x'\   }
	}
	{   \hproves{M}  { \  x'\neq x' \  } { \ u:=y_0.m(y_1,.. y_n))\  } { \  x\neq x'\ }	}
\end{array}
\\
\\
\inferruleSD{\hspace{4.7cm} [\sc{IntCall}]}
	{ 
	   	M, C, m  :  (\, A_1, \ A_2\, )\ \ \  \ \ \ \ \ fv(A_1)=\overline x
          		}
	{   \hproves{M} 
						{ \ {\internal{y_0}}  \wedge  y:C  \ \wedge \ A_1[\overline y/\prg{this},\overline x] \  }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \  A_2[ u/result,\overline y/\prg{this},\overline x]  \ }	
}
\\
\\
\sdN{
\inferruleSD{\hspace{4.7cm} [\sc{ExtCall1}]}
	{ 
   	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
        }
	{   \hproves{M} 
						{ \    { \external{y_0} }\ \wedge \ \overline {x:C}  \ \wedge \  \PushAS  {y}{  A_1} \  }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \ \PushAS  {y} { A_2}  \ }	
}
}
\\
\\
\red{ 
\inferruleSD{\hspace{4.7cm} [\sc{ExtCall2}]}
	{ 
         	\promises M   {\TwoStatesQ {\overline {x:C}} {A_1}{A_2}}
   	}
	{   \hproves{M} 
						{ \  {\external{y_0}  } \ \wedge\ \overline {x:C}\ \wedge\  \PushAS  {y} { A_1} \ \wedge\  A_1 \  }
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \  \ \PushAS  {y} { A_2}  \wedge A_2  \ }	
}}
\\
\\

\end{array}
$
\caption{Internal and External Calls Logic}
\label{f:calls}
\label{f:external:calls}
\end{figure}








\newcommand{\sigmas}{\widetilde \sigma}

 
\begin{figure}[hbt]
$
\begin{array}{c}
\begin{array}{lclcl}
\PushAS y  e\ \triangleq\ e & & \PushAS y   {(A_1  \wedge  A_2)}\ \triangleq\ \PushAS y  { A_1}  \wedge   \PushAS y  {A_2}  & & 
 \PushAS y { (A_1 \vee  A_2)}\ \triangleq\  \PushAS y {A_1}  \vee  \PushAS y {A_2} 
  \\ \\
\PushAS y  {(\neg A)}\ \triangleq\ \neg( {\PushAS y A} ) & &
 \PushAS y  {(\forall x:C.A)}\ \triangleq\ \forall x:C.({\PushAS y A} )&  &  
  \PushAS y  {(\exists x:C.A)}\ \triangleq\ \exists x:C.({\PushAS y A} )
 \\ \\
\PushAS y  {x:C}\ \triangleq\  x:C 
& &
\PushAS y  {(\internal x)}\ \triangleq\ {\internal x}
& &
\PushAS y  {(\external x)}\ \triangleq\ {\external x}
\end{array}
\\
\\
\begin{array}{cclcl}
& & \sdN{\PushAS y {(\inside x)}\ \triangleq\ \protectedFrom x {\overline {y} \ \wedge\ x\neq \overline y} }
&\ \  &   \PushAS y {(\protectedFrom x {\overline {u}})}\ \triangleq\ \red{\protectedFrom x  {\overline {u}} } % {(\overline {y'}\setminus \overline {y})} 
  \\
  \\
\end{array}
\end{array}
$
\caption{The push operator for assertions } 
\label{f:Push}
\end{figure}
 

\vspace{.1cm}


\noindent
\textbf{Notation}  We write $\PushS {y} {\sigma}$ for the set of states that is the result of pushing a new frame with the values of $\overline y$ onto the stack of $\sigma$.
We lift operators that apply to one state to apply to sets of states: If  $\sigmas$ is a set of states,  then $\sigmas[ \overline{x \mapsto v}]$ is the set of states from $\sigmas$ to which we applied the substitution. And the   notation 
$M,   \sigmas \models A$ holds if  $M, \  \sigma \models A$ for all $\sigma \in \sigmas$.
  \vspace{.1cm}
  
The following lemma is the counterpart to, but sightly different than, Lemma \ref{lemma:lifts} and \ref{lemma:lowers} from earlier:

\sdN{
\begin{lemma} 
\label{lemma:push:ass:state}
For any states  $\sigma$, $\sigma'$, assertion $A$,  and variables $\overline x$, $\overline y$, $\overline z$ disjoint with one another,  and such that 
$fv(A)\subseteq \overline x$:
\begin{enumerate}
 \item
 \label{lemma:push:ass:state:one}
$M, \sigma \models \PushAS {y} {A}\ \ \ \ \ \ \   \Longrightarrow  \ \ \ \ M,  (\PushS {y} {\sigma})[\overline{x \mapsto {\interpret {\sigma} {x}} } ] \models A$
\item
\label{lemma:push:ass:state:two}
$M, {\PushSLong {(\overline y, \overline z)} \sigma }   \models\  A \  \ \ \ \Longrightarrow  \ \ \ \ M,  \sigma[\overline{x \mapsto {\interpret {\sigma} {x}} } ] \models  \PushAS  {y} {A}$
\end{enumerate}
\end{lemma}
}

\vspace{.1cm}
\noindent 
\blue{\textbf{Comment} The $ \pushSymbol$ operator reminds me of the magic wand. Namely, $-\!-\!*$ is spatial and heap based:  the assertion $A -\!-\!* A'$ says: if you combine with a heap that satisfies $A$, then the complete heap will satisfy $A'$. While $\PushASLong {\_} {\_}$ is temporal and  stack based: the assertion  $\PushAS {y} A$ says that if you push a frame with range the values of $\overline y$, then $A$ will hold. 

{\red{I am surprised that $ \pushSymbol$  only affects  ${\inside x}$, and leaves all else unmodified,}} \textbf{End Comment} }


 


\subsection{Proving \SpecLang Specifications}

\subsubsection{Deriving sub-specifications}


\label{s:module-proof}

\begin{figure}[thb]
%\footnotesize
$
\begin{array}{c}
\inferrule [Two-State]
	{
	\\\\
	M \vdash \encaps{\overline {x:C}\, \wedge \, A_1} \ \ \ \ \ \ \ \ \ \ \ M \vdash \encaps{\overline {x:C}\, \wedge \, A_2}
	\\\\
	\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
					  \strut \hspace{4.5cm} {\hproves{M}{ \overline{x:C}\ \wedge \ A_1\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A_2\ }} \ \parallel \  A_2 
}
	{
	M\ \vdash\ {\TwoStatesQ {\overline {x:C}} {A_1} {A_2} }
	}
\\\\
\\\\
\inferrule [One-State]
	{
		%        A_{os} %=\overline{\OneStateQ{\overline {y:C}}{A''}}\ 
		% \mbox{\ conjunction of all one state invariants in } HS(M)   
		\\ \\ 
		\textit{for all}\ \  \textit{public methods  from } D,\ \textit{with}\ \prg{mBody}(m,D,M)=\overline{y:D}\{\  s \ \}\\\\
					  \strut \hspace{4.5cm}  {\hproves{M}{ \overline{x:C}\ \wedge \ A\ \wedge \ \prg{this}:\prg{D} \wedge\ \overline{y:D}  } {\ s\ } {\ A\ }} \ \parallel \  A 
}
	{  
	         M\ \vdash \ \OneStateQ{\overline {y:C}}{A} 
	}
\\\\
\inferrule [Intrm]
	{
		\\ \\
		A_{os} %=\overline{\OneStateQ{\overline {y:C}}{A''}}\ 
		\mbox{\ conjunction of all one state invariants in } HS(M)    
		\\\\
 		 \hproves{M} { \ A_1\ \wedge\ A_{os}\ } {\ s\ } {\ A_2\ \wedge\ A_{os}\  } \
 		\\\\ 	
				\forall  s', z, m.[\ \  \
				   s \equiv s'; z.m(\_); \_\ \wedge \ 
				  \hproves{M} {\ A_1 \wedge \ A_{os}\ } {\ s'\ } {\  \external{z}\  } \\ \\
				  \strut \hspace{6.5cm}
				  \Longrightarrow\ \ \ \hproves{M}{\ A_1 \wedge A_{os} \ }{\ s'\ } {\ A_2 \wedge A_{os}  \ } \ \ ]
	}
	{  
	         { \hproves{M}{\ A_1\ }   {\ s\ } {\ A_2\ } }  \parallel \  A_2   
	}
\\\\
\begin{array}{lcl}
\inferrule[Weaken]
{
M \vdash S \\ \strongerI M S {S'}
}
{
M \vdash S'
}
&\ \ \  &
\inferrule[Multi]
	{
	M\ \vdash\ S 
	\\
	M\ \vdash\ S' 
	}
	{
	M\ \vdash\ S \wedge S'
	}
\end{array}

\end{array}
$
\caption{Inferring that module satisfies its specification}
\label{f:module:invariats}
\end{figure}

TODO: Does the consequence rule require that the assertions are encapsulated? And if an assertion is encapsulated, is its consequence also encapsulated?

The rules also require that the variables in the quatifiers do not appear in the bodies, and are disjoint from the parameters.
TODO explain. Also, we only look at the methods exported from the module.  Also, we ned to add some dynamic type checking to the language, ie the method call crashes if actual params do not fir the formal types. OR we type them all as \prg{Object}.

TODO: shall we drop one-state invariants? Do not know how to prove them here. But they are in the spirit of capabilities literature.

%\subsection{Soundness of the \SpecLang Logic}
%
% 
%\label{s:soundness}
%
%We will now prove soundness of the  \SpecLang Logic. For this, we will first prove soundness of our extended Hoare logic.
%
%
%\begin{lemma}
%Assuming a sound \SpecO proof system, $\proves{M}{A}$, and  and
%a sound encapsulation inference system, $\proves{M}{\encaps{A}}$. Then:
%\begin{itemize}
%\item
%The inference system  $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$  defined in the previous section is sound.
%\end{itemize}
%\end{lemma}
%
%\begin{proof}
%Take arbitrary modules  $M$, $M'$, expression $e$,  assertions $A$, $A'$ and $A''$ and assume
%\begin{enumerate}
%\item
% $M\ \vdash\  \{\, A \,  \}\ e\  \{\, A' \, \}$ 
% \item
% $M,\sigma \ \models \ A$
% \item
%$ \sigma.cont$=$e$ 
%\item
%$M\circ M', \sigma \leadsto^* \sigma' \ \ \wedge\ \ \sigma'.cont$ is a value
%\end{enumerate}
%We want to show that
%\begin{enumerate}
%\item
%$M,\sigma' \ \models \ A' $
%\end{enumerate}
%The proof proceeds by induction over a lexicographic ordering over the tuples $(M, A, e, A', \sigma, \sigma')$ This ordering is the tuple of ($m_{cl}$, $m_{ext}$), where 
%$m_{cl}$ is the length of the maximal sequence of proof steps in "classical Hoare logic, ie excluding a step {\sc{ExtCall}} involved in proving that  ie excluding a step {\sc{ExtCall}}, and the $m_{ext}$ is the number of external calls that occurred ... {TODO: this needs to be refined!}
%
%\end{proof}



 