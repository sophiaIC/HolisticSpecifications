We will now develop an inference system to prove that a module % is well-formed $\vdash M$, \ie that a module 
satisfies its specification. This is done in three phases.
%\TODO{\red{TODO: refer to what we said in approach section}}

In the first phase we develop a logic of triples ${\hproves{M}  {A} {\ s\ }{A'} }$, which have the expected meaning, \ie 
(*) execution of statement $s$ in a state satisfying {the \emph{precondition}}  $A$ will lead to a state satisfying  {the \emph{postcondition}}  $A'$.
These tuples only apply to statements $s$ that  do not contain method calls  (even internal calls) -- this is so, because method calls may contain calls to external methods, and therefore can only be described through quadruples.
Our triples extend an underlying Hoare logic  (${M \vdash_{ul}  \{A\} {\ s\ } \{A'\} }$) and  introduce new judgements  which talk about protection.

In the second phase we develop a logic of quadruples ${\hprovesN{M}  {A} {\ s\ }{A'} {A''}}$. These promise, as usual, that (*) 
In addition, they promise that (**) any intermediate external states reachable during execution of that statement will satisfy the invariant  $A'''$.  
{We call $A''$ the \midcond.}
 We incorporate all triples from the first phase,       
introducing invariants, give the usual substructural rules, and deal with method calls. 
For method calls we use the methods' specs, and in addition, for public methods we use the fact that they preserve the module's invariants. 
For call to external  methods, we can only use the fact that they preserve the module's invariants. 
 
In the third phase, we prove adherence to each of the specifications. 
For method specifications we prove that the body maps the precondition to the postcondition and preserves the method's invariant. 
For module invariants we prove that they  are preserved by all public methods of the module.

\vspace{.1cm}
Before describing these three phases, we introduce some preliminaries.


\subsection{Preliminaries: Specification Lookup and Renamings}

The judgment    $\promises M S$ expresses that $S$ is guaranteed by the module. 
In particular, it allows   \emph{safe  renamings}. 
These renamings are   a convenience, akin to the Barendregt convention, and  allow simpler Hoare rules for  method calls -- \cf Sect. \ref{s:calls}.
\Cf Definition \ref{d:promises}.

\subsection{First Phase: Triples}


\begin{figure}[tht]
$
\begin{array}{c}
% \begin{array}{lcl}
\inferrule[\sc{extend}]
	{ M \vdash_{ul} \{ \ A\ \} {\ stmt\ }\{\ A'\ \} \\
	 stmt  \ \mbox{contains no method call} }
	{\hproves{M}  {A} {\ stmt\ }{A'} } 
% MOVED
%	& &
%\inferrule[\sc{types-1}]
%	{  stmt \ \mbox{contains no method call} \\
%	stmt  \ \mbox{contains   no assignment to $x$}}
%	{\hproves{M}  {x:C} {\ stmt\ }{x:C} }
% \end{array}
% \end{array}
\end{array}
 $
\caption{Embedding underlying Hoare Loagic}
\label{f:underly}
\end{figure}
 
\subsubsection{Embedding an underlying Hoare Logic}

\begin{axiom}
\label{ax:ul}
{Assume   Hoare logic with judgements % of the form 
\ $M \vdash_{ul} \{ A \} s \{ A' \}$, \ 
so that $\Stable{A}$ and $\Stable{A'}$. }
\end{axiom}


In  Fig. \ref{f:underly} and \ref{f:protection} we introduce our triples, of the form ${   \hproves{M}  {A} s {A'}}$. 
These promise, as expected, that any execution of $stmt$ in a state that satisfies $A$ leads to a state that satisfies $A'$.
These tuples only apply to statements that do not contain method calls.

With rule {\sc{extend}} in Fig. \ref{f:underly},  any assertion $M \vdash_{ul} \{ A \} s \{ A' \}$  whose statement does not contain a method call, and which 
can be proven in the underlying Hoare logic, to also be proven in our logic. %More in \ref{s:types}.
 

\begin{figure}[tht]
$
\begin{array}{c}
 \sdN{\inferruleSD{\hspace{2.3cm} [\sc{prot-new}]}
	{	}
	{	 
 	\hproves{M} 
 						{\  \internal {u}   \ }
 					{\  u = \prg{new}\ C \ }
 						  { \  \inside{u}\  \wedge  \protectedFrom{u}{x} \ } 
 	}
}
\\
\\
	{{\inferruleSD{\hspace{2.3cm} [\sc{prot-1}]}
	{   stmt \ \mbox{contains no method call, and no assignment to $z$}
	\\
	{\hproves{M}  {\re = z} {\ stmt\ }{ \re=z} }
	}
	{\hproves{M} 
						{\  \inside{\re}  \ }
						{\  stmt \ }
						{\  \inside{\re}\ }
	}
}}
%\\
% this onw ia wronf!!!
%\\
%	{{\inferruleSD{\hspace{2.3cm} [\sc{prot-2}]}
%	{   stmt \ \mbox{contains no method call, and no assignment to $z$ or $z'$}
%	\\
%	{\hproves{M}  {\re = z \wedge \re' = z'} {\ stmt\ }{\re = z \wedge \re' = z'} }
%	}
%	{\hproves{M} 
%						{\  \protectedFrom{\re}{\re'}  \ }
%						{\  stmt \ }
%						{\  \ \protectedFrom{\re}{\re'}\ }
%	}
%	}}
%\\
%\\
%\mbox{\sdN{We had this rule, but I believe  that it is not sound when $y$=$z$, or $x$=$y$}}
\\
      {\inferruleSD{\hspace{5.3cm} [\sc{prot-3}]}
	{ }
	{\hproves{M} 
						{\ \protectedFrom{y.f}{z}\ }
						{\ x =y.f\ }
						{\ \protectedFrom{x}{z}\ }
	}
}
%
%\\
%\\
%\sdN{\mbox{Is his rule is subsumed by {\sc{Prot-1}}}}
%\\
%       {\inferruleSD{\hspace{5.3cm} [\sc{prot-???}]}
%	{ }
%	{\hproves{M} 
%						{\  \inside{x}\ \wedge \   \protectedFrom{x}{y'} \ }
%						{\ y.f=y'\ }
%						{\  \inside{x}\ }
%	}
%}	
%\\
\\
        {\inferruleSD{\hspace{5.3cm} [\sc{prot-4}]}
	{ }
	{\hproves{M} 
						{\ \protectedFrom{x}{z} \ \wedge \   \protectedFrom{x}{y'} }
						{\ y.f=y'\ }
						{\ \protectedFrom{x}{z} \ }
	}
}	 
\end{array}
 $
\caption{Triples -- protection}
\label{f:protection}
\end{figure}







 

 \subsubsection{Reasoning about protection}


In Fig. \ref{f:protection} we  give rules about the preservation of protection.
In \textsc{Prot-1}, we see that  protection of an object $o$ is preserved by internal code which does not call any methods: namely any heap modifications will
ony affect internal objects, and this will not expose new, unmitigated external access to $o$.
%In \textsc{Prot-2}, the assignment $y=y'.f$ does not create a new route from $z$ to $x$, and therefore  $\protectedFrom{x}{z}$ is preserved.
\jm{In \textsc{Prot-3}, if $y.f$ is protected from some $z$, then the field access $x=y.f$ retains that protection, and therefore $\protectedFrom{x}{z}$.}
In \textsc{Prot-4}, if $x$ is protected from $y'$, then the assignment $y.f=y'$ does not create a new unprotected route  to $x$, and therefore   $\protectedFrom{x}{z}$ is preserved.
}
Moreover, ``protection'' of an object can decrease is if we call an external method, and pass it an internal object as argument. This is then covered by the rule in Fig. \ref{f:external:calls}.

\begin{lemma}
\label{l:no:meth:calls}
If ${\hproves{M}  {A} {\ s\ }{A'} }$, then $s$ contains no method calls.
\end{lemma}
  
\jm{Fig. \ref{f:protection} extends an assumed underlying Hoare logic with rules for reasoning about protection. To supplement this, we introduce some consequence rules in Fig. \ref{f:protection:conseq} to reason about protection apart from a Hoare logic. These are primarily useful when applying \textsc{Consquence} style Hoare rules.}


\begin{figure}[htb]
\begin{mathpar}
\inferrule
	{M \vdash x : \prg{int} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Int}_1]
	\and
\inferrule
	{M \vdash x : \prg{int} \rightarrow \neg \protectedFrom{x}{y}}
	{}
	\quad[\textsc{Prot-Int}_2]
	\and
\inferrule
	{M \vdash x : \prg{bool} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Bool}_1]
	\and
\inferrule
	{M \vdash x : \prg{bool} \rightarrow \neg \protectedFrom{x}{y}}
	{}
	\quad[\textsc{Prot-Bool}_2]
	\and
\inferrule
	{M \vdash x : \prg{str} \rightarrow \protectedFrom{y}{x} }
	{}
	\quad[\textsc{Prot-Str}_1]
	\and
\inferrule
	{M \vdash x : \prg{str} \rightarrow \neg \protectedFrom{x}{y}}
	{}
	\quad[\textsc{Prot-Str}_2]
	\and
\inferrule
	{M \vdash x \neq y \wedge y : \prg{intl} \rightarrow \protectedFrom{x}{y}}
	{}
	\quad[\textsc{Prot-Intl}]
\end{mathpar}
\caption{Consequence Rules for Protection}
\label{f:protection:conseq}
\end{figure}

\jm{Julian: I added the above, but these are not sensible with the current definition of protection because protection is only defined between objects, and not ints, bools, and strings. They are necessary for the example proofs (or alternatively we can use object encodings of these types, but I think that might be more difficult). The rules for strings are potentially not necessary. They only help make the Seciton 2 example work when we send back a message as a string. Similarly, we could probably drop the bool rules.}


\begin{figure}[htb]
$
\begin{array}{c}
% \begin{array}{lcl}
\inferruleSD{[\sc{Mid}]}
	{\hproves{M}  {A} {\ s\ }{A'} }
	{\hprovesN{M}  {A} {\ s\ }{A'} {A''} }
\\
\\
% MOVED
% THIS RULE IS NOT SOUND -- we need to adapt it
%{
%\inferrule[\sc{types-2}]
%	{ \hprovesN{M}  {A} {\ s\ }  {A'} {A''}  }
%	{\hprovesN{M}  {x:C \wedge A} {\ s\ }  {x:C\wedge A'} {A''}}
%}
% \end{array}
% \\
% \\
\begin{array}{lcl}
\inferruleSD{[\sc{combine}]}
	{  \begin{array}{l}
	\hprovesN{M}  {A_1} {\ s\ } {A_2}  {A} \\ % \hspace{1.4cm}  
	\hprovesN{M}  {A_3} {\ s\ } {A_4} {A}
	\end{array}
	}
	{ \hprovesN{M}  {A_1 \wedge A_3 }{\ s\ } {A_2 \wedge A_4} {A} }
& &
\inferruleSD{[\sc{sequ}]}
	{  \begin{array}{l} 
	\hprovesN{M}  {A_1} {\ s_1\ } {A_2}  {A}  \\ % \hspace{1.4cm} 
	\hproves{M}  {A_2} {\ s_2\ } {A_3} {A}
	\end{array}
	}
	{   \hprovesN{M}  {A_1   }{\ s_1; \, s_2\ } {  A_3} {A} }
\end{array}
\\ \\
\inferruleSD{ \hspace{3cm} [\sc{consequ}]}
	{
%	\begin{array}{l}
	 { \hprovesN  {M}  {A_4} {\, s\, } { A_5} {A_6}  }
	 \hspace{1.4cm} 
	 M \vdash A_1 \rightarrow A_4 
	 \hspace{1.4cm} 
	{ M \vdash A_5   \rightarrow  A_2  }
	 \hspace{1.4cm}   
	{  M \vdash A_6 \rightarrow A_3 }
%	\end{array}
	}
	{   \hprovesN{M}  {A_1 }{\ s\ } {A_2} {A_3} }
  \end{array}
 $
\caption{Hoare Quadruples - incorporating Hoare triples and substructural rules }
\label{f:substructural}
\end{figure}

\subsection{Second Phase: Quadruples}

\subsubsection{Introducing mid-conditions, and substructural rules}
Fig. \ref{f:substructural} introduces quadruple rules of the from ${\hprovesN{M}  {A} {\ s\ }{A'} {A''} }$ which do not deal with method calls.

Rule {\sc{mid}} embeds  triples  ${\hproves{M}  {A} {\ s\ }{A'} }$  into quadruples ${\hprovesN{M}  {A} {\ s\ }{A'} {A''} }$; this is sound, because $s$ is guaranteed not to contain method calls (by lemma \ref{l:no:meth:calls})
\footnote{The restriction to statements which do not contain method calls in rule {\sc{types-1}} was imposed so as to make this lemma valid}, and therefore its execution is guaranteed not to reach any external states.

 
The remaining rules in Fig. \ref{f:substructural} apply to \emph{any} statements -- even those containing method calls.
%MOVED 
% Rule {\sc{types-2}} generalizes {\sc{types-1}} to any statement, provided that  there already exists a triple for that statement.
Rule {\sc{combine}} combines two quadruples for the same statement into one.
Rule   {\sc{sequ}}is the usual rule  for statement sequences  adapted to quadruples.
% SD: at the moment the below is not needed
%{{Rule   {\sc{consequ}} is more interesting, because it employs a new inference, {{$\inferd$}}, rather than  the usual inference, $\rightarrow$.
%For stable assertions, $\rightarrow$ and $\inferd$ behave the same way -- more  in section 
%} }



\subsubsection{Reasoning about   calls}
\label{s:calls}
is described in Fig. \ref{f:internal:calls}. {\sc{Call\_Int}}  and {\sc{Call\_Int\_Adapt}}  for internal methods, whether public or private; \ % \  {\sc{Call\_Ext}} 
and {\sc{Call\_Ext\_Adapt}} for  external methods.




\begin{figure}[htb]
\small{
$\begin{array}{c}
 \inferruleSD{\hspace{4.7cm} [\sc{Call\_Int}]}
	{
	   	\begin{array}{l}
		\promises  M {\mprepostN{A_1}{p\ C}{m}{y}{C}{A_2} {A_3}}  
          	\end{array}
		}
	{  \hprovesN {M} 
						{ \  y_0:C,\overline {y:C} \wedge  A_1[y_0/\prg{this}] \ }
						 { \ u:=y_0.m(y_1,.. y_n)\    }
					         { A_2[ u/res,y_0/\prg{this}] } 
						{   A_3 } % A_3[y_0/\prg{this}]   }	
}
 \\
\\
{ \inferruleSD{\hspace{4.7cm} [\sc{Call\_Int\_Adapt}]}
	{
	   	\begin{array}{l}
		\promises  M {\mprepostN{A_1}{p\ C}{m}{y}{C}{A_2} {A_3}}  
          	\end{array}
		}
	{  \hprovesN {M} 
						{ \,  y_0\!:\!C, \overline {y\!:\!C} \wedge {\PushASLong {\sdN{(y_0,\overline {y})}} {(A_1[y_0/\prg{this}])} }  \, }
												{ \, u\!:=\!y_0.m(y_1,.. y_n)\,    }
						{  { \PushASLong  {\sdN{(y_0,\overline {y})}}  {(A_2[ u/res,y_0/\prg{this}])} }   }
						{   A_3 } % [y_0/\prg{this}]  }	
}
}
%\\
% \\ 
% WRONG
% \inferruleSD{\hspace{4.7cm} [\sc{Call\_Ext}]}
% 	{ 
%   	 \promises M   {\TwoStatesN {\overline {x:C}} {A}} 
%        }
%	{   \hprovesN{M} 
%						{ \    { \external{y_0}} \,     \wedge \,  \overline{x:C}\  \wedge\ {{A}}\ }  
%						{ \ u:=y_0.m(y_1,.. y_n)\    }
%						{ \   {{A}}  \ }
%						{\  A \   }	
%}
\\
 \\ 
 \inferruleSD{\hspace{4.7cm} [\sc{Call\_Ext}\_Adapt]}
 	{ 
   	 \promises M   {\TwoStatesN {\overline {x:C}} {A}} 
        }
	{   \hprovesN{M} 
						{ \    { \external{y_0}} \,     \wedge \,  \overline{x:C}\  \wedge\ {\PushASLong {\sdN{(y_0,\overline {y})}}  {A}}  \ } 
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \   {\PushASLong {\sdN{(y_0,\overline {y})}}  A}  \ }
						{\  A \   }
	}	

\\
 \\ 
{
 \inferruleSD{\hspace{4.7cm} [\sc{Call\_Ext}\_Adapt\_Strong]}
 	{ 
   	 \promises M   {\TwoStatesN {\overline {x:C}} {A}} 
        }
	{   \hprovesN{M} 
						{ \    { \external{y_0}} \,     \wedge \,  \overline{x:C}\ \wedge  A   \wedge\ {\PushASLong {\sdN{(y_0,\overline {y})}}  {A} }\  }   
						{ \ u:=y_0.m(y_1,.. y_n)\    }
						{ \   A \wedge {\PushASLong {\sdN{(y_0,\overline {y})}}  {A} } \  }  
						{\  A \   }	
}
}

\end{array}
$
}
\caption{Hoare Quadruples for Internal and External Calls -- here $\overline y$ stands for $y_1, ... y_n$}
%, and  $\overline C$ stands for  $C_1, ... C_n$}
\label{f:internal:calls}
\label{f:external:calls}
\label{f:calls}
\end{figure}
% }}

  {\sc{Call\_Int}} is as expected:  
We look up the method's specification,   require the precondition, and guarantee the postcondition and midcondiition. 
For {\sc{Call\_Int\_Adapt}} we require the adapted pre-condition ($  \PushASLong {(y_0, \overline y)}{A_1}$  rather than $A_1$) and also ensure the adapted post-condition ($ \PushASLong {(y_0, \overline y)}{A_2}$  rather than $A_2$).
Remember that$  \PushASLong {(y_0, \overline y)}{A_1}$ at the caller's side guarantees that $A_1$ holds at the start of the callee (after pushing the frame with   $y_0, \overline y$), while  
$A_2$ at the end of the callee guarantees that  $ \PushASLong {(y_0, \overline y)}{A_2}$  holds when returning to the callee's frame (when popping the frame)
-- cf.  lemma \ref{lemma:push:ass:state}.
 {\sc{Call\_Int}} and {\sc{Call\_Int\_Adapt}}  are applicable whether the method is public or private.


For external methods,  {\sc{Call\_Ext\_Adapt}}, we consider the module's invariants. If the module promises to preserve $A$, \ie if  $\promises M   {\TwoStatesN {\overline {x:D}} {A}}$, and   $ \PushASLong {(y_0, \overline y)}{A}$  holds before the call, then it also holds after  the call, and $A$ is also a \midcond of the call.
In  {\sc{Call\_Ext\_adapt}},  we require that the adapted version,  \ie that   $ \PushASLong {(y_0, \overline y)}{A}$ holds before the call. Then, the 
adapted version version also holds after the call. Moreover, $A$ is also a \midcond of the call.


\vspace{.1cm}

Notice that at the point of the call, for internal calls, in {\sc{Call\_Int}} we require the the un-adapted version of the the method's precondition (\ie $A_1[y_0/\prg{this}]$), while for external calls, both {\sc{Call\_Ext\_Adapt}} and {\sc{Call\_Ext\_Adapt\_Strong}}, we require the adapted version of the invariant (\ie $ \PushASLong {(y_0, \overline y)}{A}$). 
This is so, because when the callee is internal, then  variable-free, $\Pos{\_}$-assertions are preserved against pushing of frames -- \cf lemma \ref{l:preserve:asrt}.\ref{l:preserve:asrt:two}.
On the other hand, when the callee is external, then $\Pos{\_}$-assertions are not necessarily preserved against pushing of frames -- \cf \ref{push:does:not:preserve} 
Therefore, we can only safely assume that $A$ holds upon entry to the callee, if $ \PushASLong {(y_0, \overline y)}{A}$ held at the caller site -- \cf lemma \ref{lemma:push:ass:state}.

Remember also, that $A$ does not imply $ \PushASLong {(y_0, \overline y)} {A}$, nor does $ \PushASLong {(y_0, \overline y)}{A}$  imply $A$ -- \cf example \ref{push:does:not:imply}.


\vspace{.1cm}
The interested reader might notice, that while $\Pos{\_}$,-assertions are preserved against pushing of internal frames, they are not necessarily preserved against popping of such frames. }\red{TODO - write the counterexample}.
Nevertheless, {\sc{Call\_Int}} guarantees the unadapted version, $A$, 
% rather than the adapted version, $\PushAS {y} {A}$, 
upon return from the method call. 
This is sound, because of our use  of the concept of \emph{deep satisfaction} of assertions -- more in section \ref{s:deep:valid}.
 

\vspace{.1cm}
 {{
\noindent
\textbf{Implicit renamings} In all rules above  the actual and formal parameter names were identical. We achieved this through the implicit renamings from Def. \ref{d:promises}.  
 }}
 
%\subsubsection{Aliasing and Calls}

\TODO{TODO: revisit that section}

%{Rules  {\sc{CallAndAlias}}  and  {\sc{CallNonAlias}} say that calls preserve aliasing, resp. non-aliasing, between variables, ie they preserve $x=x$ resp. $x\neq x$. These two rules apply to internal as well as external calls. When the callee's receiver is external, they make the extra requirement that  $\PushAS {y}{\extract{M}}$ -- we  will discuss this requirement together with the discussion of Fig. \ref{f:external:calls}.     Note that $x=x'$ expresses that $x$ and $x'$ are aliases, while  $u\txteq x$ expresses that $u$ and $x$ are textually the same --
%the latter is stronger, i.e.   $x\txteq u$ implies $x=u$. 
%% It is possible that variables are aliases, without being textually the same, i.e. it is possible to have $x=x'$ while $u\not\equiv x'$. 
% As $...\equiv ...$ is a textual assertion, and thus  state-independent,  it is a side-condition of the rules and is  not part of the Hoare triple's precondition.
%}
%
%
%\small{
%\begin{figure}[hbt]
%$\begin{array}{c}
%\inferruleSD{\hspace{4.7cm}  [{\sc{CallAndAlias}}}
%	{ 
%	{   x \txtneq u\txtneq x'  }
%	}
%	{   \hproves{M}  { \ x=x'\   \wedge \ ({\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}})\  }	{ \ u:=y_0.m(y_1,.. y_n)\  } { \  x=x'\ }	 }
%
%\\ \\ 
%\inferruleSD{\hspace{4.7cm} [{\sc{CallNonAlias}}]}	
%{ 
%		{ \ x \txtneq u \txtneq x'\   }
%	}
%	{   \hproves{M}   { \ x\neq x'\   \wedge \ ({\external{y_0}}  \rightarrow \  \PushAS {y}{\extract{M}})\  } { \ u:=y_0.m(y_1,.. y_n))\  } { \  x\neq x'\ }	 }
%\\
%\\
%\end{array}
%$
%\caption{Logic for Aliasing around Calls }
%\label{f:internal:alias:calls}
%\end{figure}
%}




\subsection{Third phase: Proving adherence to Module Specifications}
\label{sect:wf}

In Fig. \ref{f:wf} we  define the judgment $\vdash M$, which says that % module $M$ 
$M$ has been proven to be well formed. 
%has been proven to satisfy its specification.



\begin{figure}[thb]
$
\begin{array}{l}
\begin{array}{lcl}
\inferruleSDNarrow 
{~ \strut  {\sc{WellFrm\_Mod}}}
{  M \vdash \SpecOf {M}
}
{
\vdash M  
}
& \hspace{0.7cm} &
\inferruleSDNarrow 
{~ \strut   {\sc{Comb\_Spec}}}
{  
M \vdash S_1 \hspace{1cm}  M \vdash S_2
}
{
M \vdash S_1 \wedge S_2
}
\end{array}
\\
\\
\inferruleSD 
{~ \strut \hspace{6.5cm} {\sc{method}}}
{  
 \prg{mBody}(m,D,M)=p \ (\overline{y:D})\{\  stmt \ \}  %\ \ \vee \ \   \prg{mBody}(m,D,M)=\prg{public} \ \overline{x:C}\{\  stmt \ \}       
    \\
  {\hprovesN{M} { \ \prg{this}:\prg{D}, \overline{y:D}\, \wedge\, A_1\  } {\ stmt\ } {\ A_2 \ }   {A_3} } 
}
{
M \vdash {\mprepostN {A_1}{p\ D}{m}{y}{D}{A_2} {A_3} }
}
%\\
%\\
%{
%\inferruleSD 
%{~ \strut \hspace{6.5cm} {\sc{invariant-hope}}}
%{
%\begin{array}{l}
%\forall  D,  m:\ \ \  \ \  \prg{mBody}(m,D,M)=\prg{public} \ (\overline{y:C})\{\  stmt \ \}      \ \ \Longrightarrow  
%  \\
%   ~ \strut \hspace{0.3cm}  \ \ \ 
% {
% \hprovesN {M}  
% 	{ \ \prg{this}:\prg{D}, \overline{y:D},\,   \overline{x:C},\,\external z \, \wedge\,  \PushASLong {z} {A}\ }   
%	{\ stmt\ }   
%	{\  \neg{ \protectedFrom{res}{z}}\  \wedge    {\PushASLong {z} {A}} \ }  
%	{  \PushASLong {z} {A} }
%}
% \end{array}
%}
%{
%M \vdash \TwoStatesN{ \overline{x:C}} {A}
%}
%}
%\\
%\\
%{
%\inferruleSD 
%{~ \strut \hspace{6.5cm} {\sc{invariant-2-failed}}}
%{
%\begin{array}{l}
%\forall  D,  m:\ \ \  \ \  \prg{mBody}(m,D,M)=\prg{public} \ (\overline{y:C})\{\  stmt \ \}      \ \ \Longrightarrow  
%  \\
%   ~ \strut \hspace{0.3cm}  \ \ \ 
% {
% \hprovesN {M}  
% 	{ \ \prg{this}:\prg{D}, \overline{y:D},\,   \overline{x:C} \, \wedge\,  A\ }   
%	{\ stmt\ }   
%	{\  \neg{ \inside{res}}\  \wedge    {A} \ }  
%	{  A }
%}
% \end{array}
%}
%{
%M \vdash \TwoStatesN{ \overline{x:C}} {A}
%}
%}
%\\
%\\
%{
%\inferruleSD 
%{~ \strut \hspace{6.5cm} {\sc{invariant-3-failed}}}
%{
%\begin{array}{l}
%\forall  D,  m:\ \ \  \ \  \prg{mBody}(m,D,M)=\prg{public} \ (\overline{y:C})\{\  stmt \ \}      \ \ \Longrightarrow  
%  \\
%   ~ \strut \hspace{0.3cm}  \ \ \ 
% {
% \hprovesN {M}  
% 	{ \ \prg{this}:\prg{D}, \overline{y:D},\,   \overline{x:C},\,\external z \, \wedge\,  A\ }   
%	{\ stmt\ }   
%	{\  \neg{ \protectedFrom{res}{z}}\  \wedge    {A} \ }  
%	{  A }
%}
% \end{array}
%}
%{
%M \vdash \TwoStatesN{ \overline{x:C}} {A}
%}
%}
\\
\\
{
\inferruleSD 
{~ \strut \hspace{6.5cm} {\sc{invariant}}}
{
\begin{array}{l}
\forall  D,  m:\ \ \  \ \  \prg{mBody}(m,D,M)=\prg{public} \ (\overline{y:C})\{\  stmt \ \}      \ \ \Longrightarrow  
  \\
   ~ \strut \hspace{0.3cm}  \ \ \ 
 {
 \hprovesN {M}  
 	{ \ \prg{this}:\prg{D}, \overline{y:D},\,   \overline{x:C} \, \wedge\,  A\ }   
	{\ stmt\ }   
	{\  A\, \wedge\, \PushASLong {\prg{res}} {A} \ }  
	{  A }
}
 \end{array}
}
{
M \vdash \TwoStatesN{ \overline{x:C}} {A}
}
}
\end{array}
$
\caption{Methods' and Modules' Adherence to Specification}
\label{f:wf}
\end{figure}

\footnote{Julian's reflections on the invariant and metod call rules:

 I think it somewhat makes sense for the Invariant rule to be asymmetric since
calls to internal code are asymmetric from the perspective of protection. There is no change in specific protection when entering 
internal code, but there may be when returning to external code from internal code. 

I'd have to think about it more, but I don't believe there is any decrease in general protection when entering internal code,
but there may be when exiting internal code. The adaptation in the post-condition is there to address the potential
for protection to be lost on return.

Magic wand adaptation (i.e. A -* x) expresses what must hold before crossing the boundary from internal to external code
(i.e. before an internal method return or call to an external method) for the adapted assertion to still be satisfied after crossing 
that boundary. I think there are a few things that are useful to consider here:
it is good to note that if you remove protection from the assertion language, the magic wand would be the identity
(i.e. A -* x = A) since only protection is modified when passing values between objects via method calls
more importantly, the way we define protection is based around fields and external/internal objects, and passing a value
to an internal object (via a method call) modifies neither a field nor grants any external object access to any other object
According to my understanding of the intended semantics of the magic wand, entering internal code from frame should
not affect any sort of protection.
My impression is that part of the intent of the magic wand is to be able to express "what needs to hold before a call
so that <x>  holds within the new frame (whether that frame is internal or external)?". I still need to think about how that
fits in with my above description of magic wand adaptation.
}

%$\begin{array}{lclcl}
%PRE(A_1 \wedge A_2} \trangleq PRE(A_1) \wedge PRE(A_2} & PRE{\protectedFrom \re \re
%
%{{\sc{WellFrm\_Mod}} and 
% {\sc{Comb\_Spec}} together say that a module is well formed if it satisfies each conjunct of its specification.
% }
% 
 {{\sc{Method}} says that  a module satisfies a method specification if the method body satisfies the corresponding pre-, post- and \midcond.
 }
 {{\sc{Invariant}} says that  a module satisfies an invariant specification $\TwoStatesN{ \overline{x:C}} {A}$,  if the method body of each public method
 has $A$ as its  pre-, post- and \midcond. Moreover, since the method is public, \prg{this} and the parameters are not protected upon method entry ($\overline{ \neg\inside{y}}\, \wedge\, \overline{x:C}$)),
 and the result is not protected upon method exit ($ \neg\inside{res}$)
}
 
 \vspace{.1cm}

\noindent
\textbf{Implicit renamings} We follow a form of Barendregt convention: In  {\sc{Method}}  we assume, wlog, that no free variable  in $A_1$   clashes with a variable  in $stmt$.
In {\sc{Invariant}} we assume, wlog, that none of
 $\overline x$ clash with  $\overline y$ or a variable  in $stmt$. 
% : Any of $\overline x$  which clashes with $\ovelrine y$ or a variable  in $stmt$,   gets implicitly renamed  in the proof that $ {\hprovesN{M} { \ \prg{this}:\prg{D}\, \wedge\, \overline{y:D}\,  \overline{x:C}\, \wedge\,  \wedge\,  A\  } {\ stmt\ } {\ A\ } {\ A \ }  } $


 




 
