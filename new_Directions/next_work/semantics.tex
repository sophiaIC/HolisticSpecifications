% \renewcommand{\sd}[1]{#1}
 \newcommand{\sdOct}[1]{#1}
\newcommand{\re}{\mathit{e}}

\section{points to make earlier}

\subsection{one}
In the introduction show a method where
\begin{lstlisting}
    void cautious(untrusted : Object, acc: Account){
    PRE acc.passwd PRT-FROM untrusted
    POST acc.passwd PRT-FROM untrusted
     ...
        ext-call does not pass acc.pwd
     ...
   }
\end{lstlisting}

Even external object creation may return an old, preexisting object.
Nevertheless, we are able to prove the above. Make a diagram that has an untrust', which has access to a.pwd. 


\subsection{two}
In our setting, we must deal with the possibility  that any untrusted object may point to any other untrusted object.
Therefore, any reference given to an untrusted object may end up, in principle,  eventually given to all of them.
Therefore if there was an untrusted object $u$ that had reference to $o$,  and we knew that $o$ was protected from $z$ now, we are not
allowed   to deduce that $o$ will still be protected in the "deep" future.
However, if we consider the "shallow" future, we can do better than that.

Namely, if  before an untrusted call with receiver and arguments $\overline z$ we know that $o$ is protected from $\overline z$, and if we know that the internal objects do not leak $o$ to the the external world, then we know that during execution of the untrusted call (and also all nested trusted or untrusted calls), $o$ will be protected (ie no locally accessible external object will obtain direct access), and that after the call, $o$ will still be protected from $\overline z$.

Going back to the discussion where $u$ \kjx{refers}
\st{has an (un-mitigated?)reference} to $o$,  if at the untrusted call
with receiver and arguments $\overline z$, we know that $o$ is
protected from $\overline z$, then this does not preclude
\kjx{$u$ referring to $\overline z$, but it does preclude $\overline
  z$ referring to $u$ -- because if $\overline z \rightarrowtail u$
  then $\overline z \rightarrowtail o$.}
\st{that $u$ has unmitigated access to $\overline z$, but it does precludes that any of  $\overline z$ has unmitigated access to $u$ (because if had, then it would also have had unmitigated access to $o$ itself).}

\subsection{three}
NOTE: JAMES asked Do we need to worry about well-fomedness? Eg what if
we had an assertion $3 \wedge 5 \rightarrow 66$?

  

\subsection{four}
Say that protected-from is a heap property, whereas protected is a
heap-frame property.


\subsection{five}
Say authority implies eventual permission. Ie we want to guarnatee that an untrusted object will not get permission to a capability. Lack of eventual permissions bounds authority.


\section{\SpecLang specifications}
\label{s:semantics}

 
In this section we define {the}  \SpecLang specification language.  
We first define an underlying programming language, \LangOO (\S \ref{sub:Loo}).
We then define an assertion language, \AssertLang, which can talk about the
contents of the state, as well as about protection (\S \ref{sub:SpecO}).  Finally, we define the syntax and
semantics of  \SpecLang
specifications (\S \ref{s:holistic-guarantees}).

 


\section{\LangOO -- the underlying object oriented programming languages}

\subsection{\LangOO syntax and semantics}
\label{sub:Loo} 
 \LangOO  is a {small}, imperative, sequential, 
class based, typed, object-oriented language, whose
fields are private to the class where they are defined -- similar to the one in OOPSLA\footnote{any differences?}.
The complete definition of \LangOO i 
{can be found in the appendices  \cite{necessityFull}.}
 A \LangOO state $\sigma$ consists of a 
heap $\chi$, and a  {stack $\psi$ which is a sequence of frames}.
A frame, $\phi$, consists of
local variable map, and a continuation, \ie a sequence of statements to be executed.
%{We use  $| \sigma |$ to describe the numbers of frames in the stack of  $\sigma$, i.e. the number of nested, currently active method calls.}
 A statement may assign to variables, create new objects and push them to the heap, 
perform field reads and writes on objects,  or
 call methods on those objects. 

 
Modules are mappings from class names to class definitions. 
Execution 
takes place
 in the context of  a module $M$ and   a state $\sigma$,
 defined via unsurprising small-step semantics of the form \ \ 
   $M, \sigma \leadsto \sigma'$.
The   top frame's continuation contains the statement to be 
executed next.  

\paragraph{Notation} We adopt notation from OOPSLA, where
 $\interpret{\phi}{x}$  indicates the value of $x$   in the local variable map of frame $\phi$, 
 and where $\interpret{\sigma}{x} = v$ means that $x$ 
maps to $v$ in the top-most frame of $\sigma$'s stack, and $\interpret{\sigma}{x.f} = v$
has the obvious meaning. The terms $\sigma.\prg{stack}$,  
$\sigma.\prg{contn}$,  
$\sigma.\prg{heap}$     mean the stack, 
the continuation at the
top frame of $\sigma$, %resp. 
and the heap of $\sigma$.
The term $\alpha\!\in\!\sigma.\prg{heap}$ means that $\alpha$ is in the domain of the heap of $\sigma$, and \emph{$x$ fresh in $\sigma$} means that 
$x$ isn't in the variable map of the top frame of $\sigma$, 
while the substitution  $\sigma[x \mapsto \alpha]$ is applied to the top frame of $\sigma$.
 \ $C\in M$ means that class $C$ is in the domain of module $M$. 


\paragraph{Applicability} 
{While our work is based on 
  a simple, imperative, typed, object oriented}
language with unforgeable addresses and private fields, we believe
 that % our approach
 it is applicable to several programming paradigms, and 
 that   unforgeability and privacy
 can be replaced 
 by lower level mechanisms such as capability machines \cite{vanproving,davis2019cheriabi}.

  \subsection{{Reachable  Objects}}
  
{The  \SpecLang  specifications support universal quantification over  objects; such specifications 
are applicable  to all objects in the heap witch, are however, either locally reachable (i.e. there is in the heap a path from the an 
object on the top frame to the particular object), or globally reachable (i.e. there is in the heap a path from the an 
object on some frame to the particular object.)
In this section  we will formally define these concepts.}\footnote{TODO we need a better motivation for these concepts.}
 



We define  % $\Relevant \alpha \phi \sigma $ as the objects $\alpha$ which are reachable from   the frame $\phi$,
locally reachable, $ \LRelevant \alpha \sigma $, as  the objects  $\alpha$ which are reachable the top frame on the stack of $\sigma$,
and globally reachable, $\GRelevant \alpha \sigma$, as the objects  $\alpha$ which  are reachable from any  frame on the stack of $\sigma$.
 
\begin{definition} We define 
\begin{itemize}
\item
$ \LRelevant \alpha \sigma $ \ \ iff\ \  
$\exists \phi.[\ \sigma=(\phi\cdot\_, \_)$ and $\Relevant \alpha \phi \sigma\ ]$. % for some $\phi$
\item
$\GRelevant \alpha \sigma$  \ \ iff\ \  
$\exists \phi.[\ \sigma=(\_\cdot\phi\cdot\_, \_)$ and $\Relevant \alpha \phi \sigma\ ]$. % for some $\phi$
\end{itemize}
where\\
$\strut\ \ \ \  \ \ \ \ \ \ \Relevant \alpha \phi \sigma $  \ \ \ \ \ \ \ iff\ \  
$\exists n\in \mathbb{N}.\exists \prg{f}_1,... \prg{f}_n.\exists \prg{x}.[ \ \interpret{\sigma}{\phi(x).\prg{f}_1.....\prg{f}_n} = \alpha \ \ ]$.

\end{definition}


The lemma below says that 1) Any locally reachable object is globally reachable, and 
2) Any object which existed in the current  heap, and is globally reachable at some future point is globally reachable now: that is, 
no globally unreachable object may become reachable.\footnote{cite "only connectivity begets connectivity"}



\begin{lemma}
\label{lemma:relevant}
For all $\sigma$, $\sigma'$, for all objects $o$, and for all modules $M$:
\begin{enumerate}
\item
$ \LRelevant \alpha \sigma\ \ \Longrightarrow \ \   \GRelevant \alpha \sigma$
\item
$M, \sigma  \leadsto^*   {\sigma'} \ \wedge \  \GRelevant o {\sigma'} \ \wedge \ o\in dom(\sigma) \ \ \Longrightarrow \ \  \GRelevant o {\sigma}$
\item
\sdOct{TODO: finish\\
$\sigma'$ is $\sigma$ right after a method has been called  $\wedge \  \LRelevant o {\sigma'}  \ \ \Longrightarrow \ \  \LRelevant o {\sigma}$
}
\end{enumerate}
\end{lemma}

 
 \begin{figure}[htb]
\begin{tabular}{|c|c|c|}
\hline \\
\resizebox{3.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/heap.png}
} 
&
\resizebox{5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/locReachA.png}
} 
&
\resizebox{5cm}{!}{
\includegraphics[width=\linewidth]{diagrams//locReachb.png}
} 
\\
\hline
 a heap
&
Locally Reachable from $\phi_1$
&
Locally Reachable from $\phi_2$
\\
\hline \hline
\end{tabular}
   \caption{A heap, and locally Reachable Objects from $\phi_1$ and $\phi_2$ }
   \label{fig:LReachable}
 \end{figure}

  \subsection{Execution and Bounded Execution}
 
\sdN{In appendix ??? we % 
define execution 
of \Loo\footnote{check whether it is Tool, or Loo, or what}; it is a small steps semantics of the shape $\leadstoOrig  {M} {\sigma_1}   {\sigma_2}$. As %we have 
 already discussed,  states (here $\sigma_1$, $\sigma_2$),  consist of a sequence of frames and of a  heap. The semantics is un-surprising. In particular, the code to be executed by a method call is kept in a continuation within the frame for that call. When a method is called, a new frame is pushed on to the stack ; this frame  maps \prg{this} and the formal parameters to  the values for the receiver and other arguments, and the continuation to the body of the method.  When the continuation is final\footnote{TODO check and define}, the frame is popped and the value from the last frame's continuation is entered into the caller's continuation.}
%In other aspects, the semantics is un-surprisring.%we return from that call, its frame is  popped, and execution continues in the context of the calling method.

\sdN{
  \begin{definition}[Execution]
\label{def:deep}
The relation  $\leadstoOrig  {M} {\sigma_1}   {\sigma_2}$ is defined  in appendix ... The relation $\leadstoOrigStar  {M} {\_}   {\_}$  is the reflexive, transitive closure of $\leadstoOrig  {M} {\_}   {\_}$ .
\end{definition}
}

\sdN{Fig. \ref{fig:UpSemantics}   such  execution steps: %small-step operational semantics steps:  
black disks indicate states;
%, $\sigma_6$, $\sigma_7$ ... $\sigma_{20}$;  
 horizontal $\leadsto$-arrows denote   steps  within the same  call; upwards arrows denote  method calls (pushing a new frame onto the stack);  downwards arrows denote method returns (popping the top of the stack). Here,   $\leadstoOrig M {\sigma_8}   {\sigma_9} $ is a step within the same call, $\leadstoOrig M {\sigma_9}   {\sigma_{10}} $ is a method call  %(say a call to $m_a$), 
with $\leadstoOrig M {\sigma_{12}}   {\sigma_{13}} $ %is a method return  (from the call to $m_a$), 
the corresponding return. %, while  $\leadstoOrig M {\sigma_{16}}   {\sigma_{17}} $ is another  method call  %(say a call to $m_b$),  and 
%with $\leadstoOrig M {\sigma_{18}}   {\sigma_{19} }$ the corresponding return.
}
%is another  method call  (from the call to $m_b$).}
% for example  we depict a case where we are executing a method (say $m_a$), which eventually calls another method (say $m_b$), and which in tis turn calls a further method (say $m_c$): We start at $\sigma_1$ and in one step we reach $\sigma_2$, which is a method  call  to $m_b$. 
%This leads to state $\sigma_3$, and after another step we reach $\sigma_5$, which is a method call to $m_c$, 
%leading to state $\sigma_5$ and $\sigma_6$. 
%The latter is the return, leading to $\sigma_7$, which again, is a return, leading to $\sigma_8$.}

\begin{figure}[htb]
\begin{tabular}{|c|}
\hline \\
\resizebox{8cm}{!}{
\includegraphics[width=\linewidth]{diagrams/bounded.png}
%\includegraphics[width=\linewidth]{diagrams/up1.png}

} 
\\
\hline
\begin{tabular}{l|l}
\ \ \ \ \ \ \  \ \ \ \ \ \ \  \ \ \ \ \ Execution \ \ \ \  &  \ \ \ \ \ \ \  \ \ \ \ \ \ \   \ \ \ \ \  Bounded Execution \ \ \ \  \\
\hline \\
 $\leadstoOrig  M  {\sigma_8}    {\sigma_9} $ \ \ \ \ \ \ \ \  \ $\leadstoOrig  M  {\sigma_9}    {\sigma_{10}} $ & 
%Bound
\ \ \  $\leadstoBounded  M  {\sigma_8} {\sigma_8}  {\sigma_9} $ \ \ \ \ \ \ \ \  \ $\leadstoBounded  M  {\sigma_9} {\sigma_8}  {\sigma_{10}} $
\\
$\leadstoOrig  M  {\sigma_{12}}   {\sigma_{13}} $ \ \ \ \ \ \ \  $\leadstoOrig  M  {\sigma_{13}}    {\sigma_{14}} $  & 
%Bound
\ \ \  $\leadstoBounded  M  {\sigma_{12}} {\sigma_8}  {\sigma_{13}} $ \ \ \ \ \ \ \  $\leadstoBounded  M  {\sigma_{13}}  {\sigma_{8}}  {\sigma_{14}} $ 
\\ 
%ORIG
$\leadstoOrig M {\sigma_{14}}   {\sigma_{15}} $  \ \ \ \ \ \ \  
\ \ \ \ \ \ \  \ \ \ & \ \ \ 
%BOUND
$\notLeadstoBounded  M  {\sigma_{14}} {\sigma_8}  {\sigma_{15}} $
\end{tabular}
\\
\hline
\end{tabular}
   \caption{Ilustrating
    Def. \ref{def:deep}  and \ref{def:shallow:term})%
    }
   \label{fig:UpSemantics}
 \end{figure}
 
\sdN{Note that $\leadstoOrig M {\sigma_{8}}   {\sigma_{9}} $ and $\leadstoOrig M {\sigma_{13}}   {\sigma_{14}} $ are steps within the same call, but 
$\leadstoOrig M {\sigma_{13}}   {\sigma_{14}} $ and $\leadstoOrig M {\sigma_{17}}   {\sigma_{18}} $ are not. %steps within the same call,
% even though all four states ($\sigma_{13}$, $\sigma_{14}$, $\sigma_{17}$, and $\sigma_{18}$), have the same number of frames on their stack.
We want a semantics to reflect whether execution steps happen within the bounds of certain call. For this, we define \emph{bounded execution}, 
$\leadstoBounded {M} {\sigma} {\sigma''} {\sigma'}$ 
which are execution steps which lead from $\sigma$ to $\sigma'$ while not popping  $\sigma''$-s top frame.
Formally,
}

{
\begin{definition}[Bounded Executions]
\label{def:shallow:term}
We define the relation  $\leadstoBounded {M} {\sigma_1} {\sigma} {\sigma_2}$ 

\begin{itemize}
\item
 $\leadstoBounded {M} {\sigma_1} {\sigma} {\sigma_2}$ \ \ \ iff \ \ \  $\leadstoOrig {M} {\sigma_1} {\sigma} {\sigma_2}$\\
$\strut  \hspace{3cm} \wedge $\\
$\strut  \hspace{2.7cm}\ \    \exists \phi,\psi, \phi_1, \phi2.[ \ \sigma = (\phi\cdot\psi,\_) \ \wedge \ \sigma_1 = (\psi_1\cdot \psi, \_)
\ \wedge\ \sigma_2 = (\psi_2\cdot \psi, \_)\ ] $ 
\item
 $\leadstoBoundedStar {M} {\_} {\sigma} {\_}$ is the reflexive, transitive closure of $\leadstoBounded {M} {\_} {\sigma} {\_}$.
\end{itemize}
\end{definition}
}
 
 \sdN{Continuing our discussion of Fig. \ref{fig:UpSemantics}, notice that $\leadstoOrig {M} {\sigma_{14}}  {\sigma_{15}}$ 
 but not  $\notLeadstoBounded  {M}  {\sigma_{14}} {\sigma_8} {\sigma_{15}}$, because this step  returns from $\sigma_8$'s
 top frame. 
Therefore, 
 $\leadstoOrigStar {M} {\sigma_8}  {\sigma_{15}}$ 
 but  $\notLeadstoBoundedStar {M} {\sigma_8} {\sigma_8} {\sigma_{15}}$, and also
  $\leadstoOrigStar {M} {\sigma_8}  {\sigma_{18}}$ 
 but  $\notLeadstoBoundedStar {M} {\sigma_8} {\sigma_8} {\sigma_{18}}$  -- the latter reflects that $\sigma_8$ and $\sigma_{18}$ beiong to different calls. 
}
 
\subsubsection{{Reachable  Objects and Shallow Semantics}}


The lemma below is the counterpart to lemma \ref{lemma:relevant} --  with the difference that  \ref{lemma:relevant:after:bounded} has the  stronger  premise  , as it requires bounded executions. 

\begin{lemma}
\label{lemma:relevant:after:bounded}
For all states $\sigma$, $\sigma'$, and $\sigma''$,for all objects $o$, and for all modules  $M$:
\begin{itemize}
\item
${\leadstoBoundedStar {M}  {\sigma} {\sigma''} {\sigma'}} \ \ \wedge \ \  \GRelevant o {\sigma'} \ \ \wedge\ \ o\in dom(\sigma)\ \ \ \Longrightarrow \ \  \ \GRelevant o {\sigma}$.
\item
${\leadstoBoundedStar {M}  {\sigma}  {\sigma} {\sigma'}} \ \ \wedge \ \   \LRelevant o {\sigma'}\  \ \wedge\ \ o\in dom(\sigma)\ \ \ \Longrightarrow \ \ \ \LRelevant o {\sigma}$.
\end{itemize}
\end{lemma}

\sdN{Consider Fig.  \ref{fig:UpSemantics}, the lemma above promises that any objects locally reachable in $\sigma_{14}$ which already existed in $\sigma_{8}$, were locally accessible in $\sigma_{8}$. However, the lemma is only  applicable to bounded execution, and as 
$\notLeadstoBoundedStar {M} {\sigma_8} {\sigma_8} {\sigma_{17}}$, 
the lemma does not promise that  objects locally reachable in $\sigma_{17}$ which already existed in $\sigma_{8}$, were locally accessible in $\sigma_{8}$ -- namely it could be hat object are made globally reachable during the step from $\sigma_{15}$ to $\sigma_{16}$.}




\section{\AssertLang -- the assertion language}
\label{sub:SpecO}

Our assertions language, \AssertLang, extends a 
 basic assertion language   with
object-capability assertions. 


\subsection{Syntax of \AssertLang}
The syntax of \AssertLang   is given in
Definition \ref{f:chainmail-syntax}.
An assertion may be an expression,   a query of the defining class of
  an object, the usual connectives and quantifiers, along 
with two non-standard assertion forms:
(1) \emph{Internal/external} and (2) \emph{Protection}, inspired by the capabilities literature, and
\footnote{TODO say how these relate with capability lit;  compare with 
 OOPSLA.}


\begin{definition}
Assertions ($A$) in
\AssertLang are defined as follows:

\label{f:chainmail-syntax}
 \[
\begin{syntax}
\syntaxElement{A}{}
		{
		\syntaxline
				{{\re}}
				{{\re} : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x:C}{A}}
				{\ex{x:C}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\internal{{\re}}}
				{\external{{\re}}}
				{\protectedFrom{{\re}} {{\re}}} 
				 {\inside {{\re}}} 
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\end{definition}

\textbf{NOTE}  Addresses may appear in assertions; this allows  assertions like $\alpha.bal > 700$, but note that universal quantification over addresses  (eg $\forall \alpha:C.[A]$) is not supported; however, we obtain the same effect through quantification over variables (eg  $\forall x:C.[A]$). Noter also that our universal quantification goes only over reachable objects, while other systems, eg Dafny quantify over allocated addresses.\footnote{example where this distinction would matter/}
\footnote{{\textbf{NOTE for us} It also allows assertions like $a1.passwd \neq a2.passwd$, whereas in the past we would have written as
$\exists x,y.[\ a1.passwd=x \wedge  a2.passwd=y \wedge x\neq y\ ]$.}} \footnote{{TODO compare with oopsla }}

\begin{definition}[Satisfaction 
of Assertions by module and  state] 
\label{def:chainmail-semantics-all}
of Assertions by module and  state] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a % program 
state $\sigma$ with 
 module $M$ by cases on the shape of $A$, in definitions \ref{def:chainmail-semantics}, \ref{def:chainmail-protection-from}, and 
 \ref{def:chainmail-protection}
\end{definition}

TODO: say why we split the def into three defs. 

\subsection{Semantics of \AssertLang -- first part}

% An illustration of the concept of reachable appears in the next subsection, in Fig. \ref{fig:Relevant}.
We   use the evaluation relation, $\eval{M}{\sigma}{e}{v}$,
which says that the expression $e$ evaluates
to value $v$ in the context of state $\sigma$ and module $M$.
As expressions in \LangOO may be recursively defined, their evaluation 
need not   % may not necessarily 
 terminate. Nevertheless, the logic of $A$ remains classical because recursion is restricted
to expressions, and not generally to assertions.
\footnote{
The semantics of $\hookrightarrow$ {is} unsurprising 
(see {the appendices %of the full paper 
\cite{necessityFull}).}
We have taken this approach from \citeasnoun{FASE}, which also contains a mechanized Coq proof that assertions are classical \cite{coqFASE}. } %Fig.\ref{f:evaluation}).


\begin{definition}[Satisfaction 
of Assertions -- first part] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a % program 
state $\sigma$ with 
 module $M$ as:
\begin{enumerate}
\item
\label{cExpr}
$\satisfiesA{M}{\sigma}{{\re}}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{{\re}}{\true}$
\item
\label{cClass}
$\satisfiesA{M}{\sigma}{{{\re}} : C}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{{\re}}{\alpha}\   \wedge \ \class{\alpha} {\sigma}= C$
\item
$\satisfiesA{M}{\sigma}{\neg A}$ \ \ \ iff \ \ \  ${M},{\sigma}\nvDash{A}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \wedge\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1} \   \wedge \ \satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \vee\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}\   \vee \ \satisfiesA{M}{\sigma}{A_2}$

\item
\label{quant1}
$\satisfiesA{M}{\sigma}{\all{x:C}{A}}$ \ \ \ iff \ \ \  
 {$\forall \alpha.[\ \GRelevant \alpha \sigma \wedge  \satisfiesA {M}{\sigma} {\alpha:C}  \ \Longrightarrow   \ \satisfiesA{M}{\sigma} {A[x/\alpha]}\ ]$.} 

\item
\label{quant2}
$\satisfiesA{M}{\sigma}{\ex{x:C}{A}}$ \ \ \ iff \ \ \  
 {$\exists \alpha.[\ \GRelevant \alpha \sigma \wedge  \satisfiesA {M}{\sigma} {\alpha:C}  \ \wedge \ \satisfiesA{M}{\sigma} {A[x/\alpha]}\ ]$.} 
\item
\label{cInternal}
$\satisfiesA{M}{\sigma}{\internal{{\re}}}$ \ \ \ iff \ \ \   $\satisfiesA{M}{\sigma}{{{\re}} : C} \ \wedge\ \ C \in M$
\item
\label{cExternal}
$\satisfiesA{M}{\sigma}{\external{{\re}}}$ \ \ \ iff \ \ \   $\satisfiesA{M}{\sigma}{{{\re}} : C} \ \wedge \ C \notin M$
\end{enumerate}
\end{definition}

\textbf{Notes:}  We use the $\Longrightarrow$ symbol in our meta-language to denote implication while $\rightarrow$ is part of Chainmail syntax.
\footnote{{TODO: explain that$x$ is fresh in $\sigma$  means that $x$ is not in the domain of the top frame, nor in the top continuation of $\sigma$.
 Note, the assumption $x$ is fresh in $\sigma$ has to be justified. Barendregt convention? Or say how we rename if $x$ is not free.}}
\footnote{{TODO: say that any assertion $A(e)$ can be understood as a shorthand for $\exists x. [ x=e \wedge A(x)]$. or  $forall x. [ x=e \rightarrow A(x)]$?? For example, the  assertion   ${\internal{e}}$ is a shorthand for $\exists x. [ x=e \wedge {\internal{x}}]$. QUESTION: do we need to talk about $=$ in the assertion language?}}
In most cases, satisfaction of an assertion not only depends on the state $\sigma$, but 
in some cases it also depends on the module: namely execution of expressions (\ref{cExpr}) might need to look up the definition of ghost fields  in $M$, while 
for internal or external provenance (\ref{cInternal} and \ref{cExternal}) we need to know all the classes defined in $M$.

{\textbf{NOTE}  that the term $\re$ may mention ghost fields, but the paths $\alpha.f_1....f_n$ may not. We see that because the latter are interpreted in $\sigma$. That is, $\satisfiesA{M}{\sigma}{{\alpha_o.f_1...f_n}=\alpha}$ is weaker than $\interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha$. TODO: write the latter as a lemma}


\subsection{Semantics of Assertions - second part:
  Protection}\footnote{Can we think of a better name than protection? \kjx{encapsulation}}

As we already discussed in the introduction\footnote{make sure we do discuss there}, in the object capabilities world permission (ie access  \footnote{cite MarkMiller thesis, and our Permission and Authority revisited} to a capability is a necessary precondition to some effect. Motto "authority implies eventual permission".
In our work, we express this as "lack of eventual permission to the relevant capability implies that the given effect will never take place".
For this, we need the concept of "lack of  eventual permission".  

\sdN{
We define this lack of \sdN{eventual} permission as "protected".  
An object $o$ is \emph{protected  from} another, external, object $o'$, if $o'$ can obtain direct access to   $o$ only if 
$o$ is ``introduced'' to some external object (not necessarily $o'$, but external) by some internal object $o''$.  Here we use ``introduce'' in the Mark Miller sense, whereby $o_1$ is is ``introduced'' to $o_2$ by $o_3$, iff either $o_3$ sends to $o_2$ a message containing $o_1$, 
or $o_2$ made a call to $o_3$, and $o_3$ eventually returns  $o_1$ as the result of the call.
} 

\sdN{The motivation for protection comes from considering eventual executions, but this condition is less practical. Instead, we can obtain sufficient conditions just by observing the heap. In the definition below, we say that $o$ is protected from $o'$ if the last object on any path from $o'$ to $o$ is internal. 
% that is the old definition: An object $o$ is protected from another, external, object $o'$, if $o'$ can obtain   $o$ only if 
%some internal object is involved in giving access to $o$. In other words, $o$ cannot become reachable to $o'$ unless a method is executed on
%some internal object. That is, $o$ is protected from $o'$ if any path from $o'$ to $o$ goes through at least one internal object.}
}

\begin{definition}[Satisfaction 
of Assertions by module and  state -- continued; Protection] 
\label{def:chainmail-protection-from}
We continue the definitions in \ref{def:chainmail-semantics}, and define   
\begin{enumerate}
\item
\label{cProtected}
 $\satisfiesA{M}{\sigma}{\protectedFrom{{\alpha}} {{\alpha_{o}}}}$  \ \ \ iff  
 \begin{itemize}
 \item
 $\satisfiesA{M} {\sigma} {\internal{\alpha_0}}$
 \\
 or
 \item
$\forall n\in\mathbb{N}. \forall f_1,...f_n.$\\
$
[\ \ \interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha \ \ \  \Longrightarrow \ \ \ \satisfiesA{M} {\sigma} {\internal{{\interpret{\sigma}{\alpha_{o}.f_1...f_{n-1}}}}}\ \ ]$
\end{itemize}
\item
$\satisfiesA{M}{\sigma}{\protectedFrom{{\re}} {{\re_{o}}}}$  \ \ \ iff \\
  $\exists \alpha, \alpha_{o}. [\  \ \eval{M}{\sigma}{{\re}}{\alpha}\ \wedge \eval{M}{\sigma}{{\re_0}}{\alpha_0} \  \wedge \ 
  \satisfiesA{M}{\sigma}{\protectedFrom{{\alpha}} {{\alpha_{o}}}}
 \ \  ]$
 \end{enumerate}
 \end{definition}\footnote{Do we need that $\alpha \neq \alpha_{o}$?}

\vspace{.5cm}

 


\footnote{JAMES' comment: If is possible that "we" do not know the complete heap (eg we only know about the green stuff.) how do we know whether an object is protected. The answer is that we do not know that it is protected, but we do know that our code guarnartees poreservation of protectedness.
%Nevertheless, if the objecta are "riobust" then we can prove that some properties will be preserved. 
}
\footnote{
OLD COMMENTS: ${\inside {\_}}$  is central to thinking about capabilities. For example, the balance of an account whose
  password is  encapsulated/protected?  will not decrease in the next step.
  Often, API implementations contain objects whose capabilities, while  crucial for the implementation, if exposed,
would break the intended guarantees of the API. Such objects need to remain confined - see
such an example in Section \ref{s:examples}. 
}
\footnote{{\textbf{TODO} make the connection with domination}}

Figure \ref{fig:ProtectedFrom} illustrates the concept of an object being protected from another object. All the pink objects are external, and the green objects are internal. The left pane shows the objects that are protected from $o_5$\footnote{QUESTION: should we write $5$ or $o_5$?}, the middle pane shows the objects protected from $o_7$, and the right pane shows the objects protected from $o_2$. We highlight the protected objects in yellow. Thus, all objects except $o_6$ are protected from $o_5$;\ all objects expect $o_8$ are protected from $o_7$;\ and all objects except $o_3$, $o_6$, $o_7$, and $o_8$ are protected from $o_2$. 


\begin{figure}[htb]
\begin{tabular}{|c|c|c|}
\hline \\
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prfA.png}
} 
&
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prfB.png}
} 
&
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prfC.png}
} 
\\
\hline
protected from $o_5$
&
protected from $o_7$
&
protected from $o_2$
\\
\hline \hline
\end{tabular}
   \caption{Protected From }
   \label{fig:ProtectedFrom}
 \end{figure}
 
 

Note that $o_8$ is not protected from $o_2$ because there is a path from $o_2$ to $0_8$ which only traverses external objects. Note also, that even though $o_9$ is external, it is protected from $o_7$.
Finally, note that $o_6$ is not protected from $o_2$. 
Namely, even through there are some internal objects on the path from $o_2$ to $o_6$, in our current model, these objects are not sufficient to prevent eventual, unmitigated access of $o_2$ to $o_6$: it is possible for $o_2$ to make a call to $o_3$, and then this call to return $o_5$. Once $o_2$ has access to $o_5$, it can also get access to $o_6$. 


\vspace{.1in}

We now introduce the concept of an object being protected.
An object is protected, if it is protected from all locally reachable objects. This could also be understood as 
"an object is protected from the top frame". \footnote{TODO: motivate; many external objects, no matter which one has unprotected access to an object }
 
\begin{definition}[Satisfaction 
of Assertions by module and  state  continued -- Protection] 
\label{def:chainmail-protection}
We continue the definitions in \ref{def:chainmail-semantics}, \ref{def:chainmail-protectionFrom } and  define   
\begin{enumerate}
\item
$\satisfiesA{M}{\sigma} {\inside {\re}}$  \ \ \ iff \ \ \ 
\begin{enumerate}
\item
{$\forall \alpha.[ \  \LRelevant {\alpha}  {\sigma}\ \Longrightarrow \ \  \satisfiesA{M}{\sigma}{\protectedFrom{\re} {{\alpha}}}\ ] $}, \ \ \ and 
\item
$\satisfiesA{M}{\sigma}{\external{\prg{this}}}\ \ \Longrightarrow\ \ \forall x\in dom(\sigma.TOPFRAME).\satisfiesA{M}{\sigma}{x\neq \re}$
\end{enumerate}
\end{enumerate}
\end{definition}\footnote{define TOPFRAME}
 
% TODO explain
  Figure \ref{fig:Protected} illustrates the concept of protection. The heap in all three panes is the same as that from  Fig \ref{fig:LReachable}, and 
 ans Fig \ref{fig:ProtectedFrom}. In the left pane the top frame is $\phi_1$; it has  one variable: \prg{this} points to $o_2$. In the middle pane the top frame is $\phi_2$; it has two  variables:   \prg{this} points to $o_3$ and \prg{x} points to $o_7$. In the right pane  the top frame is $\phi_3$; it has two  variables:   \prg{this} points to $o_7$ and \prg{x} points to $o_3$.  

\begin{figure}[htb]
\begin{tabular}{|c|c|c|}
\hline \\
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prtFirst.png}
} 
&
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prtSecond.png}
} 
&
\resizebox{4.5cm}{!}{
\includegraphics[width=\linewidth]{diagrams/prtLast.png}
} 
\\
\hline
protected  with top frame $\phi_1$ &
protected  with top frame $\phi_2$
&
protected  with top frame $\phi_3$
\\
\hline \hline

\end{tabular}
   \caption{Protected \\
 }
   \label{fig:Protected}
 \end{figure}
 
 
The locally reachable objects from $\phi_1$ were highlighted in the middle pane of.Fig \ref{fig:LReachable}, while the locally reachable object from $phi_2$ as well as from $\phi_3$ were  highlighted in the right pane of that Figure. 
We highlight the protected objects in each pane with a golden hallo.
 Note that $o_3$ is protected from $\phi_2$, but is not protected from $\phi_3$. This is so, because \prg{this} in $\phi_3$ is external, and  $o_3$ is an argument to the call. That means, that during the call, $o_7$ may obtain unmitigated access (permission?) to $o_3$. 
 
Under some circumstances, "relative protection" ($o$ is protected from $o'$) implies absolute protection ($o$ is proetcted).
The lemma below says that if we make a method call, and if an object $o$ is protected from  the receiver and arguments of that method call, then in the context of this method call, $o$ is proected.
%$\oveline z$,  \textbf{TODO: praise the lemma below}
 
 
 
 \begin{lemma}
 \label{lemma:rel:abs:prot}
 For any $m$, $\sigma$, $\sigma'$, $\overline z$, and $\alpha$. If $\sigma'$ is the result of pushing $\overline z$ onto the stack frame of $\sigma$,  %\footnote{to define that}, 
 then
 \begin{itemize}
 \item
  $\forall i\in 0..n.[\ \ \satisfiesA{M}{\sigma}{\protectedFrom {\alpha} {z_i} }  \ \ \wedge\ \ 
 [ \  \satisfiesA{M}{\sigma}{\external {z_o}} \ \Longrightarrow\   \satisfiesA{M}{\sigma} {z_i \neq {\alpha}}\ ] \ \  ] $
  \\
% old version, equivalant 
% $\forall i\in 0..n.[\ \satisfiesA{M}{\sigma}{\protectedFrom {\alpha} {z_i} }\ ] \ \ \wedge\ \ 
% [ \  \satisfiesA{M}{\sigma}{\external {z_o}} \ \Longrightarrow\  \forall i\in 0..n.(\ \satisfiesA{M}{\sigma} {z_i} {\alpha}\ )\  \  ] $ \\
  $ \Longrightarrow$ \\
   $ \satisfiesA {M} {\sigma'} {\inside {\alpha}}$
 \end{itemize}
\end{lemma}
 
 \subsection{Discussion of the semantics of assertions}
 
 {Both existential and universal quantification (defined in \ref{quant1} and \ref{quant2}) is done over all objects which are transitively 
accessible any frame in the stack (as in OOPSLA). But note that $\satisfiesA{M}{\sigma} {\inside {y}}$ only considers objects that are locally reachable ..

We do not include quantification over primitive types such as integers as \LangOO is too simple. The 
Coq mechanisation does include primitive types.}
\footnote{TODO: Do we prove the implications as in TACAS, or just rely on TACAS? -- perhaps the former, since we have some new primitives? hmhh}

\subsubsection{Alternative Definition of Protection}

We could have given a weaker definition of protection, which would require that $o$ is protected from $o'$ if $o'$ can obtain direct access to $o$ only if some internal object executes a method. 
The projection of this weaker definition into the heap structure is as below


$\satisfiesA{M}{\sigma}{ {\alpha\ }\textbf{weakPrtFrom}\ {\alpha_o} }$  \ \ \ iff \\
\begin{itemize}
\item $\satisfiesA{M}{\sigma}{\internal{\alpha_0}}$, \\ or
\item 
$\forall n\in\mathbb{N}. \forall f_1,...f_n.$\\
$
[\ \ \interpret{\sigma}{\alpha_{o}.f_1...f_n}=\alpha \ \ \  \Longrightarrow \ \ \ \exists k<n. \satisfiesA{M} {\sigma} {\internal{{\interpret{\sigma}{\alpha_{o}.f_1...f_{k}}}}}\ \ ]$
\end{itemize}


With this, weaker, definition, in Fig. \ref{fig:ProtectedFrom}, object $6$ would be weakly-protected from $2$. Namely,  here 
for $2$  to get access to $6$ it suffices for $3$ to introduce $5$ to $2$, and does not require that some internal object introduces $6$ to some external object\footnote{TODO? Hmhh This would have been clearer if there was also a field pointing from 3 to 5}.

Note however that this alternative definition does not satisfy Lemma \ref{lemma:rel:abs:prot}. For a counterexample,   consider pushing onto the frame $\phi_1$ from Fig. \ref{fig:ProtectedFrom}, a frame $\phi_4$ where $\phi_4(\prg{this})$=$2$. Then, Lemma
\ref{lemma:rel:abs:prot} would promise that $6$ is protected from that frame, even though it is not.

\section{Specifications}

\noindent
The syntax of  \SpecLang specifications is given below
 
\begin{definition}  

\noindent
{\emph{{Syntax of \SpecLang Specifications}}}

\label{f:holistic-syntax}
\[
\begin{syntax}
\syntaxElement{S}{}
		  {\syntaxline
                               {\OneStateQ {\overline {x:C}} {A} }	
				{\TwoStatesQ {\overline {x:C}} {A} {A} }	
				{S\, \wedge \, S}
		 \endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\end{definition}

\footnote{TODO motivate the rest}
\subsubsection{Arising States and {Arising} External States}

{TODO: here perhaps more motivation for external?\footnote{Here what we had: As discussed in \S \ref{s:approach}, 
{open world specifications need to be able to provide}
guarantees which hold
during execution of an internal, 
known, trusted module $M$ when linked together with any
unknown, untrusted, module $M_{ext}$. These guarantees need only hold 
when the external module is executing; we are not concerned if they are
temporarily broken by the internal module. Therefore, we are only interested in states where the
executing object (\prg{this}) is an external object. 
To express our focus on external states, we define the  \emph{external states semantics}, of the form 
$\reduction{M_{ext}}{M}{\sigma}{\sigma'}$, where $M_{ext}$ is the external
module, and $M$ is the internal module, and where we
collapse all internal steps into one single step.
}}
{A state $\sigma$ is \emph{arising},}  written $\arising{\sigma}{M}$, {if it  may arise}  % by observable states} 
by execution
starting at some initial configuration:


\begin{definition}[Arising  States]
\label{def:arising}
For modules $M$ and $M_{ext}$ we define arising and arising external states as follows:

\begin{itemize}
\item
 a state $\sigma$ is 
{ an \emph{arising} state, formally \ \ \  $\arising{\sigma}{M}$,\ \ \ 
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$M, {\sigma_0} \leadsto^* {\sigma}$.}
\item
{A a state $\sigma$ is 
called an \emph{arising} state, formally\ \ \ \  $\extArising{\sigma}{M_{ext}}{M}$,\ \ \ \
if and only if $\arising{\sigma}{M_{ext}*M}$ and $M, \sigma \models \external{\prg{this}}$.}
\end{itemize}
\end{definition}


An \emph{Initial} state's heap contains a single object of class \prg{Object}, and
its  stack   consists of a single frame, whose local variable map is a
mapping from \prg{this} to the single object, and whose continuation is  any statement.
(See Definition %s \ref{def:initial} and 
\ref{def:arising} and the 
{appendices %of the full paper 
\cite{necessityFull}).}


 
 \subsubsection{ Semantics of \SpecLang Specifications}
We now  define what it means for  a module  $M$ to satisfy specification  $S$, written as $M \vDash S$. The
 
\begin{definition}% [Semantics of \SpecLang Specifications]

We define $\satisfies{M}{{S}}$ by cases over the three possible syntactic forms.
For any assertions   $A_1$, $A_2$, and $A$: \\

\label{def:necessity-semantics}

\begin{tabular}{l l c l }

$\bullet$ & $\satisfies{M}{\OneStateQ {\overline {x:C}} {A} 	}$& iff & 
for all $M_{ext}$, $\sigma$, $\overline{x}$, such that $\overline{x}$  are free in $\sigma$, \\
  & & & $ \extArising{\sigma}{M_{ext}}{M}$ % \ \wedge 
$ \ \Longrightarrow \  $  % \\ & & &  $ \satisfiesA{M}{\sigma[\overline{x\mapsto o}]}{A} $
{$ \satisfiesA{M}{\sigma}{\forall \overline{x:C}.A}$}\footnote{{This means that we require all objects to satisfy even if not locally relevant}}
\\
\\
$\bullet$ & $\satisfies{M}{\TwoStatesQ {\overline {x:C}} {A}{A'}}$& iff & 
for all $M_{ext}$, $\sigma$, $\overline{x}$, $\overline{o}$ such that $\overline{x}$  are free in $\sigma$  \\
& & &
${\extArising{\sigma}{M_{ext}}{M}} \ \wedge\  \GRelevant {\overline o}  \sigma \wedge \ $\footnote{{notice that we are asking for globally relevant objects}}\\
& & & $ \satisfiesA{M}{\sigma[\overline{x\mapsto o}]}{\overline {x:C}}  \ \ \wedge\ \  \satisfiesA{M}{\sigma[\overline{x\mapsto o}]}{A} \ \ \wedge$ \\ 
& & &
$\red{\leadstoBoundedStar {M_{ext}\!\circ \!M}{\sigma}{\sigma} {\sigma'} } \ \ \wedge\ \  M, \sigma' \models {\external{\prg{this}}}$ \\
& & & $ \Longrightarrow $ \\
& & & $ \satisfiesA{M}{\sigma'[\overline{x\mapsto o}]}{A'} $
\\
\\
$\bullet$ &  $\satisfies{M}{S\, \wedge\, S'}$ &   iff   & $\satisfies{M}{S}\ \wedge \ \satisfies{M}{S'}$
\end{tabular} 

 
\end{definition} 


  
\footnote{{TODO: Make an example that demonstrates the difference if in the second bullet we had asked for locally relevant objects ${\overline o}$.}}
\footnote{{TODO Notice that we assume that $\overline x$ are not free in $A$ -- cf Barendregt convention.}}
\footnote{TODO: explain why we did not require the stronger $\leadstoFin{M_{ext}\!\circ \!M}{\sigma}{\sigma'}$ rather than $\leadstoBoundedStar {M_{ext}\!\circ \!M}{\sigma}{\sigma} {\sigma'}$.}
% Note that the requirements that $\extArising{\sigma}{M_{ext}}{M}$ and $\leadstoFin{M_{ext}\circ M}{\sigma}{\sigma'} $ imply that
% $M, \sigma' \models {\external{\prg{this}}}$



{We demonstrate the meaning of ${\TwoStatesQ {\overline {x:C}} {A_0}{A_0}}$ in Fig. where we assume that the pink state, \ie   ${\sigma_6}$-${\sigma_9}$ and $\sigma_{13}$-$\sigma_{20}$, are external, and the green states, \ie   ${\sigma_{10}}$, 
 ${\sigma_{11}}$,  and ${\sigma_{12}}$, are internal.}
 
 \begin{figure}[htb]
\begin{tabular}{|c|}
\hline \\
\resizebox{8cm}{!}{
\includegraphics[width=\linewidth]{diagrams/preserves.png}, 
} 
\\
\hline
\\
\begin{tabular}{lclclcl} 
$ {\sigma_6} \leadsto^*  \sigma_9 $ preserves $A_0$ & &
$ {\sigma_6} \leadsto^*  \sigma_{10} $ does not preserve $A_0$ \\
$ {\sigma_8} \leadsto^*  \sigma_{14} $ preserves $A_0$ & &
$ {\sigma_8} \leadsto^* \sigma_{17} $ does not preserve $A_0$\\
$ {\sigma_7} \leadsto^*  \sigma_{16} $  preserve $A_0$ & &
$ {\sigma_9} \leadsto^*  \sigma_{16} $ does not preserve $A_0$
\\
\hline
\end{tabular}
\end{tabular}
   \caption{Illustrating  the meaning on ${\TwoStatesQ {\overline {x:C}} {A_0}{A_0}}$    }
   \label{fig:TwoStateSemantics}
 \end{figure}
 
\subsection{Specification Examples}
\noindent
As an example, consider the following    specifications:

\begin{tabular}{lcll}
$S_1$   &     $\triangleq$   & $\OneStateQ{\prg{a}:\prg{Account} } {\inside{\prg{a}}} $
 \\
 $S_2$   &     $\triangleq$   & $\OneStateQ{\prg{a}:\prg{Account} } {\inside{\prg{a.password}}} $
 \\
 $S_3$   & $\triangleq$   &  $\TwoStatesQ {\prg{a}:\prg{Account}}  {\inside{\prg{a}}} {\inside{\prg{a}}} $
 \\
 $S_4$   & $\triangleq$   &  $\TwoStatesQ {\prg{a}:\prg{Account}}  {\inside{\prg{a.password}}} {\inside{\prg{a.password}}}$
 \\
$S_5$ & $\triangleq$   &
 $\forall \prg{a}:\prg{Account}.\forall \prg{b}:\prg{int}.$\\
  &  &  $\FirstState{\inside{\prg{a}} \wedge \prg{a.balance}=\prg{b}} 
\  \SecondState{ \prg{a.balance}= \prg{b} }$
\\
$S_6$ & $\triangleq$   &
  $\forall \prg{a}:\prg{Account}.\forall \prg{b}:\prg{int}.$\\
  &  &  $\FirstState{\inside{\prg{a.password}} \wedge \prg{a.balance}=\prg{b}} 
\  \SecondState{ \prg{a.balance}\geq \prg{b} }$
 \end{tabular}

\vspace{.2cm}
Now consider our modules from earlier. We have that

\begin{tabular}{lllllll}
$\ModA \not\models S_1$  & & $\ModA \not\models S_2$ &&  $\ModB \not\models S_1$ &  &$\ModB \not\models S_2$ \\
$\ModA \models S_3$ & &   $\ModA \models S_4$ & &  $\ModB  \models S_3$ & &  $\ModB  \not\models S_4$ \\
$\ModA \models S_5$ & &  $\ModA \models S_6$ & & $\ModB  \models S_5$ & & $\ModB   \not\models S_6$ \\
\end{tabular}

\vspace{.6cm}
Consider also  $S_{4a}$ which is a variation of $S_4$, as well as $S_7$, which ...

\begin{tabular}{lcll}
$S_{4a}$   &     $\triangleq$   &   ${\TwoStatesQ {\prg{a}:\prg{Account}.\prg{p}:\prg{Password}}  {\prg{p}=\prg{a.password} \wedge \inside{\prg{p}}}{\inside{\prg{p}}} }$
 \\
$S_7$ & $\triangleq$   & ${\TwoStatesQ {\prg{a}:\prg{Account}.\prg{p}:\prg{Password}}  {\prg{p}=\prg{a.password}} {\prg{p}=\prg{a.password}} }$
 \end{tabular}
 
 \noindent
 Fort these specifications
 
 \begin{tabular}{lllllll}
$\ModA  \models S_7$  & & $\ModB \not\models S_7$ &&  $\ModC \not\models S_7$ \\
\end{tabular}

\subsection{Tautological assertions, and Specification Implication}

\begin{definition}[Satisfaction of Assertions by a module] 
\label{def:assertion-inference-semantics}
We define satisfaction of an assertion $A$ by a  module $M$ as:
\begin{itemize}
\item
$M \vDash A$   \ \ \ iff \ \ \  $\forall M_{ext}. \forall \sigma.[\ \extArising{\sigma}{M_{ext}}{M} \ \Longrightarrow \ \ \satisfiesA{M}{\sigma}{e}\ \ ]$
\end{itemize}
\end{definition}

TODO: Here we will say that assertions are classical, as proven in FASE

\begin{definition}[Stronger Specifications] 
\label{def:specification-implication-semantics}
We define when a specification $S$ is stronger than another specification $S'$  in the context of a  module: 
 \begin{itemize}[itemsep=5pt]
\item 
$\stronger M  S  {S'}$   \ \ \ iff \ \ \  $M\models S$ implies $M \models S'$
\item
$\strongerEq M  S  {S'}$   \ \ \ iff \ \ \ $\stronger M  S  {S'}$  \ and \  $\stronger M   {S'} S$    
\end{itemize}
\end{definition}

We know about stronger specifications:

\begin{lemma}
Consider assertions $A$, $A'$, variable $y$ free in $A$, specifications $S$, $S'$, and module $M$:
\begin{itemize} [topsep=6pt,itemsep=5pt,parsep=0pt,partopsep=0pt]
\item
$\stronger M {\OneStateQ {\overline {x:C}}  {A}}  {\TwoStatesQ {\overline {x:C}} {A}{A}} $ 
    \item
 $\strongerEq  M  {\OneStateQ    {y:\prg{Object}}   {\forall \overline {x:C}[ A ] } } 
    {\OneStateQ {\overline {x:C}}  {A}} $.
\item
$  M  \models (  \overline {x:C} \wedge A) \rightarrow A'$ \ \ \  implies \ \  \ $\stronger M  {\OneStateQ {\overline {x:C}} {A}}    {\OneStateQ {\overline {x:C}} {A'}}$
\item
  \ $\stronger M  { \TwoStatesQ {y:\prg{Object}}  {\forall x:C.[A]} {\forall x:C.[A']} }    {\TwoStatesQ {\overline {x:C}} {A}{A'}} $

\item
$\stronger M  S {S''}$ and $\stronger M {S''} {S'}$\ \  implies \ \ $\stronger M S  {S'}$.
\end{itemize}

\end{lemma}



