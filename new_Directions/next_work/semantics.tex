\section{\SpecLang specifications}
\label{s:semantics}

 
In this section we define {the}  \SpecLang specification language.  
We first define an underlying programming language, \LangOO (\S \ref{sub:Loo}).
We then define an assertion language, \AssertLang, which can talk about the
contents of the state, as well as about protection (\S \ref{sub:SpecO}).  Finally, we define the syntax and
semantics of  \SpecLang
specifications (\S \ref{s:holistic-guarantees}).


\subsection{\LangOO -- the underlying object oriented programming languages}
\label{sub:Loo} 
%\jm[TODO: mention the type system and the restriction on external method calls]{}
%% We introduce a simple object-oriented language, \LangOO, upon 
%% which our specification language sits.
We repeat the def. of  \LangOO from oopsla. It is a {small}, imperative, sequential, 
class based, typed, object-oriented language, whose
fields are private to the class where they are defined. 
\LangOO is straightforward
{and the complete definition can be found in the appendices % of the full paper 
\cite{necessityFull}.}
 A \LangOO state $\sigma$ consists of a 
heap $\chi$, and a  {stack $\psi$ which is a sequence of frames}.
A frame $\phi$ consists of
local variable map, and a continuation, \ie a sequence of statements to be executed.
 A statement may assign to variables, create new objects and push them to the heap, 
perform field reads and writes on objects,  or
 call methods on those objects. 

%Program 
 Modules are mappings
from class names to class definitions. 
Execution 
%takes place
is in the context of  a module $M$ and   a state $\sigma$,
%It is % Execution
 defined via unsurprising small-step semantics of the form \ \ 
   $M, \sigma \leadsto \sigma'$.
The   top frame's continuation contains the statement to be % currently being 
executed next.
 % chopped, as generic 
 % There are several properties  of \LangOO that are important to the central topic of this paper. 
 
As discussed in \S \ref{s:approach}, %we are interested in 
{open world specifications need to be able to provide}
guarantees which hold
during execution of an internal, 
known, trusted module $M$ when linked together with any
unknown, untrusted, module $M_{ext}$. These guarantees need only hold 
when the external module is executing; we are not concerned if they are
temporarily broken by the internal module. Therefore, we are only interested in states where the
executing object (\prg{this}) is an external object. 
To express our focus on external states, we define the  \emph{external states semantics}, of the form 
$\reduction{M_{ext}}{M}{\sigma}{\sigma'}$, where $M_{ext}$ is the external
module, and $M$ is the internal module, and where we
collapse all internal steps into one single step.

 

\begin{definition}[External States Semantics]
\label{def:pair-reduce}
For  
% If we say "internal module", it is sounds as something makes the module be internal
  modules $M$,  $M_{ext}$, and % program
   states $\sigma$, $\sigma'$, 
we say that $\ \ \ \ \ \ \ \ \reduction{M_{ext}}{M}{\sigma}{\sigma'}\ \ \ \ \ \ \ \ $ if and only if there exist 
$n\in\mathbb{N}$, and states $\sigma_0$,...$\sigma_n$, such that
\begin{itemize}
\item
$\sigma$=$\sigma_1$, and  $\sigma'$=$\sigma_n$,
\item
$M_{ext} \circ M, \sigma_i \leadsto \sigma_{i+1}$  \ \ \ for all $i\in [0..n)$,
\item
$\class{\sigma}{\scd{\prg{this}}}, \class{\sigma'}{\scd{\prg{this}}}\in M_{ext}$,
\item
$\class{\sigma_i}{\scd{\prg{this}}} \in M$\ \ \ for all $i\in (1..n)$.
\end{itemize} 
\end{definition}
The function $\class{\sigma}{\_}$ is overloaded:
  applied to a variable, 
$\class{\sigma}{x}$  looks up the variable $x$ in the top frame of $\sigma$, and returns the 
class of the corresponding object in the  heap of $\sigma$;
%while  
applied to an address, $\class{\sigma}{\alpha}$  returns
the class of   the object referred by address $\alpha$ in the heap of $\sigma$.
 The module linking operator $\circ$, applied to two modules, $M_{ext}\circ M$, 
 combines the two modules into one module in the obvious way, provided their
domains are disjoint.
The details {can be found in the appendices\cite{necessityFull}.} %Appendix \ref{app:loo}.
\begin{figure}[htb]
\resizebox{\textwidth}{!}{
\input{diagrams/external_states}
}
   \caption{External States Semantics
     (Def. \ref{def:pair-reduce}),  %
     % 
     (A) $\exec{{\color{hotpink}M_{ext}} \circ {\color{lightseagreen}M}}{\sigma_1}{\ldots}\leadsto \sigma_9$ \ \ \ and \ \ \ 
     (B) $\reduction{{\color{hotpink}M_{ext}}}{{\color{lightseagreen}M}}{\sigma_2}{\ldots}\leadsto \sigma_9$, \ \ \ 
     \\
     where $\class{{\color{lightseagreen}\sigma_1}}{\scd{\prg{this}}}$,$\class{{\color{lightseagreen}\sigma_3}}{\scd{\prg{this}}}$,$\class{{\color{lightseagreen}\sigma_4}}{\scd{\prg{this}}}$,$\class{{\color{lightseagreen}\sigma_7}}{\scd{\prg{this}}}$,$\class{{\color{lightseagreen}\sigma_8}}{\scd{\prg{this}}}\in {\color{lightseagreen}M}$,\\
     and where $\class{{\color{hotpink}\sigma_2}}{\scd{\prg{this}}},\class{{\color{hotpink}\sigma_5}}{\scd{\prg{this}}} 
     \class{{\color{hotpink}\sigma_6}}{\scd{\prg{this}}},\class{{\color{hotpink}\sigma_9}}{\scd{\prg{this}}}\in {\color{hotpink}M_{ext}}$.
    %  (c) $\reduction{{\color{orange}M_{ext}}}{{\color{blue}M}}{\sigma_1}{\ldots}\leadsto \sigma_8$
    }
   \label{fig:VisibleStates}
 \end{figure}
 
Fig. \ref{fig:VisibleStates} inspired by \citeasnoun{FASE} provides a simple graphical description of 
our external states semantics: (A) is the ``normal'' execution after 
linking two modules into one: \ $M_{ext} \circ M, ... \leadsto ...$ whereas (B) is the
 external states execution when $M_{ext}$ is external,\   $\reduction{M_{ext}}{M}{...}{...}$.
Note that whether a module is external or internal depends on %our
perspective -- nothing in a module itself renders it internal or external. For example, in
 $\reduction{M_1}{M_2}{...}{...}$ the external module is $M_1$,
  while in  $\reduction{M_2}{M_1}{...}{...}$  the external module is $M_2$.

We  use the notation\ \  $\reductions{M_{ext}}{M}{\sigma}{\sigma'}$ \ 
to denote zero or more  steps starting at state $\sigma$ and ending at state $\sigma'$, in the context of internal module 
$M$ and external module $M_{ext}$.
 %Not only are we unconcerned 
%with internal states,  we are also unconcerned with  states which cannot ever arise from execution.
We are {not} concerned with internal states or states that can never arise.
{A state $\sigma$ is \emph{arising},}  written $\arising{M_{ext}}{M}{\sigma}$, {if it  may arise by external states} execution
starting at some initial configuration:



\begin{definition}[Arising  States]
\label{def:arising}
For   modules $M$ and  $M_{ext}$, a % program
 state $\sigma$ is 
called an \emph{arising} state, formally \ \ \ $\arising{M_{ext}}{M}{\sigma}$,\ \ \ 
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$\reductions{M_{ext}}{M}{\sigma_0}{\sigma}$.
\end{definition}

An \emph{Initial} state's heap
contains a single object of class \prg{Object}, and
its  stack   consists of a single frame, whose local variable map is a
mapping from \prg{this} to the single object, and whose continuation is  any statement.
(See Definition %s \ref{def:initial} and 
\ref{def:arising} and the 
{appendices %of the full paper 
\cite{necessityFull}).}


\paragraph{Applicability} 
{While our work is based on 
  a simple, imperative, typed, object oriented}
language with unforgeable addresses and private fields, we believe
 that % our approach
 it is applicable to several programming paradigms, and 
 that   unforgeability and privacy
 can be replaced 
 by lower level mechanisms such as capability machines \cite{vanproving,davis2019cheriabi}.

\subsection{\AssertLang -- the assertion language}
\label{sub:SpecO}

\AssertLang is a  \jm[removed: a subset of the \emph{Chainmail} assertions language, \ie]{}
a basic assertion language extended with
object-capability assertions. 


\subsubsection{Syntax of \AssertLang}
The syntax of \AssertLang   is given in
Definition \ref{f:chainmail-syntax}.
An assertion may be an expression,   a query of the defining class of
  an object, the usual connectives and quantifiers, along 
with two non-standard assertion forms:
(1) \emph{Internal/external} and (2) \emph{Protection}, inspired by the capabilities literature, and
 TODO say how these relate with capability lit;  compare with 
 OOPSLA.


\begin{definition}
Assertions ($A$) in
\AssertLang are defined as follows:

\label{f:chainmail-syntax}
 \[
\begin{syntax}
\syntaxElement{A}{}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\internal{x}}
				{\protectedFrom{y} {x}} 
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]


\end{definition}

TODO compare with oopsla 


\subsubsection{Semantics of \AssertLang}
The semantics of \AssertLang   
is given in Definition \ref{def:chainmail-semantics}. 
We   use the evaluation relation, $\eval{M}{\sigma}{e}{v}$,
which says that the expression $e$ evaluates
to value $v$ in the context of state $\sigma$ and module $M$.
As expressions in \LangOO may be recursively defined, their evaluation 
need not   % may not necessarily 
 terminate. Nevertheless, the logic of $A$ remains classical because recursion is restricted
to expressions, and not generally to assertions.
\footnote{We have taken this approach from \citeasnoun{FASE}, which also contains a mechanized Coq proof that assertions are classical \cite{coqFASE}.
%  The full
The semantics of $\hookrightarrow$ {is} unsurprising 
(see {the appendices %of the full paper 
\cite{necessityFull}).} } %Fig.\ref{f:evaluation}).


We adopt notation from OOPSLA, where
 $\interpret{\phi}{x} = v$  means that $x$ maps to
value $v$ in the local variable map of frame $\phi$, $\interpret{\sigma}{x} = v$ means that $x$ 
maps to $v$ in the top most frame of $\sigma$'s stack, and $\interpret{\sigma}{x.f} = v$
has the obvious meaning. The terms $\sigma.\prg{stack}$,  
$\sigma.\prg{contn}$,  
$\sigma.\prg{heap}$     mean the stack, 
the continuation at the
top frame of $\sigma$, %resp. 
and the heap of $\sigma$.
The term $\alpha\!\in\!\sigma.\prg{heap}$ means that $\alpha$ is in the domain of the heap of $\sigma$, and \emph{$x$ fresh in $\sigma$} means that 
$x$ isn't in the variable map of the top frame of $\sigma$, 
while the substitution  $\sigma[x \mapsto \alpha]$ is applied to the top frame of $\sigma$.
 \ $C\in M$ means that class $C$ is in the domain of module $M$. 

TODO motivate why we need relevant, and also 
\begin{definition}
$\sigma \models \Relevant o$ \ \ iff\ \  
$\exists n\in mathbb{N}.\exists \prg{f}_1,... \prg{f}_n.\exists \prg{x}.[ \ \interpret{\sigma}{x.\prg{f}_1.....\prg{f}_n} = o \ \wedge n\neq 0\ ]$.
\end{definition}

We now give meaning to assertions. Definitions (1)-(5) are standard. Note that Definitions (6)-(7) quantify only over objects that are accessible from the top frame. TODO  

\begin{definition}[Satisfaction % of \AssertLang 
of Assertions by a module and a state] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a % program 
state $\sigma$ with 
 module $M$ as:
\begin{enumerate}
\item
\label{cExpr}
$\satisfiesA{M}{\sigma}{e}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{e}{\true}$
\item
\label{cClass}
$\satisfiesA{M}{\sigma}{e : C}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{e}{\alpha}$ \textit{and} $\class{\sigma}{\alpha} = C$
\item
$\satisfiesA{M}{\sigma}{\neg A}$ \ \ \ iff \ \ \  ${M},{\sigma}\nvDash{A}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \wedge\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}$ and 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \vee\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}$ or 
$\satisfiesA{M}{\sigma}{A_2}$
\item
\label{quant1}
$\satisfiesA{M}{\sigma}{\all{x}{A}}$ \ \ \ iff \ \ \  
$\satisfiesA{M}{\sigma[x \mapsto o]}{A}$, \\
\strut \hspace{1.3in}   for some $x$ fresh in $\sigma$, and all  $o$ such that $\sigma \models \Relevant o$.
\item
\label{quant2}
$\satisfiesA{M}{\sigma}{\ex{x}{A}}$ \ \ \ iff \ \ \  
$\satisfiesA{M}{\sigma[x \mapsto \alpha]}{A}$, \\
\strut \hspace{1.3in}   for some $x$ fresh in $\sigma$, and some $o$ such that $\sigma \models \Relevant o$.
\item
\label{cInternal}
$\satisfiesA{M}{\sigma}{\internal{x}}$ \ \ \ iff \ \ \  
$\textit{classOf}(\sigma,x) \in M$
\item
\label{cProtected}
$\satisfiesA{M}{\sigma}{\protectedFrom{y} {x}}$  \ \ \ iff \ \ \   $\satisfiesA{M}{\sigma}{y \neq x}$  and \\
\strut \hspace{1.3in} $\forall f_1,...f_n.[\ \interpret{\sigma}{x.f_1...f_n}=\interpret{\sigma}{y} \ \rightarrow \exists k<n. 
[\,\satisfiesA{M}{\sigma}{\internal{x.f_1...f_k}} \, ] \ ]$
\end{enumerate}
\end{definition}

Both existential and universal quantification (defined in \ref{quant1} and \ref{quant2}) is done over all objects which are transitively 
accessible from the top frame in the stack. This deviates from OOPSLA. -TODO later on say why this is important.
We do not include quantification over primitive types such as integers as \LangOO is too simple. The 
Coq mechanisation does include primitive types.
 
TODO: say that an assertion like ${\internal{e}}$ is a shorthand for $\exists x. [ x=e \wedge {\internal{e}}]$. QUESTION: do we need to talk about $=$ in the assertion language?

 Note that in most cases, satisfaction of an assertion not only depends on the state $\sigma$, but 
also depends on the module in the case of expressions (\ref{cExpr}), class membership
(\ref{cClass}), and internal or external provenance (\ref{cInternal} and \ref{cExternal}).

We also define two shorthands:

\begin{definition}[Protected and External]
We define two shorthands

\begin{enumerate}
\item
$\external {y}$ is short for  $\neg(\internal {y})$
\item
${\inside {y}}$  is short for ${\all{x}{\ \external x  \rightarrow  {}{\protectedFrom{y} {x}}\ }}$
\end{enumerate}
\end{definition}

${\inside {\_}}$  is central to the expression of ambient capability. For example, the balance of an account whose
  password is \inside  will not decrease in the next step.
  Often, API implementations contain objects whose capabilities, while  crucial for the implementation, if exposed,
would break the intended guarantees of the API. Such objects need to remain confined - see
such an example in Section \ref{s:examples}. 
 
 TODO add a diagram that illustrated relative and absolute inside

TODO: Do we prove the implications as in TACAS -- since we have some new primitives? hmhh

% DO not yet remove below !!!!
% but I think we can skip it
% We now define what it means for a module to satisfy an assertion:
% $M$ satisfies  $A$ if any state arising from external steps execution of that
%module with any other external module  satisfies $A$. 
%We also assume the existence of a proof system that judges
%$\proves{M}{A}$, to prove  satisfaction of assertions. 
% We will not define such a judgement, but will rely on its existence {later on for} Theorem \ref{thm:soundness}.
%We define soundness of such a judgement in the usual way:
% 
%\begin{definition} [Satisfaction % of \AssertLang 
%of Assertions
%by a module] 
%\label{def:mdl-sat}
%For a module $M$ and assertion $A$, we say that\ \  $\satisfies{M}{A}$ \ \ if and only if 
%for all modules $M_{ext}$, and all $\sigma$, if $\arising{M_{ext}}{M}{\sigma}$, then $\satisfiesA{M}{\sigma}{A}$.
%
%\label{ax:specW-prove-soundness}
%A judgement of the form {$\proves{M}{A}$} is \emph{sound}, if for all
% modules $M$ and assertions $A$, \ if $\proves{M}{A}$ then $\satisfies{M}{A}$.
%\end{definition}

 \subsection{\SpecLang specifications}

 


\newcommand{\TwoStates}[2]{\ensuremath{{\{}\, #1 \,{\}} \, {\{}\, #2\, {\}} }} 


\noindent
The syntax of  \SpecLang specifications is given below
 
\begin{definition}  

\noindent
{\emph{\sd{Syntax of \SpecLang Specifications}}}

\label{f:holistic-syntax}
\[
\begin{syntax}
\syntaxElement{S}{}
		{
		\syntaxline
				{A}				
				{\TwoStates {A} {A} }	
				{S\, \wedge \, S}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\end{definition}

\label{sec:adapt:motivate}



\noindent
TODO -- if needed -- As an example, we consider the following three  specifications:

\begin{lstlisting}[language = Chainmail, mathescape=true,xleftmargin=2em,frame=lines,framexleftmargin=1.5em]
$\text{TODO}$   $\triangleq$  TEXT
\end{lstlisting}


 


\subsubsection{ Semantics of \SpecLang Specifications}
We now  define what it means for  a module  $M$ to satisfy specification  $S$, written as $M \vDash S$. The
 Definition~\ref{def:necessity-semantics} below is straightforward, apart from  
the use of the $\adapt  {\sigma'}{\sigma}$  (best read as ``$\sigma'$ seen
from $\sigma$'')
% although one recalcitrant author prefers ``$\sigma'$adapted to $\sigma$'') 
% our reviewers did not appreciate the jokes
to deal with the fact that execution might  change the bindings in local variables.
We explain this in detail in   \S \ref{sub:adapt:full}, but for now, the reader may ignore the applications of that operator and
read $\sigma' \triangleleft \sigma$ as $\sigma'$.

\begin{definition}[Semantics of \SpecLang Specifications]
We define $\satisfies{M}{{S}}$ by cases over the four possible syntactic forms.
For any assertions   $A_1$, $A_2$, and $A$: \\

\label{def:necessity-semantics}

\begin{tabular}{llcl}
$\bullet$ & $\satisfies{M}{{A}}$& iff & for all $M_{ext}$, $\sigma$, such that $\arising{M_{ext}}{M}{\sigma}$: \ \    \\
 & & & - $\satisfiesA{M}{\sigma}{A}$.  
\\
$\bullet$ &  $\satisfies{M}{\TwoStates {A}{A'}}$ &  iff   &  for all $M_{ext}$, $\sigma$, $\sigma'$, such that $\arising{M_{ext}}{M}{\sigma}$: \\  
 & & & -   $\satisfiesA{M}{\sigma}{A}\  \wedge \ \reductions{M_{ext}}{M}{\sigma}{\sigma'} \;\;\;\Rightarrow\;\;\; \satisfiesA{M}{\sigma' \triangleleft \sigma}{A'}$   
\\
$\bullet$ &  $\satisfies{M}{S\, \wedge\, S'}$ &   iff   & $\satisfies{M}{S}$ and $\satisfies{M}{S'}$
\end{tabular} 

 
\end{definition} 

TODO say how this related to OOPSLA from-to-onlyIf, and how the other two are not expressed. But this should go to related work.

\begin{definition}[Alternative Definition for Semantics of \SpecLang Specifications]
We define $\satisfies{M}{{S}}$ by cases over the four possible syntactic forms.
For any assertions   $A_1$, $A_2$, and $A$: \\

\label{def:necessity-semantics}

\begin{tabular}{llcl}
$\bullet$ & $\satisfies{M}{{A}}$& iff & ... as before ... \\
$\bullet$ &  $\satisfies{M}{\TwoStates {A}{A'}}$ &  iff   &  for all $M_{ext}$, $\sigma$, $\sigma'$, such that $\arising{M_{ext}}{M}{\sigma}$, and all the \\
& & & {\textbf {free variables of $A$ and $A'$ do not appear in $\sigma.{\texttt{cont}}$}}: \\  
 & & & -   $\satisfiesA{M}{\sigma}{A}\  \wedge \ \reductions{M_{ext}}{M}{\sigma}{\sigma'} \;\;\;\Rightarrow\;\;\; \satisfiesA{M}{\sigma'}{A'}$   
\\
$\bullet$ &  $\satisfies{M}{S\, \wedge\, S'}$ &   iff   & ... as before 
\end{tabular} 

TODO: explain what the requirement {\textbf {the free variables of $A$ and $A'$ do not appear in $\sigma.{\texttt{cont}}$}} buys us. 

Notice that in the above, while we require that the free variables of $A$ and $A'$ do not appear in $\sigma.{\texttt{cont}}$, we do expect that they should be in the domain of the top frame, and we do not preclude that they could be aliases with variables from 
$\sigma.{\texttt{cont}}$.

Another way of defining the semantics of $\satisfies{M}{\TwoStates {A}{A'}}$  is through renaming of all the free variables in $A$ and $A'$.

\begin{lemma}
For any $M$, and assertions $A$ and $A'$:

\begin{itemize}
\item $\satisfies{M}{\TwoStates {A}{A'}}$ iff for all $M_{ext}$, $\sigma$, $\sigma'$, such that $\arising{M_{ext}}{M}{\sigma}$: 
\\
\strut \hspace{0.1cm} $\satisfiesA{M}{\sigma[\overline y \mapsto \overline {\sigma (x)}]}{A [\overline x \mapsto \overline {y}]}
\  \wedge \ \reductions{M_{ext}}{M}{\sigma}{\sigma'} \;\;\;\Rightarrow\;\;\; \satisfiesA{M}{\sigma'[\overline y \mapsto \overline {\sigma (x)}]}{A'[\overline x \mapsto \overline {y}]}$
\end{itemize} 
\end{lemma}

 
\end{definition} 

TODO Add examples?


\subsubsection{Adaptation}
\label{sub:adapt:full}
TODO IF WE GO WITH THE FIRST ALTERNATIVE: We  now discuss  the adaptation operator.  It should be more succinct than the oopsla version.
 


