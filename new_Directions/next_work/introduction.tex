\section{Introduction}
\label{s:intro}

\red{TODO} Explain OCAP; introduce the challenge of the open word; reasoning and works by Devries, Birkedahl, Vechev, and ours.
Include in that in OCAPs the capabilities act as guards. 
That this has been tackled in FASE/OOPSLA'22 and gets better tackled here
Also the difference between necessary and sufficient.
And relation to POPL'23 paper; perhaps also some of recent work by Toby 

%Overall structure -- I do not know in what  order though.
%
%1) In today's complex world,  internal calls external and external calls internal
%
%2) To mitigate the risk, we introduced encapsulation ... ownership, private, etc etc 
%
%
%3) The OCAP model proposes capabilties .... def from OCAP. This means that capabilty is enabler -- sufficient condtion, 
%
%4)  However, a better understanding is that capability is guard, ie necessary condition. This has been recognized at OOPSLA 2022.
%
%
%5) We need to develop robust software, so that external calls do not do not have unwarranted effects ( check what term do Birkedahl et al use ).
%
%6) When we reason about open calls we can consider all possible calls back into the nmodule (2022 work), or even better 
%  have a spec of the complete module. OOSPLA did the spec but could not do the reasoning. 
%
%7) Emergent behaviour; to describe this, we need specs about complete module. Earlier work in that vein: two state invariants from the 02's. , temporal loghics, and FASE, OOPSLA
%-- competititon does not do.



%reason in the open world is not only about preservation of simple invariants; it is about reasoning about possible effects. These are reduced/increased through the availability of capabilities.
%
%The "others" tackle the problem of the ambient authority in a 1-step manner, eg there is a module, and if it exports a capability this capability may be used. For example, xxxx 
%
%FASE/OOPSLA support unrestricted ambient authority, but not the reasoning part. For example, xxxx
%
%In this paper, we support unrestricted ambient authority, and also reasoning. We are inspired by the work in FASE/OOSPLA, but with the following differences
%
%1) replace the temporal operators of FASE/necessity operators of oopsla by 2-state spec-s 
%
%2) when reasoning about a module's adherence to a 2-state spec, replace the xxx rules from OOPSLA by just one rule -- inspired by Infeasibility logic
%
%3) add one Hoare logic rule to reason about calls to external call; and add Hoare logic rules that reason about the accessibility of objects from other objects


