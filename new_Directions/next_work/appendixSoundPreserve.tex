\newcommand{\Ao}{A_{o}}
\newcommand{\Ain}{A_{in}}
\newcommand{\Aout}{A_{out}}

\subsection{Sequences, Sets, Substitutions and Free Variables}


Our system makes heavy use of textual substitution,   textual inequality, and the concept of free variables in assertions. 
 
In this subsection we introduce some notation and some lemmas to deal with these concepts.
These concepts and lemmas are by no means novel; we list them here so as to use them more easily in the subsequent proofs.


\begin{definition}[Sequences,   Disjointness, and Disjoint Concatenation]
For any variables $v$, $w$, and sequences of variables $\overline v$, $\overline w$ we define:
\begin{itemize}
\item
 $v \in \overline w \ \ \triangleq \ \  \exists  \overline {w_1},  \overline {w_1}[\  {\overline w} = \overline {w_1}, v, \overline {w_2} \ ]$
\item
$v \# w \ \ \triangleq \ \ \neg(v \txteq w)$.
\item
$\overline v \subseteq \overline w \ \ \triangleq \ \ \forall v.[\ v \in  \overline v\ \Rightarrow\ v \in  \overline w\ ]$
\item
$\overline v \#  \overline w \ \ \triangleq \ \ \forall v \in  \overline v. \forall w \in  \overline w.  [ \ v \# w\  ]$
\item
$ \overline v \cap \overline w \ \ \triangleq \ \  \overline u, \ \ \ \ \mbox{such that}\   \forall u.[ \ \ u  \in   \overline v \cap \overline w \ \ \Leftrightarrow\ \  [ \ u\in \overline v\ \wedge\ u\in \overline w\  ]$
\item
$ \overline v \setminus \overline w \ \ \triangleq \ \  \overline u, \ \ \ \ \mbox{such that}\   \forall u.[ \ \ u  \in  \overline v \setminus \overline w \ \ \Leftrightarrow\ \  [ \ u\in \overline v\ \wedge\ u\notin \overline w\  ]$
\item
$\overline v; \overline w \ \ \triangleq \ \ \overline v$, $\overline w$ \ \ if $\overline v \#  \overline w $ \ \ \ and  undefined otherwise.
\end{itemize}
\end{definition}

\begin{lemma}[Substitutions and Free Variables]
\label{l:sfs}
For any sequences of variables $\overline x$, $\overline y$, $\overline z$, $\overline v$, $\overline w$, a variable $w$, any assertion $A$, we have
\begin{enumerate}
\item
\label{l:sfs:zero}
$ \overline x[\overline{y/x} ] = \overline y $
\item
\label{l:sfs:zero:one}
$ \overline {x} \# \overline y \ \   \Rightarrow \ \  \overline y[\overline{z / x} ] = \overline y $
\item
\label{l:sfs:one}
$\overline {z} \subseteq \overline y \ \   \Rightarrow \ \  \overline y[\overline{z / x} ] \subseteq \overline y $
\item
\label{l:sfs:two}
$\overline {y} \subseteq \overline z \ \   \Rightarrow \ \  \overline y[\overline{z / x} ] \subseteq \overline z $
\item
\label{l:sfs:three}
 $\overline x \# \overline y \ \ \Rightarrow \ \ {\overline z}[\overline{y / x}]  \# \overline x $ 
 \item
 \label{l:sfs:four}
 $\fv(A[\overline{y / x}] )\, =\, \fv(A)[\overline{y / x}] $
 \item
 \label{l:sfs:five}
 $\fv(A)\, =\, \overline x; \overline v, \ \ \   \fv(A[\overline{y / x}] )\, = \,   \overline y; \overline w 
 \ \ \ \Longrightarrow\ \ \ 
 \overline v \, = \, (\overline {y}\cap\overline{v}); \overline w $
  \item
  \label{l:sfs:sixa}
 $ \overline v \# \overline x   \# \overline y   \# \overline u  \ \ \    \ \ \ \Longrightarrow\ \ \ 
w[ \overline {u/x} ][ \overline {v/y} ]  \txteq w[ \overline {v/y} ][ \overline {u/x} ]  $

 \item
  \label{l:sfs:six}
 $ \overline v \# \overline x   \# \overline y   \# \overline u  \ \ \    \ \ \ \Longrightarrow\ \ \ 
A[ \overline {u/x} ][ \overline {v/y} ]  \txteq A[ \overline {v/y} ][ \overline {u/x} ]  $
\item
  \label{l:sfs:seven}
 $( fv (A[ \overline {y/x} ])\setminus \overline y)\, \# \, \overline x$
% \item
%  \label{l:sfs:six}
%$\fv(A)\, =\, \overline x; \overline v, \ \ \   \fv(A[\overline{y / x}] )\, = \,   \overline y; \overline w, \ \ \ \overline y\, \# \, \overline x; \overline v
% \ \ \ \Longrightarrow\ \ \ 
% \overline v \, = \,\overline w \ $ 
\end{enumerate}

\end{lemma}

\noindent 
\textbf{Proof of Lemma \ref{l:sfs}}
\begin{enumerate}
\item
 by induction on  the number of elements in $\overline x$ 
\item
 by induction on  the number of elements in $\overline y$ 

\item
 by induction on  the number of elements in $\overline y$ 
\item
 by induction on  the number of elements in $\overline y$ 
\item
 by induction on the structure of $A$ 
 \item
 by induction on the structure of $A$ 
\item
Assume that\\
$(ass1)\ \ \  \fv(A)\, =\, \overline x; \overline v,$
\\
$(ass2)\ \ \  \fv(A[\overline{y / x}] )\, = \,   \overline y; \overline w$\\
We define:
\\
$(a) \ \ \  \overline {y_0} \triangleq \overline v \cap \overline y, \ \ \  \overline {v_2} \triangleq \overline v \setminus \overline y, \ \ \ \overline {y_1} = \overline {y_0}[\overline {x/y}]$
\\
This gives:\\
$(b) \ \ \ \overline {y_0} \#   \overline {v_2}$
\\
$(c)\ \ \ \overline v =  \overline {y_0}; \overline {v_2}$\
\\
$(d) \ \ \  \overline {y_1}  \subseteq \overline y$
\\
$(e) \ \ \ \overline {v_2}[\overline{y / x}] = \overline {v_2}$, \ \ \ from assumption and (a) we have $\overline x \# \overline v_2$ and by Lemma \ref{l:sfs}) part (\ref{l:sfs:zero:one})
\\
We now calculate \\
$\begin{array}{lcll}
\ \ \  \fv(A[\overline{y / x}] )   & = &  (\overline x; \overline v)[\overline{y / x}] & \mbox{ by (ass1), and Lemma \ref{l:sfs} part (\ref{l:sfs:three}).}
\\ 
& = &  (\overline x; \overline {y_0}; \overline {v_2})[\overline{y / x}] & \mbox{ by (c) above }
\\
& = &   \overline x[\overline{y / x}], \, \overline {y_0}[\overline{y / x}], \overline {v_2}[\overline{y / x}] & \mbox{ by distributivity of $[../..]$ }
\\
& = &   \overline y, \, \overline {y_1}, \overline {v_2}  & \mbox{ by Lemma \ref{l:sfs} part (\ref{l:sfs:zero}), (a), and (e). }
\\
& = &   \overline y; \overline {v_2}  & \mbox{ because (d), and  $ \overline y \# \overline {v_2}$ }
\\
\ \ \  \fv(A[\overline{y / x}] )   & = &  \overline y; \overline w  & \mbox{ by (ass2)}
\end{array}
$
\\
The above gives that $\overline {v_2} = \overline {w}$. This, together with (a) and (c) give that $\overline {v} = (\overline {y}\cap\overline{v});\overline{w}$ 
% Thus, from (c) and the above we obtain  $ \overline v =  \overline {y_0}; \overline {w}$; and (a) gives $\overline {y_0}\subseteq \overline {y}$
% \item
% Follows from (\ref{l:sfs:five}).
\item
By case analysis on whether $w \in \overline x$ ... etc
\item
By induction on the structure of $A$, and the guarantee from (\ref{l:sfs:sixa}).
\item
We take a variable sequence $\overline z$ such that \\
$(a) \  \  \fv(A  ) \subseteq \overline{x}; \overline z$
\\
This gives that\\
$(b) \  \   \overline{x} \# \overline z$
\\
Part (\ref{l:sfs:four}) of our lemma and (a) give\\
$(c) \  \  \fv(A[\overline{y / x}] ) \subseteq \overline{y}, \overline z$
\\
Therefore
\\
$(d) \  \  \fv(A[\overline{y / x}] ) \setminus {\overline y } \subseteq  \overline z$
\\
The above, together with (b) conclude the proof
 \end{enumerate}


\noindent
\textbf{End Proof}


\begin{lemma}[Substitutions and Adaptations]
\label{l:sybbs:adapt}
For any sequences of variables $\overline x$, $\overline y$, sequences of expressions $\overline e$, and   any assertion $A$, we have
\begin{itemize}
\item
$ \overline x \# \overline y \ \ \ \Longrightarrow \ \ \  \PushAS {y} {(A[\overline {e/x}])}  \txteq   (\PushAS {y} {A})[\overline{ e/x}] $
\end{itemize}

\end{lemma}

\noindent
\textbf{Begin Proof}

\noindent 
We first consider $A$ to be $\inside e_0$, and just take one variable. Then, \\
$\strut \ \ \ \ { \PushAS  {y} { (\inside {e_0}[e/x] ) } }
 \ \txteq\  {\protectedFrom {e_0[ {e/x}]} {y}}$, \\
and\\
$\strut \ \ \ \ (\PushAS {y} {\inside {e_0}})[e/x] \  \txteq\  \protectedFrom {e_0[{e/x}]} {y[ {e/x}]}$. \\
When $x \# y$  then the two assertions from above  are textually equal.
The rest follows by induction on the length of $\overline x$ and the structure of $A$.
 

\noindent
\textbf{End Proof}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preservation of assertions when pushing or popping frames}

In this section we  discuss the preservation of satisfaction of assertions when calling methods or returning from methods -- \ie when pushing or popping  frames. 
Namely, since  pushing/popping frames  does not modify the heap, these operations should preserve satisfaction of some assertion $A$, up to the fact that a) passing an object as a parameter of a a result might break its protection, and 
b) the bindings of variables change  with pushing/popping frames.
To deal with a)  upon method call, 
we   require that the fame being pushed or the frame to which we return is internal ($M, \sigma' \models \intThis$), or require the adapted version of an assertion (\ie  ${\PushAS  {v} { A}}$ rather than $A$).
To deal with b) we either require that there are no free variables in $A$, or we break the free variables of $A$ into two parts, \ie $\fv(\Ain) =  \overline{v_1};\overline{v_2}$, where the value of $\overline{v_3}$ in the caller is the same as that of  $\overline{v_1}$ in the called frame.
%To deal with b) upon method return, we also break the free variables of $A$ into two parts, \ie $\fv(\Ain) =  \overline{v_1}, \overline{v_2}$, where the value of $\overline{v_1}$ in the callee is the same as that of  i$\overline{v_3}$ in the caller.
%And in both cases   $\overline {v_2}$ do not necessarily have a value in the callee frame.
This   is described in  lemmas \ref{l:calls} -  \ref{l:calls:return}.

We have four lemmas: Lemma \ref{l:calls} describes preservation from a caller to an internal called, lemma \ref{l:calls:external}
describes preservation from a caller to any called, Lemma \ref{l:calls:return} describes preservation from an internal called to a caller, and  Lemma \ref{l:calls:return:ext} describes preservation from an any called to a caller, 
These four lemmas are used in the soundness proof for the four Hoare rules   about method calls, as given in Fig. \ref{f:calls}. 

In the rest of this subsection we will first  state and discuss each of the lemmas,
and we will then prove them.
  
 
 %%%% From caller to called %%%
\begin{lemma}[From caller to internal called]
\label{l:calls}

For any assertion $\Ain$, states $\sigma$, $\sigma'$,  
variables  $\overline{v_1}$,    $\overline{v_2}$,  $\overline{v_3}$,  $\overline{v_4}$,  $\overline{v_6}$,  % addresses $\overline \alpha_2$ and $\overline \alpha_4$, 
statement $stmt$, and frame $\phi$.

\noindent
% $ ~ $ % and $\overline{y'}$,  \\
If 
\begin{enumerate}[(i)]
\item 
\label{l:calls:r:one}
$ \Pos \Ain$,  
\item 
\label{l:calls:r:two}
$\fv(\Ain) =  \overline{v_1}; \overline{v_2} $\footnote{As we said earlier. this gives  also that the variable sequences  are pairwise disjoint, \ie $\overline{v_1}\#\overline{v_2}$.},
\ \ \ 
$\fv(\Ain[\overline {v_3/v_1}]) =  \overline{v_3}; \overline{v_4} $, \ \ \ \ 
$ \overline {v_6}\triangleq\overline{v_2}\cap\overline{v_3}; \overline{v_4} $, 
\item
$\sigma'=\sigma  \pushSymbol \phi  \ \ \ \  \wedge\ \ \  Rng(\phi)= \overline{\interpret {\sigma} {v_3} }\ \ \ \ \wedge \ \  \ \ \overline {\interpret {\sigma'}  {v_1} } = \overline {\interpret {\sigma} {v_3} }$, 

\end{enumerate}

\noindent
then

\begin{enumerate}[(a)]
\item
\label{l:calls:callee:one}
$\satDAssertFrom M  \sigma k   \Ain[\overline {v_3/v_1}] % [\overline {\alpha_2/v_2}] \ \   
\ \ \wedge\ \ M, \sigma' \models \intThis
%   $  \\  $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \   \ \satDAssertFrom M  {\sigma'} k  {\Ain[\overline { {\interpret {\sigma} {v_6}} / {v_6} } ] } $
 
\item

\label{l:calls:callee:two}
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\overline {v_3})} {(\Ain[\overline {v_3/v_1}])}} 
%  $ \\  $\strut \hspace{2cm}  
\hfill \Longrightarrow  \ \ \  \   \ \ \  \  
M, \sigma' \models   {\Ain\overline { {\interpret {\sigma} {v_6}} / {v_6} } ] }$.

\end{enumerate}

\end{lemma}

In lemma \ref{l:calls},   state $\sigma$ is the state right before pushing the new frame on the stack,   while 
state $\sigma'$ is the state right after pushing the frame on the stack.
That is, $\sigma$ is the last state before entering the method body, and $\sigma'$ is the first state after entering the method body.
$\Ain$ stands for the method's precondition, while the variables $\overline {v_1}$ stand for the formal parameters of the method,
and $\overline {v_3}$ stand for the actual parameters of the call.
Therefore, $\overline {v_1}$ is the domain of the new frame, and $\overline {\sigma} {v_3}$ is its range.
The variables $\overline {v_6}$ are the free variables of $\Ain$ which are not in  $\overline {v_1}$ -- \cf Lemma \ref{l:sfs} part
( \ref{l:sfs:five}).
Therefore if (\ref{l:calls:callee:one})  the callee is internal, and 
 $\Ain[\overline {v_3/v_1}]$ holds  at the call point, or
 if (\ref{l:calls:callee:two}) ${\PushASLong  {(\overline {v_3})} {(\Ain[\overline {v_3/v_1}])}}$
 holds  at the call point, 
 then $\Ain[\overline {.../v_61}]$  holds right after pushing $\phi$ onto the stack.
% Moreover, (\ref{l:calls:callee:two})  , then $\Ain[\overline {.../v_6}]$  holds right after pushing $\phi$ onto the stack.
Notice the difference in the conclusion in (\ref{l:calls:callee:one}) and (\ref{l:calls:callee:two}): in the first case we have \scoped satisfaction, while in the second case we only have shallow satisfaction.



%%% calling external

\begin{lemma}[From caller to any called]
\label{l:calls:external}

For any assertion $\Ain$, states $\sigma$, $\sigma'$,  
variables   $\overline{v_3}$  % addresses $\overline \alpha_2$ and $\overline \alpha_4$, 
statement $stmt$, and frame $\phi$.

\noindent
% $ ~ $ % and $\overline{y'}$,  \\
If 
\begin{enumerate}[(i)]
\item 
\label{l:calls:re:one}
$ \Pos \Ain$,  
\item 
\label{l:calls:re:two}
$\fv(\Ain) =  \emptyset$,
\item
\label{l:calls:re:three}
$\sigma'=\sigma  \pushSymbol \phi  \ \ \ \  \wedge\ \ \  Rng(\phi)= \overline{\interpret {\sigma} {v_3} },$
\end{enumerate}

\noindent
then

\begin{enumerate}[(a)]
\item

\label{l:calls:callee:three}
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\overline {v_3})} {\Ain} } 
%  $ \\  $\strut \hspace{2cm}  
\hfill \Longrightarrow  \ \ \  \   \ \ \  \  
M, \sigma' \models   {\Ain} $.


\item
\label{l:calls:callee:four}
$\satDAssertFrom M  \sigma k    {(\Ain  \wedge  ({\PushASLong  {(\overline {v_3})} {\Ain} } ) )}  
% $  \\   $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \   \satDAssertFrom M  {\sigma'} k  {\Ain}$


\end{enumerate}

\end{lemma}

In lemma \ref{l:calls:external},  as in  lemma \ref{l:calls}, 
  $\sigma$ stands for the last state before entering the method body, and $\sigma'$ for the first state after entering the method body.
$\Ain$ stands for a module invariant in which all free variables have been substituted by addresses.
The lemma is intended for external calls, and therefore we have no knowledge of the method's formal parameters.
The variables   $\overline {v_3}$ stand for the actual parameters of the call, and therefore 
 $\overline {\interpret {\sigma} {v_3}}$ is the range of the new frame.
Therefore if (\ref{l:calls:callee:three})   the adapted version,
 ${\PushASLong  {(\overline {v_3})} {\Ain} }$, holds  at the call point,
 then the unadapted version, $\Ain$  holds right after pushing $\phi$ onto the stack.
 Notice that  even though the premise of (\ref{l:calls:callee:three}) requires \scoped satisfaction, the conclusion promises
 only weak satisfaction.
 Moreover, if (\ref{l:calls:callee:four})   the adapted as well as the unadapted version,
 $\Ain \wedge {\PushASLong  {(\overline {v_3})} {\Ain} }$
 holds  at the call point,
 then the unadapted version, $\Ain$  holds right after pushing $\phi$ onto the stack.
 % Moreover, (\ref{l:calls:callee:two})  , then $\Ain[\overline {.../v_6}]$  holds right after pushing $\phi$ onto the stack.
Notice the difference in the conclusion in (\ref{l:calls:callee:three}) and (\ref{l:calls:callee:four}): in the first case we have  shallow satisfaction, while in the second case we only have \scoped satisfaction.


%%% From called back to caller

\begin{lemma}[From internal called to caller]
\label{l:calls:return}

For any assertion $\Aout$, states $\sigma$, $\sigma'$,  
variables  $\overline{v_1}$,      $\overline{v_3}$,   $\overline{v_5}$,  % addresses $\overline \alpha_2$ and $\overline \alpha_4$, 
statement $stmt$.

\noindent
 If 
 
\begin{enumerate}[(i)]
\item 
\label{l:calls:r:one}
$ \Pos \Aout$,  
\item 
\label{l:callers:r:two}
$\fv(\Aout) \subseteq  \overline{v_1} $,
\item
$  \overline {\interpret {\sigma'} {v_5}}, \overline {\alpha_4} \subseteq \LRelevantO \sigma  \ \ \wedge \ \  M, \sigma' \models \intThis$,
 \item
\label{l:callers:three}
$\sigma'= (\sigma \popSymbol)[\overline{ v_4\! \mapsto\! \alpha_4}][\prg{cont}\!\mapsto\! stmt]
\ \ \wedge \ \   \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$, 
  \end{enumerate}
  
\noindent
then
% $\Longrightarrow$


\begin{enumerate} [a]
\item
\label{l:calls:caller:one}
$\satDAssertFrom M  \sigma k   \Aout  \ \  \wedge\ \ \DepthSt {\sigma'} \geq k  \ 
%$ \\ $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \   \satDAssertFrom M  {\sigma'} k   {\Aout[\overline {v_3 / v_1}]  }$ .

 
 \item
 \label{l:calls:caller:two}
 $M, \sigma \models  {\Aout}\ % \ \wedge\ \  \overline {\interpret {\sigma'} {v_5}} \subseteq \LRelevantO \sigma
%  $ \\   $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \  %
 \satDAssertFrom M  {\sigma'} k   {\PushASLong  {\overline {v_5}}    {(\Aout[\overline { v_3/v_1}])} }$.

 
\end{enumerate}

\end{lemma}

In lemma \ref{l:calls:return},  
 state  $\sigma$ stands for the last state in the method body, and $\sigma'$ for the first state after exiting  the method call.
$\Aout$ stands for a method postcondition.
The lemma is intended for internal calls, and therefore we know the method's formal parameters.
The variables   $\overline {v_1}$ stand for the formal  parameters of the method, and  
  $\overline {v_3}$ stand for the actual parameters of the call, and therefore 
  the  the formal parameters of the called have the same values as the actual parameters in the caller
  $  \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$.
% $\overline {\interpret {\sigma} {v_3}}$ is the range of the new frame.
Therefore   ( \ref{l:calls:caller:one})  and  (\ref{l:calls:caller:two})  
promise that if the postcondition $\Aout$ holds before popping the frame, then it also holds after popping frame after replacing the 
the formal parameters by the actual parameters $\Aout[\overline{v_3/v_1}]$.
As in earlier lemmas, there is an important difference between  (\ref{l:calls:caller:one}) and (\ref{l:calls:caller:two}):
In (\ref{l:calls:caller:one}), we require \emph{deep satisfaction at the called}, 
and obtain at the deep satisfaction of the \emph{unadapted} version ($\Aout[\overline{v_3/v_1}]$) at the return point;
while in (\ref{l:calls:caller:two}), we only require \emph{shallow satisfaction at the called}, 
and obtain deep satisfaction of the \emph{adapted} version (${\PushASLong  {\overline {v_5}}    {(\Aout[\overline { v_3/v_1}])} }$),
at the return point.


\begin{lemma}[From any called to caller]
\label{l:calls:return:ext}

For any assertion $\Aout$, states $\sigma$, $\sigma'$,  
variables  $\overline{v_1}$,      $\overline{v_3}$,   $\overline{v_5}$,  % addresses $\overline \alpha_2$ and $\overline \alpha_4$, 
statement $stmt$.

\noindent
 If 
 
\begin{enumerate}[(i)]
\item 
$ \Pos \Aout$,  
\item 
 $\fv(\Aout) = \emptyset$,
\item
$  \overline {\interpret {\sigma'} {v_5}}, \overline {\alpha_4} \subseteq \LRelevantO \sigma $,
 \item
$\sigma'= (\sigma \popSymbol)[\overline{ v_4\! \mapsto\! \alpha_4}][\prg{cont}\!\mapsto\! stmt]
$, 
  \end{enumerate}
  
\noindent
then
% $\Longrightarrow$


\begin{enumerate}[(a)]
\item
 \label{l:ext:return:one}
 $M, \sigma \models  {\Aout}\  
 \hfill \Longrightarrow  \ \ \  \  \satDAssertFrom M  {\sigma'} k  {\PushASLong  {\overline {v_5}}    {\Aout}}$.

\item
\label{l:ext:return:two}
$\satDAssertFrom M  \sigma k   \Aout  \ \  \wedge\ \ \DepthSt {\sigma'} \geq k  \ 
%$ \\ $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \   \satDAssertFrom M  {\sigma'} k   {\Aout \, \wedge\, {\PushASLong  {\overline {v_5}}    {\Aout}}} $

 
\end{enumerate}

\end{lemma}


In lemma  \ref{l:calls:return:ext}, similarly to  lemma \ref{l:calls:return},  
 state  $\sigma$ stands for the last state in the method body, and $\sigma'$ for the first state after exiting  the method call.
$\Aout$ stands for a method postcondition.
The lemma is meant to apply to external calls, and therefore, we do not know the method's formal parameters, 
$\Aout$ is meant to stand for a module invariant where all the free variables have been substituted by addresses --
\ie $\Aout$ has no free variables.
The variables $\overline {v_3}$ stand for the actual parameters of the call, and therefore 
 % $\overline {\interpret {\sigma} {v_3}}$ is the range of the new frame.
Therefore    (\ref{l:ext:return:one})  and  (\ref{l:ext:return:two})
promise that if the postcondition $\Aout$ holds before popping the frame, then it its adapted version 
also holds after popping frame (${\PushASLong  {\overline {v_5}}    {\Aout}}$).
 As in earlier lemmas, there is an important difference between   (\ref{l:ext:return:one})  and  (\ref{l:ext:return:two})
In  (\ref{l:ext:return:one}),  we require \emph{shallow satisfaction at the called}, 
and obtain   deep satisfaction of the \emph{adapted} version (${\PushASLong  {\overline {v_5}}    {\Aout}}$) at the return point;
while in (\ref{l:ext:return:two}), we  require \emph{deep satisfaction at the called}, 
and obtain deep satisfaction of the   \emph{conjuction}  of the \emph{unadapted} with the \emph{adapted} version (${\Aout \, \wedge\, {\PushASLong  {\overline {v_5}}    {\Aout}}}$),
at the return point.

\subsubsection{Use of these Lemmas}

As we said earlier, Lemmas \ref{l:calls}-\ref{l:calls:external} are used to prove the soundnes of the Hoare logic rules for method calls.
In the proof of soundness of {\sc{Call\_Int}}. we will use Lemma \ref{l:calls} part (\ref{l:calls:callee:one}) and Lemma \ref{l:calls:return} part (\ref{l:calls:caller:one}).  
In the proof of soundness of {\sc{Call\_Int\_Adapt}} we will use  Lemma \ref{l:calls} part (\ref{l:calls:callee:two}) and Lemma \ref{l:calls:return} part (\ref{l:calls:caller:two}).
In the proof of soundness of {\sc{Call\_Ext\_Adapt}} we will use  Lemma \ref{l:calls:external} part (\ref{l:calls:callee:three}) and Lemma \ref{l:calls:return:ext} part (\ref{l:ext:return:one}).
In the proof of soundness of {\sc{Call\_Ext\_Adapt\_Strong}} we will use  Lemma \ref{l:calls:external} part (\ref{l:calls:callee:four}) and Lemma \ref{l:calls:return:ext} part (\ref{l:ext:return:two}).
  