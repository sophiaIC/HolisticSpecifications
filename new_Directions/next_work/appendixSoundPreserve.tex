\subsection{Sequences, Sets, Substitutions and Free Variables}


Our system makes heavy use of textual substitution,   textual inequality, and the concept of free variables in assertions. 
 
In this subsection we introduce some notation and some lemmas to deal with these concepts.
These concepts and lemmas are by no means novel; we list them here so as to use them more easily in the subsequent proofs.


\begin{definition}[Sequences,   Disjointness, and Disjoint Concatenation]
For any variables $v$, $w$, and sequences of variables $\overline v$, $\overline w$ we define:
\begin{itemize}
\item
 $v \in \overline w \ \ \triangleq \ \  \exists  \overline {w_1},  \overline {w_1}[\  {\overline w} = \overline {w_1}, v, \overline {w_2} \ ]$
\item
$v \# w \ \ \triangleq \ \ \neg(v \txteq w)$.
\item
$\overline v \subseteq \overline w \ \ \triangleq \ \ \forall v.[\ v \in  \overline v\ \Rightarrow\ v \in  \overline w\ ]$
\item
$\overline v \#  \overline w \ \ \triangleq \ \ \forall v \in  \overline v. \forall w \in  \overline w.  [ \ v \# w\  ]$
\item
$ \overline v \cap \overline w \ \ \triangleq \ \  \overline u, \ \ \ \ \mbox{such that}\   \forall u.[ \ \ u  \in   \overline v \cap \overline w \ \ \Leftrightarrow\ \  [ \ u\in \overline v\ \wedge\ u\in \overline w\  ]$
\item
$ \overline v \setminus \overline w \ \ \triangleq \ \  \overline u, \ \ \ \ \mbox{such that}\   \forall u.[ \ \ u  \in  \overline v \setminus \overline w \ \ \Leftrightarrow\ \  [ \ u\in \overline v\ \wedge\ u\notin \overline w\  ]$
\item
$\overline v; \overline w \ \ \triangleq \ \ \overline v$, $\overline w$ \ \ if $\overline v \#  \overline w $ \ \ \ and  undefined otherwise.
\end{itemize}
\end{definition}

\begin{lemma}[Substitutions and Free Variables]
\label{l:sfs}
For any sequences of variables $\overline x$, $\overline y$, $\overline z$, $\overline v$, $\overline w$, a variable $w$, any assertion $A$, we have
\begin{enumerate}
\item
\label{l:sfs:zero}
$ \overline x[\overline{y/x} ] = \overline y $
\item
\label{l:sfs:zero:one}
$ \overline {x} \# \overline y \ \   \Rightarrow \ \  \overline y[\overline{z / x} ] = \overline y $
\item
\label{l:sfs:one}
$\overline {z} \subseteq \overline y \ \   \Rightarrow \ \  \overline y[\overline{z / x} ] \subseteq \overline y $
\item
\label{l:sfs:two}
$\overline {y} \subseteq \overline z \ \   \Rightarrow \ \  \overline y[\overline{z / x} ] \subseteq \overline z $
\item
\label{l:sfs:three}
 $\overline x \# \overline y \ \ \Rightarrow \ \ {\overline z}[\overline{y / x}]  \# \overline x $ 
 \item
 \label{l:sfs:four}
 $\fv(A[\overline{y / x}] )\, =\, \fv(A)[\overline{y / x}] $
 \item
 \label{l:sfs:five}
 $\fv(A)\, =\, \overline x; \overline v, \ \ \   \fv(A[\overline{y / x}] )\, = \,   \overline y; \overline w 
 \ \ \ \Longrightarrow\ \ \ 
 \overline v \, = \, (\overline {y}\cap\overline{v}); \overline w $
  \item
  \label{l:sfs:sixa}
 $ \overline v \# \overline x   \# \overline y   \# \overline u  \ \ \    \ \ \ \Longrightarrow\ \ \ 
w[ \overline {u/x} ][ \overline {v/y} ]  \txteq w[ \overline {v/y} ][ \overline {u/x} ]  $

 \item
  \label{l:sfs:six}
 $ \overline v \# \overline x   \# \overline y   \# \overline u  \ \ \    \ \ \ \Longrightarrow\ \ \ 
A[ \overline {u/x} ][ \overline {v/y} ]  \txteq A[ \overline {v/y} ][ \overline {u/x} ]  $
\item
  \label{l:sfs:seven}
 $( fv (A[ \overline {y/x} ])\setminus \overline y)\, \# \, \overline x$
  \item
  \end{enumerate}

\end{lemma}

\noindent 
\begin{proof} % \textbf{Proof of Lemma \ref{l:sfs}}

\begin{enumerate}
\item
 by induction on  the number of elements in $\overline x$ 
\item
 by induction on  the number of elements in $\overline y$ 

\item
 by induction on  the number of elements in $\overline y$ 
\item
 by induction on  the number of elements in $\overline y$ 
\item
 by induction on the structure of $A$ 
 \item
 by induction on the structure of $A$ 
\item
Assume that\\
$(ass1)\ \ \  \fv(A)\, =\, \overline x; \overline v,$
\\
$(ass2)\ \ \  \fv(A[\overline{y / x}] )\, = \,   \overline y; \overline w$\\
We define:
\\
$(a) \ \ \  \overline {y_0} \triangleq \overline v \cap \overline y, \ \ \  \overline {v_2} \triangleq \overline v \setminus \overline y, \ \ \ \overline {y_1} = \overline {y_0}[\overline {x/y}]$
\\
This gives:\\
$(b) \ \ \ \overline {y_0} \#   \overline {v_2}$
\\
$(c)\ \ \ \overline v =  \overline {y_0}; \overline {v_2}$\
\\
$(d) \ \ \  \overline {y_1}  \subseteq \overline y$
\\
$(e) \ \ \ \overline {v_2}[\overline{y / x}] = \overline {v_2}$, \ \ \ from assumption and (a) we have $\overline x \# \overline v_2$ and by Lemma \ref{l:sfs}) part (\ref{l:sfs:zero:one})
\\
We now calculate \\
$\begin{array}{lcll}
\ \ \  \fv(A[\overline{y / x}] )   & = &  (\overline x; \overline v)[\overline{y / x}] & \mbox{ by (ass1), and Lemma \ref{l:sfs} part (\ref{l:sfs:three}).}
\\ 
& = &  (\overline x; \overline {y_0}; \overline {v_2})[\overline{y / x}] & \mbox{ by (c) above }
\\
& = &   \overline x[\overline{y / x}], \, \overline {y_0}[\overline{y / x}], \overline {v_2}[\overline{y / x}] & \mbox{ by distributivity of $[../..]$ }
\\
& = &   \overline y, \, \overline {y_1}, \overline {v_2}  & \mbox{ by Lemma \ref{l:sfs} part (\ref{l:sfs:zero}), (a), and (e). }
\\
& = &   \overline y; \overline {v_2}  & \mbox{ because (d), and  $ \overline y \# \overline {v_2}$ }
\\
\ \ \  \fv(A[\overline{y / x}] )   & = &  \overline y; \overline w  & \mbox{ by (ass2)}
\end{array}
$
\\
The above gives that $\overline {v_2} = \overline {w}$. This, together with (a) and (c) give that $\overline {v} = (\overline {y}\cap\overline{v});\overline{w}$ 
\item
By case analysis on whether $w \in \overline x$ ... etc
\item
By induction on the structure of $A$, and the guarantee from (\ref{l:sfs:sixa}).
\item
We take a variable sequence $\overline z$ such that \\
$(a) \  \  \fv(A  ) \subseteq \overline{x}; \overline z$
\\
This gives that\\
$(b) \  \   \overline{x} \# \overline z$
\\
Part (\ref{l:sfs:four}) of our lemma and (a) give\\
$(c) \  \  \fv(A[\overline{y / x}] ) \subseteq \overline{y}, \overline z$
\\
Therefore
\\
$(d) \  \  \fv(A[\overline{y / x}] ) \setminus {\overline y } \subseteq  \overline z$
\\
The above, together with (b) conclude the proof
 \end{enumerate}
\end{proof} 
% \noindent \textbf{End Proof}


\begin{lemma}[Substitutions and Adaptations]
\label{l:sybbs:adapt}
For any sequences of variables $\overline x$, $\overline y$, sequences of expressions $\overline e$, and   any assertion $A$, we have
\begin{itemize}
\item
$ \overline x \# \overline y \ \ \ \Longrightarrow \ \ \  \PushAS {y} {(A[\overline {e/x}])}  \txteq   (\PushAS {y} {A})[\overline{ e/x}] $
\end{itemize}

\end{lemma}

\begin{proof}

\noindent 
We first consider $A$ to be $\inside e_0$, and just take one variable. Then, \\
$\strut \ \ \ \ { \PushAS  {y} { (\inside {e_0}[e/x] ) } }
 \ \txteq\  {\protectedFrom {e_0[ {e/x}]} {y}}$, \\
and\\
$\strut \ \ \ \ (\PushAS {y} {\inside {e_0}})[e/x] \  \txteq\  \protectedFrom {e_0[{e/x}]} {y[ {e/x}]}$. \\
When $x \# y$  then the two assertions from above  are textually equal.
The rest follows by induction on the length of $\overline x$ and the structure of $A$.
\end{proof}
 

\begin{lemma}
 \label{l:sfs:eight}
For   assertion  $A$, variables $\overline {x}$, $\overline v$, $\overline y$, $\overline w$, $\overline {v_1}$,
%  and $\overline {v_2}$,  
addresses  $\overline {\alpha_x}$, $\overline {\alpha_y}$, $\overline {\alpha_v}$, and $\overline {\alpha_{v_1}}$

\noindent
If
\begin{enumerate}[a.]
\item
\label{l:sfs:eight:one}
 $\fv(A)\, \txteq \, \overline {x}; \overline v$, \ \ \ $\fv(A[\overline{y / x}] )\, \txteq  \,   \overline y; \overline w$, 
\item
\label{l:sfs:eight:two}
$ \forall x\in {\overline x}.[\ x[\overline{y/x}]  [\overline{\alpha_y/y}]\ =\  x[\overline{\alpha_x/x} ]  \ ]$
\item
\label{l:sfs:eight:three}
$\overline v \txteq  \overline {v_1}; \overline w$, \ \ \ $\overline {v_1}\txteq  \overline y\cap \overline v$, \ \ \ $ \overline {\alpha_{v,1} } = \overline {v_1}[\overline{\alpha_v/v} ]$
\end{enumerate}

\noindent
then

\begin{itemize}
\item
  $ A [\overline{y/x}] [\overline{\alpha_y/y}]% [\overline{\alpha_w/w}] 
  \txteq A [\overline{\alpha_x/x}] [\overline{\alpha_{v,1}/v_1}] $%[\overline{\alpha_w/w}] $
\end{itemize}

\end{lemma}

\begin{proof}
$ ~ $

From Lemma \ref{l:sfs}, part \ref{l:sfs:five}, we obtain\  \ \ $(*)\ \  \overline v \, = \, (\overline {y}\cap\overline{v}); \overline w $

We first prove that \\
$\strut \hspace{3cm} \ \  (**) \ \  \forall z\in \fv(A)[\ z [\overline{y/x}] [\overline{\alpha_y/y}]   \txteq z [\overline{\alpha_x/x}] [\overline{\alpha_{v,1}/v_1}] $.
 
Take any arbitrary $z\in \fv(A)$. \\
Then, by assumptions \ref{l:sfs:eight:one} and \ref{l:sfs:eight:three}, and (*) we have that either $z\in \overline x$, or $z\in \overline {v_1}$, or 
$z\in \overline {w}$.
 
  \begin{description}
 \item
 [  {1st Case}]  
 $z\in \overline x$. 
 Then, there exists some $y_z\in \overline y$, and some $\alpha_z \in \overline {\alpha_y}$, such that    $z[\overline{y/x}]=y_z$  and
  $y_z [\overline{\alpha_y/y}] = \alpha_z$. 
  On the other hand,   by part \ref{l:sfs:eight:two} we obtain, that  $z[\overline{\alpha_x/x}] =\alpha_z$.
  And because $\overline {v_1}\# \overline {\alpha x}$ we also have that $\alpha_z[\overline{\alpha_{v,1}/v_1}] $=$\alpha_z$. 
  This concludes the case.
  \item
   [  {2nd Case}]  
$ z\in \overline {v_1}$, which means that $ z\in \overline {y}\cap\overline{v}$. Then, because $\overline x \# \overline  v$, we have that $z[\overline{y/x}]=z$. 
And because $z\in \overline y$, we obtain that there exists a $\alpha_z$, so that  $z [\overline{\alpha_y/y}] = \alpha_z$.
Similarly, because  $\overline x \# \overline  v$, we also obtain that $z[\overline{\alpha_x/x}]=z$.
And because $\overline {v_1} \subseteq \overline y$, we also obtain that $z[\overline {\alpha_{v,1}/v_1}]$=$z[\overline {\alpha_{y}/y}]$.
This concludes the case.
  \item
     [   {3rd Case}]  
  $z\in \overline {w}$. From part  \ref{l:sfs:eight:one} of the assumptions and from (*) we obtain  $\overline {w} \#  \overline {y}\# \overline {x}$, which implies  that $z [\overline{y/x}] [\overline{\alpha_y/y}]$=$z$.
  Moreover, (*) also gives that $\overline {w} \#  \overline {v_1}$, and this gives that
  $z[\overline{\alpha_x/x}] [\overline{\alpha_{v,1}/v_1}] $=$z$.
  This concludes the case
\end{description}

The lemma follows from (*) and structural induction on $A$.
\end{proof}


\input{appendixReachAndSim}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preservation of assertions when pushing or popping frames}

In this section we  discuss the preservation of satisfaction of assertions when calling methods or returning from methods -- \ie when pushing or popping  frames. 
Namely, since  pushing/popping frames  does not modify the heap, these operations should preserve satisfaction of some assertion $A$, up to the fact that a) passing an object as a parameter of a a result might break its protection, and 
b) the bindings of variables change  with pushing/popping frames.
To deal with a)  upon method call, 
we   require that the fame being pushed or the frame to which we return is internal ($M, \sigma' \models \intThis$), or require the adapted version of an assertion (\ie  ${\PushAS  {v} { A}}$ rather than $A$).
To deal with b) we either require that there are no free variables in $A$, or we break the free variables of $A$ into two parts, \ie $\fv(\Ain) =  \overline{v_1};\overline{v_2}$, where the value of $\overline{v_3}$ in the caller is the same as that of  $\overline{v_1}$ in the called frame.
%To deal with b) upon method return, we also break the free variables of $A$ into two parts, \ie $\fv(\Ain) =  \overline{v_1}, \overline{v_2}$, where the value of $\overline{v_1}$ in the callee is the same as that of  i$\overline{v_3}$ in the caller.
%And in both cases   $\overline {v_2}$ do not necessarily have a value in the callee frame.
This   is described in  lemmas \ref{l:calls} -  \ref{l:calls:return}.

We have four lemmas: Lemma \ref{l:calls} describes preservation from a caller to an internal called, lemma \ref{l:calls:external}
describes preservation from a caller to any called, Lemma \ref{l:calls:return} describes preservation from an internal called to a caller, and  Lemma \ref{l:calls:return:ext} describes preservation from an any called to a caller, 
These four lemmas are used in the soundness proof for the four Hoare rules   about method calls, as given in Fig. \ref{f:calls}. 

In the rest of this  section we will first introduce some further auxiliary concepts and lemmas, 
and then state, discuss  and  prove Lemmas \ref{l:calls} -  \ref{l:calls:return}.  

 \input{appendixSoundPreserveAux}
 
 \subsection{Preservation of assertions when pushing or popping frames -- stated and proven}
 %%%% From caller to called %%%
\begin{lemma}[From caller to internal called]
\label{l:calls}

For any assertion $\Ain$, states $\sigma$, $\sigma'$,  
variables  $\overline{v_1}$,    $\overline{v_2}$,  $\overline{v_3}$,  $\overline{v_4}$,  $\overline{v_6}$,  % addresses $\overline \alpha_2$ and $\overline \alpha_4$, 
and frame $\phi$.

\noindent
% $ ~ $ % and $\overline{y'}$,  \\
If 
\begin{enumerate}[(i)]
\item 
\label{l:calls:r:one}
$ \Pos \Ain$,  
\item 
\label{l:calls:r:two}
$\fv(\Ain) =  \overline{v_1}; \overline{v_2} $\footnote{As we said earlier. this gives  also that the variable sequences  are pairwise disjoint, \ie $\overline{v_1}\#\overline{v_2}$.},
\ \ \ 
$\fv(\Ain[\overline {v_3/v_1}]) =  \overline{v_3}; \overline{v_4} $, \ \ \ \ 
$ \overline {v_6}\triangleq\overline{v_2}\cap\overline{v_3}; \overline{v_4} $, 
\item
\label{l:calls:r:three}
$\sigma'=\sigma  \pushSymbol \phi  \ \ \ \  \wedge\ \ \  Rng(\phi)= \overline{\interpret {\sigma} {v_3} }$
\item
\label{l:calls:r:four}
 $\overline {\interpret {\sigma'}  {v_1} } = \overline {\interpret {\sigma} {v_3} }$, 

\end{enumerate}

\noindent
then

\begin{enumerate}[a.]
\item
\label{l:calls:callee:one}
$\satDAssertFrom M  \sigma k   \Ain[\overline {v_3/v_1}] % [\overline {\alpha_2/v_2}] \ \   
\ \ \wedge\ \ M, \sigma' \models \intThis
%   $  \\  $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \   \ \satDAssertFrom M  {\sigma'} k  {\Ain[\overline { {\interpret {\sigma} {v_6}} / {v_6} } ] } $
 
\item

\label{l:calls:callee:two}
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\overline {v_3})} {(\Ain[\overline {v_3/v_1}])}} 
%  $ \\  $\strut \hspace{2cm}  
\hfill \Longrightarrow  \ \ \  \   \ \ \  \  
M, \sigma' \models   {\Ain\overline { {\interpret {\sigma} {v_6}} / {v_6} } ] }$.

\end{enumerate}

\end{lemma}


 

\paragraph{Discussion of Lemma} In lemma \ref{l:calls},   state $\sigma$ is the state right before pushing the new frame on the stack,   while 
state $\sigma'$ is the state right after pushing the frame on the stack.
That is, $\sigma$ is the last state before entering the method body, and $\sigma'$ is the first state after entering the method body.
$\Ain$ stands for the method's precondition, while the variables $\overline {v_1}$ stand for the formal parameters of the method,
and $\overline {v_3}$ stand for the actual parameters of the call.
Therefore, $\overline {v_1}$ is the domain of the new frame, and $\overline {\sigma} {v_3}$ is its range.
The variables $\overline {v_6}$ are the free variables of $\Ain$ which are not in  $\overline {v_1}$ -- \cf Lemma \ref{l:sfs} part
( \ref{l:sfs:five}).
Therefore if (\ref{l:calls:callee:one})  the callee is internal, and 
 $\Ain[\overline {v_3/v_1}]$ holds  at the call point, or
 if (\ref{l:calls:callee:two}) ${\PushASLong  {(\overline {v_3})} {(\Ain[\overline {v_3/v_1}])}}$
 holds  at the call point, 
 then $\Ain[\overline {.../v_61}]$  holds right after pushing $\phi$ onto the stack.
Notice the difference in the conclusion in (\ref{l:calls:callee:one}) and (\ref{l:calls:callee:two}): in the first case we have \scoped satisfaction, while in the second case we only have shallow satisfaction.

\begin{proof} $ ~ $ 

We will use $\overline {\alpha_1}$ as short for $\{\interpret {\sigma'} {v_1}$, and $\overline {\alpha_3}$ as short for $\overline {\interpret \sigma {v_3} }$.
\\
We aslo define  $\overline{v_{6,1}} \triangleq \overline{v_2} \cap \overline{v_3}$, \ \ 
   $\overline {\alpha_{6,1}} \triangleq  \overline {v_{6,1}} [\overline {\interpret {\sigma} {v_6}/v_6 }]$
\\
We  establish that\\
$\ \strut \ \  (*) \ \ \  \Ain[\overline {v_3/v_1}][\overline { {\interpret \sigma {v_3} }/v_3 }] \txteq \Ain[\overline  {\alpha_1/v_1}][\overline { \alpha_{6,1}/v_{6,1}}] $\\
This holds by  By Lemma \ref{l:sfs:eight} and assumption \ref{l:calls:r:four} of the current lemma.
\\
And we define    $\overline{v_{6,2}} \triangleq \overline{v_2} \setminus \overline{v_3}$, \ \ 
       $\overline {\alpha_{6,2}} \triangleq  \overline {v_{6_2}} [\overline {\interpret {\sigma} {v_6}/v_6 }]$.


\begin{enumerate}[a.]
\item
Assume  \\
  $\satDAssertFrom M  \sigma k   \Ain[\overline {v_3/v_1}] $. 
      \ \ \ \ \ By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
$\satDAssertFrom M  \sigma k   \Ain[\overline {v_3/v_1}][\overline { {\alpha_3}/v_3 }] $   
      \ \ \ \ \ By (*) from above we have\\
$\satDAssertFrom M  \sigma k   \Ain[\overline  {\alpha_1 /v_1}  [\overline { \alpha_{6,1}/v_{6,1}}] $ \\    
$\strut \hspace{2cm}  $ The above, and   Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}  give that\\
$\satDAssertFrom M  \sigma k   \Ain[\overline { \alpha_1/v_1}]  [\overline { \alpha_{6,1}/v_{6,1}}]  [\overline { \alpha_{6,2}/v_{6,2}}]$ 
\\ The assertion above is variable-free.Therefore,  by Lemma \ref{l:aux:aux:caller:called} part \ref{l:aux:aux:caller:called:one} we also obtain\\ 
$\satDAssertFrom M   {\sigma'} k   {\Ain[\overline {\alpha_1/v_1}]  [\overline { \alpha_{6,1}/v_{6,1}}]  [\overline { \alpha_{6,2}/v_{6,2}}]}$ \\
With  \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} the above gives \\
$\satDAssertFrom M  {\sigma'}  k  { \Ain[\overline{  \interpret {\sigma'} {v_1}/v_1}]  [\overline {  \interpret {\sigma} {v_6}/v_6 }]}$\\
 By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}, we obtain \\
$\satDAssertFrom M   {\sigma'}  k  { \Ain   [\overline {  \interpret {\sigma} {v_6}/v_6 }]}$
\item
Assume\\
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\overline {v_3})} {(\Ain[\overline {v_3/v_1}])}}$. 
 \ \ \ \ \ By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
 $ \satDAssertFrom M  \sigma k    {(\PushASLong  {(\overline {v_3})} {(\Ain[\overline {v_3/v_1} ])}) [\overline { {\alpha_3}/v_3 }] }$
 \ \ \ \ \ which implies that\\
$ \satDAssertFrom M  \sigma k   { \PushASLong  {(\overline {\alpha_3})} {(\Ain[\overline {v_3/v_1} ][\overline { {\alpha_3}/v_3 }]) }  }$
      \ \ \ \ \ By (*) from above we have\\
$\satDAssertFrom M  \sigma k  { \PushASLong  {(\overline {\alpha_3})}  {( \Ain[\overline  {\alpha_1 /v_1}]  [\overline { \alpha_{6,1}/v_{6,1}}] )}}$
 \\
$\strut \hspace{2cm}  $The above, and   Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}  give that\\
 $\satDAssertFrom M  \sigma k  {({ \PushASLong  {(\overline {\alpha_3})}  {( \Ain[\overline  {\alpha_1 /v_1} ] [\overline { \alpha_{6,1}/v_{6,1}}] )}}
 ) [\overline  {\alpha_{6,2} /v_{6,2}} ] }$
  \\
$\strut \hspace{2cm}  $ And the above gives\\
 $\satDAssertFrom M  \sigma k  { \PushASLong  {(\overline {\alpha_3})}  {( \Ain[\overline  {\alpha_1 /v_1} ] [\overline { \alpha_{6,1}/v_{6,1}}]  [\overline  {\alpha_{6,2} /v_{6,2}} ] ) }} $
  \\
The assertion above is variable-free.Therefore,  by Lemma \ref{l:aux:aux:caller:called} part \ref{l:aux:aux:caller:called:two} we also obtain\\ 
$ M  \sigma' \models  {   {  \Ain[\overline  {\alpha_1 /v_1} ] [\overline { \alpha_{6,1}/v_{6,1}}]  [\overline  {\alpha_{6,2} /v_{6,2}} ] }} $  
  \\
We apply Lemma  \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}, and  Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}, and obtain \\
$ M,   {\sigma'}  \models  { \Ain   [\overline {  \interpret {\sigma} {v_6}/v_6 }]}$  
  
  
\end{enumerate}


\end{proof}
%%% calling external

\begin{lemma}[From caller to any called]
\label{l:calls:external}

For any assertion $\Ain$, states $\sigma$, $\sigma'$,  
variables   $\overline{v_3}$  
statement $stmt$, and frame $\phi$.

\noindent
If 
\begin{enumerate}[(i)]
\item 
\label{l:calls:ext:re:one}
$ \Pos \Ain$,  
\item 
\label{l:callsext:re:two}
$\fv(\Ain) =  \emptyset$,
\item
\label{l:calls:ext:re:three}
$\sigma'=\sigma  \pushSymbol \phi  \ \ \ \  \wedge\ \ \  Rng(\phi)= \overline{\interpret {\sigma} {v_3} },$
\end{enumerate}

\noindent
then

\begin{enumerate}[a.]
\item
\label{l:calls:callee:three}
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\overline {v_3})} {\Ain} }  \hfill \Longrightarrow  \ \ \  \   \ \ \  \   M, \sigma' \models   {\Ain} $.
 
\item
\label{l:calls:callee:four}
$\satDAssertFrom M  \sigma k    {(\Ain  \wedge  ({\PushASLong  {(\overline {v_3})} {\Ain} } ) )}    \hfill \Longrightarrow  \ \ \  \   \satDAssertFrom M  {\sigma'} k  {\Ain}$

\end{enumerate}

\end{lemma}

\begin{proof}
\begin{enumerate}[a.]
\item
Assume that \\
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\overline {v_3})} {\Ain} }$\\
	By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
$ \satDAssertFrom M  \sigma k    {\PushASLong  {(\interpret {\sigma} {v_3})} {\Ain} }$.\\
We now have a variable-free assertion, and by Lemma \ref{l:aux:aux:caller:called}, part \ref{l:aux:aux:caller:called:two}, we obtain\\
$ M,  \sigma'    \models \Ain$.
\item
Assume that \\
$ \satDAssertFrom M  \sigma k    {\Ain \wedge \PushASLong  {(\overline {v_3})} {\Ain} }$\\
	By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
$ \satDAssertFrom M  \sigma k    {\Ain \wedge \PushASLong  {(\interpret {\sigma} {v_3})} {\Ain} }$.\\
We now have a variable-free assertion, and by Lemma \ref{l:aux:aux:caller:called}, part \ref{l:aux:aux:caller:called:two}, we obtain\\
$ \satDAssertFrom M  {\sigma'} k  \models \Ain$.
\end{enumerate}

\end{proof}

\paragraph{Discussion of Lemma \ref{l:calls:external}} In this lemma,  as in  lemma \ref{l:calls}, 
  $\sigma$ stands for the last state before entering the method body, and $\sigma'$ for the first state after entering the method body.
$\Ain$ stands for a module invariant in which all free variables have been substituted by addresses.
The lemma is intended for external calls, and therefore we have no knowledge of the method's formal parameters.
The variables   $\overline {v_3}$ stand for the actual parameters of the call, and therefore 
 $\overline {\interpret {\sigma} {v_3}}$ is the range of the new frame.
Therefore if (\ref{l:calls:callee:three})   the adapted version,
 ${\PushASLong  {(\overline {v_3})} {\Ain} }$, holds  at the call point,
 then the unadapted version, $\Ain$  holds right after pushing $\phi$ onto the stack.
 Notice that  even though the premise of (\ref{l:calls:callee:three}) requires \scoped satisfaction, the conclusion promises
 only weak satisfaction.
 Moreover, if (\ref{l:calls:callee:four})   the adapted as well as the unadapted version,
 $\Ain \wedge {\PushASLong  {(\overline {v_3})} {\Ain} }$
 holds  at the call point,
 then the unadapted version, $\Ain$  holds right after pushing $\phi$ onto the stack.
Notice the difference in the conclusion in (\ref{l:calls:callee:three}) and (\ref{l:calls:callee:four}): in the first case we have  shallow satisfaction, while in the second case we only have \scoped satisfaction.


%%% From called back to caller

\begin{lemma}[From internal called to caller]
\label{l:calls:return}

For any assertion $\Aout$, states $\sigma$, $\sigma'$, variables $res$, $u$ variable sequences  $\overline{v_1}$, $\overline{v_3}$,   $\overline{v_5}$,  and statement $stmt$.

\noindent
 If 
 
\begin{enumerate}[(i)]
\item 
\label{l:calls:r:one}
$ \Pos \Aout$,  
\item 
\label{l:callers:r:two}
$\fv(\Aout) \subseteq  \overline{v_1} $,
\item
$  \overline {\interpret {\sigma'} {v_5}}, {\interpret {\sigma} {res}} \subseteq \LRelevantO \sigma  \ \ \wedge \ \  M, \sigma' \models \intThis$.
 \item
\label{l:callers:three}
\label{l:calls:return:three}
$\sigma'= (\sigma \popSymbol)[ u  \mapsto  {\interpret {\sigma} {res}}][\prg{cont}\!\mapsto\! stmt]
\ \ \wedge \ \   \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$.
  \end{enumerate}
  
\noindent
then

\begin{enumerate} [a.]
\item
\label{l:calls:caller:one}
$\satDAssertFrom M  \sigma k   {\Aout \, \wedge\,  {(\PushASLong  {res} {\Aout})} }\ \  \wedge\ \ \DepthSt {\sigma'} \geq k  \ 
%$ \\ $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \   \satDAssertFrom M  {\sigma'} k   {\Aout[\overline {v_3 / v_1}]  }$ .
 \item
 \label{l:calls:caller:two}
 $M, \sigma \models  {\Aout}\ % \ \wedge\ \  \overline {\interpret {\sigma'} {v_5}} \subseteq \LRelevantO \sigma
%  $ \\   $\strut \hspace{2cm} 
 \hfill \Longrightarrow  \ \ \  \  %
 \satDAssertFrom M  {\sigma'} k   {\PushASLong  {\overline {v_5}}    {(\Aout[\overline { v_3/v_1}])} }$. 
\end{enumerate}

\end{lemma}


\paragraph{Discussion of Lemma \ref{l:calls:return}}  
 State  $\sigma$ stands for the last state in the method body, and $\sigma'$ for the first state after exiting  the method call.
$\Aout$ stands for a method postcondition.
The lemma is intended for internal calls, and therefore we know the method's formal parameters.
The variables   $\overline {v_1}$ stand for the formal  parameters of the method, and  $\overline {v_3}$ stand for the actual parameters of the call.
Therefore the   formal parameters of the called have the same values as the actual parameters in the caller
  $  \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$.
% $\overline {\interpret {\sigma} {v_3}}$ is the range of the new frame.
Therefore   ( \ref{l:calls:caller:one})  and  (\ref{l:calls:caller:two})  
promise that if the postcondition $\Aout$ holds before popping the frame, then it also holds after popping frame after replacing the 
the formal parameters by the actual parameters $\Aout[\overline{v_3/v_1}]$.
As in earlier lemmas, there is an important difference between  (\ref{l:calls:caller:one}) and (\ref{l:calls:caller:two}):
In (\ref{l:calls:caller:one}), we require \emph{deep satisfaction at the called}, 
and obtain at the deep satisfaction of the \emph{unadapted} version ($\Aout[\overline{v_3/v_1}]$) at the return point;
while in (\ref{l:calls:caller:two}), we only require \emph{shallow satisfaction at the called}, 
and obtain deep satisfaction of the \emph{adapted} version (${\PushASLong  {\overline {v_5}}    {(\Aout[\overline { v_3/v_1}])} }$),
at the return point.

\begin{proof}$ ~ $

We use the following short hands: $\alpha$ as   $\overline {\interpret {\sigma} {res}}$, 
\ \ \ \ 
$\overline {\alpha_1}$   for $\overline {\interpret {\sigma} {v_1}}$, \ \ \ 
$\overline {\alpha_5}$ as short for $\overline {\interpret {\sigma'} {v_5}}$.

\newcommand{\substOne}{[\overline{\alpha_1/v_1}]}
\newcommand{\substFive}{[\overline{\alpha_5/v_5}]}

\begin{enumerate}[a.]
\item
Assume that \\
$\satDAssertFrom M  \sigma k   {\Aout  \wedge  {\PushASLong  {res} {\Aout} } } $\\
	By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
$ \satDAssertFrom M  \sigma k   {\Aout\substOne  \wedge  {\PushASLong  {\alpha} {(\Aout\substOne)} } }$.\\
We now have a variable-free assertion,
and by Lemma \ref{l:aux:aux:called:caller}, part \ref{l:aux:aux:called:caller:one}, we obtain\\
$ \satDAssertFrom M  \sigma k   {\Aout\substOne} $.\\
By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}, and because $ \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$  this  implies that \\
$ \satDAssertFrom M  \sigma k   {\Aout[\overline { v_3/v_1}] } $.
\item
Assume that \\
$M,  \sigma\models \Aout  $\\
By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
$M,  \sigma\models \Aout\substOne$\\
We now have a variable-free assertion,
and by Lemma \ref{l:aux:aux:called:caller}, part \ref{l:aux:aux:called:caller:two}, we obtain\\
$ \satDAssertFrom M  {\sigma'} k    {\PushASLong {\overline \alpha_5} {\Aout\substOne}}$\\
By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}, and because $ \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$  and $\alpha_5 = \overline {\interpret {\sigma'} {v_5}}$, we obtain \\
$ \satDAssertFrom M  {\sigma'} k    {\PushASLong {\overline v_5} {\Aout[\overline {v_3/v_1}]}}$
\end{enumerate}

\end{proof}



\begin{lemma}[From any called to caller]
\label{l:calls:return:ext}

For any  assertion $\Aout$, states $\sigma$, $\sigma'$, variables $res$, $u$ variable sequence   $\overline{v_5}$,  and statement $stmt$.

\noindent
 If 
 
\begin{enumerate}[(i)]
\item 
$ \Pos \Aout$,  
\item 
 $\fv(\Aout) = \emptyset$,
\item
$  \overline {\interpret {\sigma'} {v_5}}, {\interpret {\sigma} {res}} \subseteq \LRelevantO \sigma $.
 \item
$\sigma'= (\sigma \popSymbol)[ u  \mapsto  {\interpret {\sigma} {res}}][\prg{cont}\!\mapsto\! stmt]$.
  \end{enumerate}
 \noindent
then

\begin{enumerate}[a.]
\item
 \label{l:ext:return:one}
 $M, \sigma \models  {\Aout}\  
 \hfill \Longrightarrow  \ \ \  \  \satDAssertFrom M  {\sigma'} k  {\PushASLong  {(\overline {v_5})}    {\Aout}}$.

\item
\label{l:ext:return:two}
$\satDAssertFrom M  \sigma k   \Aout  \ \  \wedge\ \ \DepthSt {\sigma'} \geq k  \ 
 \hfill \Longrightarrow  \ \ \  \   \satDAssertFrom M  {\sigma'} k   {\Aout \, \wedge\, {\PushASLong  {(\overline {v_5})}    {\Aout}}} $

 
\end{enumerate}

\end{lemma}

\begin{proof}$ ~ $


\begin{enumerate}[a.]
\item
Assume that \\
$\strut \ \ \ M, \sigma \models  {\Aout}$\\
Since $\Aout$ is a variable-free assertion,  by   Lemma \ref{l:aux:aux:called:caller}, part \ref{l:aux:aux:called:caller:one}, we obtain\\  
$\strut \ \ \ \satDAssertFrom M  {\sigma'} k   {\PushASLong  {(\overline {\interpret {\sigma'} {v_5}})}    {\Aout}}$.\\
By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one},  we obtain \\
$\strut \ \ \ \satDAssertFrom M  {\sigma'} k  {\PushASLong  {(\overline {v_5})}    {\Aout}}$
\item
Similar argument to the proof of Lemma \ref{l:calls:return}, part (b).
%$M,  \sigma\models \Aout  $\\
%By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one} this  implies that \\
%$M,  \sigma\models \Aout\substOne$\\
%We now have a variable-free assertion,
%and by Lemma \ref{l:aux:aux:called:caller}, part \ref{l:aux:aux:called:caller:two}, we obtain\\
%$ \satDAssertFrom M  {\sigma'} k    {\PushASLong {\overline \alpha_5} {\Aout\substOne}}$\\
%By Lemma \ref{l:assrt:unaffect} part \ref{l:assrt:unaffect:one}, and because $ \overline {\interpret {\sigma} {v_1} }\, =\,  \overline {\interpret {\sigma'}  {v_3} }$  and $\alpha_5 = \overline {\interpret {\sigma'} {v_5}}$, we obtain \\
%$ \satDAssertFrom M  {\sigma'} k    {\PushASLong {\overline v_5} {\Aout[\overline {v_3/v_1}]}}$
\end{enumerate}

\end{proof}


\paragraph{Discussion of lemma  \ref{l:calls:return:ext}}, Similarly to  lemma \ref{l:calls:return},  
in this lemma, state  $\sigma$ stands for the last state in the method body, and $\sigma'$ for the first state after exiting  the method call.
$\Aout$ stands for a method postcondition.
The lemma is meant to apply to external calls, and therefore, we do not know the method's formal parameters, 
$\Aout$ is meant to stand for a module invariant where all the free variables have been substituted by addresses --
\ie $\Aout$ has no free variables.
The variables $\overline {v_3}$ stand for the actual parameters of the call.
Parts    (\ref{l:ext:return:one})  and  (\ref{l:ext:return:two})
promise that if the postcondition $\Aout$ holds before popping the frame, then it its adapted version 
also holds after popping frame (${\PushASLong  {\overline {v_5}}    {\Aout}}$).
 As in earlier lemmas, there is an important difference between   (\ref{l:ext:return:one})  and  (\ref{l:ext:return:two})
In  (\ref{l:ext:return:one}),  we require \emph{shallow satisfaction at the called}, 
and obtain   deep satisfaction of the \emph{adapted} version (${\PushASLong  {\overline {v_5}}    {\Aout}}$) at the return point;
while in (\ref{l:ext:return:two}), we  require \emph{deep satisfaction at the called}, 
and obtain deep satisfaction of the   \emph{conjuction}  of the \emph{unadapted} with the \emph{adapted} version (${\Aout \, \wedge\, {\PushASLong  {\overline {v_5}}    {\Aout}}}$),
at the return point.

\subsection{\textbf{Use of Lemmas \ref{l:calls}-\ref{l:calls:external} }}

As we said earlier, Lemmas \ref{l:calls}-\ref{l:calls:external} are used to prove the soundness of the Hoare logic rules for method calls.

In the proof of soundness of {\sc{Call\_Int}}. we will use Lemma \ref{l:calls} part (\ref{l:calls:callee:one}) and Lemma \ref{l:calls:return} part (\ref{l:calls:caller:one}).  
In the proof of soundness of {\sc{Call\_Int\_Adapt}} we will use  Lemma \ref{l:calls} part (\ref{l:calls:callee:two}) and Lemma \ref{l:calls:return} part (\ref{l:calls:caller:two}).
In the proof of soundness of {\sc{Call\_Ext\_Adapt}} we will use  Lemma \ref{l:calls:external} part (\ref{l:calls:callee:three}) and Lemma \ref{l:calls:return:ext} part (\ref{l:ext:return:one}).
And finally, in the proof of soundness of {\sc{Call\_Ext\_Adapt\_Strong}} we will use  Lemma \ref{l:calls:external} part (\ref{l:calls:callee:four}) and Lemma \ref{l:calls:return:ext} part (\ref{l:ext:return:two}).



 



 
 
  