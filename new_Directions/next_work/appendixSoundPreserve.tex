

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preservation of assertions when pushing or popping frames}

In this section we  discuss the preservation  assertions when pushing and popping of frames. 
The result of this discussion is  lemma \ref{l:calls}. 
 which will be used when we prove soundness of the rules about method calls, as given in Fig. \ref{f:calls}. 

%We will first state  lemma \ref{l:calls}, then discuss it, and a then we will define and prove a sequence of concepts and 
% lemmas which we will use in the proof of lemma \ref{l:calls}.
 
\begin{lemma}
\label{l:calls}
For states $\sigma$, $\sigma'$, assertion $A$, %,  such that $\fv(A)=\emptyset$, 
variables  $\overline{v_1}$,    $\overline{v_2}$,  $\overline{v_3}$,   $\overline{v_4}$,    $\overline{v_5}$,  and  $\overline{v_6}$,
addresses $\overline \alpha_3$, and $\overline \alpha$, statement $stmt$, and frame $\phi$.

\noindent
% $ ~ $ % and $\overline{y'}$,  \\
If 
\begin{enumerate}[(i)]
\item 
\label{l:calls:r:one}
$ \Pos A$,  
\item 
\label{l:calls:r:two}
$\overline {v_3} =\fv(A) \setminus \{  \overline{v_1} , \overline{v_2} \}$ % \,  \subseteq \, \overline{v_3}$, 
\item 
\label{l:calls:r:three}
 $\overline{v_1} \cap \overline{v_2}\  =\ \emptyset\ = \ \overline{v_3} \cap \overline{v_6}$,
\item 
\label{l:calls:r:four}
 $\overline {\interpret {\sigma'} {v_1} } = \overline {\interpret {\sigma} {v_1} }$, \ \ and\ \  $\overline {\interpret {\sigma'}  {v_2} } = \overline {\interpret {\sigma} {v_4} }$, \ \ and \ \  $\overline {\interpret {\sigma}  {v_3} } = \overline {\alpha_3}$,   
\end{enumerate}
 then 
\begin{enumerate}

\item
\label{l:calls:callee}
$\sigma'=\sigma  \pushSymbol \phi  \ \ \ \   \Longrightarrow$

\begin{enumerate}
\item
\label{l:calls:callee:one}
$\satDAssertFrom M  \sigma k   A[\overline {v_4/v_2}] \ \    \wedge\ \ M, \sigma' \models \intThis  
% $\\
 \hfill  \Longrightarrow\ \ \ \ \ \ \  \ \satDAssertFrom M  {\sigma'} k   A[\overline { \alpha_3/v_3}]$.

\item
\label{l:calls:callee:two}
$% \satDAssertFrom M  \sigma k   {\PushAS  {v_5} { A[\overline {v_4/v_2}] }} 
M, \sigma \models {\PushAS  {v_5} { A[\overline {v_4/v_2}] }}  \ \ \wedge\ \ Range(\phi)=\overline {\interpret {\sigma} {v_5}}
\hfill \Longrightarrow  \ \ \ \  \   \ \ \ \ %\satDAssertFrom M  {\sigma'} {\DepthSt {\sigma'}}  {A[\overline  {\alpha_3/v_3}]}$.
M, \sigma' \models  {A[\overline  {\alpha_3/v_3}]}$.

\item
\label{l:calls:callee:three}
$\satDAssertFrom M  \sigma k   {A[\overline {v_4/v_2}]  \wedge (\PushAS  {v_5} { A[\overline {v_4/v_2}] )}}  \ \ \wedge\ \ Range(\phi)=\overline {\interpret {\sigma} {v_5}}
  $\\  $
\strut \hspace{5cm} \hfill \Longrightarrow \ \ \ \ \ \ \  \   \satDAssertFrom M  {\sigma'} k  {A[\overline { \alpha_3/v_3}]}$.


\end{enumerate}
\item
\label{l:calls:caller}
$\sigma'= (\sigma \popSymbol)[\overline{ v_6\! \mapsto\! \alpha}][\prg{cont}\!\mapsto\! stmt]
 \ \ \ \   \Longrightarrow$ 

\begin{enumerate}
\item
\label{l:calls:caller:one}
$\satDAssertFrom M  \sigma k   A[\overline {v_4/v_2}] \ \  \wedge\ \ \DepthSt {\sigma'} \geq k  \wedge\ \ M, \sigma' \models \intThis
\hfill \Longrightarrow   \ \ \ \ \ \ \  \   \satDAssertFrom M  {\sigma'} k   {A[\overline { \alpha_3/v_3}]}$ 

\item
\label{l:calls:caller:two}
%$\satDAssertFrom M  \sigma k   A[\overline {v_4/v_2}] \ \ 
$M, \sigma \models  {A[\overline  {v_4/v_2}]}\ \ \wedge\ \  \overline \alpha,  \overline {\interpret {\sigma'} {v_5}} \subseteq \LRelevantO \sigma
\hfill \Longrightarrow   \ \ \ \ \ \ \  \  M , \sigma' \models  {\PushASLong  {\overline {v_5}}   {{(A[\overline {\alpha_3/v_3}])}}}$

\item
\label{l:calls:caller:three}
$\satDAssertFrom M  \sigma k   {A[\overline  {v_4/v_2}]} \ \ \wedge\ \  \overline \alpha, \overline {\interpret {\sigma'} {v_5}} \subseteq \LRelevantO \sigma  $\\  $\strut \hspace{5cm} \hfill \Longrightarrow  \ \ \ \ \ \ \  \  \satDAssertFrom M  {\sigma'} k    {{{(A[\overline {\alpha_3/v_3}])}} \wedge \PushASLong  {\overline {v_5}}   {{(A[\overline {\alpha_3/v_3}])}}}$

 \end{enumerate}
\end{enumerate}

\end{lemma}


TODO: discuss the cases, and write the proof

Note that in  parts \ref{l:calls:caller:two} and \ref{l:calls:caller:three} we have ${\PushASLong  {\overline {v_5}}   {{(A[\overline {\alpha_3/v_3}])}}}$, and not $({\PushASLong  {\overline {v_5}}   A})[\overline {\alpha_3/v_3}]$.  The two assertions differ when $\overline {v_5}$ and $\overline {v_3}$ overlap.
%\begin{lemma}
%\label{l:calls:old}
%For states $\sigma$, $\sigma'$, assertion $A$, %,  such that $\fv(A)=\emptyset$, 
%variables  $u$, $u'$, $y_0$, $\overline{x}$, and  $\overline{y}$\footnote{We take $\overline y$ to stand for $y_1, ... y_n$}, statement $stmt$, frame $\phi$.
%
%$ ~ $ % and $\overline{y'}$, 
%\\
%If 
% $\overline{x}=\fv(A)\setminus\{ {\overline{y}} \cup \prg{this} \}$, and 
% %= \ \wedge \ \ 
% $ \Pos A$, then
%  
%\begin{enumerate}
%
%\item
%\label{l:calls:callee}
%$\sigma'=\sigma  \pushSymbol \phi \ \ \wedge \ \  dom(\phi)=\overline{y}\cup \{ \prg{this} \}\ \ \wedge\ \ 
%\overline{y} \subseteq dom(\sigma)\ \  \wedge\ \
%\interpret \sigma {y_0} = \interpret \phi {\prg{this}}\ \ \wedge \ \ 
%\overline{ {\interpret \sigma y}= {\interpret {\sigma'} y}}$\\
%implies
%
%\begin{enumerate}
%\item
%\label{l:calls:callee:one}
%$\satDAssertFrom M  \sigma k   A[y_0/\prg{this}] \ \    \wedge\ \ M, \sigma' \models \intThis  
%% $\\
% \hfill  \Longrightarrow\ \ \ \ \  \ \satDAssertFrom M  {\sigma'} k   A[\overline {x \mapsto {\interpret \sigma x}}]$.
%
%\item
%\label{l:calls:callee:two}
%$\satDAssertFrom M  \sigma k   {\PushASLong  {(y_0,\overline{y})} {( A[y_0/\prg{this}])}}
%% $\\  $
%\hfill \Longrightarrow\ \ \ \ \ \ M,  {\sigma'} \models   A[\overline {x \mapsto {\interpret \sigma x}}]$.
%
%\item
%\label{l:calls:callee:three}
%$\satDAssertFrom M  \sigma k   {(A \wedge \PushASLong  {(y_0,\overline{y})} {( A[y_0/\prg{this}])})}$\\  
%$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   A[\overline {x \mapsto {\interpret \sigma x}}]$
%
%%\item
%%$\satDAssertFrom M  \sigma k   {(A\ \wedge \ \PushAS  {y} {( A[y_0/\prg{this}])})}$\\ % \ \  \wedge\ \   \wedge\ \ M, \sigma' \models \intThis 
%%$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   A[\overline {x \mapsto {\interpret \sigma x}}]$
%
%\end{enumerate}
%\item
%\label{l:calls:caller}
%$\sigma'= (\sigma \popSymbol)[u\! \mapsto\! {\interpret {\sigma} {u'}}][\prg{cont}\!\mapsto\! stmt]\ \wedge \ u'\! \in\! dom(\sigma)\ \  \wedge\ \  
% \interpret \sigma {\prg{this}}\! =\! \interpret {\sigma'} {y_0} \ \ \wedge \ \ 
%\overline{ {\interpret {\sigma} y}\!=\! {\interpret {\sigma'} y}}$\\
%implies
%
%\begin{enumerate}
%\item
%\label{l:calls:caller:one}
%$\satDAssertFrom M  \sigma k   A \ \ \wedge\ \ \DepthSt {\sigma'} \geq k  \wedge\ \ M, \sigma' \models \intThis $ \\
%$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   {A[\overline {x \mapsto {\interpret \sigma x}}]}$ 
%
%\item
%\label{l:calls:caller:two}
%$  M , \sigma \models   A$   \\
%$\Longrightarrow\ \  M , \sigma' \models  {\PushASLong  {(y_0,\overline y)}   {(A[\overline {x \mapsto {\interpret \sigma x}}])}}$
%
%\item
%\label{l:calls:caller:three}
%$\satDAssertFrom M  \sigma k   A $   \\
%$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k    {(A \wedge \PushASLong  {(y_0,\overline y)}   {(A[\overline {x \mapsto {\interpret \sigma x}}])})}$
%
% \end{enumerate}
%\end{enumerate}
%
%\end{lemma}
%
%\textbf{Discussion of lemma  \ref{l:calls}}
%As we said earlier, this lemma is used in the proof of soundness of the call rules. 
%We consider a method call of the form $u:= y_0.m(\overline y)$.
%
%Part (\ref{l:calls:callee}) describes that $\sigma'$ is the first state after starting a method call; it is
%the result of pushing a frame (here $\phi$), where \prg{this} has the same value as $y_0$, 
%and the formal parameters of the method body ($\overline y$) have the same values as in the callee -- by Barendregt, we are allowed to make this assumption. 
%Part (\ref{l:calls:caller}) describes that $\sigma'$ is the first state after terminating a method body; it is
%the result of popping a frame  and assigning  some value from the domain of $\sigma$ to the variable $u$(here $u'$) where \prg{this} has the same value os $y_0$; 
%and the formal parameters of the method body ($\overline y$) have the same values as in the caller
%-- again,  by Barendregt, we are allowed to make this assumption 
%
%In case of an internal call, the assertion $A$ of the lemma stands for the pre-or post-condtiion
%of the method specification.
%We  expect that the specification of the method $m$ has been
%given for formal parameters $\overline y$ --again, following a form of Barendregt convention.
%%We  expect that  the pre-condition 
%%% (as in (\ref{l:calls:callee:one}), (\ref{l:calls:callee:two}) 
%%% and (\ref{l:calls:callee:three})) 
%%is expressed in terms of \prg{this}, $\overline y$, and some further free variables $\overline x$.
%%Similarly, we   expect that  the post-condition 
%%%  (as in (\ref{l:calls:caller:one}), (\ref{l:calls:caller:two}), 
%%%  and (\ref{l:calls:caller:three})) 
%%is expressed in terms of \prg{this}, $\overline y$, and some further free variables $\overline x$.
%
%In case of an external call, we consider invariant of the form ${\TwoStatesN {\overline {x:C}} {A}}$, and we
%expect that the only free variables on $A$ are    $\overline x$.
%By Barendregt again, we expect that the variables $\overline x$ do not overlap with the variables $y_0, \overline y$.
%
%
%Thus, for internal as well as for external call, for the reasons discussed in the previous two paragraphs, it makes sense to require that  $\fv(A)\setminus\{ {\overline{y}} \cup \prg{this} \} =\overline{x}$. 
%It makes sense to also require that $\Pos A$, because $\Pos {\_}$ is a requirement for any well-formed  specification.
%
% 
%Parts  (\ref{l:calls:callee:one})  and (\ref{l:calls:caller:one})  are  used to prove soundness of rule {[\sc{Call\_Int}]}.
%  Note that the requirement $M, \sigma' \models \intThis $  in (\ref{l:calls:callee:one}) ensures that the callee is internal
%  (one can see an example demonstrating the need for a local callee in Fig.  \ref{fig:Protected}),
%  while the requirement $M, \sigma' \models \intThis $  in   (\ref{l:calls:caller:one}) ensures that the caller is internal
%  (the caller has to be internal because of similar situation to that in .Fig.  \ref{fig:Protected}).
%Parts
% (\ref{l:calls:callee:two}) and (\ref{l:calls:caller:two}) and are  used to prove soundness of rule {[\sc{Call\_Int\_Adapt}]},
%as well as rule {[\sc{Call\_Ext\_Adapt}]}.
%  Note that   (\ref{l:calls:callee:two}) and (\ref{l:calls:caller:two}) make no requirement for the callee or the caller to be internal.  
% Parts
%(\ref{l:calls:callee:three}) and (\ref{l:calls:caller:three}) are  used to prove soundness of rule {[\sc{Call\_Int\_Adapt\_Strong}]}.
%
%\vspace{.4cm}
%We will next consider the proof of lemma  \ref{l:calls}.
%The lemma's validity hinges on the fact that the  heap does not change,
% the locally visible objects decrease upon entry to a method body, ad that  upon exit, we know that the arguments of the callee are 
% locally visible to the caller.
%Moreover, the lemma does some renaming of variables,
%In the next section we shall introduce some auxialiary concepts tha 
%
%\vspace{.2cm}
%\subsubsection{Auxiliary concepts and lemmas to prove  lemma  \ref{l:calls}}
%The remainder of this section is devoted to the proof of lemma  \ref{l:calls}.
%%
%Lemma \ref{l:push:pop} is  the counterpart of that lemma, but expressed for  variable-free assertions,
%and abstracting the reachability relations between states,
% For a more convenient formulation of Lemma \ref{l:push:pop}, we define in Def. \ref{def:prec} the relation  $\sigma \parallel \sigma' $ which expresses that the two states have identical heaps. 
% We also define 
% $\sigma \prec \sigma'$ which expresses that all addresses reachable from the top frame of $\sigma'$ are also reachable from the top frame of $\sigma$. 
%Finally, we define  $\overline \alpha \prec \sigma$ expresses that all objects locally reachable from the top frame of $\sigma$ are reachable from some address in $\overline \alpha$.
% 
% 
% 
%\begin{definition}
%$~ $ %
%\label{def:prec}
%\begin{itemize}
%\item
%$\sigma \prec \alpha\ \ \ \triangleq\ \ \ \LRelevant {\alpha} {\phi}$
%\item
%$\sigma \prec \sigma'\ \ \ \triangleq\ \ \  \forall \alpha.[\ \LRelevant {\alpha} {\sigma'} \ \Rightarrow \  \LRelevant {\alpha} {\sigma}] $
%\item
%$\overline \alpha \prec \sigma \ \ \ \triangleq\ \ \  \forall \alpha'.[\ \LRelevant {\alpha'} {\sigma} \ \Rightarrow \  \exists \overline f, \alpha. [\ \alpha \in \overline \alpha \wedge 
%\interpret \sigma {\alpha.{\overline f}} = \alpha' \ ]$
%\item
%$\sigma \parallel \sigma'  \ \ \ \triangleq\ \ \ \exists \overline \phi,  \overline {\phi'}, \chi. [\ \sigma=( \overline \phi, \chi )\ \wedge\ 
%\sigma=( \overline {\phi'}, \chi )\ ]$
%\end{itemize}
%\end{definition}
%
%We then ....
%
%\begin{lemma}
%For any states $\sigma$, $\sigma'$, assertion $A$,  such that $\fv(A)=\emptyset$
%\label{l:push:pop:prelim}
%\begin{enumerate}
%\item
%$\sigma \parallel \sigma'\ \ \wedge \ \ \Stable {A}\  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models A  \ \Longleftrightarrow \ \ M, \sigma' \models A\ ] $.
%\item
%$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec \sigma'\ \ \wedge  \ \ M, \sigma' \models \intThis\  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models \inside \alpha \ \ \Longrightarrow \ \ M, \sigma' \models  \inside \alpha\ ]$.
%\item
%$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec \sigma'\ \ \wedge  \ \ M, \sigma' \models \intThis\ \wedge \ \ \Pos A \  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models A \ \ \Longrightarrow \ \ M, \sigma' \models A\ ]$.
%\item
% $\sigma \parallel \sigma'\ \ \wedge \ \ \overline \alpha \prec \sigma'\  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models \protectedFrom {\alpha'} {\overline \alpha} \ \ \Longrightarrow \ \ M, \sigma' \models \inside {\alpha'}\ ]$.
%\item
% $\sigma \parallel \sigma'\ \ \wedge \ \ \overline \alpha \prec \sigma'\ \  \wedge \ \ \Pos A   \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models  {\PushAS   {\alpha} {A}}  \ \ \Longrightarrow \ \ M, \sigma' \models A\ ]$.
%\item
%$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec {\overline \alpha}%\ \ \wedge \ \ M, \sigma' \models \intThis
%  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma   \models \inside {\alpha'} \ \ \Longrightarrow \ \ M, \sigma' \models \protectedFrom {\alpha'} {\overline \alpha} \ ]$
%\item
%$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec {\overline \alpha}\ \  \wedge \ \ \Pos A   \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma   \models A \ \ \Longrightarrow \ \ M, \sigma' \models \protectedFrom {\alpha'} {\PushAS   {\alpha} {A}} \ ]$
%\end{enumerate}
%\end{lemma}
%
%{\textbf{Proof Sketch  of Lemma \ref{l:push:pop:prelim}}}
%\begin{enumerate}
%\item
%by unfolding the definitions
%\item
%by induction on the definition of $\Stable {\_}$; the requirement $M, \sigma' \models \intThis$ ensures that ....
%\item
%by induction on the definition of $\Pos {\_}$, and part (2)
%\item
%by unfolding the definitions
%\item
%by induction on the definition of $\Pos {\_}$, and part (4)
%by unfolding the definitions
%\item
%by induction on the definition of $\Pos {\_}$, and part (6)
%
%\end{enumerate}
%{\textbf{End Proof Sketch}}
%
%
%\vspace{.2cm}
%
%We now express preservation of variable-free assertions in the presence of pushing and popping frames
% 
%\begin{lemma}
%\label{l:push:pop}
%For all   variables $y$, statements $stmt$, states $\sigma$, $\sigma'$, numbers $k\in \mathbb{N}$, assertions  $A$,
% frames $\overline {\phi}$ %, $\phi_n$, $\phi_{n+1}$ and $\phi$, heap $\chi$,  and 
%and addresses $\alpha$ and $\overline \alpha$: % variables $\overline z$, $\overline u$:
%
%% $\strut \\ $
%
%\noindent
%If $\Pos A$ and $\fv(A)=\emptyset$, then
%
%
%\begin{enumerate}
%
%\item
%\label{pp:l:same:one}
%$\sigma'=\sigma[\prg{cont}\mapsto stmt]$,   and $\sigma \prec \alpha$, then for any assertion $A'$:\\
%%\begin{itemize}
%%\item
%$\strut \ \   \ \ \ \ \satDAssertFrom M  \sigma k   A' \ \ \wedge\ \ M, \sigma' \models \intThis  \strut \hspace{3.6cm}  \Longrightarrow  \ \ \satDAssertFrom M  {\sigma'} k   A' $
%%\end{itemize}
%
%
%\item
%\label{pp:l:same:two}
%If $\sigma'=\sigma[y \mapsto \alpha]$,   then \\
%%\begin{itemize}
%%\item
%$\strut \ \   \ \ \ \ \satDAssertFrom M  \sigma k   A \ \ \wedge\ \ M, \sigma' \models \intThis  \strut \hspace{3.6cm}  \Longrightarrow  \ \ \satDAssertFrom M  {\sigma'} k   A $
%%\end{itemize}
%
%\item
%\label{pp:l:push}
%If $\sigma'=\sigma  \pushSymbol \phi$   and $\sigma \prec \sigma'$, then
%\begin{enumerate}
%\item
%\label{pp:l:one}
%$\satDAssertFrom M  \sigma k   A \ \ \wedge \  \ M, \sigma' \models \intThis $ \\
%$\strut \hspace{8cm} \Longrightarrow\   \satDAssertFrom M  {\sigma'} k   A $.
%
% 
%\item 
%\label{pp:l:three}
%$M, \sigma \models    {\PushAS   {\alpha} {A}} \ \ \wedge\ \  Rng(\phi)=\overline {\alpha}$ \\
%$\strut \hspace{8cm} \Longrightarrow\  M,  {\sigma'} \models   A $.
%
%\item
%\label{pp:l:five}
%$\satDAssertFrom M  \sigma k     {A \wedge ( \PushAS   {\alpha} {A})} \ \ \wedge\ \  Rng(\phi)=\overline {\alpha}$ \\
%$\strut \hspace{8cm} \Longrightarrow\   \satDAssertFrom M  {\sigma'} k   {A \wedge( \PushAS   {\alpha} {A})}  $.
%\end{enumerate}
%
%
%\item
%\label{pp:l:pop}
%If $\sigma=\sigma'  \pushSymbol \phi$ and $ \sigma' \prec \sigma$, then
%\begin{enumerate}
%
%\item
%\label{pp:l:two}
%$\satDAssertFrom M  \sigma k   A  \ \  \wedge\ \ k \leq \DepthSt{\sigma'}$ \\
%$\strut \hspace{8cm} \Longrightarrow\  \satDAssertFrom M  {\sigma'} k   A  $.
% 
%\item
%\label{pp:l:four}
%$M, \sigma  \models A  \ \  %\wedge\ \ k \leq \DepthSt{\sigma'} \ \ 
%\wedge\ \      \sigma \prec {\overline \alpha}$,\\
%$\strut \hspace{8cm} \Longrightarrow \  
%M, \sigma  \models {\PushAS   {\alpha} {A}}$.
%
%\item
% \label{pp:l:six}
%$\satDAssertFrom M  \sigma k     {A \wedge ( \PushAS   {\alpha} {A})} \ \ \wedge\ \  \sigma \prec {\overline {\alpha}}
% %\ \ \wedge \ \ M, \sigma' \models \intThis
% \ \  \wedge\ \ k \leq \DepthSt{\sigma'} \ \ $ \\
%$\strut \hspace{8cm} \Longrightarrow \  \satDAssertFrom M  {\sigma'} k   {A \wedge( \PushAS   {\alpha} {A})}  $.
%
%\end{enumerate}
%
%\end{enumerate}
%\end{lemma}
% 
% \noindent
%\vspace{.1cm}
%{\textbf{Discussion of Lemma \ref{l:push:pop}}} 
% In the lemma above, part \ref{pp:l:same:one}  and  \ref{pp:l:same:two} are
% about small modifications to the top frame, which, if is is internal, preserves validity of any assertion.
% Part \ref{pp:l:push} is about preservation of validity from the caller to the  callee's frame (this is why we require that $\sigma'=\sigma  \pushSymbol \phi$),
% while part \ref{pp:l:pop} is about preservation of validity from the callee's frame to the caller's (this is why we require that $\sigma=\sigma'  \pushSymbol \phi$),
% 
%%   parts (\ref{pp:l:one}), (\ref{pp:l:three}) and (\ref{pp:l:five}) are about preservation of assertions when pushing a frame (since $\sigma'=\sigma  \pushSymbol \phi$), while parts (\ref{pp:l:two}), (\ref{pp:l:four}) and (\ref{pp:l:six}) are about preservation of assertions when popping a frame (since $\sigma=((\overline {\phi}\cdot \phi_n \cdot \phi_{n+1}),\chi)$ and $\sigma' = ((\overline {\phi}\cdot \phi_n[..],\chi)$).
% 
% In part  (\ref{pp:l:one}) we require that  $M, \sigma' \models \intThis$ -- therefore this part is applicable only if the callee is internal; note that we make no such requirement   in (\ref{pp:l:three}) or (\ref{pp:l:five})  -- therefore we can 
% apply these parts to internal as well as external calls.
%% No loger true, as I introdiced part (1)
%%In parts    (\ref{pp:l:four}) and (\ref{pp:l:six})  we require that  $M, \sigma'  \models \intThis$ -- therefore these parts are applicable only if the caller is internal. This, however is not a restriction, really, because our quadruples are always from the point of view of the caller, and are applicable to internal code only.
% 
% Note the requirements that $k \leq \DepthSt {\sigma'}$ in parts (\ref{pp:l:two})  and (\ref{pp:l:six}): this ensures that the corresponding assertion holds at the level of the callee as well as of the caller. 
% This requirement is necessary so  that the assertion 
% 
% We do  not make such a requirement in part  (\ref{pp:l:four})  
% 
%\noindent
%\vspace{.1cm}
%{\textbf{Proof Sketch  of Lemma \ref{l:push:pop}}}
%By application of Lemma  \ref{l:push:pop:prelim} -- TODO add details
%%\vspace{.1cm}
%
%{\textbf{End Proof Sketch}} 
%
%\vspace{.2cm}
%\subsubsection{Poving  lemma  \ref{l:calls}}
%
%\noindent
%\vspace{.1cm}
%{\textbf{Proof Sketch  of Lemma \ref{l:calls}}}
% 
% %\vspace{.1cm}
%
%{\textbf{End Proof Sketch}} 
%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%