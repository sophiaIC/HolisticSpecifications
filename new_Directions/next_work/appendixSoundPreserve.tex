%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preservation of assertions when pushing or popping frames}

In this section we  discuss the preservation  assertions when pushing and popping of frames. 
The result of this discussion is  lemma \ref{l:calls}. 
 which will be used when we provr soundness of the rules about method calls, as given in Fig. \ref{f:calls}. 

We will first state  lemma \ref{l:calls}, then discuss it, and a then we will define and prove a sequence of concepts and 
 lemmas which we will use in the proof of lemma \ref{l:calls}.

\begin{lemma}
\label{l:calls}
For any states $\sigma$, $\sigma'$, assertion $A$, %,  such that $\fv(A)=\emptyset$, 
variables  $u$, $u'$, $y_0$, and  $\overline{y}$\footnote{We take $\overline y$ to stand for $y_1, ... y_n$}, statement $stmt$, frame $\phi$.

$ ~ $ % and $\overline{y'}$, 
\\
If 
 $\fv(A)\setminus\{ {\overline{y}} \cup \prg{this} \} =\overline{x}\ \ \wedge \ \  \Pos A$
  
\begin{enumerate}

\item
\label{l:calls:callee}
$\sigma'=\sigma  \pushSymbol \phi \ \ \wedge \ \  dom(\phi)=\overline{y}\cup \{ \prg{this} \}\ \ \wedge\ \ 
\overline{y} \subseteq dom(\sigma)\ \  \wedge\ \
\interpret \sigma {y_0} = \interpret \phi {\prg{this}}\ \ \wedge \ \ 
\overline{ {\interpret \sigma y}= {\interpret {\sigma'} y}}$\\
implies

\begin{enumerate}
\item
\label{l:calls:callee:one}
$\satDAssertFrom M  \sigma k   A[y_0/\prg{this}] \ \    \wedge\ \ M, \sigma' \models \intThis 
$\\
$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   A[\overline {x \mapsto {\interpret \sigma x}}]$

\item
\label{l:calls:callee:two}
$\satDAssertFrom M  \sigma k   {\PushASLong  {(y_0,\overline{y})} {( A[y_0/\prg{this}])}}$\\  
$\Longrightarrow\ \  M,  {\sigma'} \models   A[\overline {x \mapsto {\interpret \sigma x}}]$

\item
\label{l:calls:callee:three}
$\satDAssertFrom M  \sigma k   {(A \wedge \PushASLong  {(y_0,\overline{y})} {( A[y_0/\prg{this}])})}$\\  
$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   A[\overline {x \mapsto {\interpret \sigma x}}]$

%\item
%$\satDAssertFrom M  \sigma k   {(A\ \wedge \ \PushAS  {y} {( A[y_0/\prg{this}])})}$\\ % \ \  \wedge\ \   \wedge\ \ M, \sigma' \models \intThis 
%$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   A[\overline {x \mapsto {\interpret \sigma x}}]$

\end{enumerate}
\item
\label{l:calls:caller}
$\sigma'= (\sigma \popSymbol)[u\! \mapsto\! {\interpret {\sigma} {u'}}][\prg{cont}\!\mapsto\! stmt]\ \wedge \ u'\! \in\! dom(\sigma)\ \  \wedge\ \  
 \interpret \sigma {\prg{this}}\! =\! \interpret {\sigma'} {y_0} \ \ \wedge \ \ 
\overline{ {\interpret {\sigma} y}\!=\! {\interpret {\sigma'} y}}$\\
implies

\begin{enumerate}
\item
\label{l:calls:caller:one}
$\satDAssertFrom M  \sigma k   A \ \ \wedge\ \ \DepthSt {\sigma'} \geq k  \wedge\ \ M, \sigma' \models \intThis $ \\
$\Longrightarrow\ \  \satDAssertFrom M  {\sigma'} k   {A[\overline {x \mapsto {\interpret \sigma x}}]}$ 

\item
\label{l:calls:caller:two}
$  M , \sigma \models   A$   \\
$\Longrightarrow\ \  M , \sigma' \models  {\PushASLong  {(y_0,\overline y)}   {(A[\overline {x \mapsto {\interpret \sigma x}}])}}$

\item
\label{l:calls:caller:three}
$\satDAssertFrom M  \sigma k   A $   \\
$\Longrightarrow\ \  \satDAssertFrom M  \sigma' k    {(A \wedge \PushASLong  {(y_0,\overline y)}   {(A[\overline {x \mapsto {\interpret \sigma x}}])})}$

 \end{enumerate}
\end{enumerate}

\end{lemma}

\textbf{Discussion of lemma  \ref{l:calls}}
As we said earlier, this lemma is used in the proof of soundness of the call rules. 
We consider a method call of the form $u:= y_0.m(\overline y)$.

Part ((\ref{l:calls:callee}) describes that $\sigma'$ is the first state after starting a method call; it is
the result of pushing a frame (here $\phi$), where \prg{this} has the same value as $y_0$, 
and the formal parameters of the method body ($\overline y$) have the same values as in the callee.
Part ((\ref{l:calls:caller}) describes that $\sigma'$ is the first state after terminating a method body; it is
the result of popping a frame  and assigning  some value from the domain of $\sigma$ to the variable $u$(here $u'$) where \prg{this} has the same value os $y_0$; the formal parameters of the method body ($\overline y$) have the same values as in the caller.

In case of an internal call, the assertion $A$ of the lemma stands for the pre-or post-condtiion.
We  expect that the specification of the method $m$ has been
given for formal parameters $\overline y$ --following a form of Barendregt convention.
We  expect that  the pre-condition 
% (as in (\ref{l:calls:callee:one}), (\ref{l:calls:callee:two}) 
% and (\ref{l:calls:callee:three})) 
is expressed in terms of \prg{this}, $\overline y$, and some further free variables $\overline x$.
Similarly, we   expect that  the post-condition 
%  (as in (\ref{l:calls:caller:one}), (\ref{l:calls:caller:two}), 
%  and (\ref{l:calls:caller:three})) 
is expressed in terms of \prg{this}, $\overline y$, and some further free variables $\overline x$.

In case of an external call, we assume an  invariant of the form ${\TwoStatesN {\overline {x:C}} {A}}$, and we
expect that the only free variables on $A$ are the $\overline x$.
Ny Barendregt again, we expect that the $\overline x$ do not verlap with $y_0 \overline y$. 
This is why we require that  $\fv(A)\setminus\{ {\overline{y}} \cup \prg{this} \} =\overline{x}$. 
We also require that $\Pos A$, because this is a requirement for any well-formed  specification.

 
Parts
 (\ref{l:calls:callee:one})  and (\ref{l:calls:caller:one})  are  used to prove soundness of rule {[\sc{Call\_Int}]}.
  Note that the requirement $M, \sigma' \models \intThis $  in (\ref{l:calls:callee:one}) ensures that the callee is internal
  (one can see an example demonstrating the need for a local callee in Fig.  \ref{fig:Protected}),
  while the requirement $M, \sigma' \models \intThis $  in   (\ref{l:calls:caller:one}) ensures that the caller is internal
  (the caller has to be internal because xxx).
Parts
 (\ref{l:calls:callee:two}) and (\ref{l:calls:caller:two}) and are  used to prove soundness of rule {[\sc{Call\_Int\_Adapt}]},
as well as rule {[\sc{Call\_Ext\_Adapt}]}.
  Note that   (\ref{l:calls:callee:two}) and (\ref{l:calls:caller:two}) make no requirement for the callee or the caller to be internal.  
 Parts
(\ref{l:calls:callee:three}) and (\ref{l:calls:caller:three}) are  used to prove soundness of rule {[\sc{Call\_Int\_Adapt\_Strong}]}.

The lemma's validity hinges on the following facts: 
1) The heap does not change.
2)  The locally visible objects decrease upon entry to a method body. 
3) ???|
?? Say something about free vartiables ??

\vspace{.2cm}
\subsubsection{Auxiliary concepts and lemmas to prove  lemma  \ref{l:calls}}
The remainder of this section is devotes to the proof of lemma  \ref{l:calls}.

Lemma \ref{l:push:pop} is  about preservation of variable-free, stable assertions when pushing or popping frames. 
The reason assertions are preserved hinges on the fact that the heap does not change, and that  local reachability decreases as we push frames, and increases as we pop them.
 For a more convenient formulation of Lemma \ref{l:push:pop}, we define in Def. \ref{def:prec} the relation  $\sigma \parallel \sigma' $ which expresses that the two states have identical heaps. 
 We also define 
 $\sigma \prec \sigma'$ which expresses that all addresses reachable from the top frame of $\sigma'$ are also reachable from the top frame of $\sigma$. 
Finally, we define  $\overline \alpha \prec \sigma$ expresses that all objects locally reachable from the top frame of $\sigma$ are reachable from some address in $\overline \alpha$.
 
 
 
\begin{definition}
$~ $ %
\label{def:prec}
\begin{itemize}
\item
$\sigma \prec \alpha\ \ \ \triangleq\ \ \ \LRelevant {\alpha} {\phi}$
\item
$\sigma \prec \sigma'\ \ \ \triangleq\ \ \  \forall \alpha.[\ \LRelevant {\alpha} {\sigma'} \ \Rightarrow \  \LRelevant {\alpha} {\sigma}] $
\item
$\overline \alpha \prec \sigma \ \ \ \triangleq\ \ \  \forall \alpha'.[\ \LRelevant {\alpha'} {\sigma} \ \Rightarrow \  \exists \overline f, \alpha. [\ \alpha \in \overline \alpha \wedge 
\interpret \sigma {\alpha.{\overline f}} = \alpha' \ ]$
\item
$\sigma \parallel \sigma'  \ \ \ \triangleq\ \ \ \exists \overline \phi,  \overline {\phi'}, \chi. [\ \sigma=( \overline \phi, \chi )\ \wedge\ 
\sigma=( \overline {\phi'}, \chi )\ ]$
\end{itemize}
\end{definition}

We then ....

\begin{lemma}
For any states $\sigma$, $\sigma'$, assertion $A$,  such that $\fv(A)=\emptyset$
\label{l:push:pop:prelim}
\begin{enumerate}
\item
$\sigma \parallel \sigma'\ \ \wedge \ \ \Stable {A}\  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models A  \ \Longleftrightarrow \ \ M, \sigma' \models A\ ] $.
\item
$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec \sigma'\ \ \wedge  \ \ M, \sigma' \models \intThis\  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models \inside \alpha \ \ \Longrightarrow \ \ M, \sigma' \models  \inside \alpha\ ]$.
\item
$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec \sigma'\ \ \wedge  \ \ M, \sigma' \models \intThis\ \wedge \ \ \Pos A \  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models A \ \ \Longrightarrow \ \ M, \sigma' \models A\ ]$.
\item
 $\sigma \parallel \sigma'\ \ \wedge \ \ \overline \alpha \prec \sigma'\  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models \protectedFrom {\alpha'} {\overline \alpha} \ \ \Longrightarrow \ \ M, \sigma' \models \inside {\alpha'}\ ]$.
\item
 $\sigma \parallel \sigma'\ \ \wedge \ \ \overline \alpha \prec \sigma'\ \  \wedge \ \ \Pos A   \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma \models  {\PushAS   {\alpha} {A}}  \ \ \Longrightarrow \ \ M, \sigma' \models A\ ]$.
\item
$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec {\overline \alpha}%\ \ \wedge \ \ M, \sigma' \models \intThis
  \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma   \models \inside {\alpha'} \ \ \Longrightarrow \ \ M, \sigma' \models \protectedFrom {\alpha'} {\overline \alpha} \ ]$
\item
$\sigma \parallel \sigma'\ \ \wedge \ \ \sigma \prec {\overline \alpha}\ \  \wedge \ \ \Pos A   \ \ \ \ \Longrightarrow\  \ \ \ \ [ \ M, \sigma   \models A \ \ \Longrightarrow \ \ M, \sigma' \models \protectedFrom {\alpha'} {\PushAS   {\alpha} {A}} \ ]$
\end{enumerate}
\end{lemma}

{\textbf{Proof Sketch  of Lemma \ref{l:push:pop:prelim}}}
\begin{enumerate}
\item
by unfolding the definitions
\item
by induction on the definition of $\Stable {\_}$; the requirement $M, \sigma' \models \intThis$ ensures that ....
\item
by induction on the definition of $\Pos {\_}$, and part (2)
\item
by unfolding the definitions
\item
by induction on the definition of $\Pos {\_}$, and part (4)
by unfolding the definitions
\item
by induction on the definition of $\Pos {\_}$, and part (6)

\end{enumerate}
{\textbf{End Proof Sketch}}


\vspace{.2cm}

We now express preservation of variable-free assertions in the presence of pushing and popping frames
 
\begin{lemma}
\label{l:push:pop}
For all   variables $y$, statements $stmt$, states $\sigma$, $\sigma'$, numbers $k\in \mathbb{N}$, assertions  $A$,
 frames $\overline {\phi}$ %, $\phi_n$, $\phi_{n+1}$ and $\phi$, heap $\chi$,  and 
and addresses $\alpha$ and $\overline \alpha$: % variables $\overline z$, $\overline u$:

% $\strut \\ $

\noindent
If $\Pos A$ and $\fv(A)=\emptyset$, then


\begin{enumerate}

\item
\label{pp:l:same:one}
$\sigma'=\sigma[\prg{cont}\mapsto stmt]$,   and $\sigma \prec \alpha$, then for any assertion $A'$:\\
%\begin{itemize}
%\item
$\strut \ \   \ \ \ \ \satDAssertFrom M  \sigma k   A' \ \ \wedge\ \ M, \sigma' \models \intThis  \strut \hspace{3.6cm}  \Longrightarrow  \ \ \satDAssertFrom M  {\sigma'} k   A' $
%\end{itemize}


\item
\label{pp:l:same:two}
If $\sigma'=\sigma[y \mapsto \alpha]$,   then \\
%\begin{itemize}
%\item
$\strut \ \   \ \ \ \ \satDAssertFrom M  \sigma k   A \ \ \wedge\ \ M, \sigma' \models \intThis  \strut \hspace{3.6cm}  \Longrightarrow  \ \ \satDAssertFrom M  {\sigma'} k   A $
%\end{itemize}

\item
\label{pp:l:push}
If $\sigma'=\sigma  \pushSymbol \phi$   and $\sigma \prec \sigma'$, then
\begin{enumerate}
\item
\label{pp:l:one}
$\satDAssertFrom M  \sigma k   A \ \ \wedge \  \ M, \sigma' \models \intThis $ \\
$\strut \hspace{8cm} \Longrightarrow\   \satDAssertFrom M  {\sigma'} k   A $.

 
\item 
\label{pp:l:three}
$M, \sigma \models    {\PushAS   {\alpha} {A}} \ \ \wedge\ \  Rng(\phi)=\overline {\alpha}$ \\
$\strut \hspace{8cm} \Longrightarrow\  M,  {\sigma'} \models   A $.

\item
\label{pp:l:five}
$\satDAssertFrom M  \sigma k     {A \wedge ( \PushAS   {\alpha} {A})} \ \ \wedge\ \  Rng(\phi)=\overline {\alpha}$ \\
$\strut \hspace{8cm} \Longrightarrow\   \satDAssertFrom M  {\sigma'} k   {A \wedge( \PushAS   {\alpha} {A})}  $.
\end{enumerate}


\item
\label{pp:l:pop}
If $\sigma=\sigma'  \pushSymbol \phi$ and $ \sigma' \prec \sigma$, then
\begin{enumerate}

\item
\label{pp:l:two}
$\satDAssertFrom M  \sigma k   A  \ \  \wedge\ \ k \leq \DepthSt{\sigma'}$ \\
$\strut \hspace{8cm} \Longrightarrow\  \satDAssertFrom M  {\sigma'} k   A  $.
 
\item
\label{pp:l:four}
$M, \sigma  \models A  \ \  %\wedge\ \ k \leq \DepthSt{\sigma'} \ \ 
\wedge\ \      \sigma \prec {\overline \alpha}$,\\
$\strut \hspace{8cm} \Longrightarrow \  
M, \sigma  \models {\PushAS   {\alpha} {A}}$.

\item
 \label{pp:l:six}
$\satDAssertFrom M  \sigma k     {A \wedge ( \PushAS   {\alpha} {A})} \ \ \wedge\ \  \sigma \prec {\overline {\alpha}}
 %\ \ \wedge \ \ M, \sigma' \models \intThis
 \ \  \wedge\ \ k \leq \DepthSt{\sigma'} \ \ $ \\
$\strut \hspace{8cm} \Longrightarrow \  \satDAssertFrom M  {\sigma'} k   {A \wedge( \PushAS   {\alpha} {A})}  $.

\end{enumerate}

\end{enumerate}
\end{lemma}
 
 \noindent
\vspace{.1cm}
{\textbf{Discussion of Lemma \ref{l:push:pop}}} 
 In the lemma above, part \ref{pp:l:same:one}  and  \ref{pp:l:same:two} are
 about small modifications to the top frame, which, if is is internal, preserves validity of any assertion.
 Part \ref{pp:l:push} is about preservation of validity from the caller to the  callee's frame (this is why we require that $\sigma'=\sigma  \pushSymbol \phi$),
 while part \ref{pp:l:pop} is about preservation of validity from the callee's frame to the caller's (this is why we require that $\sigma=\sigma'  \pushSymbol \phi$),
 
%   parts (\ref{pp:l:one}), (\ref{pp:l:three}) and (\ref{pp:l:five}) are about preservation of assertions when pushing a frame (since $\sigma'=\sigma  \pushSymbol \phi$), while parts (\ref{pp:l:two}), (\ref{pp:l:four}) and (\ref{pp:l:six}) are about preservation of assertions when popping a frame (since $\sigma=((\overline {\phi}\cdot \phi_n \cdot \phi_{n+1}),\chi)$ and $\sigma' = ((\overline {\phi}\cdot \phi_n[..],\chi)$).
 
 In part  (\ref{pp:l:one}) we require that  $M, \sigma' \models \intThis$ -- therefore this part is applicable only if the callee is internal; note that we make no such requirement   in (\ref{pp:l:three}) or (\ref{pp:l:five})  -- therefore we can 
 apply these parts to internal as well as external calls.
% No loger true, as I introdiced part (1)
%In parts    (\ref{pp:l:four}) and (\ref{pp:l:six})  we require that  $M, \sigma'  \models \intThis$ -- therefore these parts are applicable only if the caller is internal. This, however is not a restriction, really, because our quadruples are always from the point of view of the caller, and are applicable to internal code only.
 
 Note the requirements that $k \leq \DepthSt {\sigma'}$ in parts (\ref{pp:l:two})  and (\ref{pp:l:six}): this ensures that the corresponding assertion holds at the level of the callee as well as of the caller. 
 This requirement is necessary so  that the assertion 
 
 We do  not make such a requirement in part  (\ref{pp:l:four})  
 
\noindent
\vspace{.1cm}
{\textbf{Proof Sketch  of Lemma \ref{l:push:pop}}}
By application of Lemma  \ref{l:push:pop:prelim} -- TODO add details
%\vspace{.1cm}

{\textbf{End Proof Sketch}} 

\vspace{.2cm}
\subsubsection{Poving  lemma  \ref{l:calls}}

\noindent
\vspace{.1cm}
{\textbf{Proof Sketch  of Lemma \ref{l:calls}}}
 
 %\vspace{.1cm}

{\textbf{End Proof Sketch}} 

%%%%%%%%
%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%