

\section{Bits and Bobs: points to make earlier}

\subsection{one}
In the introduction show a method where
\begin{lstlisting}
    void cautious(untrusted : Object, acc: Account){
    PRE acc.passwd PRT-FROM untrusted
    POST acc.passwd PRT-FROM untrusted
     ...
        ext-call does not pass acc.pwd
     ...
   }
\end{lstlisting}

Even external object creation may return an old, preexisting object.
Nevertheless, we are able to prove the above. Make a diagram that has an untrust', which has access to a.pwd. 


\subsection{two}
In our setting, we must deal with the possibility  that any untrusted object may point to any other untrusted object.
Therefore, any reference given to an untrusted object may end up, in principle,  eventually given to all of them.
Therefore if there was an untrusted object $u$ that had reference to $o$,  and we knew that $o$ was protected from $z$ now, we are not
allowed   to deduce that $o$ will still be protected in the "deep" future.
However, if we consider the "shallow" future, we can do better than that.

Namely, if  before an untrusted call with receiver and arguments $\overline z$ we know that $o$ is protected from $\overline z$, and if we know that the internal objects do not leak $o$ to the the external world, then we know that during execution of the untrusted call (and also all nested trusted or untrusted calls), $o$ will be protected (ie no locally accessible external object will obtain direct access), and that after the call, $o$ will still be protected from $\overline z$.

Going back to the discussion where $u$ \kjx{refers}
\st{has an (un-mitigated?)reference} to $o$,  if at the untrusted call
with receiver and arguments $\overline z$, we know that $o$ is
protected from $\overline z$, then this does not preclude
\kjx{$u$ referring to $\overline z$, but it does preclude $\overline
  z$ referring to $u$ -- because if $\overline z \rightarrowtail u$
  then $\overline z \rightarrowtail o$.}
\st{that $u$ has unmitigated access to $\overline z$, but it does precludes that any of  $\overline z$ has unmitigated access to $u$ (because if had, then it would also have had unmitigated access to $o$ itself).}

\subsection{three}
NOTE: JAMES asked Do we need to worry about well-fomedness? Eg what if
we had an assertion $3 \wedge 5 \rightarrow 66$?

  

\subsection{four}
Say that protected-from is a heap property, whereas protected is a
heap-frame property.


\subsection{five}
Say authority implies eventual permission. Ie we want to guarantee that an untrusted object will not get permission to a capability. Lack of eventual permissions bounds authority.

\subsection{six}
Execution takes many modules, but satisfaction only one module.


\paragraph{The next sections are organized as follows}
\label{s:semantics}
% In this section we define {the}  \SpecLang specification language.  
We first define an underlying programming language, \LangOO (\S \ref{sub:Loo}).
We then define an assertion language, \AssertLang, which can talk about the
contents of the state, as well as about protection (\S \ref{sub:SpecO}).  Finally, we define the syntax and
semantics of  \SpecLang
specifications (\S \ref{s:holistic-guarantees}).

 

