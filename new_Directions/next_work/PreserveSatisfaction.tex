All program logics deal with framing in some form or other, \ie conditions under which  satisfaction of  assertions is preserved across program execution. 
This is the subject of the current Section.

We start with  Lemma \ref{l:assrt:unaffect}  which says that satisfaction of an assertion is not affected by replacing a variable by its value, nor by changing the continuation in a state.


\begin{lemma}
\label{lemma:addr:expr}
\label{l:assrt:unaffect}
For all $M$, $\sigma$, $\alpha$, $x$, $\re$, $stmt$, and $A$:

\begin{enumerate}
\item
\label{one:ad:exp}
$
\satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma}{A[{\interpret \sigma x}/x]} % \ ]
 $ 
\label{l:assrt:unaffect:one}
$\satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma}{A[{\interpret \sigma x}/x]}   $ 
% holds, but not used
>>>>>>> 1c2697daf51fc05cd432cc357bf0ecc94789eb60
%\item
%$\eval{M}{\sigma}{{\re}}{\alpha}  \ \ \Longrightarrow\ \  [ \ \satisfiesA{M}{\sigma}{A} \  \Longleftrightarrow\   \  \satisfiesA{M}{\sigma}{A[\alpha/\re]} \  \  ]$
\item
$ \satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma[\prg{cont}\mapsto stmt]}{A}$ 
\end{enumerate}

\end{lemma}

 \noindent
We now move to assertion preservation across method call and return. % (Sect \ref{s:preserve:call:ret}),   or heap modification (Sect \ref{s:preserve:encaps}).

\subsection{Stability: Preservation across method call and return}
\label{s:preserve:call:ret}
In most program logics, satisfaction of  variable-free assertions  is preserved when pushing/popping frames
-- \ie immediately after entering a method or  returning from it.
This, however, is not   the case for our assertions, because whether  $\inside {\alpha}$ holds, depends on the heap as well as the set of objects reachable from the top frame, and
the latter  changes when the frame changes.
This is shown, \eg in  Fig. \ref{fig:Protected} where 
$\sigma_1,\chi \models \inside {o_3}$, then $.\sigma_2,\chi \not\models \inside {o_3}$, and then $\sigma_3,\chi  \models \inside {o_3}$
 %$o_3$ was not protected with top frame $\phi_1$,  
%became protected when we pushed the frame $\phi_2$,  and again, is no longer protected when we push $\phi_3$ on the stack. 

 

Nevertheless,  assertions which do  not contain  $\inside {\_}$, called   $\Stable {\_}$, are stable against pushing and popping of frames.  
Moreover, assertions which do  not contain $\inside {\_}$ in negative positions, called $\Pos {\_}$,  are stable against pushing  of {internal} frames provided that the range of the new frame contains locallty reachable addresses -- 
\cf  Defs   in \A\ \ref{app:preserve}.

\begin{lemma}
For all  states $\sigma$ and frames $\phi$, and for all assertions $A$ such that $ fv(A)=\emptyset$:
\label{l:preserve:asrt}
 
\begin{itemize}
\item 
$\Stable{A}\ \ \ \  \Longrightarrow \ \  \ \  [\ \ M, \sigma \models A \ \ \Longleftrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
\item 
\label{l:preserve:asrt:two}
$\Pos{A}\ \ \  \wedge \ \ \  {   \ Rng(\phi)\subseteq \LRelevantO   \sigma \ } \ \ \ \Longrightarrow $
\\
$\strut \hspace{2cm} \ \  \ \  [\ \ M, \sigma \models A \  \wedge \  M, {\PushSLong \phi \sigma} \models  \intThis \ \ \Longrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
%\item 
%$\Neg{A}\ \ \   \Longrightarrow \ \  \ \  [\ \  M,{\PushSLong \phi \sigma} \models A\ \ \Longrightarrow \ \  M, \sigma \models A   \ \  ]$
%
\end{itemize}
\end{lemma}

 
$Stbl$ assertions are preserved when pushing or popping frames, but do not support % allow to include 
$\inside {\_}$ requirements -- a crucial ingredient for our work. While
$Stb^+$ assertions \emph{are} preserved  when pushing  internal frames,   they  are \emph{not} preserved when pushing  external frames   (\cf  Ex. \ref{push:does:not:preserve}), \emph{nor} when popping frames   (\cf Ex. \ref{ex:motivate:scoped}). 

 
\begin{example}[External Push might not preserve]
\label{push:does:not:preserve}
In    Fig. \ref{fig:Protected}, where $\sigma_2$ by pushing external frame onto $\sigma_1$, and 
$\sigma_1 \models \inside {o_3}$ but $\sigma_2 \not\models \inside {o_3}$.
% Bad syntax above, but fits in one line
\end{example}
 

\begin{example}[Method return might not preserve]
\label{ex:motivate:scoped}
Assume state $\sigma_a$, such that $\interpret {\sigma_a} {\prg{this}}=o_1$, $\interpret {\sigma} {\prg{this}.f}=o_2$, $\interpret {\sigma} {x}=o_3$, $\interpret {\sigma} {x.f}=o_2$,  
and $\interpret {\sigma} {x.g}=o_4$, where $o_2$ is external and all other objects are internal. 
We then have $..,\sigma_a \models  \inside {o_4}$.
Assume that the continuation of $\sigma_a$   consists of a method $x.m()$. Then,
upon entry to that method, when we push the new frame, we have a state $\sigma_b$, which also satisfies $..,\sigma_a \models  \inside {o_4}$.
Assume that the   body of $m$ is $\prg{this}.f.m1(\prg{this}.g); \prg{this}.f := \prg{this};  \prg{this}.g := \prg{this}$, and that the external method $m1$ stores in the 
receiver a reference to the argument.
Then, at the end of method execution, and before popping the stack, we have a state $\sigma_c$, which also satisfies $..,\sigma_c \models  \inside {o_4}$.
However, after we pop the stack, we obtain $\sigma_d$, for which $..,\sigma_d \not\models  \inside {o_4}$.
\end{example}


\vspace{.1cm}
Even though  $Stb^+$ assertions    are \emph{not} preserved when  external frames are pushed, \emph{nor} when frames are popped, we need
ways to ensure that an assertion holds when entering a method or returning from a method. 
The former  is done through the viewpoint adaptation operator (Sect \ref{s:viewAndProtect}); the latter thought   
\scoped sarisfaction (Section \ref{s:scoped:valid}).
  
   
 \subsection{Viewpoints and Protection}
 \label{s:preserve:encaps}
 \label{s:viewAndProtect}
 
 As we discussed in section \ref{sec:howThird} sometimes an assertion $A$ is not satisfied at the callerâ€™s
viewpoint, but is satisfied at the called viewpoint:  right before a method call, $A$ might not be satisfied,
but if  $\PushASLong  {\overline y} A$ is satisfied (where $\overline y$ are the receiver and arguments to the call), then $A$
will be satisfied right when the called method body starts. Thus, the operator $\FIXSymbolA$
 translates an assertion from the viewpoint of the called, to that of the caller.
 

The  $\FIXSymbolA$  operator is  defined in Fig. \ref{f:Push}. 
Only the first equation is interesting, i.e.  $\PushAS y {(\inside \re)}$: For 
$\re$ to be protected from the viewpoint of the called, it should be protected from all the call's arguments,
\ie  $\protectedFrom {\re} {\overline {y}}$. 
The notation $\protectedFrom {\re} {\overline {y}}$   stands for $\protectedFrom \re {y_0}\, \wedge\, ...  \protectedFrom \re {y_n}$, assuming that $\overline y$=${y_0, ... y_n}$.


\begin{definition}
\label{def:push}
[The $\FIXSymbolA$  operator] is  defined below

$
\begin{array}{c}
\begin{array}{l}
\begin{array}{rclcrcl}
  \PushAS y {(\inside \re)} & \triangleq &  \protectedFrom \re {\overline {y} }
  & \ \ \  \ &
  \PushAS y   {(A_1  \wedge  A_2)} & \triangleq &  (\PushAS y  { A_1})  \wedge  ( \PushAS y  {A_2} )  
\\ 
 \PushAS y {(\protectedFrom \re {\overline {u}})} &  \triangleq& \protectedFrom \re {\overline {u}} 
  & &
 \PushAS y  {(\forall x:C.A)} & \triangleq & \forall x:C.({\PushAS y A} )  
  \\  
  \PushAS y  {(\external \re)} &  \triangleq & {\external \re}  %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
  & & 
  \PushAS y  {(\neg A)} &  \triangleq & \neg( {\PushAS y A} )  
    \\
     \PushAS y  {\re} &  \triangleq&   \re %    \PushAS y  {(\internal \re)} &  \triangleq & {\internal \re}
    & &
    \PushAS y  {(\re:C)} &  \triangleq&   \re:C 
 \end{array}
\end{array}
\end{array}
$
\label{f:Push}
\end{definition}

 





\vspace{.1cm}

\begin{example}
\label{push:does:not:imply}
$A$ does not imply $\PushAS {y} {A}$: \Eg  take 
  a   $\sigma_1$ where $\interpret {\sigma_1} {\prg{this}}$ = $o_1$, and $o_1$ is internal,  and there is no other object. Then, we have
$\_,\sigma_1 \models \inside {\prg{this}}$ and $\_,\sigma_1 \not\models \protectedFrom {\prg{this}} {\prg{this}}$.
Nor does  $\PushAS {y} {A}$  imply $A$. \Eg  take a $\sigma_2$ where $\interpret {\sigma_2} {\prg{this}}$ = $o_1$,
 $\interpret {\sigma_2} {x}$ = $o_2$ , and  $\interpret {\sigma_2} {x.f}$ = $o_3$, and $o_2$ is external, and there are no other objects or fields.
 Then $\_,\sigma_2 \models   \protectedFrom {x.f} {\prg{this}}$ but  $\_,\sigma_2 \not\models \inside {x.f}$.
\end{example}

 Lemma \ref{lemma:push:ass:state}  states that $\FIXSymbolA$ is the counterpart to the states' operator $\pushSymbol$:
A caller state
$\sigma$ satisfies  $\PushAS y A$, if and only if the called state  ($\PushASLong {\phi} {\sigma}$) % (after pushing a frame with the values of $\overline y$) 
satisies $A$.  
%% The below was fine when we had a more detailed version
% (1) If \ the caller state
%$\sigma$ satisfies  $\PushAS y A$, then  the called state  ($\PushASLong {\phi} {A}$) % (after pushing a frame with the values of $\overline y$) 
%will satisfy $A$.  
%(2) is the opposite: {If the called state ($\PushASLong {\phi} {A}$) % (in which we pushed a frame with the values for $\overline y, \overline z$
% satisfies $A$, then the caller state will satisfy 
%$\PushAS {y} {A}$. } % will hold {in the caller state}. % after popping that frame.


\begin{lemma} 
\label{lemma:push:ass:state}
For a  state  $\sigma$, assertion $A$ with $\fv(A)=\emptyset$,  variables   $\overline y$, frame $\phi$ with $Range (\phi)=\overline {\interpret \sigma y}$:


\begin{itemize} %{enumerate}
 \item
 \label{lemma:push:ass:state:one}
 \label{lemma:push:ass:state:two}
$M, \sigma \models \PushAS  {y} {A}\ \  \ \ \ \ \  \ \ \    \Longleftrightarrow  \ \ \ \ M,  \PushSLong {\phi} {\sigma}   \models A$
%\item
%\label{lemma:push:ass:state:two}
%$M, { \PushSLong {\phi} {\sigma} } \models  A \ \  \ \ \ \ \  \ \ \    \Longrightarrow  \ \ \ \ M,  \sigma \models  \PushAS  {y} {A}$
\end{itemize}  % {enumerate}
\end{lemma}


 
\subsection{Encapsulation: Preservation across heap modifications}
\label{s:preserve:encaps}
 
Proofs of adherence to {\SpecLang specifications  hinge on the expectation that some,  specific, assertions are always satisfied unless some 
} internal (and thus known) computation took place. 
{We call such assertions   \emph{encapsulated}.}
 

The judgment $M\ \vdash \encaps{A}$  expresses that satisfaction of $A$ involves looking into the state of  
internal objects only,  \cf. Def \ref{d:encaps:sytactic}.
{On the other hand, $M  \models \encaps{A}$ says that assertion $A$  is  \emph{encapsulated} by a module $M$, \ie in all possible states % which arise from execution of module $M$ with any other  module $\Mtwo$, 
execution which involves $M$ and any set of other module $\Mtwo$, always satisfies  $A$  unless the execution  included internal execution steps}.
 

\begin{definition}[An assertion $A$ is \emph{encapsulated} by module $M$] $~$ \\
\label{d:encaps}
\begin{itemize}
%\item 
%$M \vdash \encaps{A}  \ \   \triangleq  \ \  \exists \Gamma.[\ M; \emptyset \vdash \encaps{A}; \Gamma\ ]$ \ \  as defined in Fig. \ref{f:encaps}.
\item
$ % \begin{equation}
    M\ \models \encaps{A}\ \   \triangleq  \ \   
    \begin{cases}
     \forall \Mtwo, \sigma, \sigma',  \overline{\alpha}, \overline{x} \mbox{ with } \overline{x}=Free(A)\\ % , \mbox{and }  \arising{M\madd\Mtwo}{\sigma}:\\
   \ \ \ \  [\ \ \  \satisfiesA{M}{\sigma}{({A[{\overline {\alpha/x}}]} \ \wedge\ \externalexec)}\  \wedge\ { \leadstoBounded {M\madd\Mtwo}  {\sigma}{\sigma'}} % \\    \ \ \ \ \ \   \ \ \ 
   \ \ \Longrightarrow\ \ 
  %  \ \ \ \ \ \  \ 
   {M},{\sigma'}\models{A[{\overline {\alpha/x}}]} \ \  ]
    \end{cases}
 $% \end{equation}
 \end{itemize}
  \end{definition}
  
 
  \begin{lemma}[Encapsulation Soundness]
\label{lem:encap-soundness}
% A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
For all modules $M$, and assertions $A$: 

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ \Longrightarrow\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{lemma}

