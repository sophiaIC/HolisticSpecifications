All program logics deal with framing in some form or other, \ie conditions under which  satisfaction of  assertions is preserved across program execution. 
This is the subject of the current Section.

We start with  Lemma \ref{l:assrt:unaffect}  which says that satisfaction of an assertion is not affected by replacing a variable by its value, nor by changing the continuation in a state.


\begin{lemma}
\label{lemma:addr:expr}
\label{l:assrt:unaffect}
For all $M$, $\sigma$, $\alpha$, $x$, $\re$, $stmt$, and $A$:

\begin{enumerate}
\item
\label{one:ad:exp}
$x\in \fv(A) \ \ \Longrightarrow \ \ [ \ \satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma}{A[{\interpret \sigma x}/x]} \ ] $ 
\item
$\eval{M}{\sigma}{{\re}}{\alpha}  \ \ \Longrightarrow\ \  [ \ \satisfiesA{M}{\sigma}{A} \  \Longleftrightarrow\   \  \satisfiesA{M}{\sigma}{A[\alpha/\re]} \  \  ]$
\item
$ \satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma[\prg{cont}\mapsto stmt]}{A}$ 
\end{enumerate}

\end{lemma}

 \noindent
We now move to assertion preservation across pushing/popping of frames, or heap modification.

\subsection{Preservation across method call and return}
In most program logics, satisfaction of assertions without any free variables  is preserved when pushing/popping frames
-- \ie immediately after entering a method or  returning from it.
This, however, is not   the case for our assertions, because  $\inside {\alpha}$ depends on the heap as well as the set of objects reachable from the top frame, and  
that changes when the frame changes.
{This is shown, \eg in  Fig. \ref{fig:Protected} where $o_3$ was not protected with top frame $\phi_1$,  
became protected when we pushed the frame $\phi_2$,  and again, is no longer protected when we push $\phi_3$ on the stack. 

 

Nevertheless,  assertions which do  not contain  $\inside {\_}$, called   $\Stable {\_}$, are stable against pushing and popping of frames.  
Moreover, assertions which do  not contain $\inside {\_}$ in negative positions, called $\Pos {\_}$,  are stable against pushing  of {internal} frames provided that the range of the new frame contains locallty reachable addresses -- 
\cf  Defs   in \A\ \ref{app:preserve}.

\begin{lemma}
For all  states $\sigma$ and frames $\phi$, and for all assertions $A$ such that $ fv(A)=\emptyset$:
\label{l:preserve:asrt}
 
\begin{itemize}
\item 
$\Stable{A}\ \ \ \  \Longrightarrow \ \  \ \  [\ \ M, \sigma \models A \ \ \Longleftrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
\item 
\label{l:preserve:asrt:two}
$\Pos{A}\ \ \  \wedge \ \ \  \sdN{   \ Rng(\phi)\subseteq \LRelevantO   \sigma \ } \ \ \ \Longrightarrow $
\\
$\strut \hspace{2cm} \ \  \ \  [\ \ M, \sigma \models A \  \wedge \  M, {\PushSLong \phi \sigma} \models  \intThis \ \ \Longrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
%\item 
%$\Neg{A}\ \ \   \Longrightarrow \ \  \ \  [\ \  M,{\PushSLong \phi \sigma} \models A\ \ \Longrightarrow \ \  M, \sigma \models A   \ \  ]$
%
\end{itemize}
\end{lemma}

 
$Stbl$ assertions give us   preservation of satisfaction against pushing/popping of frames, but do not allow to include 
$\inside {\_}$ requirements -- a crucial ingredient for our work. On the other hand,
$Stb^+$ assertions  give us only limited preservation against pushing, and no preservation against popping. 

\sdN{
\begin{example}
\label{push:does:not:preserve}
$\Pos{A}$ assertions are not necessarily preserved against pushing of frames with external callees. \Eg take 
   $\sigma_1$, $\sigma_2$   to be as in the middle and right pane of  Fig. \ref{fig:Protected}:  We have
$\_,\sigma_1 \models \inside {o_3}$ but $\_,\sigma_2 \not\models \inside {o_3}$.
\end{example}
}

Nevertheless, to deal with method calls,  it is crucial to be able to ensure at the point of a method call, that upon method entry the method's precondition will hold, 
and to use an assertion at the end of method execution to ensure properties which hold upon method return.
We will see how to do that in the next section, and also in Section \ref{s:deep:valid}.
  
   
 \subsection{Viewpoints and Protection}
 \label{s:viewAndProtect}
 
 As we discussed in section \ref{sec:howThird} it may happen that an assertion $A$ is not satisfied from the caller’s
viewpoint, but is satisfied from the callee’s viewpoint:  right before the method call, $A$ might not be satisfied,
but if  $\PushASLong  {\overline y} A$ is satisfied (where $\overline y$ are the receiver and arguments to the call), then $A$
will be satisfied right when the callee’s method body starts. Thus, the operator $\pushSymbolAA$
 translates an assertion from the viewpoint of the callee, to that of the caller.
 
% it applies to assertions and sequences of variables:  $\PushAS y A$   guarantees that $A$ will be satisfied when the values of $y$ have been pushed onto a new frame:
% thus, $\PushAS y A$ is \emph{hypothetical}.
 % : if a state satisfies $\PushAS y A$, then after pushing
% onto that state a frame which contains the values  of $\overline y$, assertion $A$ will be satisfied. }
% $\pushSymbolAA$ is the counterpart to $\pushSymbol$, which we had defined for states, \cf Lemma \ref{lemma:push:ass:state}

% Lemma \ref{lemma:vars:to:addresses} says that: (1)Satisfaction of an assertion $A$ in the context of a state $\sigma$ implies  satisfaction of the assertion resulting  from substituting free variables according to the top frame ($A[\sigma]$)}.
%%(2) A bounded execution step (thus not returning from current call)
%in an external state preserves absolute protection.
%(3) An objects which is protected from  the receiver and arguments of a method call, is protected   after the corresponding frame has been pushed onto the stack.

The  $\pushSymbolAA$  operator is  defined in Fig. \ref{f:Push}. 
Only the first equation is interesting, i.e.  $\PushAS y {(\inside \re)}$: For 
$\re$ to be protected from the viewpoint of the callee, it should be protected from all the call's arguments,
\ie  $\protectedFrom {\re} {\overline {y}}$. 
The notation $\protectedFrom {\re} {\overline {y}}$   stands for $\protectedFrom \re {y_0}\, \wedge\, ...  \protectedFrom \re {y_n}$, assuming that $\overline y$=${y_0, ... y_n}$.
%In all other cases,   $\pushSymbolA$  leaves simple $\re$'s unmodified %(i.e. the second to sixth equation), 
% or is applied to the sub-assertions. % (i.e. the seventh to eleventh equation).



\begin{definition}
\label{def:push}
%\begin{figure}[hbt]
[The $\pushSymbolAA$  operator] is  defined below

$
\begin{array}{c}
\begin{array}{l}
\begin{array}{rclcrcl}
  \PushAS y {(\inside \re)} & \triangleq &  \protectedFrom \re {\overline {y} }
  & \ \ \  \ &
  \PushAS y   {(A_1  \wedge  A_2)} & \triangleq &  (\PushAS y  { A_1})  \wedge  ( \PushAS y  {A_2} )  
\\ 
 \PushAS y {(\protectedFrom \re {\overline {u}})} &  \triangleq& \protectedFrom \re {\overline {u}} 
  & &
 \PushAS y  {(\forall x:C.A)} & \triangleq & \forall x:C.({\PushAS y A} )  
  \\  
  \PushAS y  {(\external \re)} &  \triangleq & {\external \re}  %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
  & & 
  \PushAS y  {(\neg A)} &  \triangleq & \neg( {\PushAS y A} )  
    \\
     \PushAS y  {\re} &  \triangleq&   \re %    \PushAS y  {(\internal \re)} &  \triangleq & {\internal \re}
    & &
    \PushAS y  {(\re:C)} &  \triangleq&   \re:C 
 \end{array}
\end{array}
\end{array}
$
% \caption{The $\pushSymbolAA$  operator  } 
\label{f:Push}
%\end{figure}
\end{definition}

 


\newcommand{\sigmas}{\widetilde \sigma}



\vspace{.1cm}

\begin{example}
\label{push:does:not:imply}
% The requirement   $\fv(A)=\emptyset$   accommodates for the difference between variable maps in $\sigma$ and  $\PushS {y} {\sigma}$.}
%%We could, instead,  require that $fv(A)=\overline x$, \ $\overline x \notin \sigma$, \ $\overline x \notin  \PushAS {y} {A}$, and   assert that (1)\ $M, \sigma[\overline{x \mapsto \alpha} ] \models \PushAS {y} {A}\  \Longrightarrow   \ M,  \PushS {y} {(\sigma[\overline{x \mapsto \alpha}])}   \models A$, and similarly for (2).}
%%In both (1) and (2), we  use the renaming $\sigma[\overline{x \mapsto \alpha} ]$ to ensure that the free variables of $A$ are mapped to the same values in the caller's and the callee's frame.
% \notesep 
$A$ does not imply $\PushAS {y} {A}$: \Eg  take 
  a   $\sigma_1$ where $\interpret {\sigma_1} {\prg{this}}$ = $o_1$, and $o_1$ is internal,  and there is no other object. Then, we have
$\_,\sigma_1 \models \inside {\prg{this}}$ and $\_,\sigma_1 \not\models \protectedFrom {\prg{this}} {\prg{this}}$.

And $\PushAS {y} {A}$  imply $A$. \Eg  take a $\sigma_2$ where $\interpret {\sigma_2} {\prg{this}}$ = $o_1$,
 $\interpret {\sigma_2} {x}$ = $o_2$ , and  $\interpret {\sigma_2} {x.f}$ = $o_3$, and $o_2$ is external, and there are no other objects or fields.
 Then $\_,\sigma_2 \models   \protectedFrom {x.f} {\prg{this}}$ but  $\_,\sigma_2 \not\models \inside {x.f}$.
\end{example}

 Lemma \ref{lemma:push:ass:state}  states that $\pushSymbolAA$ is the counterpart to the states' operator $\pushSymbol$:
 %states the guarantees given by $\pushSymbolAA$: \  
 (1) If \ %the current state 
$\sigma$ satisfies  $\PushAS y A$, then  the callee state  ($\PushS {y} {\sigma}$) % (after pushing a frame with the values of $\overline y$) 
will satisfy $A$. %after pushing a frame with the values of $\overline y$ (here $\PushS {y} {\sigma}$)
(2) is the opposite: {If the callee state ($\PushSLong {(\overline y, \overline z)} {\sigma}$) % (in which we pushed a frame with the values for $\overline y, \overline z$
 satisfies $A$, then the caller state will satisfy 
% (here , conversely,   if a state satisfies  $A$ after a top frame containing the  values of $\overline y$  and some other variables has been pushed % (here \PushSLong {(\overline y, \overline z)} \sigma), 
$\PushAS {y} {A}$. } % will hold {in the caller state}. % after popping that frame.
%, and mapping the free variables of $A$ to their values  in the state  before.


\begin{lemma} 
\label{lemma:push:ass:state}
For any state  $\sigma$, assertion $A$, and variables   $\overline y, \overline z$, disjoint with one another:
\\
If  $\fv(A)=\emptyset$, then
\begin{enumerate}
 \item
 \label{lemma:push:ass:state:one}
$M, \sigma \models \PushAS {y} {A}\ \ \ \ \ \ \  \ \ \    \Longrightarrow  \ \ \ \ M,  \PushS {y} {\sigma}   \models A$
\item
\label{lemma:push:ass:state:two}
$M, { \PushSLong {(\overline y, \overline z)} {\sigma} } \models\  A \  \ \ \ \Longrightarrow  \ \ \ \ M,  \sigma \models  \PushAS  {y} {A}$
\end{enumerate}
\end{lemma}



\noindent
\textbf{NOTE}   
To simplify notation,  we lifted % the $\models$ 
judgements to sets of states: If  $\overline{\sigma}$ is a set of states,  then
$M,   \overline{\sigma} \models A$ stands for  $\forall\sigma\! \in\! \overline{\sigma}[\, M,\sigma \models A \, ]$.    

\footnoteSD{\vspace{.1cm}
\noindent 
{\textbf{Comment}} The $ \pushSymbol$ operator reminds me of the magic wand. Namely, $-\!-\!*$ is spatial and heap based:  the assertion $A -\!-\!* A'$ says: if you combine with a heap that satisfies $A$, then the complete heap will satisfy $A'$. While $\PushASLong {\_} {\_}$ is temporal and  stack based: the assertion  $\PushAS {y} A$ says that if you push a frame with range the values of $\overline y$, then $A$ will be satisfied. {\textbf{End Comment} }
}
 
\subsection{Preservation across heap modifications}

 
Proofs of adherence to {\SpecLang specifications  hinge on the expectation that some,  specific, assertions are always satisfied unless some 
} internal (and thus known) computation took place. 
{We call such assertions   \emph{encapsulated}.}
 

The judgment $M\ \vdash \encaps{A}$  expresses that satisfaction of $A$ involves looking into the state of  
internal objects only,  \cf. Def \ref{d:encaps:sytactic}.
{On the other hand, $M  \models \encaps{A}$ says that assertion $A$  is  \emph{encapsulated} by a module $M$, \ie in all possible states % which arise from execution of module $M$ with any other  module $\Mtwo$, 
execution which involves $M$ and any set of other module $\Mtwo$, always satisfies  $A$  unless the execution  included internal execution steps}.
 

\begin{definition}[An assertion $A$ is \emph{encapsulated} by module $M$] $~$ \\
\label{d:encaps}
\begin{itemize}
%\item 
%$M \vdash \encaps{A}  \ \   \triangleq  \ \  \exists \Gamma.[\ M; \emptyset \vdash \encaps{A}; \Gamma\ ]$ \ \  as defined in Fig. \ref{f:encaps}.
\item
$ % \begin{equation}
    M\ \models \encaps{A}\ \   \triangleq  \ \   
    \begin{cases}
     \forall \Mtwo, \sigma, \sigma',  \overline{\alpha}, \overline{x} \mbox{ with } \overline{x}=Free(A)\\ % , \mbox{and }  \arising{M\madd\Mtwo}{\sigma}:\\
   \ \ \ \  [\ \ \  \satisfiesA{M}{\sigma}{({A[{\overline {\alpha/x}}]} \ \wedge\ \externalexec)}\  \wedge\ { \leadstoBounded {M\madd\Mtwo}  {\sigma}{\sigma'}} % \\    \ \ \ \ \ \   \ \ \ 
   \ \ \Longrightarrow\ \ 
  %  \ \ \ \ \ \  \ 
   {M},{\sigma'}\models{A[{\overline {\alpha/x}}]} \ \  ]
    \end{cases}
 $% \end{equation}
 \end{itemize}
  \end{definition}
  
 
  \begin{lemma}[Encapsulation Soundness]
\label{lem:encap-soundness}
% A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
For all modules $M$, and assertions $A$: 

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ \Longrightarrow\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{lemma}

