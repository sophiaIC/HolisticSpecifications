 \section{Preservation of Satisfaction of Assertions}

\sdN{Satisfaction of an assertion depends on the contents of the heap, and the map of local variables to addresses in the top frame of that stack. 
It is useful to know under what conditions  satisfaction of  assertions is preserved across changes to the state.
In particular, what if the heap remains the same, and the assertion has no free variables?
Usually, in such cases satisfaction is preserved across pushing/popping of frames on the stack.
However, in our assertion language, assertions may talk about protection, and as we have already seen in Fig. 4, this property is affected when we push of pop frames.

In this section we will study the preservation of satisfaction across pushing and popping of frames.

Lemma \ref{l:assrt:unaffect}  says that satisfaction of an assertion is not affected by replacing a variable by its value, nor by changing the continuation in a state.


\begin{lemma}
\label{lemma:addr:expr}
\label{l:assrt:unaffect}
For all $M$, $\sigma$, $\alpha$, $x$, $\re$, $A$:

\begin{enumerate}
\item
\label{one:ad:exp}
$ \satisfiesA{M}{\sigma[x\mapsto \alpha]}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma}{A[\alpha/x]} $ 
\item
$\eval{M}{\sigma}{{\re}}{\alpha}  \ \ \ \Longrightarrow\ \ \  [ \ \satisfiesA{M}{\sigma}{A} \  \Longleftrightarrow\   \  \satisfiesA{M}{\sigma}{A[\alpha/\re]} \  \  ]$
\item
$ \satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma[\prg{cont}\mapsto stmt]}{A}$ 
\end{enumerate}

\end{lemma}

A corollary of   lemma \ref{l:assrt:unaffect}.\ref{one:ad:exp} is that $\satisfiesA{M}{\sigma}{A}  \ \ \Longleftrightarrow  \ \   \satisfiesA{M}{\sigma}{A[{\interpret \sigma x}/x]}$.


\subsubsection{Stable, and Positive Assertions}\footnote{BETTER NAME?}  Stable assertions are those which   do not contain the requirement $\inside{\_}$ are called {\emph {stable}}. 
Their satisfaction is preserved against pushing and popping of frames.
Positive Assertions are those where protection appears only in positive positions.
Their satisfaction is preserved against pushing of frames.

\newcommand{\lclSPACE}{\ \ \ \ \ }
% An assertion is {\emph {stable}}, written as $\Stable A$ if it does not contain $\inside {\re}$ assertions:
\begin{definition}
\label{def:Basic}
%\begin{figure}[hbt]
[$\Stable{\_}$] assertions: %  defined below

$
\begin{array}{l}
 \begin{array}{lll}
  \Stable {\inside{\re}}  \triangleq  false & \lclSPACE &   \Stable {\protectedFrom \re {\overline {u}}} =  
  \Stable  {\internal \re} =  %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
    \Stable {\re}=   
     \Stable {\re:C}\   \triangleq \    true
 \end{array}
  \\
 \begin{array}{lcl}
 \Stable  {A_1  \wedge  A_2}\  \triangleq\     \Stable  { A_1}  \wedge    \Stable  {A_2}    &
\lclSPACE  &  
 \Stable  {\forall x:C.A} =\Stable  {\neg A} \   \triangleq\   \Stable A
 \end{array}
 \end{array}
$
\label{f:Basic}
\end{definition}

 
% An assertion is {\emph {stable}}, written as $\Stable A$ if it does not contain $\inside {\re}$ assertions:
\begin{definition}
\label{def:Pos}
%\begin{figure}[hbt]
[$\Pos{\_}$] assertions: %  defined below

$
\begin{array}{l}
 \begin{array}{l}
  \Pos {\inside{\re}} =  \Pos {\protectedFrom \re {\overline {u}}} =  
  \Pos  {\internal \re} =   
    \Pos {\re}=   
     \Pos {\re:C}\   \triangleq \    true
 \end{array}
  \\
 \begin{array}{lll}
 \Pos  {A_1  \wedge  A_2}\  \triangleq\     \Pos  { A_1}  \wedge    \Pos  {A_2}   \  &
      
 \Pos  {\forall x:C.A}   \triangleq\   \Pos A
\   &
  \Pos {\neg A}  \triangleq \Neg A
 \end{array}
 \\
 \\
  \begin{array}{ll}
  \Neg {\inside{\re}}\  \triangleq \    false &    \Neg {\protectedFrom \re {\overline {u}}} =  
  \Neg  {\internal \re} =   
    \Neg {\re}=   
     \Neg {\re:C}\   \triangleq \    true
 \end{array}
  \\
 \begin{array}{lll}
 \Neg  {A_1  \wedge  A_2}\  \triangleq\     \Neg  { A_1}  \wedge    \Neg  {A_2}   \ \   
 &    
 \Neg  {\forall x:C.A}   \triangleq\   \Neg A \ \ 
&
  \Neg {\neg A}  \triangleq \Pos A
 \end{array}

 \end{array}
$
\label{f:Pos}
\end{definition}

As we see in the following lemma, stability is stronger than positive and also negative protection. On the other hand, positive protection does not imply stability, consider, \eg the assertion $\inside \re$.

\begin{lemma}
For all   assertions $A$  
\label{l:preserve:asrt}
 
\begin{itemize}
\item 
$\Stable{A}\ \ \ \  \Longrightarrow \ \  \ \  \Pos{A}\  \wedge\  \Neg{A} $
\end{itemize}
\end{lemma}

Lemma \ref{l:preserve:asrt}  is about preservation of satisfaction of   assertions  across pushing and popping of frames:

\begin{lemma}
For all  states $\sigma$ and frames $\phi$, and for all assertions $A$ such that $ fv(A)=\emptyset$:
\label{l:preserve:asrt}
 
\begin{itemize}
\item 
$\Stable{A}\ \ \ \  \Longrightarrow \ \  \ \  [\ \ M, \sigma \models A \ \ \Longleftrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
\item 
$\Pos{A}\ \ \ \  \Longrightarrow \ \  \ \  [\ \ M, \sigma \models A \ \ \Longrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
\item 
$\Neg{A}\ \ \   \Longrightarrow \ \  \ \  [\ \ M, \sigma \models A \ \Longleftarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$

\end{itemize}
\end{lemma}
 }
  
   
 \subsubsection{Viewpoints and Protection}
 
 
{The examples in Fig. \ref{fig:Protected} demonstrate that % validity of assertions which refer to 
 protection may be affected by the pushing and popping of frames on the stack. For example, $o_3$ was not protected with top frame $\phi_1$,   became protected when we pushed the frame $\phi_2$,  and again, is no longer protected when we push $\phi_3$ on the stack. 
 
Below we define 
$\pushSymbolAA$, which  translates an assertion from the viewpoint of the callee, to that of the caller:
it applies to assertions and sequences of variables:  $\PushAS y A$   guarantees that $A$ will hold when the values of $y$ have been pushed onto a new frame:
 thus, $\PushAS y A$ is \emph{hypothetical}.
 % : if a state satisfies $\PushAS y A$, then after pushing
% onto that state a frame which contains the values  of $\overline y$, assertion $A$ will hold. }
% $\pushSymbolAA$ is the counterpart to $\pushSymbol$, which we had defined for states, \cf Lemma \ref{lemma:push:ass:state}

% Lemma \ref{lemma:vars:to:addresses} says that: (1)Validity of an assertion $A$ in the context of a state $\sigma$ implies  validity of the assertion resulting  from substituting free variables according to the top frame ($A[\sigma]$)}.
%%(2) A bounded execution step (thus not returning from current call)
%in an external state preserves absolute protection.
%(3) An objects which is protected from  the receiver and arguments of a method call, is protected   after the corresponding frame has been pushed onto the stack.

The  $\pushSymbolAA$  operator is  defined in Fig. \ref{f:Push}. Only the first equation is interesting, i.e.  $\PushAS y {(\inside x)}$: For 
$x$ to be protected from the viewpoint of the callee, it should be protected from all the call's arguments,
\ie  $\protectedFrom x {\overline {y}}$. 
In all other cases,   $\pushSymbolA$  leaves simple $\re$'s unmodified %(i.e. the second to sixth equation), 
 or is applied to the sub-assertions. % (i.e. the seventh to eleventh equation).

\begin{definition}
\label{def:push}
%\begin{figure}[hbt]
[The $\pushSymbolAA$  operator] is  defined below

$
\begin{array}{c}
\begin{array}{l}
\begin{array}{rclcrcl}
  \PushAS y {(\inside \re)} & \triangleq &  \protectedFrom \re {\overline {y} }
  & \ \ \  \ &
  \PushAS y   {(A_1  \wedge  A_2)} & \triangleq &  (\PushAS y  { A_1})  \wedge  ( \PushAS y  {A_2} )  
\\ 
 \PushAS y {(\protectedFrom \re {\overline {u}})} &  \triangleq& \protectedFrom \re {\overline {u}} 
  & &
 \PushAS y  {(\forall x:C.A)} & \triangleq & \forall x:C.({\PushAS y A} )  
  \\  
  \PushAS y  {(\external \re)} &  \triangleq & {\external \re}  %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
  & & 
  \PushAS y  {(\neg A)} &  \triangleq & \neg( {\PushAS y A} )  
    \\
     \PushAS y  {\re} &  \triangleq&   \re %    \PushAS y  {(\internal \re)} &  \triangleq & {\internal \re}
    & &
    \PushAS y  {(\re:C)} &  \triangleq&   \re:C 
 \end{array}
\end{array}
\end{array}
$
% \caption{The $\pushSymbolAA$  operator  } 
\label{f:Push}
%\end{figure}
\end{definition}

 


\newcommand{\sigmas}{\widetilde \sigma}



\vspace{.1cm}

 Lemma \ref{lemma:push:ass:state}  states that $\pushSymbolAA$ is the counterpart to the states' operator $\pushSymbol$:
 %states the guarantees given by $\pushSymbolAA$: \  
 (1) If \ %the current state 
$\sigma$ satisfies  $\PushAS y A$, then   { the callee state (after pushing a frame with the values of $\overline y$) 
will satisfy $A$}. %after pushing a frame with the values of $\overline y$ (here $\PushS {y} {\sigma}$)
(2) is the opposite: {If the callee state (in which we pushed a frame with the values for $\overline y, \overline z$) satisfies $A$, then the
caller state will satisfy 
% (here , conversely,   if a state satisfies  $A$ after a top frame containing the  values of $\overline y$  and some other variables has been pushed % (here \PushSLong {(\overline y, \overline z)} \sigma), 
$\PushAS {y} {A}$. } % will hold {in the caller state}. % after popping that frame.
%, and mapping the free variables of $A$ to their values  in the state  before.


\begin{lemma} 
\label{lemma:push:ass:state}
For any state  $\sigma$, assertion $A$, and variables   $\overline y, \overline z$, disjoint with one another:
\\
If  $\fv(A)=\emptyset$, then
\begin{enumerate}
 \item
 \label{lemma:push:ass:state:one}
$M, \sigma \models \PushAS {y} {A}\ \ \ \ \ \ \  \ \ \    \Longrightarrow  \ \ \ \ M,  \PushS {y} {\sigma}   \models A$
\item
\label{lemma:push:ass:state:two}
$M, { \PushSLong {(\overline y, \overline z)} {\sigma} } \models\  A \  \ \ \ \Longrightarrow  \ \ \ \ M,  \sigma \models  \PushAS  {y} {A}$
\end{enumerate}
\end{lemma}
 \footnoteSD{OLD form:
 \\
 \begin{enumerate}
 \item
 \label{lemma:push:ass:state:one}
$M, \sigma[\overline{x \mapsto \alpha} ] \models \PushAS {y} {A}\ \ \ \     \Longrightarrow  \ \ \ \ M,  \PushS {y} {(\sigma[\overline{x \mapsto \alpha}])}   \models A$
\item
\label{lemma:push:ass:state:two}
$M, {(\PushSLong {(\overline y, \overline z)} {(\sigma[\overline{x \mapsto \alpha} ] )})}  \models\  A \  \ \ \ \Longrightarrow  \ \ \ \ M,  \sigma[\overline{x \mapsto \alpha} ] \models  \PushAS  {y} {A}$
\end{enumerate}
}


\noindent
\textbf{NOTES} \notesep 
{We require   $\fv(A)=\emptyset$ in order to be accommodate for the difference between variable maps in $\sigma$ and  $\PushS {y} {\sigma}$.}
%We could, instead,  require that $fv(A)=\overline x$, \ $\overline x \notin \sigma$, \ $\overline x \notin  \PushAS {y} {A}$, and   assert that (1)\ $M, \sigma[\overline{x \mapsto \alpha} ] \models \PushAS {y} {A}\  \Longrightarrow   \ M,  \PushS {y} {(\sigma[\overline{x \mapsto \alpha}])}   \models A$, and similarly for (2).}
%In both (1) and (2), we  use the renaming $\sigma[\overline{x \mapsto \alpha} ]$ to ensure that the free variables of $A$ are mapped to the same values in the caller's and the callee's frame.
 \notesep 
To simplify notation,  we lifted % the $\models$ 
judgements to sets of states: If  $\sigmas$ is a set of states,  then
$M,   \sigmas \models A$ stands for  $\forall\sigma\! \in\! \sigmas.[\, M,\sigma \models A \, ]$.    

\footnoteSD{\vspace{.1cm}
\noindent 
\blue{\textbf{Comment} The $ \pushSymbol$ operator reminds me of the magic wand. Namely, $-\!-\!*$ is spatial and heap based:  the assertion $A -\!-\!* A'$ says: if you combine with a heap that satisfies $A$, then the complete heap will satisfy $A'$. While $\PushASLong {\_} {\_}$ is temporal and  stack based: the assertion  $\PushAS {y} A$ says that if you push a frame with range the values of $\overline y$, then $A$ will hold. \textbf{End Comment} }
}
%{{I am surprised that $ \pushSymbol$  only affects  ${\inside x}$, and leaves all else unmodified,}}
