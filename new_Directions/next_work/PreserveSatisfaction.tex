Program logics require some form of framing, \ie conditions under which  satisfaction of  assertions is preserved across program execution. 
This is the subject of the current Section.

We start with  Lemma \ref{l:assrt:unaffect}  which says that satisfaction of an assertion is not affected by replacing a variable by its value, nor by changing the continuation in a state.


\begin{lemma}
\label{lemma:addr:expr}
\label{l:assrt:unaffect}
For all $M$, $\sigma$, $\alpha$, $x$, $\re$, $stmt$, and $A$:

\begin{enumerate}
\item
\label{one:ad:exp}
\label{l:assrt:unaffect:one}
$\satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma}{A[{\interpret \sigma x}/x]}   $ 
% holds, but not used
%\item
%$\eval{M}{\sigma}{{\re}}{\alpha}  \ \ \Longrightarrow\ \  [ \ \satisfiesA{M}{\sigma}{A} \  \Longleftrightarrow\   \  \satisfiesA{M}{\sigma}{A[\alpha/\re]} \  \  ]$
\item
$ \satisfiesA{M}{\sigma}{A}   \ \ \ \Longleftrightarrow\ \ \ \satisfiesA{M}{\sigma[\prg{cont}\mapsto stmt]}{A}$ 
\end{enumerate}

\end{lemma}

 \noindent
We now move to assertion preservation across method call and return. % (Sect \ref{s:preserve:call:ret}),   or heap modification (Sect \ref{s:preserve:encaps}).

\subsection{Stability} %{Stability: Preservation across method call and return}
\label{s:preserve:call:ret}
In most program logics, satisfaction of  variable-free assertions  is preserved when pushing/popping frames
-- \ie immediately after entering a method or  returning from it.
This, however, is not   the case for our assertions, where whether $\alpha$ is protected, \ie whether   $\inside {\alpha}$ holds, depends on the heap as well as the set of objects reachable from the top frame;
the latter  changes when the frame changes.
This is shown, \eg in  Fig. \ref{fig:Protected} where 
$\sigma_1,\chi \not\models \inside {o_3}$, then $.\sigma_2,\chi \models \inside {o_3}$, and then $\sigma_3,\chi  \not\models \inside {o_3}$
 %$o_3$ was not protected with top frame $\phi_1$,  
%became protected when we pushed the frame $\phi_2$,  and again, is no longer protected when we push $\phi_3$ on the stack. 

 

%Nevertheless,  
{Assertions} which do  not contain  $\inside {\_}$, called   $\Stable {\_}$, are preserved when pushing/popping  frames.  
{Less strictly}, assertions which do  not contain $\inside {\_}$ in \emph{negative} positions, called $\Pos {\_}$,  are preserved when pushing  {internal} frames provided that the range of the new frame contains locally reachable addresses -- 
\cf  Defs   in \A\ \ref{app:preserve} and Lemma \ref{l:stbl:preserves}.

\begin{lemma}
For all  states $\sigma$, frames $\phi$,   all assertions $A$ with  $\fv(A)=\emptyset $
\label{l:preserve:asrt}
\label{l:stbl:preserves} 
\begin{itemize}
\item 
$\Stable{A} \  \ \  \Longrightarrow  \  \ \  [\ \ M, \sigma \models A \ \ \Longleftrightarrow \ \  M,{\PushSLong \phi \sigma} \models A\ \ ]$
\item 
\label{l:preserve:asrt:two}
$\Pos{A}   \ \wedge    \ Rng(\phi)\!\subseteq\! \LRelevantO   \sigma\ \wedge\  M, {\PushSLong \phi \sigma} \models  \intThis\  \wedge  \ M, \sigma \models A $
% \\
%$\strut \hspace{2cm} \ \  \ \ 
$\  \ \Longrightarrow \  \ M,{\PushSLong \phi \sigma} \models A\ $
\end{itemize}
\end{lemma}


While $Stb^+$ assertions \emph{are} preserved  when pushing  internal frames,   they  are \emph{not} necessarily preserved when pushing  external frames   (\cf  Ex. \ref{push:does:not:preserve}), \emph{nor} when popping frames   (\cf Ex. \ref{ex:motivate:scoped}). 

 
\begin{example}[$Stb^+$  not always preserved by External Push]
\label{push:does:not:preserve}
%In    Fig. \ref{fig:Protected}, where $\sigma_2$ by pushing external frame onto $\sigma_1$, and 
%$\sigma_1 \models \inside {o_3}$ but $\sigma_2 \not\models \inside {o_3}$.
% Bad syntax above, but fits in one line
In    Fig. \ref{fig:Protected}, where $\sigma_3$ emerges by pushing an external frame into $ \sigma_2$â€™s stack we have $\sigma_2 \models \inside {o_3}$ and $\sigma_3 \not\models \inside {o_3}$ 
\end{example}
 

\begin{example}[$Stb^+$ not always preserved by Method Return]
\label{ex:motivate:scoped}
Assume state $\sigma_a$, such that $\interpret {\sigma_a} {\prg{this}}=o_1$, $\interpret {\sigma} {\prg{this}.f}=o_2$, $\interpret {\sigma} {x}=o_3$, $\interpret {\sigma} {x.f}=o_2$,  
and $\interpret {\sigma} {x.g}=o_4$, where $o_2$ is external and all other objects are internal. 
We then have $..,\sigma_a \models  \inside {o_4}$.
Assume %that
 the continuation of $\sigma_a$   consists of a method $x.m()$. Then,
upon entry to that method, when we push the new frame, we have  state $\sigma_b$, which also satisfies $..,\sigma_b \models  \inside {o_4}$.
Assume % that
 the   body of $m$ is $\prg{this}.f.m1(\prg{this}.g); \prg{this}.f := \prg{this};  \prg{this}.g := \prg{this}$, and % that 
 the external method $m1$ stores in the 
receiver a reference to the argument.
Then, at the end of method execution, and before popping the stack, we have   state $\sigma_c$, which also satisfies $..,\sigma_c \models  \inside {o_4}$.
However, after we pop the stack, we obtain $\sigma_d$, for which $..,\sigma_d \not\models  \inside {o_4}$.
\end{example}


% \vspace{.1cm}
{We work with  $Stb^+$  assertions   (the  $Stbl$ requirement is too strong). 
But  we need to address the lack of preservation of $Stb^+$ assertions  {for external method calls and returns}.
 %,  makes it difficult to  ensure certain (perhaps weaker) assertions hold when entering   or returning from a method. 
We do the former   through    \emph{adaptation}   ($\FIXSymbolA$ in Sect \ref{s:viewAndProtect}), and the latter through  
\emph{\scoped satisfaction} (\S \ref{s:scoped:valid}).
  }
   
 \subsection{Adaptation } % and Protection}
 \label{s:preserve:encaps}
 \label{s:viewAndProtect}
 
 As we discussed in \S  \ref{sec:howThird} it is possible for an assertion  not to be satisfied at the caller
but to be  satisfied at the called viewpoint {(the callee)}. %:  right before a method call, $A$ might not be satisfied,
We define the operator $\FIXSymbolA$ which  translates an assertion from the viewpoint of the callee, to that of the caller.

\begin{definition}
\label{def:push}
[The $\FIXSymbolA$  operator]  

$
\begin{array}{c}
\begin{array}{l}
\begin{array}{rclcrcl}
  \PushAS y {\inside \re} & \triangleq &  \protectedFrom \re {\overline {y} }
  & \ \ \  \ &
  \PushAS y   {(A_1  \wedge  A_2)} & \triangleq &  (\PushAS y  { A_1})  \wedge  ( \PushAS y  {A_2} )  
\\ 
 \PushAS y {(\protectedFrom \re {\overline {u}})} &  \triangleq& \protectedFrom \re {\overline {u}} 
  & &
 \PushAS y  {(\forall x:C.A)} & \triangleq & \forall x:C.({\PushAS y A} )  
  \\  
  \PushAS y  {(\external \re)} &  \triangleq & {\external \re}  %   \PushAS y  {(\external \re)} & \triangleq &   {\external \re}
  & & 
  \PushAS y  {(\neg A)} &  \triangleq & \neg( {\PushAS y A} )  
    \\
     \PushAS y  {\re} &  \triangleq&   \re %    \PushAS y  {(\internal \re)} &  \triangleq & {\internal \re}
    & &
    \PushAS y  {(\re:C)} &  \triangleq&   \re:C 
 \end{array}
\end{array}
\end{array}
$
\label{f:Push}
\end{definition}

Only the first equation in  Def.  \ref{def:push}  is interesting,
  $\PushAS y {\inside \re}$.  
For $\re$ to be {protected at  the} callee, it should be protected from all the call's arguments,
\ie  $\protectedFrom {\re} {\overline {y}}$. 
The notation $\protectedFrom {\re} {\overline {y}}$   stands for $\protectedFrom \re {y_0}\  \wedge\  ...  \wedge \protectedFrom \re {y_n}$, assuming that $\overline y$=${y_0, ... y_n}$.

Lemma \ref{lemma:push:ass:state}  states that  $\FIXSymbolA$ indeed adapts assertions from the callee to the caller.
It is the counterpart to the states' operator $\pushSymbol$:
A caller   $\sigma$ satisfies  $\PushAS y A$, if and only if the callee   ($\PushASLong {\phi} {\sigma}$) % (after pushing a frame with the values of $\overline y$) 
satisfies $A$.  
%% The below was fine when we had a more detailed version
% (1) If \ the caller state
%$\sigma$ satisfies  $\PushAS y A$, then  the callee's state  ($\PushASLong {\phi} {A}$) % (after pushing a frame with the values of $\overline y$) 
%will satisfy $A$.  
%(2) is the opposite: {If the called state ($\PushASLong {\phi} {A}$) % (in which we pushed a frame with the values for $\overline y, \overline z$
% satisfies $A$, then the caller state will satisfy 
%$\PushAS {y} {A}$. } % will hold {in the caller state}. % after popping that frame.

\begin{lemma} 
\label{lemma:push:ass:state}
For   state  $\sigma$, assertion $A$ with $\fv(A)=\emptyset$,  variables   $\overline y$, frame $\phi$ with $Range (\phi)=\overline {\interpret \sigma y}$:


\begin{itemize} %{enumerate}
 \item
 \label{lemma:push:ass:state:one}
 \label{lemma:push:ass:state:two}
$M, \sigma \models \PushAS  {y} {A}\ \  \ \ \ \ \  \ \ \    \Longleftrightarrow  \ \ \ \ M,  \PushSLong {\phi} {\sigma}   \models A$
\end{itemize}  % {enumerate}
\end{lemma}


Moreover, $\FIXSymbolA$ turns an assertion into a stable assertion (Lemma \ref{l:push:stbl}), and {in internal states, an assertion implies its adapted version (Lemma \ref{lemma:internal:adapted}).}

\begin{lemma}
For all    assertions $A$ : \ \ \ \ \  $\Stable{ \PushAS y A}$
\label{l:push:stbl}
\end{lemma}

{
\begin{lemma}
\label{lemma:internal:adapted}
For a state $\sigma$, variables $\overline y\subseteq dom(\sigma)$:\ \ \ $M, \sigma \models A \wedge \intThis \ \ \Longrightarrow M, \sigma \models  \PushAS {y} {A}$.
\end{lemma}
}

{ In general, original versions of  assertions do  not  \sdN{imply} adapted versions, nor vice versa:}
 

\begin{example}[Adapted and Original versions are incomparable]
\label{push:does:not:imply}
\notesep   $A$ does not imply $\PushAS {y} {A}$:\  \Eg  take 
  a   $\sigma_1$ where $\interpret {\sigma_1} {\prg{this}}$ = $o_1$, and $o_1$ is {external},  and there is no other object. Then, we have
$\_,\sigma_1 \models \inside {\prg{this}}$ and $\_,\sigma_1 \not\models \protectedFrom {\prg{this}} {\prg{this}}$.
\notesep Nor does  $\PushAS {y} {A}$  imply $A$.\  \Eg  take a $\sigma_2$ where $\interpret {\sigma_2} {\prg{this}}$ = $o_1$,
 $\interpret {\sigma_2} {x}$ = $o_2$ , and  $\interpret {\sigma_2} {x.f}$ = $o_3$, and $o_2$ is external, and there are no other objects or fields.
 Then $\_,\sigma_2 \models   \protectedFrom {x.f} {\prg{this}}$ but  $\_,\sigma_2 \not\models \inside {x.f}$.
\end{example}






 
\subsection{Encapsulation} % : Preservation across heap modifications}
\label{s:preserve:encaps}
 
Proofs of adherence to specifications  hinge on the expectation that some,  specific, assertions are always satisfied unless some internal (and thus known) computation took place. 
{We call such assertions   \emph{encapsulated}.}
 

The judgment $M\ \vdash \encaps{A}$  expresses that satisfaction of $A$ involves looking into the state of  
internal objects only,  \cf. Def \ref{d:encaps:sytactic}.
{On the other hand, $M  \models \encaps{A}$ says that assertion $A$  is  \emph{encapsulated} by a module $M$, \ie in all possible states % which arise from execution of module $M$ with any other  module $\Mtwo$, 
execution which involves $M$ and any set of other modules $\Mtwo$, always satisfies  $A$  unless the execution  included internal execution steps}.
 

\begin{definition}[An assertion $A$ is \emph{encapsulated} by module $M$] $~$ 
\label{d:encaps}
%\begin{itemize}
%\item 
%$M \vdash \encaps{A}  \ \   \triangleq  \ \  \exists \Gamma.[\ M; \emptyset \vdash \encaps{A}; \Gamma\ ]$ \ \  as defined in Fig. \ref{f:encaps}.
%\item

$ % \begin{equation}
    M\ \models \encaps{A}\ \   \triangleq  \ \   
    \begin{cases}
     \forall \Mtwo, \sigma, \sigma',  \overline{\alpha}, \overline{x} \mbox{ with } \overline{x}=\fv(A)\\ % , \mbox{and }  \arising{M\madd\Mtwo}{\sigma}:\\
   \ \ \ \  [\ \ \  \satisfiesA{M}{\sigma}{({A[{\overline {\alpha/x}}]} \ \wedge\ \externalexec)}\  \wedge\ { \leadstoBounded {M\madd\Mtwo}  {\sigma}{\sigma'}} % \\    \ \ \ \ \ \   \ \ \ 
   \ \ \Longrightarrow\ \ 
  %  \ \ \ \ \ \  \ 
   {M},{\sigma'}\models{A[{\overline {\alpha/x}}]} \ \  ]
    \end{cases}
 $% \end{equation}
 %\end{itemize}
  \end{definition}
  
 
  \begin{lemma}[Encapsulation Soundness]
\label{lem:encap-soundness}
% A judgement of the form $\proves{M}{\encaps{A}}$  is\  \emph{sound}, \ if 
For all modules $M$, and assertions $A$: 

$\strut \hspace{1.5cm} \proves{M}{\encaps{A}} \ \ \ \ \Longrightarrow\ \ \ \ \satisfies{M}{\encaps{A}}$.
\end{lemma}

