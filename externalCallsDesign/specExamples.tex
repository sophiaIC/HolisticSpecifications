Here we will write examples of the specs

% \subsection{Flavours and notation}

\subsubsection{Flavours}

There is an open question as to whether the semantics of from-to-... is "deep" or "shallow". By "deep" we mean the semantics where to "to"-part can see inside the future call stack. For example, if external method "m1" called internal  method "m2", and if "m2" called external method " m3", then, fo the semantic oif from-to, do we consider pairs of states where $\sigma$ is in "m1" and $\sigma'$ is in "m3"?  The "deep" defintion would say "yes", and the shallow definition would say "no". The choice does make a difference.

Julian said that in FASE we had chosen "shallow", but in OOPSLA-22, we had chosen "deep". Sophia prefers "shallow".

\subsubsection{Notation}

\paragraph{Spec} Proposed new notation for $from\ A1\ to\  A2\ onlyIf A3$, is: \ \ \  $\onlyIf{A1} {A2} {A3}$. \\
For $from\ A1\ next\  A2\ onlyIf A3$, it is: \ \ \  $\onlyIfSingle{A1} {A2} {A3}$.
\\
For  $from\ A1\ to\  A2\ onlyThrough A3$, is:  \ \ \ $\onlyThrough{A1} {A2} {A3}$.

\paragraph{Assertions} Proposed new notation for external: $\external{p}$. Based on this, we define "outside", as soemthing that is accessible from something external:

\begin{definition}
We define the predicate $\outside{\_}$ as follows:

$\begin{array}{lll}
   \Mod*\Mod{'}, \sigma \models \outside{x} & \triangleq & \ \Mod*\Mod{'}, \sigma \models \exists y.[ \ \access{y} {x} \wedge \external {y}  \ ] \end{array}
$

\end{definition}

Therefore, we will have nothing like "words" or "keywords" in the assertions, or the specifications/

\subsubsection{Specification Implication}


\begin{definition}
A specification $\SpecB{'}$ is \emph{stronger} than a specification $\SpecB{}$:

$\begin{array}{lll}
 \SpecB{'}\prec \SpecB{} & \triangleq &  
 \forall  \Mod,\Mod'. [\ \  \Mod*\Mod'\models \SpecB{'} \ \ \longrightarrow\ \   \Mod*\Mod' \models \SpecB{}\ \ ]
  \end{array}
$

\end{definition}

\textbf{SOPHIA:} we should explore some $\prec$ relations, in the future. And relate with similar in temporal logic. 

\subsection{No Password becomes external}\footnote{Note also, that we had been using "external" on Monday and Tuesday, but it should have been "outside"}

$\begin{array}{lll}
 \Spec{no\_leak\_weak} & \triangleq &  \forall a.  \forall p.\\
 & &   \onlyIf{a:\prg{Account}\wedge a.\prg{pwd}=p}{\outside{p}} {\outside{p}}\   
~ \\
\\
 \Spec{no\_leak\_strong} & \triangleq &  \forall p.\\
 & &   \onlyIf{p:\prg{Password}} {\outside{p}} {\outside{p}}\  \\
 ~ \\
 \Spec{no\_leak\_wrong} & \triangleq\ & \forall p. \\
 & &    \onlyIf{true} {p:\prg{Password} \wedge \outside{p}} {\outside{p}} 

\end{array}
$

\vspace{.1in}
\noindent
Here the following holds:

$\Spec{no\_leak\_wrong}  \ \prec\ \Spec{no\_leak\_strong}  \ \prec \ \Spec{no\_leak\_weak} $

\noindent
Note also that
 $\Spec{no\_leak\_wrong} $ is too strong, because it precludes the creation of any external \prg{Password} .
 
 \subsection{Bank currency constant}
 
 We define as \prg{currcy} the currency of a bank, ie the sum of the balances of all accounts held by that bank.
 
 $\begin{array}{lll}
 \Spec{curr\_const} & \triangleq &  \forall b,n.\\
 & &   \onlyIf{b:\prg{Bank}\wedge b.\prg{currcy}=n}{b.\prg{currcy}\neq n} {false}\   
 \\
  \Spec{curr\_infl} & \triangleq &  \forall b,n.\\
 & &   \onlyThrough{b:\prg{Bank}\wedge b.\prg{currcy}=n}{b.\prg{currcy}> n} {\calls{\_}{b}{\prg{print}}{\_} }   
\end{array}
$
 
 Note that with the deep semantics, the method  \prg{transfer\_2} does not satisfy the spec $ \Spec{curr\_const}$, but with the shallow semantics, it does satisfy the spec $ \Spec{curr\_const}$. The proof will require the use of the spec itself (as in modular verification). And similar arguments about satisfaction of,  and proof of  adherence to, $\Spec{curr\_infl}$.
 
\subsection{Protected Fields vs Protected Values in Fields}

There is a distinction between protected fields, and protected values within fields. 
The specifications below demonstrate this distinction.
 
 $\begin{array}{lll}
 \Spec{protect\_f} & \triangleq &  \forall a.\\
 & &   \onlyIf{a:\prg{Account}\wedge \neg \outside{\prg{a.password}}}
 					{\outside{\prg{a.password}}} 
 					{false}\   
 \\
 \Spec{protect\_v} & \triangleq &  \forall a, p.\\
 & &   \onlyIf{a:\prg{Account}\wedge \prg{a.password} = \prg{p} \wedge \neg \outside{\prg{p}}}
 					{\outside{\prg{p}}} 
 					{false}\    
\end{array}
$
$\Spec{protect\_f}$ says that if a password to an account is not externally known, then 
the field will never be externally known. This does not preclude the example in \S \ref{s:deactivate_leak_old}, as it only says that at any moment, the present value will not be externally known. This is useful in the case of protecting the account balance, as it is necessary to know the current password to withdraw money from the account, not previous passwords.

$\Spec{protect\_v}$ says that if the value that the password field points to is not externally known, then it will never be externally known. This is useful to say that certain fields are safe, and do not leak the values stored there. (julian: I'm not entirely sure that this spec is good enough though)
 