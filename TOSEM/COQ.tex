We have constructed a Coq model\footnote{A current model can be found at: https://github.com/sophiaIC/HolisticSpecifications} \cite{coq} of the core of the Chainmail
specification language, along with the underlying \LangOO language.
Our formalism is organised as follows:
\begin{enumerate}
\item
The \LangOO Language: a class based, object oriented language with mutable references.
\item
Chainmail: The full assertion syntax and semantics defined in Definitions \ref{def:execution:internal:external}, \ref{def:arise}, \ref{def:valid:assertion:access}, \ref{def:valid:assertion:control}, \ref{def:valid:assertion:view}, \ref{def:restrict}, \ref{def:valid:assertion:space}, % Adaptation no longer needed \ref{def:config:adapt},
\ref{def:valid:assertion:time} and \ref{def:module_satisfies}.
\item
\LangOO Properties: Secondary properties of the loo language that aid in reasoning about its semantics.
\item
Chainmail Properties: The core properties defined on the semantics of Chainmail.
\end{enumerate}

%We also formalise several of the properties defined in this paper. 
In Table~\ref{tab:Coq:properties} we list and present the properties of Chainmail we have formalised in Coq.
We have proven that Chainmail obeys much of the properties of classical logic. While we formalise most of the underlying semantics, we make several assumptions in our Coq formalism: (i) the law of the excluded middle,  a property that is well known to be unprovable in constructive logics, and (ii) the equality of variable maps and heaps down to renaming. Coq formalisms often require fairly verbose definitions and proofs of properties involving variable substitution and renaming, and assuming equality down to renaming saves much effort.

\begin{table}
  \begin{tabular}{|l|l|l|l|}
    \hline

\textbf{Lemma \ref{lemma:linking} (and 3)} &
Properties of Linking
        & 
\parbox{.35\textwidth}{\scriptsize\begin{enumerate}[label={(\arabic*)}]
            \item \texttt{moduleLinking\_associative}
            \item \texttt{moduleLinking\_commutative\_1}
            \item \texttt{moduleLinking\_commutative\_2}
            \item \texttt{linking\_preserves\_reduction}
        \end{enumerate}}
        \\
\hline
\textbf{Lemma \ref{lemma:classic}} &   
\parbox{.35\textwidth}{\scriptsize\begin{enumerate}[label={(\arabic*)}]
            \item $A \wedge \neg A \equiv \texttt{false}$
            \item $A \vee \neg A \equiv \texttt{true}$
            \item $A \vee A' \equiv A' \wedge A$
            \item $A \wedge A' \equiv A' \wedge A$
            \item $(A \vee A') \vee A'' \equiv A \vee (A' \vee A'')$
        \end{enumerate}}
        & 
\parbox{.35\textwidth}{\scriptsize\begin{enumerate}[label={(\arabic*)}]
            \item \texttt{sat\_and\_nsat\_equiv\_false}
            \item -
            \item \texttt{and\_commutative}
            \item \texttt{or\_commutative}
            \item \texttt{or\_associative}
        \end{enumerate}}
        \\
\hline
\textbf{Lemma \ref{lemma:basic_assertions_classical}} &   
\parbox{.35\textwidth}{\scriptsize\begin{enumerate}[label={(\arabic*)}]
            \item $A \wedge \neg A \equiv \texttt{false}$
            \item $A \vee \neg A \equiv \texttt{true}$
            \item $A \vee A' \equiv A' \wedge A$
            \item $A \wedge A' \equiv A' \wedge A$
            \item $(A \vee A') \vee A'' \equiv A \vee (A' \vee A'')$
            \item $(A \vee A') \wedge A'' \equiv (A \vee A'') \wedge (A' \vee A'')$
            \item $(A \wedge A') \vee A'' \equiv (A \wedge A'') \vee (A' \wedge A'')$
            \item $\neg (A \wedge A') \equiv (\neg A \vee \neg A')$
            \item $\neg (A \vee A') \equiv (\neg A \wedge \neg A')$
            \item $\neg (\exists x.A) \equiv \forall x. (\neg A)$
            \item $\neg (\exists S.A) \equiv \forall S. (\neg A)$
            \item $\neg (\forall x.A) \equiv \exists x. (\neg A)$
            \item $\neg (\forall S.A) \equiv \exists S. (\neg A)$
        \end{enumerate}}
        & 
\parbox{.35\textwidth}{\scriptsize\begin{enumerate}[label={(\arabic*)}]
            \item \texttt{sat\_and\_nsat\_equiv\_false}
            \item -
            \item \texttt{and\_commutative}
            \item \texttt{or\_commutative}
            \item \texttt{or\_associative}
            \item \texttt{and\_distributive}
            \item \texttt{or\_distributive}
            \item \texttt{neg\_distributive\_and}
            \item \texttt{neg\_distributive\_or}
            \item \texttt{not\_ex\_x\_all\_not}
            \item \texttt{not\_ex\_$\Sigma$\_all\_not}
            \item \texttt{not\_all\_x\_ex\_not}
            \item \texttt{not\_all\_$\Sigma$\_ex\_not}
        \end{enumerate}}
\\
\hline
  \end{tabular}
  \caption{Chainmail Properties Formalised in Coq}
  \label{tab:Coq:properties}
\end{table}