% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)
\usepackage{relsize}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{xspace}
\usepackage{definitions}
\usepackage{multirow,bigdelim}
\usepackage{pbox}
\usepackage{courier}
\usepackage{amssymb}

\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!
\newcommand{\dispatch}[1]{\blacktriangleright #1 \blacktriangleleft}

%%% END Article customizations

%%% The "real" document content comes below...

\title{Callbacks}
\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section{Unrestricted External Method Calls in \Nec}
We need to to define Hoare logic rules for code that potentially contains calls or returns to external
code. Specifically, we need to define Hoare logic rules for internal code that ends in either a return
or call to external code, but is otherwise purely internal. Thus, the conclusion of our rules need to be of the following two forms:
$$\proves{M}{\hoare{A}{s; \prg{return } x}{A'}}$$ and
$$\proves{M}{\hoare{A}{s; \blacktriangleright x.m(\overline{y})\blacktriangleleft}{A'}}$$
The first is self explanatory, i.e. some statements (s) followed by a return. The second introduces new
syntax: $\blacktriangleright x.m(\overline{y}) \blacktriangleleft$. This means that the post-condition ($A'$)
holds directly after the method call is dispatched (i.e. in the new frame created by the method call $x.m(\overline{y})$), and not after the method call has completed.
We are not attempting to prove anything about the state of the program after some unknown 
external computation, we are only attempting to prove properties of the program state when entering 
external code from internal code. In fact, it is not clear that we can know much about the 
program state upon completion of $x.m(\overline{y})$ at this low level, for that we need much 
higher level \Nec specifications that consider the entire internal module.

\subsection{Extension to \Nec Assertions}
Before we introduce new rules for \Nec, we must introduce a new assertion form.
If unrestricted external method calls are allowed, we introduce counter-examples to proofs that certain methods 
must have been called. An example is the \prg{transfer} method below, a variant on the \prg{transfer} method 
from the bank account example in the OOPSLA 2022 paper.
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
method transfer(pwd, acc, amt)
	if this.authenticate(pwd)
		this.logger.log(...)
		balance -= amt
		acc.balance += amt
	return null
\end{lstlisting}
Suppose we wish to prove:
\begin{lstlisting}[language = Chainmail, frame = lines, mathescape = true]
Strans $\triangleq$ a : Account $\wedge$ a.balance = bal
			to a.balance < bal
			onlyThrough _ calls a.transfer(a.password, acc, amt)
\end{lstlisting}
In the OOPSLA 2022 version there was no external call \prg{this.logger.log(...)}, and as a result we could prove that if the 
balance ever decreased then execution must have passed through a program state where \prg{transfer} was called.
This is not true in the \prg{transfer} method above as the initial program state referenced in \prg{Strans} might
refer to an external program state that arises from \prg{this.log.logger(...)}, i.e. midway through the call to \prg{transfer},
and not before the call to transfer. For this reason, we need a broader specification on method calls, an we introduce
the assertion form $\called{\_}{\prg{a}}{\prg{transfer}}{\prg{a.password}, \prg{acc}, \prg{amt}}$ with the following semantics:
\begin{itemize}
\item
$\satisfies{M; (\chi, \psi)}{\called{x}{y}{m}{\overline{z}}}$ iff there exists some $\phi \in \psi$ such that 
\begin{description}
\item[-]
$\phi.(\prg{contn}) = (w := y'.m(\overline{z'}); s)$ for some variables $w, y', \overline{z'}$, and some statement $s$, and
\item[-]
$\interpret{\sigma}{x} = \interpret{\sigma}{\prg{this}}$
\item[-]
$\interpret{\sigma}{y} = \interpret{\sigma}{y'}$
\item[-]
$\interpret{\sigma}{\overline{z}} = \interpret{\sigma}{\overline{z}'}$
\end{description}
\end{itemize}

\subsection{Extension to \Nec Proof System}
\label{s:extension}
Below are some proposed proof rules to extend \Nec so it is able to 
reason about unrestricted external method calls.

\begin{mathpar}
\infer
	{}
	{\proves{M}
		{\hoare
			{z.f = y}
			{x := z.f}
			{\access{x}{y}}}}
	\quad(\textsc{Read})
	\and
\infer
	{}
	{\proves{M}
		{\hoare
			{\true}
			{x.f := y}
			{\access{x}{y}}}}
	\quad(\textsc{Write})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\internal{x}}
			{s}
			{\internal{x}}
		}
	}
	\quad(\textsc{Internal})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\external{x}}
			{s}
			{\external{x}}
		}
	}
	\quad(\textsc{External})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{y \neq z \wedge \neg \access{x}{y}}
			{\return{z}}
			{\neg \access{x}{y}}
		}
	}
	\quad(\textsc{Ret-Access$_1$})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\prg{this} \neq x \wedge \access{x}{y}}
			{\return{z}}
			{\access{x}{y}}
		}
	}
	\quad(\textsc{Ret-Access$_2$})
	\and
\infer
	{}
	{\proves{M}
		{\hoare
			{e}
			{\return{z}}
			{e}}}
	\quad(\textsc{Ret-Exp})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{x = this}
			{\dispatch{y.m(\overline{z})}}
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}}}
	\quad(\textsc{Called$_I$})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}
			{x' := y'.f}
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}}}
	\quad(\textsc{Called-Read})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}
			{x'.f := y'}
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}}}
	\quad(\textsc{Called-Write})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}
			{x' := y'.m'(\overline{z}')}
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}}}
	\quad(\textsc{Called-Call})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}
			{\prg{if}(e)\ s1\ \prg{else}\ s2}
			{\called
				{x}
				{y}
				{m}
				{\overline{z}}}}}
	\quad(\textsc{Called-If})
	\and
\infer
	{}
	{\proves{M}
		{\hoare
			{y \not\in \overline{z} \wedge \neg \access{x}{y}}
			{\dispatch{z_0.m(\overline{z})}}
			{\neg \access{x}{y}}}}
	\quad(\textsc{Call-Access$_1$})
	\and
\infer
	{}
	{\proves{M}
		{\hoare
			{y \in \overline{z}}
			{\dispatch{x.m(\overline{z})}}
			{\access{x}{y}}}}
	\quad(\textsc{Call-Access$_2$})
	\and
\infer
	{}
	{\proves{M}
		{\hoare
			{\access{x}{y}}
			{\dispatch{z_0.m(\overline{z})}}
			{\access{x}{y}}}}
	\quad(\textsc{Call-Access$_3$})
	\and
\infer
	{}
	{\proves{M}
		{\hoare
			{e}
			{\dispatch{z_0.m(\overline{z})}}
			{e}}}
	\quad(\textsc{Call-Exp})
	\and
\infer
	{
	\proves{M}
		{\hoare
			{A_1 \wedge \neg A}
			{s}
			{\neg A_2}}
	}
	{
	\proves{M}
		{\hoare
			{A_1 \wedge \neg A}
			{s}
			{A_2}}
	}
	\quad(\textsc{Necessary})
\end{mathpar}
From \textsc{Ret-Access$_1$} and \textsc{Call-Access$_1$} we can prove \textsc{Ret-Inside}, \textsc{Call-Inside$_1$}, and \textsc{Call-Inside$_2$}:
\begin{mathpar}
\infer
	{}
	{\proves
		{M}
		{\hoare
			{x \neq y \wedge \wrapped{x}}
			{\return{y}}
			{\wrapped{x}}}}
	\quad(\textsc{Ret-Inside})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{x \not\in \overline{z} \wedge \wrapped{x}}
			{\dispatch{y.m(\overline{z})}}
			{\wrapped{x}}}}
	\quad(\textsc{Call-Inside$_1$})
	\and
\infer
	{}
	{\proves
		{M}
		{\hoare
			{\internal{y} \wedge \wrapped{x}}
			{\dispatch{y.m(\overline{z})}}
			{\wrapped{x}}}}
	\quad(\textsc{Call-Inside$_2$})
\end{mathpar}

\paragraph{Extended \Nec rules with Unrestricted External Method Calls.}
To help define an extension to \Nec, we introduce the following definition:
\begin{definition}[Maximally Internal Chunks]
For a module $M$, let $S_M$ be the the set of all maximally internal code chunks within $M$.
\end{definition}
We introduce the following rule to \Nec to allow for unrestricted external method calls from internal code.
\begin{mathpar}
\infer
	{
	[\forall s \in S_M, 
		\proves
			{M}
			{\hoare
				{A_1 \wedge \neg A}
				{s}
				{\neg A_2}}] \\
	\proves{M}{A_1 \longrightarrow A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A}}}
	}
	{\onlyIfSingle{A_1}{A_2}{A}}
	\quad(\textsc{If1-Encaps})
\end{mathpar}
We now remove \textsc{If1-Classical}, \textsc{If1-Inside}, and \textsc{If1-Internal} from the \Nec defined in the OOPSLA 2022 paper as
they are derivable from the rules defined above and are redundant.



\section{Specifying Unrestricted External Method Calls}

Our proposed strategy for introducing unrestricted external method calls (and thus potential re-entrant code)
is to specify all ``\emph{maximally internal blocks}''. Consider the following variant of the \prg{Bank Account}
example:
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
module Bank
	class Password
	class Account
		field balance : int
		field password : Password
		method pay(pwd, acc, amt)
			if this.authenticate(pwd)
				balance -= amt
				acc.send(amt)
			return null
		method setPassword(pwd, newPwd)
			if this.authenticate(pwd)
				this.password = pwd
			return null
		method authenticate(pwd)
			return this.password == pwd
\end{lstlisting}
Here an \prg{Account} object has a \prg{pay} method that includes the external method call \prg{acc.send(amt)}.
The \emph{maximally internal blocks} of \prg{pay} in the above example are:
\begin{lstlisting}[language = Chainmail, frame = lines]
if this.authenticate(pwd)
	balance -= amt
	acc.send(amt)
\end{lstlisting}
\begin{lstlisting}[language = Chainmail, frame = lines]
return null
\end{lstlisting}
\prg{setPassword} and \prg{authenticate} contain no external method calls, and thus the method bodies are maximally internal.
Suppose we wish to prove that \prg{Bank} satisfies the following specification:
\begin{lstlisting}[language = Chainmail, frame = lines, mathescape = true]
Sbank $\triangleq$ a : Account $\wedge$ a.balance = bal
			to a.balance < bal
			onlyIf $\neg$inside(a.password)
\end{lstlisting}
Our proof broadly follows 5 steps:
\begin{enumerate}
\item
\label{A}
Proof that a decrease in balance requires either a call to \prg{pay}, or for \prg{pay} to be executed at some intermediate point 
\item
Proof that for \prg{pay} to be executing requires that some external object has access to \prg{a.password}, i.e. that $\neg\wrapped{\prg{a.password}}$
\item
\label{B}
Proof that if $\neg\wrapped{\prg{a.password}}$ is true at some intermediate point, then either $\neg\wrapped{\prg{a.password}}$ was true at the start,
or $\wrapped{\prg{a.password}}$ was true, and some external object gained access to \prg{a.password}
\item
\label{C}
Proof that it is not possible for external objects to gain access to \prg{a.password} if $\wrapped{\prg{a.password}}$ is true.
\item
Therefore, by \ref{B} and \ref{C} we have the desired result.
\end{enumerate}
Much of the details of the above proof follows that of the OOPSLA 2022 paper, however the two proofs differ in the way proofs about internal 
computation are constructed as the new version includes a call to external code in \prg{pay}, i.e. \ref{A} and \ref{C} above.


\subsection{Proof of Step \ref{A}}
\label{ss:stepA}
To prove step \ref{A} we need to prove that for all maximally internal chunks $s$ we have
\begin{lstlisting}[language = Chainmail, frame = lines, mathescape = true]
PayDecrBal $\triangleq$
	{a : Account $\wedge$ a.balance = bal $\wedge$ $\neg$ _ calls a.pay(a.password, _, _)
	$s$
	{a.balance $\geq$ bal}
\end{lstlisting}
There are 5 maximally internal chunks to \prg{Bank}:
\begin{enumerate}
\item
\label{chunk:pay:correctPwd1}
The branch of \prg{pay} where the password is correct
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
	if this.authenticate(pwd) // pwd == a'.password
		balance -= amt
		$\blacktriangleright$acc.send(amt)$\blacktriangleleft$
\end{lstlisting}
\item
\label{chunk:pay:correctPwd2}
The remaining statements after the return of \prg{send}  in the \prg{pay} method
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
return null // the remaining statements after the call to send
\end{lstlisting}
\item
\label{chunk:pay:incorrectPwd}
The branch of \prg{pay} where the password is not correct
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
	if this.authenticate(pwd) // pwd != a'.password i.e. we skip the if statement
		balance -= amt
		acc.send(amt)
	return null
\end{lstlisting}
\item
\label{chunk:authenticate}
The body of authenticate
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
$\blacktriangleright$a'.authenticate(pwd)$\blacktriangleleft$
	return this.password == pwd
\end{lstlisting}
\item
\label{chunk:setPassword}
The body of \prg{setPassword}
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
$\blacktriangleright$a'.setPassword(pwd, newPwd)$\blacktriangleleft$
	if this.authenticate(pwd)
		this.pwd = newPwd
	return null
\end{lstlisting}
\end{enumerate}
We can prove \prg{PayDecrBal} for all these chunks. It is trivially satisfied by \ref{chunk:pay:correctPwd1}, \ref{chunk:pay:correctPwd2}, 
and \ref{chunk:pay:incorrectPwd} because $\neg\called{\_}{\prg{a}}{\prg{called}}{\prg{a.password, \_, \_}}$ is not true, and thus 
the precondition does not hold, and it is satisfied by \ref{chunk:authenticate} and \ref{chunk:setPassword} because they do not modify 
\prg{a.balance}. To construct these proofs, we use the rules defined in \S \ref{s:extension}. We start by proving that the correct account
and password are necessary to decrease the balance:
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
{a : Account $\wedge$ a.balance = bal $\wedge$ (a' $\neq$ a $\vee$ pwd $\neq$ a.password)}
	$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
		if this.authenticate(pwd) // pwd == a'.password
			balance -= amt
			$\blacktriangleright$acc.send(amt)$\blacktriangleleft$
{a.balance $\geq$ bal}
\end{lstlisting}
To construct this proof, we consider both branches of the proof independently. Thus
by (\textsc{Call-Exp}) and consequence we get:
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
{a : Account $\wedge$ a.balance = bal $\wedge$ a' $\neq$ a}
	$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
{a.balance $\geq$ bal $\wedge$ a' $\neq$ a}
\end{lstlisting}
by consequence and composition we get:
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
{a : Account $\wedge$ a.balance = bal $\wedge$ a' $\neq$ a}
	$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
		if this.authenticate(pwd) // pwd == a'.password
{a.balance $\geq$ bal $\wedge$ a' $\neq$ a}
\end{lstlisting}
by consequence and composition we get:
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
{a : Account $\wedge$ a.balance = bal $\wedge$ a' $\neq$ a}
	$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
		if this.authenticate(pwd) // pwd == a'.password
			balance -= amt
{a.balance $\geq$ bal $\wedge$ a' $\neq$ a}
\end{lstlisting}
by consequence and composition we get:
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
{a : Account $\wedge$ a.balance = bal $\wedge$ a' $\neq$ a}
	$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
		if this.authenticate(pwd) // pwd == a'.password
			balance -= amt
			$\blacktriangleright$acc.send(amt)$\blacktriangleleft$
{a.balance $\geq$ bal}
\end{lstlisting}
Using the same approach we prove:
\begin{lstlisting}[language = Chainmail, frame  = lines, mathescape = true]
{a : Account $\wedge$ a.balance = bal $\wedge$ pwd $\neq$ a.password}
	$\blacktriangleright$a'.pay(pwd, acc, amt)$\blacktriangleleft$
		if this.authenticate(pwd) // pwd == a'.password
			balance -= amt
			$\blacktriangleright$acc.send(amt)$\blacktriangleleft$
{a.balance $\geq$ bal}
\end{lstlisting}

\subsection{Proof of Step \ref{C}}
The proof of step \ref{C} follows much the same structure as the proof of step \ref{A}. For all maximally internal chunks, we are interested 
in proving the following specification holds:
\subsection{Proof of Step \ref{A}}
To prove step \ref{A} we need to prove that for all maximally internal chunks $s$ we have
\begin{lstlisting}[language = Chainmail, frame = lines, mathescape = true]
PwdLeak $\triangleq$
	{a : Account $\wedge$ inside(a.password)}
	$s$
	{inside(a.password)}
\end{lstlisting}
Again, we refer to the maximally internal code chunks referred to in \S \ref{ss:stepA}.
Specifically, none of the code chunks grant access to \prg{a.password}.
 
\section{External Method Call Examples}
\subsection{Call to External, Untrusted Code, Effectively Call-back Free}
\label{s:ex1}
In the example below, the \prg{pay} method makes an external method call \prg{send} to the unknown object \prg{acc}
after to decreasing the \prg{balance} by \prg{amt}. This is \emph{effectively callback free} as the external method 
call occurs at the end of the method, and thus \prg{acc.send(amt)} has no effect on the behaviour of \prg{pay}.
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
module Bank
	class Password
	class Account
		field balance : int
		field password : Password
		method pay(pwd, acc, amt)
			if this.authenticate(pwd)
				balance -= amt
				acc.send(amt)
			return null
		method setPassword(pwd, newPwd)
			if this.authenticate(pwd)
				this.password = pwd
			return null
		method authenticate(pwd)
			return this.password == pwd
\end{lstlisting}

\subsection{Call to External, Untrusted Code, with a potential for Re-entrancy Attack}
The example below is a variant of the example in \S \ref{s:ex1}, where the call \prg{acc.send(amt)}
occurs before the \prg{balance} is decreased, and thus the account can be exploited by \prg{acc}
using re-entrant calls to \prg{pay} to send more money than is due.
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
module Bank
	class Password
	class Account
		field balance : int
		field password : Password
		method pay(pwd, acc, amt)
			if this.authenticate(pwd)
				acc.send(amt)
				balance -= amt
			return null
		method setPassword(pwd, newPwd)
			if this.authenticate(pwd)
				this.password = pwd
			return null
		method authenticate(pwd)
			return this.password == pwd
\end{lstlisting}

\subsection{Call to External Code, Nested Within an Internal Call}
The example below includes a \prg{Logger} as a field to \prg{Account}. \prg{Logger}
is externally defined and untrusted. During payment, we pass to logger the amount being paid, 
and the receiver.
\begin{lstlisting}[language = Chainmail, frame = lines]
module Logging
  class Logger
  	field logFile : Out
  	method log(s : String)
  		logFile.append(s)
module Bank
	import Logging
	class Password
	class Account
		field balance : int
		field password : Password
		field logger : Logger
		method pay(pwd, acc, amt)
			if this.authenticate(pwd)
				balance -= amt
				logger.log(''${} paid to {}'', amt, acc)
				acc.send(amt)
				return null
			logger.log(''Authentication Failed.'')
			return null
		method setPassword(pwd, newPwd)
			if this.authenticate(pwd)
				this.password = pwd
		method authenticate(pwd)
			logger.log(``Authenticating'')
			return this.password == pwd
\end{lstlisting}

\subsection{Call to External, Trusted Code}

\begin{lstlisting}[language = Chainmail, frame = lines]
module Logging
  class Logger
  	field logFile : Out
  	method log(s : String)
  		logFile.append(s)
module Bank
	import Logging
	class Password
	class Account
		field balance : int
		field password : Password
		field logger : Logger
		method pay(pwd, acc, amt)
			if this.authenticate(pwd)
				balance -= amt
				logger.log(''${} paid to {}'', amt, acc)
				acc.send(amt)
				return null
			logger.log(''Authentication Failed.'')
			return null
		method setPassword(pwd, newPwd)
			if this.authenticate(pwd)
				this.password = pwd
		method authenticate(pwd)
			return this.password == pwd
\end{lstlisting}




\end{document}
