
The specification of  a \prg{Purse} appears in Fig. \ref{fig:PurseSpec}. This specification is at level 1, and therefore pre-conditions for not mention $\obeys x {Purse}$ but postconditions do.
The specification of  an  \prg{Escrow} appears in Fig. \ref{fig:EscrowSpec}. This specifications is at level 2, and therefore both pre- and post-conditions may mention  $\obeys x {Purse}$ .

\newcommand{\sMT}{sellerM} 
\newcommand{\bMT}{buyerM}
\newcommand{\sGT}{sellerG} 
\newcommand{\bGT}{buyerG}
\newcommand{\sM}{\prg{\sMT}}
\newcommand{\bM}{\prg{\bMT}}
\newcommand{\sG}{\prg{\sGT}}
\newcommand{\bG}{\prg{\sGT}}
\newcommand{\old}{\ensuremath{_{old}}}

\subsection{Purse}

The \prg{Purse} has a ghost field (or abstract predicate), \prg{CanTrade(\_)}, which guarantees that the receiver and argument belong to the same \prg{Mint}.  It also has another ghost field, which is the balance of the account.

\textbf{To discuss} \begin{enumerate}
\item
implicit obeys for the receiver
\item
\prg{CanTrade} definition
\item
\prg{CanTrade} role
\end{enumerate}
%   fields sellerMoney, sellerGoods, buyerMoney, buyerGoods //  Purse
%   fields price, amt   // Number
% had to drop this one

\begin{figure*}[t]
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{specification}$ $Purse$ {
    
    $\textbf{ghost}$ balance:int
    $\textbf{ghost}$ CanTrade(x):bool  
         
    $\textbf{invr}\  \prg{this}.\prg{balance}\geq 0$  
    $\textbf{invr}\  \forall \prg{p}:\prg{Object}.[\ \ \prg{this.CanTrade(p)} \ \longrightarrow \  \obeys {\prg{p}} {\prg{Purse}}\ \wedge \  \prg{p.CanTrade(this)} \  ]$
    $\textbf{invr}\   \forall \prg{p1},\prg{p2}:\prg{Object}[\ \ \prg{this.CanTrade(p1)}\ \wedge\  \prg{p1.CanTrade(p2)}\ \longrightarrow \  \prg{this.CanTrade(p2)}\ ]$  
    $\textbf{scoped-invr}\  \forall b:int.[\ \inside{\prg{this}}  \ \wedge \prg{this}.\prg{balance}\geq b \ ]$
     
     
    true  // implicit $\obeys {\prg{this}} {Purse}$
         $\textbf{\{}$ this.transfer(p,amt) $\textbf\}$ : bool
    res $\wedge$  this.CanTrade(p) // implicit $\obeys {\prg{p}} {\prg{Purse}}$
    $\vee$
    $\neg$res $\wedge$ [ this==p $\vee$ this.balance$\leq$amt $\vee$ $\neg(\, \prg{this.CanTrade(p)}\,)$ ]

    this$\neq$p $\wedge$ this.balance=bm$\geq$amt $\wedge$  this.CanTrade(p)  
     // $implicit \obeys {\prg{this}} {Purse} \ \wedge\ \    \obeys {\prg{p}} {\prg{Purse}}$
         $\textbf{\{}$ this.transfer(p,amt) $\textbf\}$ : bool
   res $\wedge$ this.balance=balT-amt $\wedge$ p.balance=balP+amt 

}

\end{lstlisting}
\caption{Specification of  $Purse$ -- 1st version}
\label{fig:PurseSpec}
 \end{figure*}
 
 
 \begin{figure*}[t]
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{specification}$ $Purse$ {
    
    $\mbox{...  \textbf{ghost}, \textbf{invr}, \textbf{scoped-invr} } as\ earlier \ ...$
     
    // $implicit\  \obeys {\prg{this}} {\prg{Purse}}$
    this.CanTrade(p) 
    // $implicit \ obeys {\prg{p}} {\prg{Purse}}$
     $\wedge$  this$\neq$p $\wedge$ this.balance=balT$\geq$amt $\wedge$ p.balance=balP
         $\textbf{\{}$ this.transfer(p:Object,amt:nat) $\textbf\}$ : bool
    res $\wedge$ this.balance=this.balance\old-amt $\wedge$ p.balance=p.balance\old+amt 

    // $implicit\  \obeys {\prg{this}} {\prg{Purse}}$
    this=p $\vee$ this.balance$\leq$amt $\vee$ $\neg(\, \prg{this.CanTrade(p)}\,)$  
         $\textbf{\{}$ this.transfer(p,amt) $\textbf\}$ : bool
    $\neg$ res $\wedge$ this.balance=this.balance\old $\wedge$ p.balance=p.balance\old
}

\end{lstlisting}
\caption{Specification of  $Purse$ -- 2nd version}
\label{fig:PurseSpec:two}
 \end{figure*}
 
 
A possible implementation of \prg{Purse} appears below. The Purses have a field storing their Mint and their balance

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{class}$ $PurseImpl\_a\ \textbf{implements} Purse$ {
    
    $\textbf{field}$ myMint: Mint
    $\textbf{field}$ myBalance: int
     
    $\textbf{ghost}$ CanTrade(x) $\textbf{is}$ this.myMint = x.myMint
    $\textbf{ghost}$ balance $\textbf{is}$ this.myBalance
    
    method transfer(p:Object,amt:nat)  // external
    	if p.myMint == this.myMint and this.blance>= amt 
	then
		this.balance -= amt
		p.balance += amt
		// will throw exception if p is not from class \prg{Purse}
		return true
	else
		return false	
  
}
\end{lstlisting}

A anotherimplementation of \prg{Purse} appears below. The Purses have a field storing their Mint, but their balances are stored in a 
lookup table in the Mint

\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
 $\textbf{class}$ Mint{

	field myPurses ... a list of Purse
	field myBalances .., a map from Purse to int
	
	method inMint(p:Purse) : bool    //  internal
	...	
	method getBalance{p:Purse): int
	...
	method setBalance(p:Purse,amt:int): void
	...	
}
 $\textbf{class}$Purse{
    
    $\textbf{field}$  myMint: Mint
     
    $\textbf{ghost}$ CanTrade(x) $\textbf{is}$ this.myMint.inMint(x)
    $\textbf{ghost}$ balance $\textbf{is}$ this.myMint = x.myMint
    
    method transfer(p:Object,amt:nat) // external 
    	if myMint.inMint(p) and myMint.getBalance(this)>= amt 
	then
		myMint.setBalance(this,...)
		myMint.setBalance(p,...)
		return true
	else
		return false	
  
}
\end{lstlisting}



\begin{figure*}[t]
\begin{lstlisting}[mathescape=true, language=Chainmail, frame=lines]
$\textbf{specification}$ $Escrow$ {
    
    //   1$^{st}$ case:
    $\obeys  {\{\sM,\sG\}} {Purse}$ $\wedge$ 
    $\sM$.CanTrade($\bM$) $\wedge$  $\sG$.CanTrade($\bG$)  $\wedge$ price, amt:$\mathbb{N}$  $\wedge$
    $\bM$.balance=bm$\geq$price  $\wedge$  $\sM$.balance=sG$\geq$amt $\wedge$ ...
    $\obeys  {p} {Purse}$   $\wedge$ p.balance = pM
           $\textbf{\{}$ this.deal($\sM,\, \bM,\, \sG,\, \bG$, price, amt) $\textbf\}$
    res $\wedge$
    $\bM$.balance=bM-price $\wedge$ $\sM$.balance=....  $\wedge$
    p.balance=pM

     //   2$^{nd}$ case:
    $\obeys  {\sM } {Purse}$ $\wedge$ $\neg(\obeys  { \bM} {Purse})$ $\wedge$ 
    ....
    $\obeys  {p} {Purse}$ $\wedge$ $\protectedFrom {p} {\{ \bM, \sG, \bG \}}$  $\wedge$ p.balance = pM
          $\textbf{\{}$ this.deal($\sM,\, \bM,\, \sG,\, \bG$, price, amt) $\textbf\}$
    $\neg$ res $\wedge$
    .... $\wedge$
    p.balance=pM
     
}

\end{lstlisting}
\caption{Specification of  $Escrow$.\prg{::deal} -- Incomplete}
\label{fig:EscrowSpec}
 \end{figure*}