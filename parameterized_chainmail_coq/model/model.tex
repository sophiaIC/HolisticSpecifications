	\title{Model Outline}	
	
	\documentclass[12pt]{article}
	
	\usepackage{mathpartir}
	\usepackage{amsmath}
	\usepackage{amsthm}
	\usepackage{amssymb}
	\usepackage{color,soul}
	\usepackage{oz}
	\usepackage{listings}
	\usepackage{color}
	\usepackage{csquotes}	

	
	\newtheorem{definition}{Definition}
	
	\renewcommand\lstlistingname{Quelltext} % Change language of section name
	
	\lstset{ % General setup for the package
		language=Java,
		basicstyle=\scriptsize\sffamily,
		numbers=left,
	 	numberstyle=\tiny,
		frame=tb,
		tabsize=4,
		columns=fixed,
		showstringspaces=false,
		showtabs=false,
		keepspaces,
		morekeywords={field, method, module, calls, presumes, achieves, external, internal, access},
		commentstyle=\color{red},
		keywordstyle=\color{blue}
	}
	
	\date{}
	
	\begin{document}
	\maketitle
	
	\section{Syntax}
	\begin{figure}[h]
	$$
	\begin{array}{llr}
	s & ::= &\\ 
	| & \texttt{skip} &\\
	| & \texttt{call}\ \alpha.\texttt{m}(\overline{\texttt{x} \mapsto v}) &\\ 
	| & \texttt{acc}\ \texttt{x}\ v &\\
	| & \texttt{drop}\ \texttt{x} &\\
	| & \texttt{mut}\ \alpha.\texttt{f} := v &\\
	| & \texttt{new}	\ \texttt{C}(\overline{\texttt{f} \mapsto v}) &\\
	| & \texttt{return}\ v
	\end{array}
	\begin{array}{llr}
	p & ::= &\\ 
	| & \texttt{true} &\\
	| & \texttt{false} &\\
	| & i & \textit{where}\ i \in \mathbb{Z}
	\end{array}
	\begin{array}{llr}
	v & ::= &\\ 
	| & p &\\
	| & \alpha\\
	| & \texttt{null}
	\end{array}
	\begin{array}{llr}
	b & ::= &\\ 
	| & \texttt{return}\ v &\\
	| & \texttt{x} := \bigcirc\ ; b&\\
	| & s\ ; b\\
	\end{array}
	$$
	\[
	\phi\ ::=\ (\texttt{this:=}\alpha\; ;\texttt{local:=}\overline{v}\; ; \texttt{contn:=}\{b\})\\
	\psi\ ::=\ \phi\ |\ \phi : \psi\\
	o\ ::=\ (\texttt{class:=C}\; ; \texttt{fields:=}\overline{\texttt{f}\mapsto v})\\
	\chi\ ::=\ \overline{\alpha \mapsto o}\\
	\sigma\ ::=\ (\chi, \psi)\\
	\mathcal{B} : \overline{\texttt{x} \mapsto v}\ \rightarrow\ b \\
	\texttt{CDef}_\texttt{E}\ ::=\ \texttt{class}\ \texttt{C} \{ 
		\overline{\texttt{f}}\; ; 
		\overline{\texttt{m} \mapsto \{ \mathcal{B}\}}
	\}\\
	\mathcal{M} : \sigma\ \rightarrow\ \sigma \\
	\mathcal{H} : \{P\}\ \_\ \{Q\}  \\
	\texttt{CDef}_\texttt{I}\ ::=\ \texttt{class}\ \texttt{C} \{ 
		\overline{\texttt{f}}\; ; 
		\overline{\texttt{m} \mapsto \overline{\mathcal{H}};\ \{\mathcal{M}\}}
	\}\\
	M_{\texttt{E}}\ ::=\ \overline{\texttt{C} \mapsto \texttt{CDef}_\texttt{E}}\\
	M_{\texttt{I}}\ ::=\ \overline{\texttt{C} \mapsto \texttt{CDef}_\texttt{I}}
	\]
	\caption{Syntax}
	\label{f:syntax}
	\end{figure}
	
	
	\section{Operational Semantics}
	
	\begin{figure}[h]
	\hfill \fbox{$M_\texttt{I}\ \fcmp\ M_\texttt{E}\ \bullet\ \sigma_1\ \leadsto\ \sigma_2$}
	\begin{mathpar}
	\infer
		{
		\alpha.\texttt{f},\ v\ \in\ visible((\chi, \psi), (\chi, \psi).\texttt{this}) \\
		(\chi, \psi).\texttt{contn:=}\ \{\texttt{mut}\ \alpha.\texttt{f}\ \texttt{:=}\ v\ ; \ b\}
		}
		{
		M_\texttt{I}\ \fcmp\ M_\texttt{E}\ \bullet\ 
			(\chi, \psi)\ 
			\leadsto\ 
			(\chi[\alpha.\texttt{f} \mapsto v], \psi[\texttt{contn:=\{b\}}])
		}
		\quad (\textsc{Mut})
		\and
	\infer
		{
		\overline{v}\ \in\ visible((\chi, \psi), (\chi, \psi).\texttt{this}) \\
		\phi.\texttt{contn:=}\ \{\texttt{x}\ :=\ \texttt{new}\ \texttt{C}(\overline{f\ \mapsto\ v})\ ; \ b\} \\
		\phi' = \phi[\texttt{local:=}[x \mapsto \alpha]\phi.\texttt{local}\ ;\ \texttt{contn:=}\{b\}] \\
		\alpha\ \textit{fresh in}\ \chi \\
		o = (\texttt{class:=C}\ ;\ \texttt{fields:=}\overline{\texttt{f}\ \mapsto\ v})
		}
		{
		M_1\ \fcmp\ M_2\ \bullet\ 
			(\chi, \phi:\psi)\ 
			\leadsto\ 
			((\chi)[\alpha \mapsto o], \phi\ :\ \psi)
		}
		\quad (\textsc{New})
		\and
	\infer
		{
		\alpha_\texttt{this} = (\chi, \psi).\texttt{this} \\
		\alpha, \overline{v}\ \in\ visible((\chi, \psi), \alpha_\texttt{this}) \\
		classOf((\chi, \psi), \alpha) = \texttt{C} \\
		M_2(C).m = \{b\}\\
		(\chi, \psi)\texttt{.contn} = \{\texttt{x}\ :=\ \texttt{call}\ \alpha.\texttt{m}(\overline{v})\}
		}
		{
		M_1\ \fcmp\ M_2\ \bullet\ 
			(\chi, \psi)\ 
			\leadsto\ 
			(\chi, (\texttt{this:=}\alpha_\texttt{this}\ ;\ \texttt{local:=}\overline{v}\ ;\ \texttt{contn:=}\{b\})\ :\ \psi)
		}
		\quad (\textsc{Call})
		\and
	\infer
		{ 
		\sigma_1 = (\chi, \phi_1\ :\ \phi_2 \ :\ \psi) \\
		v\ \in\ visible(\sigma_1, \sigma_1.\texttt{this}) \\
		\phi_1.\texttt{contn:=}\ \{\texttt{return}\ v\ ; \ b\} \\
		\phi = \phi_2[\texttt{local:=}\phi_2.\texttt{local}\cup\{v\}] 
		}
		{
		M_1\ \fcmp\ M_2\ \bullet\ 
			\sigma_1\ 
			\leadsto\ 
			(\chi, \phi\ :\ \psi)
		}
		\quad (\textsc{Rtrn$^1$})
		\and
	\infer
		{ 
		v\ \in\ visible((\chi, \phi_1\ :\ \phi_2 \ :\ \psi) , \phi_1.\texttt{this}) \\
		\phi_1.\texttt{contn:=}\ \{\texttt{return}\ v\} \\
		\phi = \phi_2[\texttt{local:=}[\texttt{x}\ \mapsto\ v]\phi_2.\texttt{local}] 
		}
		{
		M_1\ \fcmp\ M_2\ \bullet\ 
			(\chi, \phi_1\ :\ \phi_2 \ :\ \psi) \ 
			\leadsto\ 
			(\chi, \phi\ :\ \psi)
		}
		\quad (\textsc{Rtrn$^2$})
	\end{mathpar}
	\caption{Pair Reduction.}
	\label{f:pair_reduction}
	\end{figure}
	
	
	\section{External and Internal Steps}
	
	Pair reduction consists of a series of either external or internal steps. That is any pair reduction step of the form
	$$M_1\ \fcmp\ M_2\ \bullet\ \sigma_1\ \leadsto\ \sigma_2$$
	is either
	\begin{enumerate}
	\item
	An external step: i.e. a single reduction step purely between external frames. Only external objects can be modified in an external step.
	\item
	an internal step: a series of internal steps between two external frames that takes one of the following forms:
	\begin{enumerate}
	\item \texttt{call-call}: a method call on an internal object that in its execution makes an external method call. The resulting stack introduces a continuous block of internal frames  to the top of the stack.
	\item \texttt{call-return}: a method call on an internal object that returns without making any external method calls. 
	The resulting stack is more or less equal to to the initial stack (not including modifications to the local environment and continuation of the top frame).
	\item \texttt{return-call}: a return from a prior internal to external method call, followed by another method call. The resulting stack is  a single external frame on top of a continuous block of internal frames.
	\item \texttt{return-return}: a return from a prior internal to external method call, followed by a return from a prior external to internal method call. The resulting stack removes a continuous block of internal frames from the stack.
	\end{enumerate}
	\end{enumerate}
	
	The distinction between internal and external steps is important because it determines which objects in the heap might be modified during a particular pair reduction step, and what kind of internal reduction step is important because it is required to determine to which possible internal execution path might be 
	
	
	\section{Changes}
	
	In proving satisfaction of different specifications, it is useful to investigate when different portions of the heap is modified.
	Many specifications assert that certain portions of the heap can only be modified under certain conditions, and this is often 
	done using temporal operators. As a simple example, the bank account example from the paper:
	 
	  \vspace{.01in}
	(BankSpec)\ \  $\triangleq$\\ 
	$\forall \texttt{a}.[\ \ \texttt{a}:\texttt{Account} \wedge \texttt{changes}\langle{\texttt{a.balance}}\rangle  \ \    
	    \longrightarrow \ \    \hfill$ \\
	  $\strut \hspace{2.3cm} 
	% TODO explain:
	% we no longer need Past here, as we are ion visible states 
	  \exists \texttt{o}. [\    \texttt{o}\ \texttt{calls}\ {\texttt{a.}}{\texttt{deposit}}({\_,\_}) \vee\  \texttt{o}\ \texttt{calls}\ {\_.}{\texttt{deposit}}({\texttt{a},\_})\rangle\  \ ] \ \ \ \ ] \hfill $
	\vspace{.05in}
	
	Currently there is no \texttt{changes} assertion in  chainmail, however one might encode \texttt{changes} using \texttt{next}:
	$$\texttt{changes}\langle \texttt{x.f} \rangle = \exists \texttt{i}. [\texttt{x.f} = i\ \wedge\ \texttt{next}\langle \texttt{x.f}\neq \texttt{i} \rangle]$$
	The above encoding does not generally capture \texttt{changes} because \texttt{next} has no concept of the future if 
	the current configuration is a method return statement. This does not technically matter for \texttt{changes} because 
	method return does not modify fields. This arises more problematically if we need to assert that a reduction step 
	changes \texttt{access}, as this *can* be changed by method return (i.e. via the local enviroment).
	
	Of the 4 kinds of internal steps, a version of \texttt{changes} that is defined using \texttt{next} can only 
	capture internal steps of the form of (a) and (b), and not internal steps of the form of (c) and (d).
	
	\subsection{Hoare Logic}
	Define a Hoare triple as 
	$$M_1\ \fcmp\ M_	2, \sigma_0 \vDash \{A_1\}\ \sigma\ \{ A_2\}$$
	That is, for modules $M_1$ and $M_2$, initial configuration $\sigma_0$, current configuration $\sigma$, and assertions $A_1$ and $A_2$, 
	if $A_1$ is satisfied before reduction of $\sigma$ then $A_2$ will be satisfied afterward.
	
	Using such a hoare triple, we can define \texttt{changes} as such:
	$$M_1\ \fcmp\ M_	2, \sigma_0, \sigma \vDash \texttt{changes}\langle A \rangle\ \equiv\ M_1\ \fcmp\ M_2, \sigma_0 \vDash \{A\}\ \sigma\ \{ \neg A\}$$
	In most cases (I think, ..., probably, ..., not sure) we are concerned with changes that require an internal step, and not an external one. For this purpose, 
	it is helpful if we assume that the internal module $M_1$ is fully specified with classical specs. That is, for every possible pass through internal code 
	(of the forms listed (a), (b), (c), and (d) above) that internal step is fully specified with regards to modifications to the heap. In the bank account example
	this means that we are able to identify all possible internal methods that might modify the balance of an account, and thus determine that the only 
	possible step that might result in such a change is a call to \texttt{deposit}.
	
	\section{Examples}
	
	We classify pair reduction steps in the following way.
	\begin{definition}
	\begin{mathpar}
	\infer
		{(M_1\ \circ\ M_2)\ \bullet\ \sigma\ \leadsto\ \sigma_1\ \leadsto\ \ldots\ 
		\leadsto\ \sigma_n\ \leadsto\ \sigma'\\
		(\forall \sigma_i.\ M_1\ \fcmp\ M_2, \sigma_0, \sigma_i\ \vDash \texttt{internal}\langle \sigma_i.(\texttt{self}) \rangle)\\
		M_2, \sigma_0, \sigma\ \vDash \texttt{external}\langle \sigma.(\texttt{self}) \rangle\\
		M_2, \sigma_0, \sigma'\ \vDash \texttt{external}\langle \sigma'.(\texttt{self}) \rangle}
		{M_1\ \fcmp\ M_2\ \bullet\ \sigma\ \leadsto^\texttt{int}\ \sigma'}
		\quad(\textsc{Int})
		\and
	\infer
		{(M_1\ \circ\ M_2)\ \bullet\ \sigma\ \leadsto\ \sigma'\\
		M_2, \sigma_0, \sigma\ \vDash \texttt{external}\langle \sigma.(\texttt{self}) \rangle\\
		M_2, \sigma_0, \sigma'\ \vDash \texttt{external}\langle \sigma'.(\texttt{self}) \rangle}
		{M_1\ \fcmp\ M_2\ \bullet\ \sigma\ \leadsto^\texttt{ext}\ \sigma'}
		\quad(\textsc{Ext})
	\end{mathpar}
	\end{definition}
	\begin{definition}
	$$M_1\ \fcmp\ M_2\ \bullet\ \sigma\ \leadsto\ \sigma'$$
	if and only if
	\begin{itemize}
	\item
	$M_1\ \fcmp\ M_2\ \bullet\ \sigma\ \leadsto^\texttt{int}\ \sigma'$ or
	\item
	$M_1\ \fcmp\ M_2\ \bullet\ \sigma\ \leadsto^\texttt{ext}\ \sigma'$
	\end{itemize}
	\end{definition}
	
	Next we define some useful properties.
	
	$$\texttt{changes}\langle A \rangle\ \equiv\ A\ \wedge\ \texttt{next}\langle \neg A \rangle$$
	$$\texttt{changed}\langle A \rangle\ \equiv\ \neg A\ \wedge\ \texttt{prev}\langle A \rangle$$
	
	\begin{mathpar}
	\infer
		{
		\sigma\ \vDash\ \texttt{changes}\langle A \rangle
		}
		{
		\sigma\ \vDash\ \texttt{next}\langle\texttt{changed}\langle A \rangle \rangle
		}
		\and
	\infer
		{
		\sigma\ \vDash\ A \\
		\sigma\ \vDash\ \texttt{will}\langle \neg A \rangle
		}
		{
		\sigma\ \vDash\ \texttt{will}\langle\texttt{changed}\langle A \rangle\rangle
		}
		\and
	\infer
		{
		\sigma\ \vDash\ A_1\ \longrightarrow\ A_2 \\
		\sigma\ \vDash\ \texttt{will}\langle A_1 \rangle
		}
		{
		\sigma\ \vDash\ \texttt{will}\langle A_2 \rangle
		}
		\and
	\infer
		{
		\sigma\ \vDash\ \texttt{changed}\langle A \rangle
		}
		{
		\sigma\ \vDash\ \texttt{prev}\langle A \rangle
		}
		\and
	\infer
		{
		\sigma\ \vDash\ \texttt{changed}\langle A \rangle
		}
		{
		\sigma\ \vDash\ \neg A
		}
	\end{mathpar}
	
	
	\begin{definition}
	For an initial configuration $\sigma_0$, internal module $M_1$, and external module $M_2$, we define the following:
	\begin{itemize}
	\item
	$\Sigma(\sigma_0) = \{\sigma_0\} \cup\ \{\sigma | M_1\ \fcmp\ M_2\ \bullet\ \sigma_0 \leadsto^*\ \sigma\}$
	\item
	$\mathcal{L}(\sigma) = \{p | p\ \text{is primitive}\ \wedge\ \sigma\ \in\ \Sigma(\sigma_0)\ \wedge\ M_1\ \fcmp\ M_2\ \bullet\ \sigma_0, \sigma \vDash p\}$
	\item
	$\mathcal{H} = \{\ \{P\}\ \_\ \{Q\}\ |\ \sigma\ \sigma'\ \in\ \Sigma(\sigma_0)\ \wedge\ M_1\ \fcmp\ M_2\ \bullet\ \sigma\ \leadsto^\texttt{int}\ \sigma'\ \longrightarrow\ P(\sigma)\ \wedge\ Q(\sigma') \}$
	\end{itemize}
	\end{definition}
	
	\begin{definition}
	We define the set of internally changeable assertions as
	\begin{mathpar}
	\infer
		{}
		{v\ \in\ \mathcal{P}(\sigma)}
		\and
	\infer
		{e_1, e_2\ \in\ \mathcal{P}(\sigma)}
		{e_1\ =\ e_2\ \in\ \mathcal{P}(\sigma)}
		\and
	\infer
		{\sigma\ \vDash\texttt{internal}\langle \alpha \rangle}
		{\alpha.f \in\ \mathcal{P}(\sigma)}
		\and
	\infer
		{\sigma\ \vDash\texttt{internal}\langle \alpha \rangle}
		{\texttt{access}\langle \alpha, \_ \rangle \in\ \mathcal{P}(\sigma)}
		\and
	\infer
		{A\ \in\ \mathcal{P}(\sigma)}
		{\neg A \in\ \mathcal{P}(\sigma)}
		\and
	\infer
		{A_1, A_2\ \in\ \mathcal{P}(\sigma)}
		{A_1\ \wedge\ A_2 \in\ \mathcal{P}(\sigma)}
		\and
	\infer
		{A_1, A_2\ \in\ \mathcal{P}(\sigma)}
		{A_1\ \vee\ A_2 \in\ \mathcal{P}(\sigma)}
	\end{mathpar}
	\end{definition}
	Finally we state the following properties.
	\begin{mathpar}
	\infer
		{
		\sigma\ \vDash\ A \\ 
		\sigma\ \leadsto^\texttt{ex}\ \sigma' \\
		A\ \in\ \mathcal{P}(\sigma)
		}
		{
		\sigma'\ \vDash\ A
		}
		\and
	\infer
		{
		\sigma\ \vDash\ A \\
		\sigma'\ \vDash\ \neg A \\
		A\ \in\ \mathcal{P}(\sigma)
		}
		{
		\sigma\ \leadsto^\texttt{int}\ \sigma'
		}
		\and
	\infer
		{
		\sigma\ \leadsto^\texttt{int}\ \sigma'
		}
		{
		\exists\ P\ Q. [\{P\}\_\{Q\}\in\ \mathcal{H}\ \wedge\ P (\sigma)\ \wedge\ Q(\sigma')]
		}
	\end{mathpar}
	
	\subsection{Bank Account Example}
	
	\begin{lstlisting}[mathescape=true]
	class Account{
		field balance
		method deposit(from, amt){
			...
		}Pre:  $\exists$ b$_1$, this.balance = b$_1$
		       $\exists$ b$_2$, from.balance = b$_2$
		 Post: this.balance = b$_1$ + amt
		       from.balance = b$_2$ + amt
	}
	\end{lstlisting}
	 
	  \vspace{.01in}
	(BankSpec)\ \  $\triangleq$\\ 
	$\forall \texttt{a}.[\ \ \texttt{a}:\texttt{Account} \wedge \texttt{changes}\langle{\texttt{a.balance}}\rangle  \ \    
	    \longrightarrow \ \    \hfill$ \\
	  $\strut \hspace{2.3cm} 
	% TODO explain:
	% we no longer need Past here, as we are ion visible states 
	  \exists \texttt{o}. [\    \texttt{o}\ \texttt{calls}\ {\texttt{a.}}{\texttt{deposit}}({\_,\_}) \vee\  \texttt{o}\ \texttt{calls}\ {\_.}{\texttt{deposit}}({\texttt{a},\_})\rangle\  \ ] \ \ \ \ ] \hfill $
	\vspace{.05in}
	
	\noindent
	let the current configuration be $\sigma$. Thus we have
	$$(\texttt{a.balance}\ = \ \texttt{b})\ \in\ \mathcal{P}(\sigma)$$ and 
	$$\sigma \vDash \texttt{changes}\langle\texttt{a.balance}\ = \ \texttt{b})\rangle$$
	It follows that $\sigma$ must be an internal step, and that there must be a specified 
	internal path that modifies \texttt{a.balance}.
	It follows that the only possible path is a \texttt{deposit} call to either \texttt{a}
	or some other \texttt{Account} with \texttt{a} as the first argument.  
	
	%\subsection{Safe Example}
	%In the example below we assume that \texttt{secret} cannot be internal to another safe.
	% 
	%  \vspace{.01in}
	%(SafeSpec)\ \  $\triangleq$\\ 
	%$\forall \texttt{s}.[\ \ \texttt{s}:\texttt{Safe} \wedge\ \neg \texttt{s.treasure = null}\ \wedge\ \texttt{will}\langle \texttt{s.treasure = null} \rangle  \ \    
	%    \longrightarrow \ \    \hfill$ \\
	%  $\strut \hspace{2.3cm} 
	%  \exists \texttt{o}. [\    \texttt{access}\langle \texttt{o}, \texttt{s.secret} \rangle\  \ ] \ \ \ \ ] \hfill $
	%\vspace{.05in}
	%
	%$$\neg \texttt{s.treasure = null}$$
	%$$\texttt{will}\langle\neg \neg \texttt{s.treasure = null}\rangle$$
	%$$\texttt{will}\langle \texttt{changed}\langle \neg \texttt{s.treasure = null} \rangle \rangle$$
	%$$\texttt{will}\langle \texttt{changed}\langle \neg \texttt{s.treasure = null} \rangle \rangle$$
	
	
	
	\newpage

	
	\section{LTL Model of Chainmail}
	
	Following the section on LTL of Michael Huth and Mark Ryan, I am attempting to build
	a Chainmail model for checking satisfaction of Chainmail assertions. This diverges some what 
	from that book, especially in two ways:
	\begin{enumerate}
	\item
		The model is not generally finite as there may be an infinite number of program configurations. However, in proving satisfaction 
		we should only need to consider a finite number (is this true?).
	\item
		Assertions in Chainmail are not just about the current program configurations, but also about the transitions, i.e. method calls/returns etc.
		In fact I am trying to explicitly capture a way of modeling these transformations, and thus developing a standard way of proving satisfaction
		for code that includes external calls (i.e. something like the DAO).
	\end{enumerate}
	
	Firstly, state in the model is captured by program configurations, and transitions between configurations 
	is captured by pair reduction steps. That is, either a transition is a single reduction between external program
	configurations, or a series of steps through internal code.
	
	
	To model internal steps in the underlying language, we define transitions through internal code as a set of 
	functions mapping configurations to configurations:
	
	\begin{definition}[Module Transition functions]
	For a module $M$, all potential execution paths that consist of only module code
	can be represented by a finite set of transformations $\pi_M$, such that for any 
	external program configuration $\sigma$ of external module $M^\prime$ that either calls a method defined in $M$,
	or returns a value to a method in $M$, there exists $p\ \in\ \pi_M$ such that
	$$M\ \fcmp\ M^\prime\ \bullet\ \sigma\ \leadsto\ p(\sigma)$$
	\end{definition}
	
	It is in fact simple to check whether any particular program configuration makes a specific 
	module transition: i.e. if the configuration makes an internal method call, or if the 
	configuration is a method return, and the underlying frame is an internal frame.
	For this reason, we extend the above definition of a module transition path to include a predicate $R$
	that specifies how $p$ is called (or returned to), along with pre- and post- conditions.
	$$R\ :\ \{P\}\ p \{Q\}$$
	
	In the case of a method call, $R$ would resemble $x\ \texttt{calls}\ \texttt{y}.\texttt{m}(\ldots) $.
	In the case of a method return, $R$ would look something like $x\ \texttt{returns}\ v\ \texttt{to}\ y$.
	(should internal frames just have transition functions instead of a normal continuation?)
	
	\begin{definition}[Chainmail Model]
	A transition system $\mathcal{M} = (M_1, M_2, \sigma_0, \Sigma, L)$ 
	is a module pair $M_1$ and $M_2$,
	an initial program configuration $\sigma_0$,
	a set of program configurations $\Sigma$ such that
	$$\Sigma\ =\ \{ \sigma \vert\ M_1\ \fcmp\ M_2\ \bullet\ \sigma_0\ \leadsto^*\ \sigma \}\ \cup\ \{\sigma_0\} $$
	and a labelling function
	$L : \Sigma \mapsto P(Atoms)$.
	\end{definition}
	
	
	
	
	\begin{figure}[h]
	\[
	\begin{array}{lcr}
	\begin{array}{llr}
	a & ::= &\textit{Atoms}\\ 
	| & e & \\
	| & e\ :\ C & \\
	| & e\ \in\ S & \\
	| & \langle x\ \texttt{access}\ y \rangle &\\
	| & \texttt{internal}\langle x \rangle &\\
	| & \texttt{external}\langle y \rangle &\\
	| & \langle x\ \texttt{makes step}\ p \rangle & \\
	\end{array}&
	~~~~~~~~~~~~~~~ &
	\begin{array}{llr}
	A & ::= & \textit{Assertions}\\ 
	| & a & \\
	| & \neg A & \\
	| & A\ \wedge\ A & \\
	| & A\ \vee\ A & \\
	| & A\ \longrightarrow\ A & \\
	| & \forall\ x.\ A & \\
	| & \exists\ x.\ A & \\
	| & \forall\ S.\ A & \\
	| & \exists\ S.\ A & \\
	| & \texttt{next}\langle  A \rangle& \\
	| & \texttt{will}\langle  A \rangle& \\
	| & \texttt{prev}\langle  A \rangle& \\
	| & \texttt{was}\langle  A \rangle& 
	\end{array}
	\end{array}
	\]
	\caption{Assertions}
	\label{f:assertions}
	\end{figure}
	
	Fig. \ref{f:assertions} gives a syntax for Chainmail assertions.
	The main difference between the assertions of Fig. \ref{f:assertions}, and those of FASE is the 
	replacement of $\langle\texttt{x calls y.m(...)}\rangle$ with $\langle x\ \texttt{makes step}\ p\rangle$.
	
	\begin{definition}[Satisfaction of internal path step]
	$\sigma$ satisfies $\langle x\ \texttt{makes step}\ p \rangle$ if and only if there exists $R$, $P$, and $Q$ such that $R\ :\ \{P\}p\ \{Q\} \in\ \pi_M$ and
	$(R\ \sigma)$ holds.
	\end{definition}
	
	The second difference is the distinction between atomic assertions and general assertions.
	Atomic assertions are simple irreducible assertions.
	Satisfaction of atomic assertions can be determined in the absence of an initial configuration as they do not include temporal operators,
	thus we introduce an alternate form for satisfaction:
	$$M_1 \fcmp M_2,\ \sigma_1\ \vDash\ a$$
	Transitions between program configurations are defined using pair reduction:
	
	\begin{mathpar}
	\infer
		{
		(M_1 \circ M_2)\ \bullet\ \sigma_1\ \leadsto\ \sigma_2 \\
		classOf\ \sigma_1.(\texttt{this})\ \in M_2 \\
		classOf\ \sigma_2.(\texttt{this})\ \in M_2
		}
		{
		M_1 \fcmp M_2\ \bullet\ \sigma_1\ \leadsto\ \sigma_2
		}
		\and
	\infer
		{
		M_1 \fcmp M_2,\ \sigma_1\ \vDash\ \langle x\ \texttt{makes step}\ p\rangle
		}
		{
		M_1 \fcmp M_2\ \bullet\ \sigma\ \leadsto\ p(\sigma)
		}
	\end{mathpar}
	
	\subsection{Module Code without External Calls}
	
	In cases were modules do not include external calls, 
	module transition paths are relatively simple, and
	are just method calls. In this case, the syntax of Fig. \ref{f:assertions}
	becomes that of FASE.
	
	\subsection{Module Code with External Calls}

	
	\subsection{Changes Requiring Internal Reduction Steps}
	
	The main reason for broadening the chainmail expression of 
	an internal step to include not only method calls, but also  
	method returns is to be able to refer these boundaries inside of
	chainmail, and not just as part of some meta-reasoning. Here I
	connect the $\langle x \texttt{makes step}\ p\rangle$ to the 
	earlier reasoning about  \texttt{changed}.
	There are two categories of changes that require internal reduction steps:
	
	\begin{enumerate}
	\item Internal Mutation:
	\begin{mathpar}
	\infer
		{
		\exists \ x\ v. [\texttt{changed}\langle x.f\ =\ v \rangle\ \wedge\ 
		\langle x\ \texttt{internal} \rangle
		}
		{\exists\ y\ p, \langle y\ \texttt{makes step}\ p\rangle}
	\end{mathpar}
	\item Internal Encapsulation:
	\begin{mathpar}
	\infer
		{\exists \ x\ y. [\texttt{changed}\langle \neg \langle x\ \texttt{access}\ y\rangle \rangle\ \wedge\ \texttt{prev}\langle 
		\forall z. [\neg \langle z\ \texttt{access}\ y \rangle\ \vee\ \langle \texttt{internal}\ z \rangle] 
		\rangle ]}
		{\exists\ x'\ p, \langle x'\ \texttt{makes step}\ p\rangle}
	\end{mathpar}
	\end{enumerate}
	
	All other changes could occur as part of external client code.
	
	
	\subsubsection{Safe}
	
	As an example, consider a simplified version of the Safe specification:
	\begin{mathpar}
	\infer
		{\forall\ \texttt{s}, [\texttt{s}\ :\ \texttt{Safe}\ \wedge\ \texttt{will}\langle \texttt{change}\langle \texttt{s.treasure} \rangle\rangle]\ \longrightarrow\ 
		\texttt{will}\langle \exists o. [\langle o\ \texttt{access}\ \texttt{s.secret} \rangle] \rangle}
		{}
	\end{mathpar}
	\begin{mathpar}
	\infer
		{\forall\ \texttt{s}, [\texttt{s}\ :\ \texttt{Safe}\ \wedge\ \texttt{will}\langle \texttt{changed}\langle \texttt{s.treasure} \rangle\rangle]\ \longrightarrow\ 
		\texttt{will}\langle \exists o. [\langle o\ \texttt{access}\ \texttt{s.secret} \rangle] \rangle}
		{}
	\end{mathpar}
	\begin{mathpar}
	\infer
		{\forall\ \texttt{s}, [\texttt{s}\ :\ \texttt{Safe}\ \wedge\ \texttt{will}\langle \texttt{changed}\langle \texttt{s.treasure} \rangle\ \wedge\ \langle \texttt{s}\ \texttt{internal}\rangle\rangle]\ \longrightarrow}
		{}
	\end{mathpar}
	\begin{mathpar}
	\infer
		{\texttt{will}\langle \exists o. [\langle o\ \texttt{access}\ \texttt{s.secret} \rangle] \rangle}
		{}
	\end{mathpar}
	\begin{mathpar}
	\infer
		{\forall\ \texttt{s}, [\texttt{s}\ :\ \texttt{Safe}\ \wedge\ \texttt{will}\langle \texttt{changed}\langle \texttt{s.treasure} \rangle\ \wedge\ \langle \texttt{s}\ \texttt{internal}\rangle\rangle]\ \longrightarrow}
		{}
	\end{mathpar}
	\begin{mathpar}
	\infer
		{\texttt{will}\langle \exists o. [\langle o\ \texttt{access}\ \texttt{s.secret} \rangle] \rangle}
		{}
	\end{mathpar}
	
	


	
	\newpage
	
	\section{Hoare Logic and Reverse Hoare Logic}
	
	In order to simplify proof construction for satisfaction of Chainmail assertions we define a logic for reasoning about single
	internal steps for a module. To do this I make use of traditional Hoare triples, along with the reverse Hoare triples defined by 
	de Vries and Koutavas.
	
	In Chainmail we are not concerned with the effects that a statement or specific method has on the program state, but rather 
	what effects an entire module might have on the program state. As an intermediate step to constructing proofs about full Chainmail
	it is useful to be able to prove simpler specifications on a module, and the ways it might change the program state. That is, if we were able
	to prove limited specifications on how a single execution path through only module-internal code modifies 
	program state, it would assist in the proof of more general Chainmail specifications. Below I present a Hoare-like triple that 
	places a module in the middle rather that a single statement to be evaluated.
	$$\{A_1\}\ M\ \{A_2\}$$
	$A_1$ and $A_2$ are Chainmail assertions, and $M$ denotes some module. Thus, the above specification can be read as
	\begin{displayquote}
	\textit{for any purely module-internal execution path through $M$, if $A_1$ is true beforehand, $A_2$ will be true afterward}
	\end{displayquote}
	
	We are also not only concerned with constructing proofs about
	programs in a traditional forward style. We don't always need to reason about the program state after the execution
	of a program based on what is true before, but also the inverse, i.e. we often need to infer the program state before the 
	execution of a program based on the program state after evaluation. For this reason it is useful to include specifications
	of the form of de Vries and Koutavas' Reverse Hoare Logic.
	$$[A_1]\ M\ [A_2]$$
	Above I use the notation used by O'Hearn in his related paper on Incorrectness Logic, and the above specification can be read as
	\begin{displayquote}
	\textit{for any purely module-internal execution path through $M$, if $A_2$ is true afterward, $A_1$ will be true before}
	\end{displayquote}
	This is not exactly how de Vries and Koutavas phrase it. They might rather say that $A_1$ represents the a super set of the
	states from which $A_2$ is reachable. This is in contrast to saying that for a traditional Hoare triple $\{A_1\}\ M\ \{A_2\}$,
	$A_2$ represents a super set of the states that are reachable from $A_1$.
	
	It should be noted that these definitions can not be encoded in Chainmail currently. In fact the following equivalences do not generally hold:
	$$\{A_1\}\ M\ \{A_2\}\ \not\equiv\ M\ \vDash\ \texttt{prev}\langle A_1 \rangle\ \longrightarrow\ A_2$$
	$$[A_1]\ M\ [A_2]\ \not\equiv\ M\ \vDash\ A_2\ \longrightarrow\ \texttt{prev}\langle A_1 \rangle$$
	This is because the left hand sides of the above equivalences imply only internal steps, while satisfaction of the right hand sides 
	is determined for all possible steps, including external steps. While the above does not hold, the following do hold:
	$$M\ \vDash\ \texttt{prev}\langle A_1 \rangle\ \longrightarrow\ A_2\ \Rightarrow\ \{A_1\}\ M\ \{A_2\}$$
	$$M\ \vDash\ A_2\ \longrightarrow\ \texttt{prev}\langle A_1 \rangle\ \Rightarrow\ [A_1]\ M\ [A_2]$$
	The above hold because Chainmail satisfaction considers all potential pair reduction steps, including internal steps.
	
	Another note is that there does not seem to be anything stopping us from writing quite complex Chainmail specifications 
	in the above form. For this reason, if we actually intend these specifications to be a simpler, intermediate step then they 
	must be simpler. Thus, we restrict specifications to only those concerned with a single internal step. This is shown in Figure \ref{f:specs}.
	
	\begin{figure}[h]
	\footnotesize
	\[
	\begin{array}{lll}
	\begin{array}{llr}
	R & ::= &\textit{Simple Assertion}\\ 
	| & a & \\
	| & \neg R & \\
	| & R\ \wedge\ R & \\
	| & R\ \vee\ R & \\
	| & R\ \longrightarrow\ R & \\
	| & \forall\ x.\ R & \\
	| & \exists\ x.\ R & \\
	| & \forall\ S.\ R & \\
	| & \exists\ S.\ R & \\
	\end{array}&
	\begin{array}{llr}
	P & ::= &\textit{Pre}\\ 
	| & R & \\
	| & \texttt{next}\langle  R \rangle& \\
	| & \texttt{changes}\langle  R \rangle& \\
	| & \neg P & \\
	| & P\ \wedge\ P & \\
	| & P\ \vee\ P & \\
	| & P\ \longrightarrow\ P & \\
	| & \forall\ x.\ P & \\
	| & \exists\ x.\ P & \\
	| & \forall\ S.\ P & \\
	| & \exists\ S.\ P & \\
	\end{array}&
	\begin{array}{llr}
	Q & ::= & \textit{Post}\\ 
	| & R & \\
	| & \texttt{prev}\langle  R \rangle& \\
	| & \texttt{changed}\langle  R \rangle& \\
	| & \neg Q & \\
	| & Q\ \wedge\ Q & \\
	| & Q\ \vee\ Q & \\
	| & Q\ \longrightarrow\ Q & \\
	| & \forall\ x.\ Q & \\
	| & \exists\ x.\ Q & \\
	| & \forall\ S.\ Q & \\
	| & \exists\ S.\ Q & \\
	\end{array}
	\end{array}
	\]
	\normalsize
	\caption{Specification Syntax}
	\label{f:specs}
	\end{figure}
	
		I use $a$ to represent \emph{atomic} assertions as indicated in Figure \ref{f:assertions}, with the single modification that I replace $ \langle x\ \texttt{makes step}\ p \rangle$ 
		with  $\langle x\ \texttt{calls}\ y.m(x_1, ...) \rangle$, in line with the definition of chainmail specifications in the FASE 2020 paper. Further, the only temporal operators that may 
		be used are ones that refer to the other side of the triple, i.e. preconditions may use \texttt{next} or \texttt{changes} to refer to the state after evaluation, and postconditions 
		may use \texttt{prev} or \texttt{changed} to refer to the program state before evaluation.
		This syntax is chosen as satisfaction of assertions of this form can be checked by considering only those program states that abut an internal execution.
		
		We require specifications on modules take the following syntactic forms:
	$$\{P\}\ M\ \{Q\}$$
	$$[P]\ M\ [Q]$$

	\subsection{Examples}
	
	\subsubsection{Bank Account}

	
	In the following code examples I borrow O'Hearn's keywords \texttt{presumes} and \texttt{achieves} to indicate 
	the distinction between what is presumed to be true before execution, and what is achieved after execution.

	
	Below is the definition for the module \texttt{Bank}. \texttt{Bank} contains a single class, \texttt{Account}, which has a 
	\texttt{balance} field and a \texttt{deposit} method. \texttt{deposit} transfers a positive amount (\texttt{amt}) from some 
	account (\texttt{from}) 	to the reciever account. If \texttt{amt} is negative, or \texttt{from.balance} is less than or equal 
	to \texttt{0}, then neither balance is changed.
\begin{lstlisting}[mathescape=true]
module Bank {
	class Account {
		{presumes: $\exists$ x y acc.[ $\langle$ x calls this.deposit(acc, y) $\rangle$ $\vee$ 
							   $\langle$ x calls acc.deposit(this, y) $\rangle$ ]
		 achieves: $\exists$ b.[ changed$\langle$ this.balance = b $\rangle$ ]}
		 
		{presumes: x access this
		 achieves: x access this}
	
		field balance
		method deposit(from, amt) {
			...
		}
}
\end{lstlisting}
	As part of the definition of \texttt{Account}, I include some specifications in the form of \texttt{presumes} and \texttt{achieves}. The first can be
	read as: if an internal \texttt{Bank} execution step is made, and 
	$$\texttt{$\exists$ b.[ changed$\langle$ this.balance = b $\rangle$ ]} $$
	is achieved, then 
	$$\texttt{$\exists$ x y acc.[$\langle$ x calls this.deposit(acc, y) $\rangle$ $\vee$ $\langle$ x calls acc.deposit(this, y) $\rangle$]}$$
	was true beforehand. In other words, 
	\begin{displayquote}
	if the balance of an account changes then it was as a result of a call to \texttt{deposit} where the changed
	account was either the reciever or the \texttt{from} account
	\end{displayquote}
	I place the specifications within the \texttt{Account} class only so we might use the \texttt{this} keyword. A similar specification
	could be written outside of \texttt{Account} by replaceing \texttt{this} with \texttt{acc'} and including \texttt{acc' : Account} as part of the specification.
	
	The second states that all \texttt{Bank} operations do not grant access to \texttt{Account}s.
	
	The Chainmail specifications for the \texttt{Bank} as they are written in the TOSEM paper are as follows:
	
\begin{lstlisting}[mathescape=true]
(1) $\triangleq$ $\forall$ a. [ a : Account $\wedge$ changes$\langle$ a.balance $\rangle$ $\longrightarrow$
               $\exists$ o.[ $\langle$ o calls a.deposit(_, _) $\rangle$ $\vee$
                     $\langle$ o calls _.deposit(a, _) $\rangle$ ] ] 
                     
(2) $\triangleq$ $\forall$ a. $\forall$ S : Set. [ a : Account $\wedge$ $\langle$ will $\langle$ changes$\langle$ a.balance $\rangle\rangle$ in S $\rangle$ 
                           $\longrightarrow$
               $\exists$ o.[ o $\in$ S $\wedge$ external$\langle$ o $\rangle$ $\wedge$ $\langle$ o access a $\rangle$] ] 
                     
(3) $\triangleq$ $\forall$ a. $\forall$ S : Set. [ a : Account $\wedge$ $\langle$ will $\langle$ $\exists$o.[ external$\langle$ o $\rangle$ $\wedge$ $\langle$ o access a $\rangle$ ] $\rangle$ in S $\rangle$ 
                           $\longrightarrow$
               $\exists$ o'.[ o' $\in$ S $\wedge$ external$\langle$ o' $\rangle$ $\wedge$ $\langle$ o' access a $\rangle$] ] 
\end{lstlisting}

\texttt{(1)}
The first of the the three specifications follows simply from the presumption and result of the \texttt{Account} class.

\texttt{(2)}
The second specification uses the following rule for reverse Hoare logic:
\begin{mathpar}
\infer
	{
	P \Rightarrow P' \\
	[P]\ M\ [Q]
	}
	{
	[P']\ M\ [Q]
	}
\end{mathpar}
Since a change to the \texttt{balance} of \texttt{a} implies a call involving \texttt{a}, and 
a call involving \texttt{a} implies \texttt{access} to \texttt{a}, it follows that there must exist
some \texttt{o} with \texttt{access} to \texttt{a}.
Satisfaction then follows the argument that either there is some current \texttt{external} object that has \texttt{access} 
to the \texttt{a}, or \texttt{Bank} can give access to \texttt{a}. Following the second specification, we
know that the latter cannot be true, and we arrive at the result.

\texttt{(3)}
The proof of \texttt{(3)} follows a similar argument to that of \texttt{(2)}.
	
	
	
	
	
	
	
	
	\bibliographystyle{abbrv}
	\bibliography{main}
	
	\end{document}