\section{Related Work}


\jnc{Ripped unceremoniously from iFM and last year's OOPSLA/ECOOP
  failures. JAMES AS A LIST TO DO tomorrow but in the limit this will
  do. Sort of --- at least backrefs to stuff in this paper needs to be
removed.  TODO TODO TODO}

Object capabilities were first introduced~\cite{MillerPhD} nine
years ago, and many recent % work attempts to manage
studies manage
or verify  safety or correctness of object capability programs.

Google's Caja \cite{Caja} applies   sandboxes, proxies, and wrappers
 to limit components'
access to \textit{ambient} capabilities.
% --- that is, capabilities that
%can be obtained from the wider environment, rather than being granted
%to a component explicitly.
Sandboxing has been validated
formally: Maffeis et al.\ \cite{mmt-oakland10} develop a model of
JavaScript, demonstrate that it obeys two principles of
object capability systems
%  (``connectivity begets connectivity'' and
%``no authority amplification''), and then % uses these principles to
and show  how untrusted applications can be prevented from interfering with
the rest of the system.  Alternatively, Taly et al.\ \cite{secureJS}
  model  JavaScript APIs in Datalog, and then
carry out a Datalog search for an ``attacker'' from the set of all
valid API calls.  This search is similar to the quantification over
potential code snippets in our model.
Murray and Lowe \cite{murray10-infoflow} model object capability
programs in CSP, and use a model checker to ensure program executions
do not leak information.

Karim et al. apply static analysis on
Mozilla's JavaScript Jetpack extension framework \cite{adsafe}, including
 pointer analyses. % In a different direction,
Bhargavan et al.\ \cite{DefJS}
extend language-based sandboxing techniques to support ``defensive''
components that can execute successfully  in otherwise untrusted
environments. Meredith et al.\
\cite{PolicyAsTypes}
 encode policies as types in higher order reflective $\pi$-calculus..  Politz et
al.\ \cite{ADsafety} use a JavaScript typechecker to check
properties such as
% \textit{``widgets cannot obtain direct references
 % to DOM nodes''} and
 \textit{``multiple widgets on the same page
  cannot communicate.''}
% --- somewhat similar in spirit to our \textbf{Pol\_4}.
Lerner et al.\ extend this system to ensure browser
extensions observe \textit{``private mode''} browsing conventions,
such as that \textit{``no private browsing history retained''}
\cite{Lerner2013b}.  Dimoulas et al.\ \cite{DPCC14} generalise the
language and typechecker based approach to enforce explicit policies,
% although the policies  are restricted to
that  describe  which components  may
access, or may influence the use of, particular capabilities.

%These approaches are all based on static analyses.
 The WebSand
\cite{flowcaps11,sabelfeld-inlining2012} and Jeeves \cite{jeeves2012}
projects use dynamic techniques to monitor safe execution of information flow policies.
 Richards et al.\ \cite{FlacJS}   extended this approach by
incorporating explicit dynamic ownership of objects (and thus of
capabilities) and policies that may examine the history of objects'
computations. While these dynamic techniques can restrict or terminate
the execution of a component that breaches its security policies, they
cannot guarantee in advance that such violations can never happen.
While information flow policies are concerned with the flow of objects (and thus also capabilities)
across the program code, our work is more concerned with the identification of the objects which protect
the services.

%Compared with all these approaches, our work   focuses on
%\textit{general} techniques for specifying (and ultimately verifying)
%capability policies, whereas these systems are generally much more
%\textit{specific}: focusing on one (or a small number) of actual
%policies. % This seems to be because contemporary object capability
%programming is primarily carried out in JavaScript, but
% There are few
A few formal verification frameworks  address JavaScript's highly
dynamic, prototype-based semantics. Gardner et al.\ \cite{Gardner12}
 developed a formalisation of JavaScript based on separation logic
% that they have used
and verified   examples. Xiong and Qin et
al.\ \cite{XiongPhd,Qin11}  worked on similar lines.
% More substantially,
Swamy et al.\ \cite{JSDijkstraMonad}  recently
developed a mechanised verification technique for JavaScript based on
the Dijkstra Monad in the F* programming language.  Finally, Jang et
al.\ \cite{Quark} % have %  managed to provide
developed a machine-checked proof of
five important properties of a web browser --- again similar to our
simple deny policies --- such as
% \textit{``no tab may interfere with
%  another tab''} and \
\textit{``cookies may not be shared across
  domains''} by writing the minimal kernel of the browser in Coq.

%\jn{THIS needs to be trimmed, add in Bertinori IFM, go somewhere!}
Previous work \cite{capeFTfJP,capeFTfJP14} has \sd{analysed}
Miller's Mint and Purse example \cite{MillerPhD} by expressing it in
Joe, a Java subset without reflection and static fields, and in Grace
\cite{capeFTfJP14}, and discussed the six capability policies that
characterise the correct behaviour of the program, as proposed in
\cite{MillerPhD}.
%We argued that these policies require a novel
%approach to specification, and showed some first ideas on how to use
%temporal logic.
 In an unpublished technical report
\cite{WAS-OOPSLA14-TR}, Drossopoulou and Noble propose a specification
language, and use
it to fully specify the six policies from \cite{MillerPhD}; however,
their formalisation showed that they allowed several possible
interpretations.  They also uncovered the need for another four policies
and formalised them as well.


