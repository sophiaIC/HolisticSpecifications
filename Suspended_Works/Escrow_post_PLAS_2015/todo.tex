==================== when was this from? ======================

Arising configurations allow us to restrict the set of configurations we to consider. For example, in a program where a class does not export visibility to a field, the constructor initialises the field to say $0$, and all method calls increment that field, the arising configurations will only consider states where the field is positive.

Add citation for two state assertions

are the rules called structural or substructural

find first paper by reynolds for separation on framing --  before sep logic

=============================

NEXT STEPS on 2nd March 2016

1) Logistics and next steps
          - go and speak with Tony Hoare

2) hash map and equality

3) modules and encapsulation

4) Sealer/Unsealer

5) more case studies

6) more Hoare Logic

7) specify forgetting 
      // you need to specify that you have no reference to something,
      // or just specify that the current object deals with other objects
      //         according to their interface
      // behavioural vs topological restrictions
      //         i.e. even of you have access to something, you do not use it
      // forget = temporal abstraction (Hawking)

8) Distribution || concurrency — this would require a stab at 3) and 10)
   failure vs timeout
   lifting trust from object to vat

9) discuss related work

10) aliasing

11) tool for proving these properties — postdoc in NZ

12) finish the current work
	- do we need step-index?
	- finish the proof of the Escrow
	- Purse proof with constructors
	- Purse with hash table

13) Other stuff
	- diamond drill important but outside our remit; we are assuming that 
           the objects are impenetrable. 
        Example
		put the Ashley Maddissson account in phone - and the account gets leaked
			vs
		put the Ashley Maddison in a peace of paper
        modelling through objects stopping obeying their spec; 
        forgetting is more than not using; when you forget then even 
            if you stop obeying the spec
        trust only until you see evidence of temper

14) Jim Larsen’s question: can you reason backwards? Can you do fault attribution? Something went wrong, and can you find who “misbehaved”? 

Mark and Martin $

=============================
EuroS&P
ACM SAC
formalise Morris’ protection in programming language

———
distributed CAPTP Sandstorm; Dr Sess assumes CapTP; 

——————
Equality

equal_now … comparison
same_yet … monotonic, i.e. a.eq(b)  implies 
same_ever … always same answer, but can throw an exception earlier
may it throw an exception?

transitive 
reflexive
if a=b then then a.m(c) and b.m(c) they behave “the same” — bisimulation?
    No, too strong.. what we want is that b behaves as a in terms of a’s specification.

Does equals mean “I am willing to consider him as a representative of me”
If equals means “we are the same entity” then it has to be symmetric. So, if James is good, and James.eq(Sophia) returns true, then Sophia.eq(James) will also return true. But if James is bad, and 
 James.eq(Sophia) returns true, then this does not imply that Sophia.eq(James) need not also return true. — This can be described as a policy for equality. 
 cf the Smalltalk yourself message.


E needs that because of unresolved promises; you need to know whether you will end up to the same object.

specification HashMap{

  ghost map: ObjectAddr -> ObjectAddr U Value

  policy Pol_unique_keys
	\forall key, key’ \in dom(map). key.eq(key’) —> key==key’


  true
	{ res = this.put(key, value)  }
  map=map_{pre}[key’|->value]  where    key’.eq(key)


  true
	{ res = this.get(key) }
  \res =/= null -> \exists key’ \in dom(map) \wedge key’.eq(key) && res = map(key’)
  &&
  res == null -> \forall key’ \in dom(map). NOT \wedge key’.eq(key) 

} 



specification Equal{

   policy_1
   true
	{ res = this.eq(x)  }
   this==x —> res==true
   &&
   res -> x obeys Equal
  
   policy_2   
   x==y
	{ res = this.eq(x); any_code; res’ = this.eq(y)  }
   res==res’
   // how say that I have not overwritten res?

   policy_3
   true
	{ res = this.eq(x); res’ = x.eq(this)  }
   res -> res’

   policy_4   
   this obeys Spec
      { res = this.eq(x); }
   x obeys Spec // too weak though
   // also too strong

   policy_5
   // cond_1
   P && this obeys Spec
        { code }
   Q 
   &&
   // cond_2
   P
     { res = this.eq(x) }
  res 
  —>
     P && this obeys Spec
	 {  code[x/this] }
     Q[x/this]

}

Perhaps I can only obey a spec if my eq method gives objects which obey the same spec.

We should think of moving Policy_5 at some different place.

We can have 
specification Equal{

   policy_1
   …
  
   policy_2   
   .. 

   policy_3
   …’

   policy_4   
   …

  }

Then we say that for any Spec any object which obeys Spec, it has to also satisfy policy_5.
 
   
    


