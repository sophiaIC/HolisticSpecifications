\documentclass{llncs}

\usepackage{graphicx}
\usepackage{amssymb}
%\usepackage[reqno]{amsmath}
\usepackage{listings}
\usepackage{url}
\usepackage{enumitem}
\usepackage{grace}
\usepackage{balance}
\usepackage{hyperref}

%\author{
%Sophia Drossopoulou\inst{1}
%\and
%James Noble\inst{2}
%\and
%Toby Murray\inst{4}
%\and
%Mark S. Miller\inst{3}
%}

%\institute{
%Imperial College London
%\email{scd@doc.ic.ac.uk}
%\and
%Victoria University of Wellington
%\email{kjx@ecs.vuw.ac.nz}
%\and
%{NICTA and UNSW}
%\email{toby.murray@nicta.com.au}
%\and
%Google, Inc.\
%\email{erights@google.com}
%}

\usepackage{natbib}
\usepackage{bbm}
\usepackage{framed}
\usepackage{graphics}
\definecolor{shadecolor}{rgb}{1,0.8,0.3}
%\usepackage{amsthm} % it conflicts with llncs
\usepackage{epsfig}
\usepackage{xspace}
%\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsfonts}
%\usepackage{amstext}
% \usepackage{txfonts}
\usepackage{url}
%\usepackage{xypic}
%\usepackage{makeidx}  % allows for indexgeneration
\usepackage{listings} % for code
  \usepackage{multirow}
  \usepackage{qsymbols}
  \usepackage{amsmath}
% \usepackage{MnSymbol}


\newcommand{\prg}[1]{{\mbox{\tt{#1}}}}
\newcommand{\forget}[1]{}
\newcommand{\etc}{{\it etc.}}
\newcommand{\eg}{{\it e.g.\,}}
\newcommand{\ie}{{\it i.e.\,}}
\newcommand{\rely}{{rely}}
\newcommand{\Rely}{{Rely}}
\newcommand{\deny}{{deny}}
\newcommand{\Deny}{{Deny}}




\input{macros.tex}


\usepackage{times}
\usepackage{latexsym}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}


\lstset{ %
  language=Java,                % the language of the code
  mathescape=true,
  basicstyle=\footnotesize\tt,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{dkgreen},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{gray},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={field,fields,predicate,private,public,final,this,throw,new,||,to,method,def,any,specification,policies,policy,then,where}               % if you want to add more keywords to the set
}


%\input{macros}
\usepackage{enumitem}
% \setlist{nolistsep}


\renewcommand\floatpagefraction{1}
\renewcommand\dblfloatpagefraction{1}
\renewcommand{\textfraction}{0.07}
\renewcommand{\topfraction}{0.9}
\newcommand{\definitionautorefname}{Definition}
\renewcommand{\theoremautorefname}{Theorem}
\newcommand{\lemmaautorefname}{Lemma}
\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{Section}
\renewcommand{\subsubsectionautorefname}{Section}

\begin{document}

\pagestyle{plain}

 \title{Case studies in \Chainmail}


% \subtitle{First Steps towards Reasoning about Risk and Trust in an Open World}
%\subtitle{Reasoning about Object Capabilities in an Open World}

\maketitle

\begin{abstract}
   
    This paper will be about the use of \Chainmail~ for several examples discussed in security.
    
The current document aims to reflect  the December 2015 meeting of James and Sophia in London, and was written up by Sophia party in December 15, and party in the last days of February 2016. It also has some some extensions added by Sophia later on. To be used to discuss during the March 2016 meeting in Mountainview (Mark, James, and Sophia), and then the meeting in London (Toby and Sophia).
 
 We discuss alternative meanings of predicates like $\MayRead$ and $\MayAccess$, we introduce a new predicate $\PassedValue$. We introduce a temporal assertion qualifier $\bf {SomeTime}$. We make a first attempt at specifying the Sealer/Unsealer protocol. And we discuss the suitability of the versions of the predicates.
  
The writeup is incomplete.  While in London, we had also discussed the   specification of recommendation services. I have not had the time to write this up yet.

\end{abstract}

\section{Introduction}
About \Chainmail, the features it supported so far, and the extensions we propose here. About why we chose the particular case studies, and --hopefully -- that they all exhibit some common requirements.

\section{Definitions}

\subsection{Validity of Assertions}

 We define validity of two state / code  assertions, ...

\begin{definition}
[Validity assertions] We define the judgment \\
$
\begin{array}{c}
\begin{array}{lcllcl}
\ \ \  \models  &   \subseteq &   Module \times code \times state   \times  Assertion 
\end{array}
\end{array}
$

\noindent
using the notation $\Prog{},\prg{code},\sigma\models \B $ as follows
\begin{itemize}
\item
$\Prog{},\prg{code},\sigma\models \syntax{\A}$  \ \hspace{.3in} ... as in the PLAS paper ...
\item
$\Prog{},\prg{code},\sigma\models \syntax{\A}_{\textit{t}}$  
iff   $\Prog{},\sigma''\models \syntax{\A}$, \\
where $\sigma''$=$\sigma$ if {{\textit{t}}}=\textsf{pre}, \\
and otherwise $\sigma''=\sigma'$  where $\sigma'$ such that $\Prog{},\prg{code},\sigma \leadsto \_, \sigma'$.
\item 
$\Prog{},\prg{code},\sigma\models \ {\bf{SomeTime}}\ \syntax{\B} $ iff 
there exists  $(\sigma',\prg{code}')\in \Arising(\sigma,\prg{code})$ such that
$\Prog{},\prg{code'},\sigma'\models   \syntax{\B}$ .

    \end{itemize}

\end{definition}

\subsection{The predicate $\MayAccess$}

We had many discussions about the meaning of \prg{$\MayAccess$(\p,\p')} in the presence of private and public fields. We now propose a predicate $\MayRead$, which may involve method calls, while $\MayAccess$ is more direct.
 
We say that $\sigma \models$ \prg{$\MayAccess$(\p,\p')}, if the object denoted by \interp{\p}{\sigma} has direct access to the   value
$\interp{\p'}{\sigma}$ --- either the value is stored in one of the object's fields, or \p\ is the current receiver, and $\p'$ is an argument.

Formally, $\MayAccess(\p,\p')$, iff there exists a field $\prg{f}$ such that \interp{\p.\prg{f}}{\sigma}=\interp{\p'}{\sigma}or $\prg{code}\equiv \p''.m(...\p'''...)$ and $\interp{\p}{\sigma}=\interp{\p''}{\sigma}$ and $\interp{\p'}{\sigma}=\interp{\p'''}{\sigma}$.



\subsection{The predicate $\MayRead$}

We define the predicate \prg{$\MayRead$(p,p')}, to express that 
\prg{p} may read   $\prg{p}'$. 
The exact definition is not yet clear to us. 
We discussed seveal alternatives:

\begin{description}
\item[$\MayRead_{rr}$\ read\_result]  We say that $\sigma \models$ \prg{$\MayRead_{rr}$(p,p')}, if the object denoted by \interp{p}{\sigma} may execute some code (a method call?) which returns the value    \interp{p'}{\sigma}.

This proposal has the disadvantage that the execution might return this value  by coincidence, e.g. if the value is a primitive value like $true$ or $10$. But perhaps this does not matter when we only consider unforgeable entities as in the capabilities world. 


\item[$\MayRead_{rv}$\ read\_value]  We say that $\sigma \models$ \prg{$\MayRead_{rv}$(p,p')}, if the object denoted by \interp{p}{\sigma} may execute some code (a method call?) which contains (in a trace semantics) the value    \interp{p'}{\sigma}.

This proposal has,  the same disadvantage as the previous proposal.

\item[$\MayRead_{df}$\ dereference\_field]  We say that $\sigma \models$ \prg{$\MayRead_{df}$(p,p'.f)}, 
if  the object denoted by \interp{p}{\sigma} may execute some code (a method call?) 
which reads the field \prg{f} from the object  denoted by  \interp{p'}{\sigma}. To capture this we will
need to add   read effects to the operational semantics - easy.

This proposal has two disadvantages: \\
1) we do not know how to give meaning to
the above if the field\prg{f} is a ghost field, for example the mint's currency. \\
 2) The semantics is somehow coarse:
For example, if we had a field \prg{spouse}, whose value is either \prg{null}, to
a pointer to a \prg{Person}, then we cannot distinguish between a method which 
queries whether a person is married, and a method which returns the spouse 
of a person. Also,\footnote{SD thought of this after the meeting with James} 
if  an object \prg{o} had a private counter \prg{cntr}, which get incremented 
every time \prg{o} executes the method call \prg{tick}, and \prg{o'} may call \prg{o.tick()},
but the value of \prg{cntr} is never communicated to \prg{o'}, then 
according to this definition, we would say that   $\sigma \models$ \prg{$\MayRead_{df}$(o',o.cntr)}.

\item[$\MayRead_{ob}$\ observe\_difference] 
We say that $\sigma \models$ \prg{$\MayRead_{ob}$(p,p'.f)}, if  there exists a 
value $v$ and a method \prg{m}, such that execution of that method by 
\prg{p} will ``see the difference'' it executing in a state where the value 
of \prg{p'.f}  has been set to $v$. More precisely,  we say that $\sigma \models$ \prg{$\MayRead_{ob}$(p,p'.f)} if  
there exists  method \prg{m}, arguments \prg{...}, and values $v1$, $v2$,  such that $\sigma, \prg{p.m(...)} \leadsto v1, \_$, and 
$\sigma[\prg{p'.f}\mapsto v], \prg{p.m(...)} \leadsto v2, \_$ and $v1\,\neq v2$.

The advantage of this approach is that it feels like information flow control, and it does not suffer from the problem with the \prg{tick} method from above. However, if \prg{p.f} is ghost field, we would not know how to construct $\sigma[\prg{p.f}\mapsto v]$, and perhaps such a state does not even exist. For example, if \prg{p.f} was the ghost field standing for the number of bank accounts registered with a certain bank, in order to change the value of this ghost field we would need to create new bank account objects, or even delete existing ones. And if we could observe the difference if, say, \prg{p.f} was negative, but there was no execution which lead to a negative value, then again the definition does not work.
 \end{description}

\noindent
We will write $\MayRead$ when we have not fixed which of the alternatives we mean. At the December'15 London we decided to adopt the solution $\MayRead_{df}$,  but now SD wonders.

\subsection{The predicate $\PassedValue$}

We define the predicate \prg{$\PassedValue$(p,p',p'')}, to express that \prg{p} 
passed the value of \prg{p'} to object \prg{p''}.  
Again, we have some alternatives to consider.

\begin{description}
\item[$\PassedValue_{d}$\ directly] expresses that \prg{p} is the current receiver and the current \prg{code} is a method call or field assignment which passes \prg{p'} to \prg{p''}.\\
Formally,
 $\Prog{},\prg{code},\sigma\models   \prg{\PassedValue(\p,\p',\p'')}$ iff
\begin{itemize}
\item $\prg{code}\equiv \prg{p}1.\prg{m}(... \prg{p}2... )$ \\
and 
 $\interp{\prg{this}}{\sigma}=\interp{\prg{p}}{\sigma}$ 
 and $\interp{\p1}{\sigma} =\interp{\prg{p'}}{\sigma}$
 and $\interp{\prg{p2}}{\sigma}=\interp{\prg{p''}}{\sigma}$,
 \\
 or
\item  $\prg{code}\equiv \prg{p}_1.\prg{f}=\prg{p}_2$ \\ and 
 $\interp{\prg{this}}{\sigma}=\interp{\prg{p}}{\sigma}$ 
 and $\interp{\prg{p2}}{\sigma} =\interp{\prg{p'}}{\sigma}$
 and $\interp{\prg{p1}}{\sigma}=\interp{\prg{p''}}{\sigma}$
\end{itemize}
\item[$\PassedValue_{e}$\ eventually] expresses that the object  \prg{p} will {\em eventually} pass \prg{p''} to \prg{p'}. 
\\
Formally,
$\Prog{},\prg{code},\sigma\models   \prg{\PassedValue(\p,\p',\p'')}$ iff
\begin{itemize}
\item $\sigma \not\models \MayRead_{??}(\p',\p'')$ and 
there exists a $\sigma',\prg{code}'\in \Arising(\sigma,\prg{code})$ such that
$\sigma' \models \neg  \MayRead_{??}(\p',\p'')$ and 
$\Prog{},\prg{code'},\sigma'\models  \PassedValue(\p,\p',\p'')  $
\end{itemize}
Note that it is not necessarily the case that $\interp{\p}{\sigma}=\interp{\p}{\sigma'}$, $\interp{\p'}{\sigma}=\interp{\p'}{\sigma'}$, 
$\interp{\p''}{\sigma}=\interp{\p''}{\sigma'}$ - but we can fix this by expanding the definition. The bigger question is which version of 
$\MayRead$ we should use -- hence $\MayRead_{??}$.

\item[$\PassedValue_{i}$\ indirectly] expresses that the object  \prg{p} will {\em indirectly} cause \prg{p''} to be readable from \prg{p'}. 
\\
Formally,
$\Prog{},\prg{code},\sigma\models   \prg{\PassedValue(\p,\p',\p'')}$ iff
\begin{itemize}
\item $\sigma \not\models \MayRead_{??}(\p',\p'')$ and 
there exists a $\sigma',\prg{code}'\in \Arising(\sigma,\prg{code})$ such that
$\sigma' \models \neg  \MayRead_{??}(\p',\p'')$ and 
$\prg{code'}\equiv \p1.\prg{m(...),...}$, and $\interp{\p}{\sigma}=\interp{\p1}{\sigma'}$,
and
$\Prog{},  \p1.\prg{m(...)},\sigma' \leadsto \_,\sigma''$,
and
$\Prog{},\sigma''\models  \MayRead(\p',\p'')  $
\end{itemize}
The note from the earlier version applies here too.

\end{description}




\section{Specifying the Sealer/Unsealer}



The sealer/unsealer was proposed by ...  The sealer/unsealer is based on the creation on a secret, sealing an object into an envelope, such that the envelope may opened only if you are holding the secret.  


\subsection{\prg{SecretFactory} - Creation returns something fresh}

The policy \prg{Pol\_Create\_Secret} guarantees that the method \prg{create} creates a fresh object which obeys \prg{Secret}.

\begin{figure}[htb]
\begin{lstlisting}[escapechar=@]
specification SecretFactory{

      policy Pol_Create_Secret
          true
      	      @{ \{ res = this.create()  \}  }@
          res $\obeys$ Secret $\wedge$ $\forall o:\PRE$ Object. $\neg \MayAccess$(o,res)
	
}
\end{lstlisting}
%\vspace*{-7mm}
\caption{\prg{SecretFactory} -  Creation of a \prg{Secret}}
\label{fig:SpecSecret}
\end{figure}


\paragraph{Sealing an object in an envelope}
The policy \prg{Pol\_seal} guarantees that the outcome of sealing is an envelope which contains the \prg{obj}, sealed with the \prg{secret}. 

\begin{figure}[htb]
\begin{lstlisting}[escapechar=@]
specification SealerUnsealer{

  policy Pol_seal
     secret $\obeys$ Secret 
         @{ \{   {envelope=\kw{this}.seal(obj,secret)}  \}  }@
     Sealed(envelope,obj,secret)	

  policy Pol_unseal
    Sealed(envelope,obj,secret) 
         @{ \{   {res=\kw{this}.unseal(envelope,secret)}  \}  }@
    res=obj 

  policy Pol_Sealed 
     Sealed(obj,envelope,secret)
         @{ \{  \kw {any\_code}  \}  }@
     $\forall o:$ Object. 
         $\MayAccess$(o,obj) $\rightarrow$ 
             $\MayAccess\PRE$(o,obj) $\vee$ 
             ${\bf SomeTime} $ $\exists\,$o'. 
             [ $\MayRead_{rr}$(o',obj) $\vee$
               $\MayRead_{rr}$(o',envelope)$\,\wedge\,$$\MayRead_{rr}$(o',secret) ]
               $\wedge$ ${\bf SomeTime} \ \PassedValue_d$(o',obj,o) 
                
}
\end{lstlisting}
%\vspace*{-7mm}
\caption{Specification of \prg{SealerUnseale}}
\label{fig:SpecSealerUnsealer}
\end{figure}


\paragraph{Unsealing an oenvelope} Now we consider how to express that we need the unsealer and the secret in order to get to the contents of the envelope.  
 
 The next requirement is to express that when we apply \prg{unseal} to an envelope, and provide the corresponding secret, then we obtain the object \prg{obj}. This is expressed on policy \prg{Pol\_unseal}.
 
The more demanding part is to express that we cannot get to the contents of the envelope unless we had the secret. This is what we are trying to express in policy \prg{Pol\_Seealed}. We apply  James' idea: if \prg{o}  got hold of a sealed object then either \prg{o} had it already, or   in the mean time somebody had access to the envelope and the secret. But the policy is not yet correct as stated.
 
\paragraph{Notes}

 \begin{itemize}
 \item The nested use of the qualifier {\bf SomeTime} in the policy \prg{Pol\_unseal} indicates that at some time $t1$ there exists an object $\prg{o}'$ which could read  \prg{obj} or the envelope and the secret, and then at some later  $t2$, where $t2$ is after $t1$ and before the completion of the execution,  the object \prg{o'} passed \prg{obj} to \prg{o}. 
 \item
We use the {\em direct} version of the predicate for passing values, i.e. $\PassedValue_d$. This is because we nested the {\bf SomeTime} qualifier. SD not sure whether we could have used the $\PassedValue_e$- or $\PassedValue_i$- version and avoid the nesting of {\bf SomeTime}.
 \item
 For \prg{o}, we use $\MayAccess(\prg{o},\prg{obj})$  rather than $\MayRead(\prg{o},\prg{obj})$, because we want to express what it takes for \prg{o}  to get direct access to \prg{obj}.
 \item
 For $\prg{o}'$, we use $\MayAccess(\prg{o}',\_)$ rather than $\MayAccess(\prg{o}',\_)$, because we must all $\prg{o}'$ to obtain $\prg{obj}$, or \prg{envelope}, or \prg{secret} in any manner it can/wants.
 \item
 Out of the four $\MayRead_{??}$ versions, we chose   $\MayRead_{rr}$.
 
 \item
 The policy \prg{Pol\_Sealed} does not say that we need to call \prg{unseal} in order to get the contents of the envelope, only that we need the envelope and the secret at the same time. Therefore, the \prg{SealerUnsealer} is allowed to offer more methods for unsealing, provided that these require both the envelope and the secret in order to return the contents.
 
 \item
 The policy \prg{Pol\_Sealed} feels like a sequence of approximations to me. Namely, $\prg{o}'$ might itself get the object or the envelope and the secret from the third party, etc etc. Perhaps this is unavoidable.
 
 \item
 Does the secret expire after its first use in sealing? Does it matter?
 \end{itemize}
 

 
\setlength{\bibsep}{0.0pt}
\bibliographystyle{abbrv} % {plainnat}
\bibliography{Case}

%\appendix
%\input{implementation}

\end{document}





