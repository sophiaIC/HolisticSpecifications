\section{Related Work}
\label{section:related-work}

\paraB{Object Capabilities and Sandboxes.}
{\em Capabilities} were developed in the 60's
by Dennis and Van Horn \cite{Dennis66} within operating systems, and
were adapted to the 
programming languages setting in the 70's \cite{JamesMorris}. 
{\em Object capabilities} were first introduced~\cite{MillerPhD} in the early 2000s,
and much recent work investigates 
the safety or correctness of object capability programs.
Google's Caja \cite{Caja} applies   sandboxes, proxies, and wrappers
to limit components'
access to \textit{ambient} authority.
% --- that is, capabilities that
%can be obtained from the wider environment, rather than being granted
%to a component explicitly.
Sandboxing has been validated
formally: Maffeis et al.\ \cite{mmt-oakland10} develop a model of
JavaScript, demonstrate that it obeys two principles of
object capability systems
%  (``connectivity begets connectivity'' and
%``no authority amplification''), and then % uses these principles to
and show  how untrusted applications can be prevented from interfering with
the rest of the system. 

\paraB{JavaScript analyses.}
\kjx{More practically, there are a range of 
recent analyses of JavaScript \cite{adsafe,DefJS,ADsafety,Lerner2013b,secureJS}
based on static analyses or type checking.
% Karim et al. apply static analysis on
% Mozilla's JavaScript Jetpack extension framework \cite{adsafe}, including
%  pointer analyses. % In a different direction,
% Bhargavan et al.\ \cite{DefJS}
% extend language-based sandboxing techniques to support ``defensive''
% components that can execute successfully  in otherwise untrusted
% environments.   Politz et
% al.\ \cite{ADsafety} use a JavaScript type checker to check
% properties such as
% % \textit{``widgets cannot obtain direct references
%  % to DOM nodes''} and
%  \textit{``multiple widgets on the same page
%   cannot communicate.''}
% % --- somewhat similar in spirit to our \textbf{Pol\_4}.
Lerner et al.\ extend these approaches to ensure browser
extensions observe \textit{``private mode''}
%browsing conventions
% such as that \textit{``no private browsing history retained''}
\cite{Lerner2013b}, while  Dimoulas et al.\ \cite{DPCC14} 
% generalise the language and type checker based approach to 
enforce explicit access policies.}
% although the policies  are restricted to
%that  describe  which components  may
%access, or may influence the use of, particular capabilities.
% Alternatively, Taly et al.\ \cite{secureJS}
% model  JavaScript APIs in Datalog, and then
% carry out a Datalog search for an ``attacker''.
% from the set of all valid API calls. 
% This search is similar to the quantification over
% potential code snippets in our model.
The problem posed by the Escrow example is that it establishes a two-way
dependency between trusted and untrusted systems --- precisely the
kind of dependencies these techniques prevent.

\paraB{Concurrent Reasoning} 
\kjx{Our Hoare logic invariants are similar to the guarantees 
in Rely-Guarantee reasoning \cite{relyguarantee}.}
\Deny-Guarantee \cite{DenyGuarantee}
distinguishes between assertions guaranteed by a thread, and actions
denied to all other threads. Deny properties correspond to our
requirements that certain properties be preserved by all code linked
to the current module. \kjx{Compared with our work, rely-guarantee and
deny-guarantee assumes co{\"o}peration: composition is legal only if  threads adhere  to
their rely or deny properties and guarantees. Our modules have to be robust  and
ensure that their invariants cannot be affected by {\em any} arbitrary, uncertified, 
untrusted code.}

% %These approaches are all based on static analyses.
%  The WebSand
% \cite{flowcaps11,sabelfeld-inlining2012} and Jeeves \cite{jeeves2012}
% projects use dynamic techniques to monitor safe execution of information flow policies.
%  Richards et al.\ \cite{FlacJS}   extended this approach by
% incorporating explicit dynamic ownership of objects (and thus of
% capabilities) and policies that may examine the history of objects'
% computations. While these dynamic techniques can restrict or terminate
% the execution of a component that breaches its security policies, they
% cannot guarantee in advance that such violations can never happen.
% While information flow policies are concerned with the flow of objects (and thus also capabilities)
% across the program code, our work is more concerned with the identification of the objects which protect
% the services.

%Compared with all these approaches, our work   focuses on
%\textit{general} techniques for specifying (and ultimately verifying)
%capability policies, whereas these systems are generally much more
%\textit{specific}: focusing on one (or a small number) of actual
%policies. % This seems to be because contemporary object capability
%programming is primarily carried out in JavaScript, but
% There are few
% A few formal verification frameworks  address JavaScript's highly
% dynamic, prototype-based semantics. Gardner et al.\ \cite{Gardner12}
%  developed a formalisation of JavaScript based on separation logic
% % that they have used
% and verified   examples. Xiong and Qin et
% al.\ \cite{XiongPhd,Qin11}  worked on similar lines.
% % More substantially,
% Swamy et al.\ \cite{JSDijkstraMonad}  recently
% developed a mechanised verification technique for JavaScript based on
% the Dijkstra Monad in the F* programming language.  Finally, Jang et
% al.\ \cite{Quark} % have %  managed to provide
% developed a machine-checked proof of
% five important properties of a web browser --- again similar to our
% simple deny policies --- such as
% % \textit{``no tab may interfere with
% %  another tab''} and \
% \textit{``cookies may not be shared across
%   domains''} by writing the minimal kernel of the browser inMore 

\paraB{Relational models of trust.}
Artz and Gil \cite{artz-trust-survey-2007} survey various
types of trust in computer science generally, although trust has also
been studied in specific settings, 
%
ranging from peer-to-peer systems \cite{aberer-trust-p2p-2001} and
cloud computing \cite{habib-trust-cloud-2011} 
to mobile ad-hoc networks \cite{cho-trust-survey-adhocnets-2011}, 
the internet of things \cite{lize-trust-IoT-2014}, 
online dating \cite{norcie-trust-online-dating},
and as a component of a wider socio-technical system
\cite{cho-trust-sustainable-2013,walter-trust-cloud-ecis2013}. 
%
Considering trust (and risk) in systems design, Cahill et al.'s overview
of the \textsc{Secure} project \cite{cahill-trust-pervasive-2003}
gives a good introduction to both theoretical and practical issues of
risk and trust, including a qualitative analysis of an e-purse
example. This project builds on Carbone's trust model
\cite{carbone-formal-trust-2003} which offers a core semantic model of
trust based on intervals to capture both trust and uncertainty in that
trust. Earlier Abdul-Rahman proposed using separate relations for
trust and recommendation in distributed systems
\cite{abdul-rahman-distributed-trust-1998}, more recently Huang and
Nicol preset a first-order formalisation that makes the same
distinction \cite{huang-formal-semantics-trust-calculus-2010}.
Solhaug and St{\o}len \cite{solhaug-trust-uncertainty-2011} 
consider how risk and trust are related to uncertainties over
actual outcomes versus knowledge of outcomes.
Compared with our work, these approaches produce models of trust
relationships between high-level system components 
(typically treating risk as uncertainty in trust) 
but do not link those relations to the system's code. 


\paraB{Logical models of trust.}
Various different logics have been used to measure trust in different
kinds of systems.  \kjx{Some of the earliest work is Lampson et al.'s
  ``speaks for'' and ``says'' constructs \cite{Lampson92}, clear
  precursors to our ``\obeys'' but for authentication rather than
  specifications.  }
Murray~\cite{Murray:phd} models object capability
patterns in CSP, and applies automatic refinement checking to analyse
various properties in the presence of untrusted components.
% including the absence of capability- and information-leaks.
%Carbone et al.\ \cite{carbone-formal-trust-2011}
%use linear temporal logic to model specific trust relationships in service
%oriented architectures.
Ries et al.\ \cite{habib-trust-CertainLogic-2011} evaluate trust under
uncertainty by evaluating Boolean expressions in terms of real values.
% for average rating, certainty, and initial expectation.
% Perhaps closer to our work, Aldini
%Aldini \cite{aldini-calculus-trust-IFIPTM2014} describes a temporal logic for
%trust that supports model checking to verify some trust properties.
Carbone et al.\  \cite{carbone-formal-trust-2011} and 
Aldini \cite{aldini-calculus-trust-IFIPTM2014} model trust using
temporal logic.
Primiero and Taddeo \cite{primiero-modal-theory-trust-2011} have
developed a modal type theory that treats trust as a second-order
relation over relations between
counterparties. Merro and Sibilio
\cite{merro-calculus-trust-adhoc-facs2011} developed a trust model for
a process calculus based on labelled transition systems.
Compared with ours, these approaches use
process calculi or other abstract logical models of systems, rather
than engaging directly with the system's code.


\paraB{Verification of Object Capability Programs.}
Drossopoulou and Noble \cite{capeFTfJP,capeFTfJP14} have
analysed Miller's Mint and Purse example \cite{MillerPhD} by
expressing it in Joe-E 
% a Java subset without reflection and static
%fields, 
and in Grace \cite{capeFTfJP14}, and discussed the six
capability policies 
% that characterise the correct behaviour of the
% program, 
as proposed in \cite{MillerPhD}.
%We argued that these policies require a novel
%approach to specification, and showed some first ideas on how to use
%temporal logic.
 In % an unpublished technical report
\cite{WAS-OOPSLA14-TR}, they % Drossopoulou and Noble 
proposed a complex
specification 
language, and used
it to fully specify the six policies from \cite{MillerPhD}; % however,
%their formalisation showed that % they allowed 
%several possible
%interpretations were possible.  
\tobym{uncovering} the need for another four policies.
%and formalised them as well.  
\tobym{More} recently,  \cite{capeIFM14} they % Drossopoulou and Noble \cite{capeIFM14} 
have shown how
different implementations of the underlying Mint and Purse systems
coexist with different policies.
In contrast, \tobym{this work formalises the informal ideas from
\cite{swapsiesOnTheInternet2015},} proposes \LangOO, which is untyped and modelled on
Grace and JavaScript rather than Java;   a much simpler specification
language \tobym{\Chainmail}; the \textbf{obeys} predicate to model trust; 
\tobym{\MayAccess\ and \MayAffect}\
to model risk;   a full
specification of the \prg{Escrow}; \tobym{and a Hoare logic for reasoning
about risk and trust, applied to the Escrow specification.}


%%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% 
%%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% %%%% 





