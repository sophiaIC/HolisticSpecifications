\section{Introduction}
\label{s:intro}


Today's   software has been built 
over decades by combining modules and components of
different provenance and 
%different degrees of 
trustworthiness. It 
is open, interacting with other programs, devices, and people.
%In \jm{the \emph{open world}, where programs interact with untrusted code,} 
%complex 
\jm[]{Software needs} to be both \jm[]{\emph{correct}} (\jm{programs do what they are supposed to}) and  % (liveness)  
\jm{\emph{robust}} (\jm{programs don't do what they aren't supposed to, even in the presence of untrusted code}). % (safety), 
%\vspace{.03in}
%\jm{or more specifically, modules need to be \emph{robust}(modules are safe, even in the presence of untrusted code).}
\jm[]{This work is addresses the robustness of modules.}

\jm{Correctness is} typically specified formally 
 through \citeasnoun{Hoare69} triples consisting of a  precondition, a code snippet, and some
 postcondition. 
 For example,
 \begin{quote}
(S$_{\text{correct}}$)\ \ Calling \prg{transfer} using the correct password will transfer the money.
\end{quote}
The precondition is a \emph{sufficient} condition for the \jm{code snippet to behave correctly}: 
assuming termination, the precondition (\eg providing the right 
password) guarantees that
%executing a code snippet (eg 
the code (\eg call the \prg{transfer} function)
%) 
will always achieve the postcondition (the money is transferred).

%Proving adherence to such specifications  poses considerable challenges, especially when in the 
%context of aliasing, re-entrancy, multithreading, memory models, to name a just a few. 
%Such challenges  have been studied intensively over the last  two decades 
% \cite{BIMutable,objInvars,DenyGuarantee,RealxedC11} -- again just naming a few.

%   \vspace{.03in}
 
%\sophiaPonder[I fear this sentence breaks the flow]
%{We go beyond  ``design by contract'' \cite{Meyer09},  and
%cannot rely on a module's client sticking to the module's contract.}
\jm{For the same bank module to 
be \emph{robust}, it must 
guarantee  that}

\begin{quote}
(S$_{\text{robust}_1}$)\ \ An account's balance does not decrease unless \prg{transfer} was called 
with the correct password.
\end{quote}

%   in a context where no external agent knows the account's password, 
% the balance of 
%that account will not decrease -- such a guarantee allows one to confidently 
% pass their bank account into untrusted code, in the expectation of receiving some payment.}
Calling \prg{transfer}  with the  correct password is 
a \emph{necessary condition} for reducing the account's  balance.
Condition   
(S$_{\text{robust}_1}$) is crucial in order to confidently pass the bank account into untrusted code, 
in the expectation of receiving some payment, but without fear
that a malicious client might steal my money \cite{ELang,miller-esop2013}.
\jm[]{While crucial, (S$_{\text{robust}_1}$) is not strong enough to ensure robustness of 
 an account}.
 (S$_{\text{robust}_1}$) does not take  account of the module's \emph{emergent behavior}.
 What if the module leaks the password, \jm[]{or allows for it to be arbitrarily changed}?
 \jm{For robustness, what} we really need is
 \begin{quote}
(S$_{\text{robust}_2}$)\  \ The balance of an account does not decrease ever in the future unless some external 
object has access to the account's current password.
\end{quote}
\jm{(S$_{\text{robust}_2}$) is a much stronger guarantee than (S$_{\text{robust}_1}$).}
With (S$_{\text{robust}_2}$), I can confidently pass my account to some untrusted client who
  does not have
 knowledge of the password; they may or may not make the payment I was expecting, but I
 know they will not steal my money \cite{ooToSecurity,miller-esop2013}.
 Note that (S$_{\text{robust}_2}$)  does not mention
 the names of any functions in the module, and 
 thus can be expressed without reference to any particular API ---
 indeed (S$_{\text{robust}_2}$) can constrain \emph{any} API with an account, an account
 balance, and a password.


 
%Type systems   % have been developed for various programming languages. They 
% give  relatively coarse-grained guarantees, \emph{e.g.,} 
% that ``message not understood'' errors 
%will not be thrown \cite{EiffelCook},
% private methods will not called by external modules \cite{JavaAccess},
%  no object or method will directly point inside the internal representation of some other object
%\cite{ownalias},
%or that race conditions will not arise  \cite{mindori}. % -- again, just naming a few.
%\sophiaPonder[]{Drop the types?}
 

%\emph{Information-flow control}  systems have been developed for
%various calculi and programming languages. Their 
% guarantees are coarse-grained:  the contents of high security variables cannot
%be affected by the values of low security variables 
%\cite{Zdancewic:Myers:01,noninteferenceOS}. 
 
%\emph{Correspondence assertions} are more fine-grained. Proposed for 
%process calculi, they %can guarantee
%{express}  that if one principal ever reaches a certain point in the protocol, 
%then some other principal has previously reached some other matching point in the protocol; 
%the term \emph{robust safety}  expresses that correspondence assertions are true in the presence of any opponent %expressible in the calculus 
%\cite{correspondence}. 
%% SD thought the below was true, but nor think it is not
%% Correspondence assertions have also
%% been proposed for Javascript. 
%A related approach,  \emph{authorisation policies}, 
%%A related problem is \emph{authorisation policies}, which 
%promises that certain actions will not be taken on certain objects
%unless corresponding  rights had been granted  \cite{Maffeis:aiamb:thesis00}.

%In   \emph{object capabilities} \cite{MillerPhD},
%effects can only be produced by sending messages to objects (which have unforgeable identities) and  there
%is no ambient authority.
%%and  objects have unforgeable identities.
%In the context of object capabilities, \citeasnoun{ddd} define  \emph{robust safety for Javascript}  
%to mean that the untrusted environment of a program cannot violate 
%its internal invariants, and developed  a verification methodology   to 
%prove   that programs that  export only %properly 
%wrapped values  are robustly safe.
%%In the same context, 
%\citeasnoun{dd} develop Kripke models to reason about 
%the result of execution of some given code snippet in parallel
%with arbitrary, unknown code and
%\citeasnoun{threoremsFreeSep} derive usage protocols from a module's
%separation logic specification.

%Most of the approaches outlined so far were not developed with
% the aim of expressing guarantees such as (S2).
%   Information flow control systems target process calculi. % are too coarse grained. 
% %Correspondence assertions target process calculi and do not exactly match 
%% the time of the effect to its cause.
% \citeauthor{ddd} are concerned with the preservation of
% internal invariants. \citeauthor{dd} are
% concerned with the \emph{effects} of known code,
% while \citeauthor{threoremsFreeSep}  reverse-engineer usage protocols.
 
%Recently,  
%{\sc{VerX}}  \cite{VerX}  and   \emph{Chainmail}  \cite{FASE} 
% added temporal operators to specification languages, and thus can express necessary conditions.  
% %Both  {\sc{VerX}}  and   \emph{Chainmail} 
% Assertions support the usual 
%   logical connectives and can refer to current state and function calls.
%   %assertions about the current state, and in addition,
% %{\sc{VerX}}  can   talk about function calls,
% \emph{Chainmail} 
% %can talk about function calls, 
% can also talk about \emph{permission} (whether an
% object has direct access to another object -- either through its fields or 
% %through the
%its arguments to a function call),    about \emph{provenance} (whether an object
% belongs to the current module, or some %client, 
% unknown module),
%{and control (whether a certain function is called with given arguments).}
%Permission and provenance are inspired by the object capabilities
% literature \cite{MillerPhD}. 
 
% is used to express safety properties of smart contracts;
% adherence to such specifications is proven through symbolic 
% execution.  \emph{Chainmail} is used to express general safety properties; it
% also includes predicates talking about provenance
% and access (more below), but lacks a proof system.
 
%\susan[font?]{}\paragraph{What we \emph{really} need} 
\vspace{.04in}
 
\jm{This paper is not the first work to address the problem of robustness,} 
\jm[is this true??? what claim can we make here?]{however, to our knowledge, it is the first that is able to 
express specifications of the form (S$_{\text{robust}_2}$), along with a system
for formally verifying such specifications.}
In contrast to \jm{correctness}  which is usually specified with % such 
Hoare triples,  a multitude of different guarantees have been proposed for \jm{robustness}, differing in the level 
of granularity,   target  language or calculi, and intended use:
\jm{object capabilities  \cite{MillerPhD, dd, threoremsFreeSep}, 
information control flow \cite{Zdancewic:Myers:01,noninteferenceOS}, 
and correspondence assertions \cite{Maffeis:aiamb:thesis00}
all
ensure some level of robust safety}.
 

  Both {\sc{VerX}} \cite{VerX} and  \emph{Chainmail} \cite{FASE} can express (S$_{\text{robust}_1}$) but
  {\sc{VerX}}  cannot express (S$_{\text{robust}_2}$), because 
(S$_{\text{robust}_2}$)  requires the concepts of provenance (``external object'') and
  permission (``has access to''x).
On the other hand, {\sc{VerX}} can prove adherence to  specifications through symbolic 
  execution, while  \emph{Chainmail}   lacks a proof system. 
  % \sophiaPonder[after Sergio]{
   Also correspondence assertions cannot express (S$_{\text{robust}_2}$): they lack
    support for provenance, and ways to match the time of an effect to that of the
    condition.%}
 % On the other hand, 
  
\vspace{.04in}

This work introduces \Nec, which consists of a specification language for expressing a module's safety guarantees such as (S$_{\text{robust}_2}$), and a logic 
%is  the first to express necessity specifications, including those like (***), and also
to prove adherence to such specifications.
We adopted % have been inspired by   
\emph{Chainmail}'s %approach to add
  capability operators, 
but we replaced its temporal operators with  {our novel}
  \emph{necessity} operators. 
  These simplifications enabled us to develop our proof logic. 
%We propose \Chainmail, a specification language % for   \emph{Necessity Specifications} 
% to describe a module's safety guarantees,
%and 
%\Chainlogic,   % \emph{Necessity Logic} 
%a logic to prove a module's adherence to such specifications.
The current work is based on a simple, imperative, typed, object oriented
language with unforgeable addresses and private fields.\footnote{We believe
 that our approach is applicable to several programming paradigms, and 
 that   unforgeability and privacy
 can be replaced 
 by lower level mechanisms such as capability machines \cite{vanproving,davis2019cheriabi}.
  }

\jm[not sure if this should go here ...]{
Unlike other work on specifying robust safety for software, \Nec allows proofs of not just simple safety 
specifications, but specifications that rely on reasoning about emergent behavior and complex interactions 
across a module's interface (such as (S$_{\text{robust}_2}$)).
Further, beyond unforgeability and privacy, \Nec is agnostic about much of the specifics
of module implementation, only that module code can be verified using some Hoare logic. This is a significant advantage, as it makes \Nec broadly applicable to any such languages that use Hoare logic to establish correctness.}


 

%\textit{Necessity Specifications}  are
\Nec supports the usual assertions, $A$, (including permission, provenance,
and control), as well as three necessity 
{operators. We now show one of these operators} 
% shown below.
% \susan[Needs to be laid out differently to put the four forms in]{}
% Thus, we  have % one  of  the two -- omitting, as there are three!
% the following forms:
%\jm[are we missing \texttt{from $A_{curr}$} nxt $A_{fut}$ onlyIf $A_{nec}$?]{}
%\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
%       $A$          from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$          from ${A_{curr}}$ to ${A_{fut}}$ onlyThrough ${A_{nec}}$
%\end{lstlisting}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
                                from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$ 
\end{lstlisting}
%  %      $A$          from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$          from ${A_{curr}}$ to ${A_{fut}}$ onlyThrough ${A_{nec}}$
The  form   {above} says that % $A$ always holds;  $A$ is an invariant.
%The second form says that  
a  {transition} from a current state satisfying $A_{curr}$ to a future
state satisfying $A_{fut}$ %(i.e.\ the transition  $A_{curr}$ to $A_{fut}$ being an effect) 
is possible only if the necessary condition
$A_{nec}$ holds in the \emph{current} state.
%The third form says that a change from %a current state satisfying 
%$A_{curr}$ to % a future state satisfying 
%$A_{fut}$  may happen only if % the necessary condition
%$A_{nec}$ holds in some \emph{intermediate} state.
 {The other two operators express either \emph{necessary conditions} for
\emph{single-step} transitions % from  $A_{curr}$  states to a   $A_{fut}$ states,
or \emph{intermediate} conditions for \emph{any} transitions.
% from a $A_{curr}$ -state t  $A_{fut}$  states.
}
Unlike  \emph{Chainmail}, 
 the necessity operators %  $\onlyIf {\_} {\_} {\_}$  and $\onlyThrough {\_} {\_} {\_}$
 are second class, and may not appear in the assertions $A$.
Being second class allows us to separate proofs about necessity from other proofs.
\jm[Not sure if it makes sense to put this here. My thinking was that it might help with the intuition of the logic early on if the form can be lined up with the english definition of (S3).]
{We provide a description of the formalization of (S$_{\text{robust}_2}$) % in \Chainspec  
in  \S\ref{s:bankSpecEx}, but give the formal statement here as an example to help with 
the reader's intuition.}
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
(S$_{\prg{robust}_2}$)  $\triangleq$   from a:Account $\wedge$ a.balance==bal
           to a.balance < bal
           onlyIf $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\access{\texttt{o}}{\texttt{a.pwd}}$]
\end{lstlisting}
\jm{A transition from a state where an account's balance is \prg{bal}, to a state where 
it has decreased, may \emph{only} occur if some unknown client object currently has access to that account's password.}


 %\sophiaPonder[not sure we need to have the latter, 
% and do not have temp logic form of it]{}.
% For same later section?
%Unlike \citeauthor{VerX} or \citeauthor{FASE}
%the necessity operators $\onlyIf {\_} {\_} {\_}$  and $\onlyThrough {\_} {\_} {\_}$
%are second class, and may nor appear in the assertions $A$.
%%support necessity specifications with this explicit
%% ``$\onlyIf {A_1} {A_2} {A_3}$'' syntax
%%
%%and concomitant specialised inference system.
%%
%%
%Our assertions $A$ support the usual expressions about program state
%%(e.g. \prg{x.f > 3}),
% logical connectives and quantifiers, 
%%(e.g. $\wedge$, $\forall$), 
%and additional predicates
%to capture \textit{provenance} (whether an object $o$'s definition is
%$\internal{\texttt{o}}$ or $\external{\texttt{o}}$) to the current
%module, and \textit{permission} \cite{miller-esop2013} (whether an
%object $o$ has direct access to another object $o'$:
%$\access{\texttt{o}}{\texttt{o'}}$).
 
\Nec \jm[removed: logic]{} is based on four main ideas: 
First, some assertions are \emph{encapsulated}, \ie
their validity may only be affected by internal calls. 
% \susan[same question - is may the correct word? This said module-internal before I edited it.]{}
Second, by leveraging the classical  specifications of methods 
(\ie the sufficient conditions) we can obtain per-method-call
 \Nec specifications; that is, necessary preconditions
  for a given effect and a given method call (at a very abstract level, this is
similar to \citeasnoun{threoremsFreeSep}).
Third we infer a per-step-condition, \ie, a necessary condition given an effect and a single, unspecified step. This step could be an internal call, or any kind of external step.
Fourth,  a novel proof system allows us to combine 
per-method \Nec specifications and encapsulated assertions 
 to obtain per-module   \Nec specifications; these describe a module's
 emergent behavior.
More in \S\ref{s:approach}.
 
%The below is good and perhaps we shpuld use it
% The challenge here is twofold: How do we specify the bad things we are
%concerned about, and how do we prove that the bad things we've
%specified do not happen?  These challenges are difficult because we
%cannot refer to just one component of a software system.  A sufficient
%specification can deal with a single component in isolation --- a
%single function for pre- and postconditions; a single class or data
%structure for invariants. A necessary specification, however, must
%provide guarantees which encompass the software system in its
%entirety, and constrain the emergent behaviour of all its components,
%for an open system, all possible sequences of API invocations.
% 
% 
%
% 
%The importance of distinguishing between sufficient and necessary
%specifications of various kinds has a long history in Computer
%Science.
% 
%  Type systems ensure entire classes of bad things can't
%happen, preserving execution even if memory structures are greatly
%corrupted \cite{Rinard03}.
%%
%More recently, \citeauthor{ddd} and \citeauthor{sandbox} with their robust safety and
%\citeauthor{FASE} with their holistic systems have tackled open world systems to prevent bad things from happening from untrusted code.
%\citeauthor{ddd} use techniques from security to ensure \jm[]{there} isn't undesirable leakage, \citeauthor{sandbox} build a sandbox and have a sophisticated type system to protect it and \citeauthor{FASE} have
%necessary conditions, which they expressed through temporal
%operators.

% In the next section, (\S\ref{s:outline}),  we outline our approach using the
% bank account as  a motivating example.%This example demonstrates, among other things, that the specification need  refer  to  individual methods in a module.
%Moreover, adherence to a Necessity Specification is not monotonic, in the following two senses:
%Adding a method to a module does not necessarily preserve adherence to a Necessity Specification,
%and while separate methods may adhere to a  Necessity Specification, their combination does
%not necessarily do so: Necessity Specifications capture a module's emergent behaviour.


\subsection{Paper Organization and Contributions}

%%In the next section, (\S\ref{s:outline}),  we outline our approach using a
%% bank account as  a motivating example.

%\jm[should this be ``a bank account''? This is the first time we mention it]{}
%
The contributions of this paper are:\begin{enumerate}
 \item
%\Chainspec, a 
A language to
express \Nec specifications (\S\ref{s:semantics}) that is  expressive
enough to encode the \emph{Chainmail} examples from \citeasnoun{FASE}. 
% in \Chainspec (\S\ref{s:expressiveness}). 
 \item
%\Chainlogic, a 
A logic for proving a module's adherence to 
 \Nec specifications (\S\ref{s:inference}), and a proof of soundness of the logic, (\S\ref{s:soundness}),
both mechanized in Coq. 
 \item
A proof in our logic % the bank account 
  that our bank module obeys its \Nec specification (\S\ref{s:examples}), mechanized in Coq.
\end{enumerate}

\jm[I don't know if we need to state parametricity on encapsulation as a limitation. In some ways it is a strength, i.e. we make no assumptions about privacy and features of the underlying language, only in so far as we need to express our examples.]{}

\jm[]{
Our formalization of \Nec does have two limitations. 
Firstly, it is specifically a logic for 
necessity and robustness properties. \Nec 
is parametric with respect assertion satisfaction, correctness,
encapsulation, and the type system. Much of these are
well-trod ground in the literature, and where needed we
do introduce simplistic language mechanisms to deal with them (e.g. a simple type system or notion of encapsulation).
Secondly, we do not allow for ``callbacks'' 
to external objects. This is a common restriction in the literature
as many either prohibit callbacks, or require
``effectively callback free contracts'' \cite{VerX},
or place significant restrictions on callbacks \cite{}
}

Our formalization of \Nec has a number of limitations: 
it is 
parametric with respect to assertion
satisfaction, encapsulation, and the type system;
we forbid 
``callbacks'' out to external objects; and
classical specifications require explicit framing.
We will discuss these limitations further as we place \Nec into the context of 
related work (\S\ref{s:related}) and consider our overall conclusions
(\S\ref{s:conclusion}). 
%
The Coq proofs of 
(2) and (3) above % soundness of \Chainspec, and the adherence of the
% bank module to it \NecessitySpecification 
appear in the
supplementary material, along with Appendices containing expanded 
definitions and further examples.
%% \sophiaPonder[]{Some less surprising definitions and some examples have been relegated to the Appendix,
%% also provided as supplementary material.}
 
%Our formalisation of \Nec has a number of limitations: 
%it is 
%parametric with respect to assertion
%satisfaction, encapsulation, and the type system;
%we forbid 
%``callbacks'' out to external objects; and
%classical specifications require explicit framing.
%We will discuss these limitations further as we place \Nec into the context of 
%related work (\S\ref{s:related}) and consider our overall conclusions
%(\S\ref{s:conclusion}). 
%%
%The Coq proofs of 
%(2) and (3) above % soundness of \Chainspec, and the adherence of the
%% bank module to it \NecessitySpecification 
%appear in the
%supplementary material, along with Appendices containing expanded 
%definitions and further examples.
%%% \sophiaPonder[]{Some less surprising definitions and some examples have been relegated to the Appendix,
%%% also provided as supplementary material.}
