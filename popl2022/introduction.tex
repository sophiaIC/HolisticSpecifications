\section{Introduction}
%Current systems are complex, and  built out of many different components of different provenance and different degree of trustworthiness.

%\begin{flushright}
%  \textit{nice things are nicer than nasty ones}\\
%  Kingsley Amis, ``Lucky Jim.''
%\end{flushright}

\begin{flushright}
  \textit{Condition B is hard to formalize, \\since it requires saying precisely what a bad
plan is,\\ and we do not attempt to do so.}\\
  Leslie Lamport
\end{flushright}
\susan[that is the best quote I could find - from Byzantine Generals]{}
\sophia[better than Amis's quote, I think]{}

The days of single, monolithic programs are long gone.  Contemporary
software is built over decades, by combining modules and components of
different provenance and different degrees of trustworthiness, and can
interact with almost every other program, device, or person.
In order for the resulting complex system to be correct, we need to be
able to reason about individual components to ensure that they behave
correctly, i.e.\ that good things happen when our programs run.
For example: if I send an email to a valid address, it will be
delivered to its recipient, or if I provide the right password, I can
transfer money from one of my bank accounts to another. 
To prove that good things can
happen, program verification systems can use witnesses, e.g.\ a
precondition, a postcondition describing the good thing (the desired
effect), and a code snippet, whose execution will establish the
effect, given the precondition.  The critical point here is that the
precondition is a \emph{sufficient} condition for the code snippet to
make the good thing happen: given the precondition, executing a
correct code snippet is guaranteed to achieve the postcondition.

Unfortunately, in a system of any complexity, knowing that good things
will happen is not enough: we also need to be sure that bad things
cannot happen. For example: we also need to be sure that an email can
only be read by the intended recipient; or that I can only transfer
money if I provide the right password. To address this problem,
we need to consider the \emph{necessary} conditions under which some
postcondition can be achieved (otherwise\susan[replaced 'or' with otherwise as I thought or was slightly confusing]{} some bad thing can happen):
it is necessary that someone is sent an email before they can read it;
it is necessary that the correct password is provided before money can
be transferred.  If a necessary condition can never be achieved, then
bad things guarded by that condition cannot happen.

The challenge here is twofold: How do we specify the bad things we are
concerned about, and how do we prove that the bad things we've
specified do not happen?  These challenges are difficult because we
cannot refer to just one component of a software system.  A sufficient
specification can deal with a single component in isolation --- a
single function for pre- and postconditions; a single class or data
structure for invariants. A necessary specification, however, must
provide guarantees which encompass the software system in its
entirety, and constrain the emergent behaviour of all its components,
for an open system, all possible sequences of API invocations.


Rather than considering the sufficient conditions to
achieve a given effect, we express necessary preconditions for the
holistic system. For example, a third party will not get to read my
email unless I forward it to them - the forward is a necessary
precondition for the reading. To reason about necessary conditions we
develop our Logic of Necessity. 

There has been work in the past to expand specifications of systems beyond the specification of good things.  blah, blah, blah  \citeauthor{FASE} were also concerned with 
 holistic specifications and necessary conditions, which they expressed through time operators.
 \Chainmail appears to be less rich than Chainmail, however we have been able to specify all their examples. In addition, \Chainmail has a proof system, which Chainmail lacked.
%To specify the bad things, we cannot
%refer to one particular piece of code, % and cannot refer to one witness;
% instead, we need to make a guarantee which encompasses all possible
% functions executable by a module in all their possible sequences or even interleavings --
 %we need to consider their \emph{emerging} behaviour.
 %Rather than considering the sufficient conditions to achieve a certain effect,
 %we express the necessary precondition. For example,    a third party 
 %will not get to read my email unless I forward it to them -- the forwarding
% is a necessary precondition for the reading.
 
 %To reason about necessary conditions, we develop a special
 %logic with such necessity triples. The most basic such holistic assertions 
 %can be derived from classical assertions (sufficient \jm[old:truples]{triples})
 %under assumptions of encapsulation;
 %they can then be further combined using our logic of necessity.




We illustrate our ideas in terms of the following example:
\prg{Account}s have a balance and a password. One may transfer
\prg{100} units from one \prg{Account} to another, but only provided
that the caller provides the right password. Below we show version
\sf{I} of the code for a class \prg{Account}.  We use a Java-like
syntax, and assume that fields are ``class-wide'' private (again as in
Java, so methods may read and write fields of any instance of that
class) and that passwords are unforgeable and not enumerable (again as
in Java, albeit without reflection).

 
\begin{lstlisting}[language=Chainmail]
class Account{
   field balance:int 
   field pwd: Password 
   method transfer(dest:Account, pwd':Password) -> void {
      if (this.pwd==pwd') {
            this.balance-=100;  dest.balance+=100; }  }
}
\end{lstlisting}

as well as a ``classical'' specification of the method \prg{transfer}:


 (ClassicSpec)$  \ \ $  $\triangleq$
\begin{lstlisting}[mathescape=true, frame=lines, language=Chainmail]
  method transfer(dest:Account, pwd':Password) -> void {
       ( PRE:  this.balance=bal1 $\wedge$ this.pwd==pwd' $\wedge$ dest.balance=bal2 $\wedge$ dest=/=this 
         POST: this.balance == bal1-100 $\wedge$  dest.balance == bal2+100 )
       ( PRE: this.balance=bal1 $\wedge$ this.pwd=/=pwd' $\wedge$ dest.balance=bal2
         POST: this.balance == bal1 $\wedge$  dest.balance=bal2 )
       ( PRE: a : Account $\wedge$ a=/=this $\wedge$ a=/=dest  $\wedge$ a.balance=bal $\wedge$ a.pwd=pwd1
         POST:  a.balance=bal $\wedge$ a.pwd=pwd1)
       ( PRE: a : Account $\wedge$ a.pwd=pwd1  
         POST: a.pwd=pwd1)       
\end{lstlisting}\footnote{Perhaps omit some of the lines here, but we do need them all in the full discussion}
 
  
 
 Now consider two further versions of the class account, given in Fig. \ref{fig:ExampleAccount}.
 In version {\sf{II}} and version {\sf{III}} the class has an additional method, \prg{set}, which enables the resetting of the password.
The method \prg{transfer} in all three versions of the class \prg{Account} satisfies the (ClassicSpec), 
however, while executing the first and third version of \prg{Account} won't exhibit unwanted behaviour, the second version doesn't preclude it.
%Namely version II allows any client to change the password of the account, and then to repeatedly withdraw money from it.
  
% On the other hand, we expect our software -- even if complex -- to provide some simple, high level
%guarantees, e.g. email addressed to me personally will not be read by a third party unless I explicitly 
%forwarded it to them.
%We except  our software to  behave correctly, even when used by a careless or malicious third party. 
%Such use of a software often consist of a sequence of actions performed on the module. 
%
%Software components respond to single actions, 
%or to sequences of such single actions. 
%When thinking about a software component we want think about the behaviour of each 
%action in isolation, but also about the \emph{emergent behaviour}, ie all
% the possible effects of the combinations of these actions. 
  
  
 
 \begin{figure}[hbtp]
 \begin{tabular}{lll}
\begin{minipage}{0.35\textwidth}
\begin{lstlisting}[language=chainmail]
class Account{
   field balance:int 
   field pwd: Password 
   method transfer(..) 
        ... as earlier ...
   method set(pwd':Password){
         this.pwd=pwd' }
}   
\end{lstlisting}
\end{minipage}
  &\ \ \  \ \   &
\begin{minipage}{0.50\textwidth}
\begin{lstlisting}[language=chainmail]
class Account{
   field balance:int 
   field pwd: Password 
   method transfer(..) 
        ... as earlier ...
   method set(pwd',pwd'':Password){
         if (this.pwd==pwd'){this.pwd=pwd''} }
}
\end{lstlisting}
\end{minipage} 
 \end{tabular}
  \caption{class \prg{Account} version II, and \ \ \ \ \ \  class \prg{Account} version III}
 \label{fig:ExampleAccount}
 \end{figure}

 
 The flaw in version {\sf{II}} arises from \emph{emergent} behaviour as \prg{set} 
 can be used to overwrite the
 password, and then using the new password \prg{transfer}  can be called.
% If we want the \prg{Account} class to be robust, we must prohibit the password from being freely available.
 Therefore, we propose a holistic specification which says that
 the \prg{balance} of an \prg{Account} reduces only if an object which does not belong to the
 class \prg{Account} has access to the password:
 
 \begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
(HolisticSpec)  $\triangleq$  a:Account $\wedge$ a.balance==bal
                   to a.balance < bal
                   onlyIf $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\access{\texttt{o}}{\texttt{a.pwd}}$]
\end{lstlisting}
 
%\jm[good point. fixed]{WHY DOES o HAVE A PRIME?}
 
 In more detail, the specification from above says that if in the current
 configuration \prg{a} is an \prg{Account},
 % with balance \prg{bal}, 
 and in some future configuration \prg{a} will have a balance less than the current one, then, in the \emph{current} configuration
 there must exist some object \prg{o}, which is \emph{external} to our module (does not belong to class
 \prg{Account}), and which has access to \prg{a}'s password.
 
 
 Thus, having access to the password is a necessary condition for the balance to reduce.
 Note, that the specification only talks about effects (here the balance reducing), and does not
 talk about individual methods (such as \prg{set} or \prg{transfer}).
 

 The holistic specification language, \Chainmail, extends traditional specifications with
notions of access, %(which object points to which)
control 
%(which methods are called)
\footnote{Sophia -perhaps drop as confusing? Susan -I think both of the bracketed phrases should be omitted, as we have already used the word access when describing the passwords and we don't mention control anywhere}, 
 the distinction between external and internal objects, and necessary conditions, 
 whereby the assertion $A~to~A'~onlyIf~A''$ expresses that if in in the current configuration
 $A$ holds, and in some future configuration $A'$, 
\susan[{changed first " to '}]{}
 will hold, then $A''$ must also hold in the 
 current configuration.  
  
 The contributions of this paper are as follows:
 
 \begin{enumerate}
 \item
 We propose \Chainmail, a specification language with which to
express holistic specifications. 
 \item
  We propose a Logic of Necessity for writing holistic assertions and for proving a module's adherence to said assertions.
 This logic builds on top of classical pre- post- conditions.
 \item
 We prove soundness of our logic.  
 \item
 We use our logic to prove adherence to the holistic assertion of the example
outlined  in this section
 \end{enumerate}
 
 We have developed a Coq proof of soundness of our approach, and a Cow proof of the
 example in this paper. We make these proofs available as supplementary material.
% QUESTIONS:
% \begin{itemize}
% \item
% holistic assertion -- different name or say we adopt from FASE; holistic -> comprehensive, integrated, aggregate \susan[I think we should keep holistic]{}
% \item
% Name for our logic?  Holistic logic? What is we have a different take on holistic next year? Necessity triples? 
%\item
%If our \Chainmail is simpler than the FASE Chainmail, then we need to argue that we can express all FASE examples
% \end{itemize}


The rest of the paper is organised as follows: .... 
%Section
%~\ref{sect:motivate:Bank} 
%\sd{gives an example from the literature} which we will use 
%to elucidate key points of \Chainmail.
%%motivates our work via an example, and then section
%~\ref{sect:chainmail} presents the \Chainmail\ specification
%language.  Section~\ref{sect:formal} introduces the formal model
%underlying \Chainmail, and then section~\ref{sect:assertions} defines
%the 
%semantics of \Chainmail's assertions.
%% SD the below is NOT ture
%%full details are relegated toappendices.   
%Section~\ref{sect:example} shows how key points of 
%exemplar problems can be specified in \Chainmail,
%section~\ref{sect:discussion}
%discusses our design, \ref{sect:related} considers related
%work, and section~\ref{sect:conclusion} concludes.
%We relegate various details to appendices.


