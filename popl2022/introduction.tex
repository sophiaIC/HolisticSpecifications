\section{Introduction}

Current systems are complex, and  built out of many different components of different provenance and
different degree of trustworthiness.
  
  \newcommand{\prg}[1]{{\texttt{#1}}}
  
In order for the resulting  complex system to offer the
desired services, the individual components 
need to   be able to make "good things"   happen.
But in order for the resulting  complex system
 to offer these services \emph{robustly},  the individual components 
 need to be able to prevent "bad things" from happening. 

  To demonstrate that   good things \emph{can} happen, we use  witnesses;
eg  a precondition and a code snippet, whose execution will establish the
wished-for effect.  For example, if I send an email to a valid address it will
be delivered to its recipient. The pre-condition and the code snippet
are \emph{sufficient} conditions for the desired effect. 

Our work is about the specification and verification of robustness: that bad things \emph{will 
not} happen. For example, nobody gets to read my email unless I forwarded it to them.   
Note that such an assertion is agnostic as to the set of methods supported by the mail-module.

The challenge here is twofold: How do we specify the "bad things",
 and how do we prove that such bad things do not happen? 

To specify the bad things, we cannot
refer to one particular peace of code, % and cannot refer to one witness;
 instead, we need to make a guarantee which encompasses all possible
 functions executable by a module in all their possible sequences or even interleavings --
 we need to consider their \emph{emerging} behaviour.
 Rather than considering the sufficient conditions to achieve a certain effect,
 we express the necessary precondition. For example,    a third party 
 will not get to read my email unless I forward it to them -- the forwarding
 is a necessary precondition for the reading.
 
 To reason about necessary conditions, we develop a special
 logic with such necessity triples. The most basic such holistic assertions 
 can be derived from classical assertions (sufficient truples)
 under assumptions of encapsulation;
 they can then be further combined using our logic of necessity.
 
 We illustrate our ideas in terms of the following example:
 \prg{Account}s have a balance and a 
password. One may transfer \prg{100} units from one \prg{Account} to another, but only provided
that  the caller provides the right password. Below we show the Version I of the code for 
a class \prg{Account}. 
We use a Java-like syntax,  and assume that fields are private in the sense of C++, \emph{i.e.,}
 only methods of that class may read or write these fields,
 and   that addresses are unforgeable, and so  there is mo way to guess a password.

 

\begin{lstlisting}
class Account{
   field bal:int 
   field pwd: Password 
   method transfer(dest:Account, pwd':Password) -> void {
      if (this.pwd==pwd') {
            this.bal-=100;  dest.bal+=100; }  }
}
\end{lstlisting}

as well as a ``classical'' specification of the method \prg{transfer}:

 (ClassicSpec)$  \ \ $  $\triangleq$

\begin{lstlisting}[mathescape=true, frame=lines]
  method transfer(dest:Account, pwd':Password) -> void {
       ( PRE:  this.balance=bal1 $\wedge$ this.pwd==pwd' $\wedge$ dest.balance=bal2 $\wedge$ dest=/=this 
         POST: this.balance == bal1-10 $\wedge$  dest.balance=dest.balance+10 )
       ( PRE: this.balance=bal1 $\wedge$ this.pwd=/=pwd' $\wedge$ dest.balance=bal2
         POST: this.balance == bal1 $\wedge$  dest.balance=dest.balance )
       ( PRE: a : Account $\wedge$ a=/=this $\wedge$ a=/=dest  $\wedge$ a.balance=bal  
         POST:  a.balance=bal $\wedge$ a.pwd=pwd1)
       ( PRE: a : Account $\wedge$ a.pwd=pwd1  
         POST: a.pwd=pwd1)       
\end{lstlisting}\footnote{Perhaps omit some of the lines here, but we do need them all in the full discussion}
  
 
  
 
 Now consider two further versions of the class account, given in Figure \ref{fig:ExampleAccount}.
 In Version II and Version III the class has an additional method, \prg{set}, which allows resetting
 the password.
The method \prg{transfer} in all three versions of the class \prg{Account} satisfy the (ClassicSpec), 
however, undoubtedly, while the first and third version of \prg{Account} are "robust", the second version is not.
Namely version II allows a client to change the password of the account, and then to repeatedly withdraw 
money from it.
  
% On the other hand, we expect our software -- even if complex -- to provide some simple, high level
%guarantees, e.g. email addressed to me personally will not be read by a third party unless I explicitly 
%forwarded it to them.
%We except  our software to  behave correctly, even when used by a careless or malicious third party. 
%Such use of a software often consist of a sequence of actions performed on the module. 
%
%Software components respond to single actions, 
%or to sequences of such single actions. 
%When thinking about a software component we want think about the behaviour of each 
%action in isolation, but also about the \emph{emergent behaviour}, ie all
% the possible effects of the combinations of these actions. 
  
  
 
 \begin{figure}[hbtp]
 \begin{tabular}{lll}
\begin{minipage}{0.35\textwidth}
\begin{lstlisting}
class Account{
   field bal:int 
   field pwd: Password 
   method transfer(..) 
        ... as earlier ...
   method set(pwd':Password){
         this.pwd=pwd' }
}   
\end{lstlisting}
\end{minipage}
  &\ \ \  \ \   &
\begin{minipage}{0.50\textwidth}
\begin{lstlisting}
class Account{
   field bal:int 
   field pwd: Password 
   method transfer(..) 
        ... as earlier ...
   method set(pwd',pwd'':Password){
         if (this.pwd==pwd'){this.pwd=pwd''} }
}
\end{lstlisting}
\end{minipage} 
 \end{tabular}
  \caption{class \prg{Account} version II, and \ \ \ \ \ \  class \prg{Account} version III}
 \label{fig:ExampleAccount}
 \end{figure}

 
 The remit of our work is to find ways to specify robustness. 
 The flaw in Version II arises from the \emph{emergent} behaviour of that class: first use \prg{set} 
 to overwrite the
 password, and then use the new password and \prg{transfer}   
 To express robustness, we need to preclude any such behaviour.
 Therefore, we propose a holistic specification which says that
 the \prg{balance} of an \prg{Account} reduces only if an object which does not belong
 class \prg{Account} has access to the password:
 
 \begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
(HolisticSpec)  $\triangleq$  a:Account $\wedge$ a.balance==bal
                   to a.balance < bal
                   onlyIf $\exists$ o'.[$\external{\texttt{o'}}$ $\wedge$ $\access{\texttt{o'}}{\texttt{a.pwd}}$]
\end{lstlisting}
 
 In more detail, the specification from above says that if in the current
 configuration \prg{a} is an \prg{Account},
 % with balance \prg{bal}, 
 and in some future configuration \prg{a} will have a balance less than the current one, then, in the \emph{current} configuration
 there must exist some object \prg{o}, which is \emph{external} to our module (does not belong to class
 \prg{Account}), and which has access to \prg{a}'s password.
 
 
 Thus, having access to the password is a necessary condition for the balance to reduce.
 Note, that the specification only talks about effects (here the balance reducing), and does not
 talk about individual methods (such as \prg{set} or \prg{transfer}).
 
 Our holistic specification language, \Chainmail, extends traditional specifications with
notions of access (which object points to which), control (which methods is called)\footnote{perhaps drop as confusing?}, 
 the distinction between external and internal objects, and necessary conditions, 
 whereby the assertion $A to A' onlyIf A''$ expresses that if in in the current configuration
 $A$ holds, and in some future configuration $A''$ will hold, then $A''$ must also hold in the 
 current configuration.  Earlier work by \cite{tacas} was also concerned with 
 holistic specifications and necessary conditions, which they expressed through time operators.
 \Chainmail is less rich than Chainmail, however it comes with a proof system which is lacking from 
 Chainmail.
 
  
 The contributions of this paper are as follows:
 
 \begin{enumerate}
 \item
 We propose \Chainmail, a specification language with which to
express holistic specifications. 
 \item
 We propose a logic of triples of assertions that allows us to prove
 a module's adherence to such a holistic assertion. 
 This logic builds on top of classical pre- post- conditions.
 \item
 We prove soundness of our logic.  
 \item
 We use our logic to prove adherence to the holistic assertion of the example
outlined  in this section
 \end{enumerate}
 
 QUESTIONS:
 \begin{itemize}
 \item
 holistic assertion -- different name or say we adopt from FASE; holistic -> comprehensive, integrated, aggregate
 \item
 Name for our logic?  Holistic logic? What is we have a different take on holistic next year? Necessity triples?
\item
If our \Chainmail is simpler than the TACAS Chainmail, then we need to argue that we can express all TACAS examples
 \end{itemize}
  
The rest of the paper is organised as follows: .... 
%Section
%~\ref{sect:motivate:Bank} 
%\sd{gives an example from the literature} which we will use 
%to elucidate key points of \Chainmail.
%%motivates our work via an example, and then section
%~\ref{sect:chainmail} presents the \Chainmail\ specification
%language.  Section~\ref{sect:formal} introduces the formal model
%underlying \Chainmail, and then section~\ref{sect:assertions} defines
%the 
%semantics of \Chainmail's assertions.
%% SD the below is NOT ture
%%full details are relegated toappendices.   
%Section~\ref{sect:example} shows how key points of 
%exemplar problems can be specified in \Chainmail,
%section~\ref{sect:discussion}
%discusses our design, \ref{sect:related} considers related
%work, and section~\ref{sect:conclusion} concludes.
%We relegate various details to appendices.
