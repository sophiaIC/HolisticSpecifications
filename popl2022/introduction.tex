\section{Introduction}
\label{s:intro}

\subsection{Necessary conditions and Robustness} 
Today's   software has been built 
over decades by combining modules and components of
different provenance and 
%different degrees of 
trustworthiness, and
is \emph{open}, interacting with other programs, devices, and people.
{Software needs} to be both  {\emph{correct}} ({programs do what they are supposed to}) and   
{\emph{robust}} ({programs don't do what they aren't supposed to, even in the presence of untrusted  {clients}}).  
 {This work  addresses the robustness of modules and APIs: {how it can be specified, and how adherence to the specification can be verified}.}

 {Correctness is} typically specified formally 
 through \citeasnoun{Hoare69} triples consisting of a  precondition, a code snippet, and a
 postcondition. 
 For example,  {for a bank module,  we may specify:}
 \begin{quote}
\Scorrect\ \ $\triangleq$ \ \ Calling \prg{transfer} on \sd{an account and using the account's password} will transfer the money.
\end{quote}
Assuming termination, the precondition is a \emph{sufficient} condition for the {code snippet to behave correctly}: 
%assuming termination, 
the precondition (\eg providing the right 
password) guarantees that
the code (\eg call the \prg{transfer} function)
will always achieve the postcondition (the money is transferred).
 
    \vspace{.05in}
    % I think we need the vspace
 
%While 
\Scorrect  describes \sd{the \emph{correct use} of the module, but is \emph{not} concerned with its \emph{robustness}.}
\sd{For example, can I pass an account to foreign untrusted code, in the expectation of receiving a payment,
but without fear that a malicious client might use the account to steal my money \cite{ELang}?}
 A first approach to specify robustness could be:
 

\begin{quote}
\SrobustA\ \ $\triangleq$ \ \ An account's balance does not decrease unless \prg{transfer} was called 
with the correct password.
\end{quote}

Specification \SrobustA % gives   the guarantee 
\sd{guarnatees} that it is not possible to  take money out of the account through some method other than \prg{transfer}
% which did not require knowledge of the password.
\sd{or without providing the password}.
  Calling \prg{transfer}   with the  correct password is 
a \emph{necessary condition} for reducing the account's  balance.

%Condition    % \SrobustA is a specification, and NOT a condition!
\SrobustA is  crucial, but  not   enough:
it does not take  account of the module's \emph{emergent behaviour},
 \sd{that is, does not cater for the potential interplay of several methods offered by the module.}
 What if the module provided further methods which leaked the password,  
 {or allowed for it to be arbitrarily changed}?
\sophiaPonder[drop?]{ While no single procedure call is capable of breaking the intent of \SrobustA, a sequence of calls might.}
{What} we really need is
 \begin{quote}
\SrobustB\ \ $\triangleq$ \ \ The balance of an account does not {\emph{ever}} decrease in the future unless some external 
object  {\emph{now}} has access to the account's current password.
\end{quote}
With \SrobustB, I can confidently pass my account to some untrusted client who
 does not have
 knowledge of the password; they may or may not make the payment I was expecting, but I
 know they will not \sd{be able to} steal my money \cite{ooToSecurity,miller-esop2013}.
 Note that \SrobustB  does not mention
 the names of any functions in the module, and 
 thus can be expressed without reference to any particular API ---
 indeed \SrobustB can constrain \emph{any} API with an account, an account
 balance, and a password.
% \sd[this is great, but I think should go somewhere later on']{\jm{Finally, \SrobustB takes into account 
% the \emph{emergent behavior} of the bank account: that is, a single method call 
% is not considered in isolation, rather, the functionality of the entire module is
% specified, including all combinations of method calls.}
%}
 
 
%Type systems   % have been developed for various programming languages. They 
% give  relatively coarse-grained guarantees, \emph{e.g.,} 
% that ``message not understood'' errors 
%will not be thrown \cite{EiffelCook},
% private methods will not called by external modules \cite{JavaAccess},
%  no object or method will directly point inside the internal representation of some other object
%\cite{ownalias},
%or that race conditions will not arise  \cite{mindori}. % -- again, just naming a few.
%\sophiaPonder[]{Drop the types?}
 

%\emph{Information-flow control}  systems have been developed for
%various calculi and programming languages. Their 
% guarantees are coarse-grained:  the contents of high security variables cannot
%be affected by the values of low security variables 
%\cite{Zdancewic:Myers:01,noninteferenceOS}. 
 
%\emph{Correspondence assertions} are more fine-grained. Proposed for 
%process calculi, they %can guarantee
%{express}  that if one principal ever reaches a certain point in the protocol, 
%then some other principal has previously reached some other matching point in the protocol; 
%the term \emph{robust safety}  expresses that correspondence assertions are true in the presence of any opponent %expressible in the calculus 
%\cite{correspondence}. 
%% SD thought the below was true, but nor think it is not
%% Correspondence assertions have also
%% been proposed for Javascript. 
%A related approach,  \emph{authorisation policies}, 
%%A related problem is \emph{authorisation policies}, which 
%promises that certain actions will not be taken on certain objects
%unless corresponding  rights had been granted  \cite{Maffeis:aiamb:thesis00}.

%In   \emph{object capabilities} \cite{MillerPhD},
%effects can only be produced by sending messages to objects (which have unforgeable identities) and  there
%is no ambient authority.
%%and  objects have unforgeable identities.
%In the context of object capabilities, \citeasnoun{ddd} define  \emph{robust safety for Javascript}  
%to mean that the untrusted environment of a program cannot violate 
%its internal invariants, and developed  a verification methodology   to 
%prove   that programs that  export only %properly 
%wrapped values  are robustly safe.
%%In the same context, 
%\citeasnoun{dd} develop Kripke models to reason about 
%the result of execution of some given code snippet in parallel
%with arbitrary, unknown code and
%\citeasnoun{threoremsFreeSep} derive usage protocols from a module's
%separation logic specification.

%Most of the approaches outlined so far were not developed with
% the aim of expressing guarantees such as (S2).
%   Information flow control systems target process calculi. % are too coarse grained. 
% %Correspondence assertions target process calculi and do not exactly match 
%% the time of the effect to its cause.
% \citeauthor{ddd} are concerned with the preservation of
% internal invariants. \citeauthor{dd} are
% concerned with the \emph{effects} of known code,
% while \citeauthor{threoremsFreeSep}  reverse-engineer usage protocols.
 
%Recently,  
%{\sc{VerX}}  \cite{VerX}  and   \emph{Chainmail}  \cite{FASE} 
% added temporal operators to specification languages, and thus can express necessary conditions.  
% %Both  {\sc{VerX}}  and   \emph{Chainmail} 
% Assertions support the usual 
%   logical connectives and can refer to current state and function calls.
%   %assertions about the current state, and in addition,
% %{\sc{VerX}}  can   talk about function calls,
% \emph{Chainmail} 
% %can talk about function calls, 
% can also talk about \emph{permission} (whether an
% object has direct access to another object -- either through its fields or 
% %through the
%its arguments to a function call),    about \emph{provenance} (whether an object
% belongs to the current module, or some %client, 
% unknown module),
%{and control (whether a certain function is called with given arguments).}
%Permission and provenance are inspired by the object capabilities
% literature \cite{MillerPhD}. 
 
% is used to express safety properties of smart contracts;
% adherence to such specifications is proven through symbolic 
% execution.  \emph{Chainmail} is used to express general safety properties; it
% also includes predicates talking about provenance
% and access (more below), but lacks a proof system.
 
%\susan[font?]{}\paragraph{What we \emph{really} need} 
\vspace{.04in}
 
 \subsection{Earlier works on Robustness} 
Our paper is not the first   to address % the problem of 
\sd{robustness}:
% In contrast to \jm{correctness}  which is usually specified with \sophiaPonder{why talk again about Hiare triples}% such 
% Hoare triples,  
 {\sd{Many} 
kinds of} guarantees have been proposed\sophiaPonder[dropped: ``proposed for  robustness'']{}, differing in the level 
of granularity,   target  language or calculi, and intended use.  {To name a few,}
object capabilities  \cite{MillerPhD, dd, threoremsFreeSep}, 
information control flow \cite{Zdancewic:Myers:01,noninteferenceOS}, 
and correspondence assertions \cite{Maffeis:aiamb:thesis00}
all
ensure some level of robust safety. 
{However, to our knowledge, 
our work is the first that is able to 
express specifications of the form %(S$_{\text{robust}_2}$),
 \SrobustB, along with a system
for formally verifying such specifications.}

{Our work is related} to  {\sc{VerX}} \cite{VerX} and  \emph{Chainmail} \cite{FASE}.
Both these approaches can express necessary conditions
  like \SrobustA. For this, they  {both employ
  temporal operators and implication, for example,  \SrobustA
 could take a form like} 
\\
 $\strut ~  ~ \hspace{.1in} \strut  \prg{a:Account} \ \wedge\ \prg{a.balance==bal}  \ \wedge\ \textbf{next}(\prg{a.balance<bal}) $\\
 $\strut ~ \hspace{2in} \strut \strut \strut \longrightarrow\    \textbf{calls}\, \prg{a.transfer(\_,a.password)}$
 \\
 { However, to express \SrobustB, one also needs what we call \emph{capability operators}, which talk about 
 provenance (``external object'') and
  permission (``\prg{x} has access to \prg{y}''). 
   {\sc{VerX}}  does not support capability operators, and thus cannot express   \SrobustB, 
   while  \emph{Chainmail} does support capability operators, and can express  \SrobustB. 
}  
 {\sc{VerX}} comes with a symbolic 
  execution system which can demonstrate adherence to its specifications, but doesn't have a proof logic, % to prove adherence,
   whereas, \emph{Chainmail}  \sd{has neither a symbolic execution system, nor a proof logic.}
  % \susan[I have separated the tools rather than separating the features as I think it is clearer]{}
  
 {Temporal operators in {\sc{VerX}}   and  \emph{Chainmail}  are first class, \ie may appear in any assertions 
and form new assertions. This makes {\sc{VerX}}   and  \emph{Chainmail} very expressive,
and allows specifications which talk about any number of points in time.
However, this expressivity comes at the cost of making it very difficult to develop a logic to
prove adherence to such specifications.}
  
\vspace{.04in}

\subsection{This work}
\label{intro:this:work}
This work introduces \Nec, which consists of a specification language for expressing a module's safety guarantees 
% such as \SrobustB, 
and a logic 
to prove adherence to such specifications.

For the specification language we adopted % have been inspired by   
\emph{Chainmail}'s %approach to add
  capability operators.
\sd{For the 
  temporal operators, we observed that while their
   unrestricted combination with  other logical connectives allows us to talk about any
   number of points in time, the examples found in the literature talk about two or at most three such points. 
   \sophiaPonder[here we should add ALL the works, \ie
   Devriese, MaxPlank, VerX, and us]{}}
  
 \sd{This led to the  crucial insight that we could merge  temporal operators and the implication 
 logical connective into our three}
 %Therefore, \jm[]{in searching for a sweet spot between expressiveness and the ability to 
 %prove examples}, we replaced the temporal operators with  {our three novel}
  \emph{necessity} operators. 
 One such necessity operator is
 
 \begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
                                from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$ 
\end{lstlisting}
%  %      $A$          from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$          from ${A_{curr}}$ to ${A_{fut}}$ onlyThrough ${A_{nec}}$
The  form   {above} says that % $A$ always holds;  $A$ is an invariant.
%The second form says that  
a  {transition} from a current state satisfying assertion $A_{curr}$ to a future
state satisfying $A_{fut}$ %(i.e.\ the transition  $A_{curr}$ to $A_{fut}$ being an effect) 
is possible only if the   necessary 
condition
$A_{nec}$ holds in the \emph{current} state.
%The third form says that a change from %a current state satisfying 
%$A_{curr}$ to % a future state satisfying 
%$A_{fut}$  may happen only if % the necessary condition
%$A_{nec}$ holds in some \emph{intermediate} state.
%The other two operators express either \emph{necessary conditions} for
%\emph{single-step} transitions % from  $A_{curr}$  states to a   $A_{fut}$ states,
%or \emph{intermediate} conditions for \emph{any} transitions.
% from a $A_{curr}$ -state t  $A_{fut}$  states.
Using %\sd{the first} 
this operator, we can formulate  \SrobustB % in \Chainspec  
as
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
$\text{\SrobustB}$  $\triangleq$   from a:Account $\wedge$ a.balance==bal
               to a.balance < bal
               onlyIf $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\access{\texttt{o}}{\texttt{a.pwd}}$]
\end{lstlisting}
Namely, a transition from a  {current} state where an account's balance is \prg{bal}, to a  {future} state where 
it has decreased, may \emph{only} occur if  {in the current state} some unknown client object  
has access to that account's password. 
More discussion in \S\ref{s:bankSpecEx}. 

  
Unlike  \emph{Chainmail}'s temporal operators, 
 the necessity operators %  $\onlyIf {\_} {\_} {\_}$  and $\onlyThrough {\_} {\_} {\_}$
 are second class, and may not appear in the assertions  {(\eg  ${A_{curr}}$)}. 
 This simplification enabled us to develop our proof logic. 
 Thus, we \sophiaPonder[Drop: "believe that we"]{have reached} a \sd{sweet spot between expressiveness and 
 provability.}
 %prove examples}, we replaced the temporal operators with  {our three novel}
%We propose \Chainmail, a specification language % for   \emph{Necessity Specifications} 
% to describe a module's safety guarantees,
%and 
%\Chainlogic,   % \emph{Necessity Logic} 
%a logic to prove a module's adherence to such specifications.



%\jm[not sure if this should go here ...\sd{Actually, not sure what is said here is true} Here what it said, but I think it breaks the flow
%Unlike other work on specifying robust safety for software,  \Nec allows proofs of not just simple safety 
%specifications, but specifications that rely on reasoning about emergent behavior and complex interactions 
%across a module's interface (such as \SrobustB).
%Further, beyond unforgeability and privacy, \Nec is agnostic about much of the specifics
%of module implementation, only that module code can be verified using some Hoare logic. 
%This is a significant advantage, as it makes \Nec broadly applicable to any such languages that use Hoare logic to establish correctness.. \sd{it is not
%a matter of language}]{}


%\textit{Necessity Specifications}  are
%\Nec supports the usual assertions, $A$, (including permission, provenance,
%and control), as well as three \jm[]{novel} necessity 
%{operators. We now show one of these operators} 
% shown below.
% \susan[Needs to be laid out differently to put the four forms in]{}
% Thus, we  have % one  of  the two -- omitting, as there are three!
% the following forms:
%\jm[are we missing \texttt{from $A_{curr}$} nxt $A_{fut}$ onlyIf $A_{nec}$?]{}
%\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
%       $A$          from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$          from ${A_{curr}}$ to ${A_{fut}}$ onlyThrough ${A_{nec}}$
%\end{lstlisting}
 


 %\sophiaPonder[not sure we need to have the latter, 
% and do not have temp logic form of it]{}.
% For same later section?
%Unlike \citeauthor{VerX} or \citeauthor{FASE}
%the necessity operators $\onlyIf {\_} {\_} {\_}$  and $\onlyThrough {\_} {\_} {\_}$
%are second class, and may nor appear in the assertions $A$.
%%support necessity specifications with this explicit
%% ``$\onlyIf {A_1} {A_2} {A_3}$'' syntax
%%
%%and concomitant specialised inference system.
%%
%%
%Our assertions $A$ support the usual expressions about program state
%%(e.g. \prg{x.f > 3}),
% logical connectives and quantifiers, 
%%(e.g. $\wedge$, $\forall$), 
%and additional predicates
%to capture \textit{provenance} (whether an object $o$'s definition is
%$\internal{\texttt{o}}$ or $\external{\texttt{o}}$) to the current
%module, and \textit{permission} \cite{miller-esop2013} (whether an
%object $o$ has direct access to another object $o'$:
%$\access{\texttt{o}}{\texttt{o'}}$).

 \susan[Probably the encapsulation statement should be the last introduced as a 'pruning'? technique.\sd{SD: agrre}]{\Nec specifications are high-level, system-wide properties. Our problem was how to develop a logic that would enable us to prove that code 
adhered to such specifications.  Our Eureka moment came when we realised that all the information we required was hiding in the classical specifications in the program functions. Of course it was not straightforward to extract what we needed, but we came up with a successful technique.}
\sophiaPonder[I think we need to make the brown stuff fit better the next paragraph.]{}
 
 \sd{The \Nec logic is based on the crucial insight that the specification $\onlyIf{A_1} {A_2} {A_3}$ is 
logically equivalent
 with $\forall \prg{stmts}. \{ A_1 \wedge \neg A_3\} \prg{stmts} \{ \neg A_2 \}$ -- that is,
 with an infinite conjunction  of Hoare triples.
We want to leverage prior work on program verification, however, we have the problem that Hoare logics only reason about given, known, statements.
 Three breakthroughs lead to the solution of that problem:
 \begin{itemize}
 \item
 First, we  leverage Hoare logic to reason about one particular method call. Namely, the \Nec specification
$ \onlyIfSingle {(A_1 \wedge {\calls{\_}{\prg{x}}{\prg{m}}{\prg{ys}} } )} {A_2} {A_3}$ is logically equivalent with the  Hoare triple 
$ \{ A_1 \wedge \neg A_3 \} \ \prg{x.m(ys)}\  \{ \neg A_2 \}$.
 \item 
 Second, if an assertion $A_2$  is \emph{encapsulated} by a module (ie the only way we can go from a 
 state that satisfies $A_2$ to a state that does not, is through a call to a method in that module), then
\sophiaPonder[slightly different in main text, have simplified here; hope it does not create confusion]{ $ \onlyIfSingle {A_1 \wedge \neq A_2} { A_2} {A_3}$ is logically equivalent with the finite conjunction
 $ \onlyIfSingle {(\, A_1 \wedge \neg A_2 \wedge {\calls{\_}{\prg{x}}{\prg{m}}{\prg{ys}}}\, )} {A_2} {A_3}$
 for all methods of that module.}
  \item Third, an inference system combines several specifications to reason about the
  emergent behaviour, for example 
   $ \onlyThrough  {A_1} {A_2} {A_3}$  and $ \onlyIf  {A_1} {A_3} {A_4}$ implies that
   $ \onlyIf  {A_1} {A_2} {A_4}$.
 \end{itemize}
More in \S\ref{s:approach}.
}

%The \Nec logic is based on four main ideas: 
%First, some assertions are \emph{encapsulated}, \ie
%their validity may only be affected by internal calls. 
%% \susan[same question - is may the correct word? This said module-internal before I edited it.]{}
%Second, by leveraging the classical  specifications of methods 
%(\ie the sufficient conditions) we can obtain per-method-call
% \Nec specifications; that is, necessary preconditions
%  for a given effect and a given method call (at a very abstract level, this is
%similar to \citeasnoun{threoremsFreeSep}).
%Third we infer a per-step-condition, \ie, a necessary condition given an effect and a single, unspecified step. This step could be an internal call, or any kind of external step.
%Fourth,  a novel proof system allows us to combine 
%per-method \Nec specifications and encapsulated assertions 
% to obtain per-module   \Nec specifications; these describe a module's
% emergent behavior.
%More in \S\ref{s:approach}.


 
  The current work is based on a simple, imperative, typed, object oriented
language with unforgeable addresses and private fields. We believe
 that our approach is applicable to several programming paradigms, and 
 that   unforgeability and privacy
 can be replaced 
 by lower level mechanisms such as capability machines \cite{vanproving,davis2019cheriabi}.
 


%The below is good and perhaps we shpuld use it
% The challenge here is twofold: How do we specify the bad things we are
%concerned about, and how do we prove that the bad things we've
%specified do not happen?  These challenges are difficult because we
%cannot refer to just one component of a software system.  A sufficient
%specification can deal with a single component in isolation --- a
%single function for pre- and postconditions; a single class or data
%structure for invariants. A necessary specification, however, must
%provide guarantees which encompass the software system in its
%entirety, and constrain the emergent behaviour of all its components,
%for an open system, all possible sequences of API invocations.
% 
% 
%
% 
%The importance of distinguishing between sufficient and necessary
%specifications of various kinds has a long history in Computer
%Science.
% 
%  Type systems ensure entire classes of bad things can't
%happen, preserving execution even if memory structures are greatly
%corrupted \cite{Rinard03}.
%%
%More recently, \citeauthor{ddd} and \citeauthor{sandbox} with their robust safety and
%\citeauthor{FASE} with their holistic systems have tackled open world systems to prevent bad things from happening from untrusted code.
%\citeauthor{ddd} use techniques from security to ensure \jm[]{there} isn't undesirable leakage, \citeauthor{sandbox} build a sandbox and have a sophisticated type system to protect it and \citeauthor{FASE} have
%necessary conditions, which they expressed through temporal
%operators.

% In the next section, (\S\ref{s:outline}),  we outline our approach using the
% bank account as  a motivating example.%This example demonstrates, among other things, that the specification need  refer  to  individual methods in a module.
%Moreover, adherence to a Necessity Specification is not monotonic, in the following two senses:
%Adding a method to a module does not necessarily preserve adherence to a Necessity Specification,
%and while separate methods may adhere to a  Necessity Specification, their combination does
%not necessarily do so: Necessity Specifications capture a module's emergent behaviour.


\subsection{Paper Organization and Contributions}

%%In the next section, (\S\ref{s:outline}),  we outline our approach using a
%% bank account as  a motivating example.

%\jm[should this be ``a bank account''? This is the first time we mention it]{}
%
The contributions of this paper are:\begin{enumerate}
 \item
%\Chainspec, a 
A language to
express \Nec specifications (\S\ref{s:semantics}).
\sophiaPonder[to revisit  that is  expressive  enough to encode the \emph{Chainmail} examples from \citeasnoun{FASE}.
-- this bit may diminish our contribution!] {}

 \item
%\Chainlogic, a 
A logic for proving a module's adherence to 
 \Nec specifications (\S\ref{s:inference}), and a proof of soundness of the logic, (\S\ref{s:soundness}),
both mechanized in Coq. 
 \item
A proof in our logic % the bank account 
  that our bank module obeys its \Nec specification (\S\ref{s:examples}), \sd{also} mechanized in Coq.
\end{enumerate}


%\jm[]{
%Our formalization of \Nec does have two limitations. 
%Firstly, it is specifically a logic for 
%necessity and robustness properties. \Nec 
%is parametric with respect assertion satisfaction, correctness,
%encapsulation, and the type system. Much of these are
%well-trod ground in the literature, and where needed we
%do introduce simplistic language mechanisms to deal with them (e.g. a simple type system or notion of encapsulation).
%Secondly, we do not allow for ``callbacks'' 
%to external objects. This is a common restriction in the literature
%as many either prohibit callbacks, or require
%``effectively callback free contracts'' \cite{VerX},
%or place significant restrictions on callbacks \cite{}
%}

Our formalization of \Nec % has a number of limitations: it
{  is 
parametric} with respect to assertion
satisfaction, encapsulation, and the type system.
{{Moreover, in line} with other work in the literature,} we forbid 
``callbacks'' out to external objects; and also
classical specifications require explicit framing.
We will discuss these  issues % limitations 
further as we place \Nec into the context of 
related work (\S\ref{s:related}) and consider our overall conclusions
(\S\ref{s:conclusion}). 
%
The Coq proofs of 
(2) and (3) above appear in the
supplementary material, along with \sd{a}ppendices containing expanded 
definitions and further examples.

