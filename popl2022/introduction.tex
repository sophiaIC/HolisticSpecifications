\section{Introduction}
\label{s:intro}

Today's   software has been built 
over decades by combining modules and components of
different provenance and 
%different degrees of 
trustworthiness. It 
is open, interacting with other programs, devices, and people.
In this 
%complex 
setting, modules need to be both useful ``good things
will eventually happen'' and  % (liveness)  
robust ``bad things will never happen'' % (safety), 
 \susan[Is it better to just omit the cite of Lamport?]{-- broadly paraphrasing \cite{Lamport77}  
 on liveness and safety.} 
%\vspace{.03in}

\emph{Good things happening} are typically specified formally 
 through triples consisting of a  precondition, a code snippet, and some
 postcondition \cite{Hoare69}.
 For example,
 \begin{quote}
(*)\ \ Calling \prg{transfer} using the correct password will transfer the money.
\end{quote}
The precondition is a \emph{sufficient} condition for the code snippet to
make the good thing happen: 
assuming termination, the precondition (eg providing the right 
password), 
%executing a code snippet (eg 
when executing the \prg{transfer} function
%) 
is guaranteed to achieve the postcondition (the money is transferred).
%Proving adherence to such specifications  poses considerable challenges, especially when in the 
%context of aliasing, re-entrancy, multithreading, memory models, to name a just a few. 
%Such challenges  have been studied intensively over the last  two decades 
% \cite{BIMutable,objInvars,DenyGuarantee,RealxedC11} -- again just naming a few.

%   \vspace{.03in}
\emph{Bad things not happening}
   irrespective of whether a module's clients are benign or malicious, is what makes a module  robust. 
%\sophiaPonder[I fear this sentence breaks the flow]
%{We go beyond  ``design by contract'' \cite{Meyer09},  and
%cannot rely on a module's client sticking to the module's contract.}
{For example}, for a bank module to 
be robust, it must 
guarantee  that

\begin{quote}
(**)\ \ An account's balance does not decrease unless \prg{transfer} was called 
with the correct password.
\end{quote}

%   in a context where no external agent knows the account's password, 
% the balance of 
%that account will not decrease -- such a guarantee allows one to confidently 
% pass their bank account into untrusted code, in the expectation of receiving some payment.}
The call of \prg{transfer}  with the  correct password is thus
a \emph{necessary condition} for any reduction of  balance.
 Condition   
(**) is crucial in order to confidently pass the bank account into untrusted code, 
in the expectation of receiving some payment, but without fear
that a malicious client might steal my money \cite{ELang,miller-esop2013}.
% Expressed as a \emph{necessary condition}, this guarantee 
%
% SD Perhaps this sentence should come later
% In this paper we propose how  to specify
%such necessary conditions formally, as well as ways to provide adherence to
%such specifications.
In contrast to ``good things   happening''  which are usually specified with % such 
Hoare triples,  a multitude of different guarantees have been proposed for ``bad things  not
happening'', differing in the level 
of granularity,   target  language or calculi, and intended use.
% , and the ways by which  the guarantees can be established.

 
%Type systems   % have been developed for various programming languages. They 
% give  relatively coarse-grained guarantees, \emph{e.g.,} 
% that ``message not understood'' errors 
%will not be thrown \cite{EiffelCook},
% private methods will not called by external modules \cite{JavaAccess},
%  no object or method will directly point inside the internal representation of some other object
%\cite{ownalias},
%or that race conditions will not arise  \cite{mindori}. % -- again, just naming a few.
%\sophiaPonder[]{Drop the types?}
 

\emph{Information-flow control}  systems have been developed for
various calculi and programming languages. Their 
 guarantees are coarse-grained:  the contents of high security variables cannot
be affected by the values of low security variables 
\cite{Zdancewic:Myers:01,noninteferenceOS}. 
 
\emph{Correspondence assertions} are more fine-grained. Proposed for 
process calculi, they %can guarantee
{express}  that if one principal ever reaches a certain point in the protocol, 
then some other principal has previously reached some other matching point in the protocol; 
the term \emph{robust safety}  expresses that correspondence assertions are true in the presence of any opponent %expressible in the calculus 
\cite{correspondence}. 
% SD thought the below was true, but nor think it is not
% Correspondence assertions have also
% been proposed for Javascript. 
A related approach,  \emph{authorisation policies}, 
%A related problem is \emph{authorisation policies}, which 
promises that certain actions will not be taken on certain objects
unless corresponding  rights had been granted  \cite{Maffeis:aiamb:thesis00}.

In   \emph{object capabilities} \cite{MillerPhD},
effects can only be produced by sending messages to objects (which have unforgeable identities) and  there
is no ambient authority.
%and  objects have unforgeable identities.
In the context of object capabilities, \citeauthor{ddd} define  \emph{robust safety for Javascript}  
to mean that the untrusted environment of a program cannot violate 
its internal invariants, and developed  a verification methodology   to 
prove   that programs that  export only %properly 
wrapped values  are robustly safe.
%In the same context, 
\citeauthor{dd} develop Kripke models to reason about 
the result of execution of some given code snippet in parallel
with arbitrary, unknown code and
 \cite{threoremsFreeSep} derive usage protocols out of a module's code.

{None} of the approaches outlined so far were developed with
 the aim of expressing guarantees such as (**):  
  Information flow control systems are too
 coarse grained. Correspondence assertions target process calculi and do not exactly match 
 the time of the effect to its cause. \citeauthor{ddd} are concerned with the preservation of
 internal invariants. \citeauthor{dd} are
 concerned with the \emph{effects} of known code,
 while \cite{threoremsFreeSep}  reverse-engineer usage protocols.
 
%Recently,  
{\sc{VerX}}  \cite{VerX}  and   \emph{Chainmail}  \cite{FASE} 
 added temporal operators to specification languages, and thus can express necessary conditions.  
 %Both  {\sc{VerX}}  and   \emph{Chainmail} 
 Assertions support the usual 
   logical connectives and can refer to current state and function calls.
   %assertions about the current state, and in addition,
 %{\sc{VerX}}  can   talk about function calls,
 \emph{Chainmail} 
 %can talk about function calls, 
 can also talk about \emph{permission} (whether an
 object has direct access to another object -- either through its fields or 
 %through the
its arguments to a function call),    about \emph{provenance} (whether an object
 belongs to the current module, or some %client, 
 unknown module),
 \sophiaPonder[]{and control (whether a certain function is called with given arguments).}
Permission and provenance are inspired by the object capabilities
 literature \cite{MillerPhD}. 
 
% is used to express safety properties of smart contracts;
% adherence to such specifications is proven through symbolic 
% execution.  \emph{Chainmail} is used to express general safety properties; it
% also includes predicates talking about provenance
% and access (more below), but lacks a proof system.
 
%\susan[font?]{}\paragraph{What we \emph{really} need} 
\vspace{.04in}

However, while (**) is a necessary condition  to confidently pass 
 an account into untrusted code, it is \emph{not} sufficient.
Guarantee (**) does not take  account of the module's \emph{emergent behaviour}.
 What if the module leaks the password or what if the module allows me to override the
 password without knowledge of the old one? 
 What we really need is
 \begin{quote}
(***)\  \ The balance of an account does not decrease ever in the future unless some external 
object has access to the account's password now.
\end{quote}
With (***), I can confidently pass my account to some untrusted client who
  does not have
 knowledge of the password; they may or may not make the payment I was expecting, but I
 know they will not steal my money \cite{ooToSecurity,miller-esop2013}.
 Note that (***)  does not mention
 the names of any functions in the module, and 
 thus can be expressed without reference to the particular API. 
 

  Both {\sc{VerX}} and  \emph{Chainmail} can express (**), but {\sc{VerX}}  cannot express (***). 
  Namely, (***)  requires the concepts of provenance and permission.
 On the other hand, {\sc{VerX}} can prove adherence to  specifications through symbolic 
  execution, while  \emph{Chainmail}   lacks a proof system. 
  
\vspace{.04in}

This work introduces \Nec, which consists of a specification language for expressing a module's safety guarantees such as (***), and a logic 
%is  the first to express necessity specifications, including those like (***), and also
to prove adherence to such specifications.
We adopted % have been inspired by   
\emph{Chainmail}'s %approach to add
  capability operators, 
  simplifying it by removing temporal operators and introducing \sophiaPonder[]{our novel}
  \emph{necessity} operators. 
  These simplifications enabled us to develop our proof logic. 
%We propose \Chainmail, a specification language % for   \emph{Necessity Specifications} 
% to describe a module's safety guarantees,
%and 
%\Chainlogic,   % \emph{Necessity Logic} 
%a logic to prove a module's adherence to such specifications.
The current work is based on a simple, imperative, typed, object oriented
language with unforgeable addresses and private fields.\footnote{We believe
 that our approach is applicable to several programming paradigms, and 
 that   unforgeability and privacy
 can be replaced 
 by lower level mechanisms such as capability machines \cite{vanproving,davis2019cheriabi}.
  }


 

%\textit{Necessity Specifications}  are
\Nec supports the usual assertions, $A$, (including permission, provenance,
and control), as well as the application of three necessity 
\sophiaPonder[]{operators. We now show one of these operators} 
% shown below.
% \susan[Needs to be laid out differently to put the four forms in]{}
% Thus, we  have % one  of  the two -- omitting, as there are three!
% the following forms:
%\jm[are we missing \texttt{from $A_{curr}$} nxt $A_{fut}$ onlyIf $A_{nec}$?]{}
%\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
%       $A$          from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$          from ${A_{curr}}$ to ${A_{fut}}$ onlyThrough ${A_{nec}}$
%\end{lstlisting}
\begin{lstlisting}[mathescape=true, language=chainmail, frame=lines]
                                from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$ 
\end{lstlisting}
%  %      $A$          from ${A_{curr}}$ to ${A_{fut}}$ onlyIf ${A_{nec}}$          from ${A_{curr}}$ to ${A_{fut}}$ onlyThrough ${A_{nec}}$
The  form   \sophiaPonder[]{above} says that % $A$ always holds;  $A$ is an invariant.
%The second form says that  
a \sophiaPonder[]{transition} from a current state satisfying $A_{curr}$ to a future
state satisfying $A_{fut}$ %(i.e.\ the transition  $A_{curr}$ to $A_{fut}$ being an effect) 
is possible only if the necessary condition
$A_{nec}$ holds in the \emph{current} state.
%The third form says that a change from %a current state satisfying 
%$A_{curr}$ to % a future state satisfying 
%$A_{fut}$  may happen only if % the necessary condition
%$A_{nec}$ holds in some \emph{intermediate} state.
\sophiaPonder[]{The other two operators express either \emph{necessary conditions} for
\emph{single-step} transitions % from  $A_{curr}$  states to a   $A_{fut}$ states,
or \emph{intermediate} conditions for \emph{any} transitions.
% from a $A_{curr}$ -state t  $A_{fut}$  states.
}
Unlike  {\sc{VerX}} and  \emph{Chainmail}, 
 the necessity operators %  $\onlyIf {\_} {\_} {\_}$  and $\onlyThrough {\_} {\_} {\_}$
 are second class, and may nor appear in the assertions $A$.
We formalize (***) % in \Chainspec  
in  \S\ref{s:bankSpecEx}.


 %\sophiaPonder[not sure we need to have the latter, 
% and do not have temp logic form of it]{}.
% For same later section?
%Unlike \citeauthor{VerX} or \citeauthor{FASE}
%the necessity operators $\onlyIf {\_} {\_} {\_}$  and $\onlyThrough {\_} {\_} {\_}$
%are second class, and may nor appear in the assertions $A$.
%%support necessity specifications with this explicit
%% ``$\onlyIf {A_1} {A_2} {A_3}$'' syntax
%%
%%and concomitant specialised inference system.
%%
%%
%Our assertions $A$ support the usual expressions about program state
%%(e.g. \prg{x.f > 3}),
% logical connectives and quantifiers, 
%%(e.g. $\wedge$, $\forall$), 
%and additional predicates
%to capture \textit{provenance} (whether an object $o$'s definition is
%$\internal{\texttt{o}}$ or $\external{\texttt{o}}$) to the current
%module, and \textit{permission} \cite{miller-esop2013} (whether an
%object $o$ has direct access to another object $o'$:
%$\access{\texttt{o}}{\texttt{o'}}$).
 
\Nec logic is based on four main ideas: 
First,  the fact that necessity operators are second class, allows us to 
 separate the proof about necessity from the rest.
 Second, some assertions are \emph{encapsulated}, \textit{i.e.,}
their validity may only be affected by internal calls. 
% \susan[same question - is may the correct word? This said module-internal before I edited it.]{}
Third, leveraging the classical  specifications of methods 
(\textit{i.e.,} the sufficient conditions) we can obtain per-method-call
 \Nec specifications; that is, necessary preconditions
  for a given effect and a given method call;  at a very abstract level, this is
similar to  \cite{threoremsFreeSep}.
Fourth,  a special proof system allows us to combine 
per-method \Nec specifications and encapsulated assertions 
 to obtain per-module   \Nec specifications; these describe a module's
 emergent behaviour.
More in \S\ref{s:approach}.
 
%The below is good and perhaps we shpuld use it
% The challenge here is twofold: How do we specify the bad things we are
%concerned about, and how do we prove that the bad things we've
%specified do not happen?  These challenges are difficult because we
%cannot refer to just one component of a software system.  A sufficient
%specification can deal with a single component in isolation --- a
%single function for pre- and postconditions; a single class or data
%structure for invariants. A necessary specification, however, must
%provide guarantees which encompass the software system in its
%entirety, and constrain the emergent behaviour of all its components,
%for an open system, all possible sequences of API invocations.
% 
% 
%
% 
%The importance of distinguishing between sufficient and necessary
%specifications of various kinds has a long history in Computer
%Science.
% 
%  Type systems ensure entire classes of bad things can't
%happen, preserving execution even if memory structures are greatly
%corrupted \cite{Rinard03}.
%%
%More recently, \citeauthor{ddd} and \citeauthor{sandbox} with their robust safety and
%\citeauthor{FASE} with their holistic systems have tackled open world systems to prevent bad things from happening from untrusted code.
%\citeauthor{ddd} use techniques from security to ensure \jm[]{there} isn't undesirable leakage, \citeauthor{sandbox} build a sandbox and have a sophisticated type system to protect it and \citeauthor{FASE} have
%necessary conditions, which they expressed through temporal
%operators.

% In the next section, (\S\ref{s:outline}),  we outline our approach using the
% bank account as  a motivating example.%This example demonstrates, among other things, that the specification need  refer  to  individual methods in a module.
%Moreover, adherence to a Necessity Specification is not monotonic, in the following two senses:
%Adding a method to a module does not necessarily preserve adherence to a Necessity Specification,
%and while separate methods may adhere to a  Necessity Specification, their combination does
%not necessarily do so: Necessity Specifications capture a module's emergent behaviour.


\subsection{Paper Organization and Contributions}

In the next section, (\S\ref{s:outline}),  we outline our approach using a
bank account as  a motivating example. 
%\jm[should this be ``a bank account''? This is the first time we mention it]{}
%
The contributions of this paper are\begin{enumerate}
 \item
%\Chainspec, a 
A language to
express \Nec specifications (\S\ref{s:semantics}). Even though it is
less expressive than  \emph{Chainmail}, we believe that it is expressive enough: we demonstrate this
by encoding the examples from \cite{FASE}.
% in \Chainspec (\S\ref{s:expressiveness}). 
 \item
%\Chainlogic, a 
A logic for proving a module's adherence to its
 \Nec specifications (\S\ref{s:inference}), and a proof of soundness of the logic, (\S\ref{s:soundness}),
 mechanized in Coq. 
 \item
A proof in our logic % the bank account 
  that our bank module obeys its \Nec specification (\S\ref{s:examples}). This is also mechanized in Coq.
\end{enumerate}
 


\noindent Finally, we discuss % place Necessity Specifications into the context of
 related work (\S\ref{s:related}) and conclude (\S\ref{s:conclusion}).
The Coq proofs of 
(2) and (3) above % soundness of \Chainspec, and the adherence of the
% bank module to it \NecessitySpecification 
appear in the
supplementary material.
\sophiaPonder[]{Some less surprising definitions and some examples have been relegated to the Appendix,
also provided as supplementary material.}
