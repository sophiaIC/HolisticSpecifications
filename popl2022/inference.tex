\section{Inference System}  

In this Section we provide an inference system for constructing 
proofs of the Holistic Guarantees defined in Section \ref{s:holistic-guarantees}.
The inference system for proving Holistic Guarantees consists of several steps:
\begin{enumerate}
\item
Proving encapsulation of module data (Section \ref{s:encap-proof})
\item
Proving module level holistic guarantees of encapsulated data from classic specifications (Section \ref{s:classical-proof})
\item
Proving single step necessary conditions from module level holistic guarantees (Section \ref{s:singleStep-proof})
\item
Proving general necessary conditions for emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}

\subsection{Proving Encapsulation}
\label{s:encap-proof}
We start by giving providing the syntax for type contexts in Fig. \ref{f:context-syntax}.
\begin{figure}[t]
\[
\begin{syntax}
\syntaxElement{\Gamma}{Type Context}
		{
		\syntaxline
				{\emptyset}
				{\alpha : C,\ \Gamma}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{}
\label{f:context-syntax}
\end{figure}
We construct type contexts out of assertions using the following rules:
\begin{mathpar}
\infer
		{}
		{\textit{Env}(\alpha : C) = \alpha : C,\ \emptyset}
		\and
\infer
		{}
		{\textit{Env}(A_1\ \wedge\ A_2) = \textit{Env}(A_1) \cup \textit{Env}(A_2)}
\end{mathpar}
Fig. \ref{f:sat-proof} gives proof rules for assertion satisfaction.
Fig. \ref{f:intrnl} gives proof rules for whether an expression is ``internal'', that is whether the footprint of an expression 
is composed of internal objects.
Fig. \ref{f:asrt-encap} gives proof rules for whether an assertion is encapsulated, that is whether 
a change in satisfaction of an assertion requires interaction with the internal module.

\begin{figure}[t]
\begin{mathpar}
\infer
		{}
		{M,\ \Gamma\ \vdash\ \intrnl{i}}
		\and
\infer
		{}
		{M,\ \Gamma\ \vdash\ \intrnl{\nul}}
		\and
\infer
		{}
		{M,\ \Gamma\ \vdash\ \intrnl{\true}}
		\and
\infer
		{}
		{M,\ \Gamma\ \vdash\ \intrnl{\false}}
		\and
\infer
		{
		\alpha : C\ \in\ \Gamma\\
		C \in M
		}
		{
		M,\ \Gamma\ \vdash \intrnl{\alpha}
		}
		\and
\infer
		{
		M,\ \Gamma\ \vdash \intrnl{e} \\
		M,\ \Gamma\ \vdash e : C\\
		[\texttt{field}\ \_\ f\ :\ D]\ \in\ M(C).(\texttt{flds}) \\
		D\ \in\ M
		}
		{
		M,\ \Gamma\ \vdash \intrnl{e.f}
		}
		\and
\infer
		{
		M,\ \Gamma\ \vdash\ \intrnl{e_1}\\
		M,\ \Gamma\ \vdash\ \intrnl{e_2}\\
		M,\ \Gamma\ \vdash\ \intrnl{e} \\
		M,\ \Gamma\ \vdash\ e_1 : C \\
		\texttt{ghost}\ \texttt{intrnl}\ g(x)\{e\} \in M(C).(\texttt{gflds})
		}
		{
		M,\ \Gamma\ \vdash \intrnl{e_1.g(e_2)}
		}
\end{mathpar}
\caption{Internal Proof Rules}
\label{f:intrnl}
\end{figure}

\begin{figure}[t]
\begin{mathpar}
\infer
		{M,\ \Gamma\ \vdash\ \intrnl{e}}
		{M,\ \Gamma\ \vdash\ \encaps{e}}
		\and
\infer
		{M,\ \Gamma\ \vdash\ \intrnl{e}}
		{M,\ \Gamma\ \vdash\ \encaps{e.f}}
		\and
\infer
		{
		M,\ \Gamma\ \vdash\ \encaps{e_1} \\
		M,\ \Gamma\ \vdash\ \encaps{e_2}
		}
		{
		M,\ \Gamma\ \vdash\ \encaps{e_1 = e_2}
		}
		\and
\infer
		{
		M,\ \Gamma\ \vdash\ \encaps{e_1} \\
		M,\ \Gamma\ \vdash\ \encaps{e_2}
		}
		{
		M,\ \Gamma\ \vdash\ \encaps{e_1 + e_2}
		}
		\and
\infer
		{
		M,\ \Gamma\ \vdash\ \encaps{e} \\
		M,\ \Gamma\ \vdash\ \encaps{e_1} \\
		M,\ \Gamma\ \vdash\ \encaps{e_2}
		}
		{
		M,\ \Gamma\ \vdash\ \encaps{\texttt{if}\ e\ \texttt{then}\ e_1\ \texttt{else}\ e_2}
		}
		\and
\infer
		{M,\ \Gamma\ \vdash\ \internal{\alpha_1}}
		{M,\ \Gamma\ \vdash\ \encaps{\access{\alpha_1}{\alpha_2}}}
		\and
\infer
		{M,\ \Gamma\ \vdash\ \forall x.[\internal{x}\ \vee\ \neg\access{x}{\alpha_2}]}
		{M,\ \Gamma\ \vdash\ \encaps{\neg\access{\alpha_1}{\alpha_2}}}
\end{mathpar}
\caption{Assertion Encapsulation Proof Rules}
\label{f:asrt-encap}
\end{figure}


\subsection{Module-Level Holistic Guarantees from Classical Specifications}
\label{s:classical-proof}
Classical specification languages are very useful, 
and have a long history in specifying the behavior 
of known programs. Holistic specifications on the 
other hand allow us to specify all possible programs, 
including potentially unknown code. In order to do this
we assume that known, internal module code is specified
using some classical specification language. In this Section
we raise classical specifications to prove holistic guarantees
for internal module code.

We do not define a new assertion language and Hoare logic
as this is a field that has seen much work. We rely on this 
prior work, and assume some underlying specification language
that makes use of common features of existing specification 
languages. Notably the syntax in Fig. \ref{f:chainmail-syntax}
contains assertion forms that are not present in common 
specification languages. For this purpose we define a subset 
of $A$, $P$ in Fig. \ref{f:classical-syntax}, that consists only 
of syntactic forms commonly found in classical specification 
languages.
\begin{figure}[t]
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}
We assume that there is some classical specification
inference system exists that allows us to prove 
specifications of the form
$$M\ \vdash\ \hoare{P}{\texttt{res} = \alpha.m(\overline{v})}{Q}$$
That is we assume we are able to prove for some method $m$
defined in module $M$, the execution of $\alpha.m(\overline{v})$
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \texttt{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces the first of the proof 
rules for Single-Step Only If.
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
%	M,\ \textit{Env}(A) \vdash\ \encaps{e}\\
	M\ \vdash\ \hoare
						{\alpha : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\texttt{res} = \alpha.m(\overline{v})}
						{\neg P_2}
	}
	{
	M\ \vdash\ \onlyIfSingle
			{P_1\ \wedge\ \alpha : C \wedge\ \calls{\_}{\alpha}{m}{\overline{v}}}
			{P_2}
			{P}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	M\ \vdash\ \hoare
						{\alpha : C \ \wedge\ \neg P}
						{\texttt{res} = \alpha.m(\overline{v})}
						{\texttt{res} \neq \alpha'}
	}
	{M\ \vdash\ \onlyIfSingle{\wrapped{\alpha'}\ \wedge\ \alpha : C \wedge\ \calls{\_}{\alpha}{m}{\overline{v}}}{\neg \wrapped{\alpha'}}{P}}
	\quad(\textsc{If1-Wrapped})
	\and
\infer
	{
	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall i\ \in\ 1\ \ldots\ n,\ k\ \in\ 1 \ldots j,\ m_1\ \ldots\ m_j\ \in\ C_i,
				M\ \vdash\ \onlyIfSingle
								{A_1\ \wedge\ \alpha : C_i\ \wedge\ \calls{\_}{\alpha}{m_k}{\overline{\alpha}}}
								{A_2}
								{A_3}\\
	M\ \vdash\ A_1\ \longrightarrow\ \neg A_2\\
	M,\ \textit{Env}(A_1)\ \vdash\ \encaps{A_2}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
\end{mathpar}
\caption{Deriving Per-Method Holistic Guarantees for Known Module Code}
\label{f:classical->singlestep}
\end{figure}

\textsc{If1-Encaps} states that if we are able to prove that $P$ is 
a necessary precondition to method $m$ to go from a state where 
$P_1$ is true to a state where $P_2$ is true, then we can raise 
that to say that for a single step of execution where that method 
is called we can go from $P_1$ to $P_2$ only if $P$ was initially true.

\textsc{If1-Wrapped} raises a classical proof about necessary preconditions 
for leaking of data by a single internal method to a the more general form of 
Single-Step Only If.

Finally, \textsc{If1-Internal} provides a more general proof step that says
if a proof of a classical specification can be proven for all internal 
methods, and that classical specification requires internally encapsulated
data, then we can construct a more general proof that does not rely on
statements about specific method calls.

%\subsection{Holistic Guarantees from Traditional Specifications}

%While our inference system provides a way to construct proofs of
%Holistic specifications, these proofs ultimately need to consider
%how known, internal code behaves. For this reason we lean on prior work 
%on traditional specifications to provide crucial guarantees 
%about known code. To this end we introduce the notation $\hoare{A_1}{M}{A_2}$ to
%mean that every method definition in every class in $M$
%has the pre-condition $A_1$ and post-conditions $A_2$. Formally 
%we have:
%\begin{definition}[Holistic Guarantees]
%\label{def:hoareMdl}
%For all assertions $A$ and $A'$ and modules $M$, we have
%$\vDash\hoare{A}{M}{A'}$ if and only if
%for all external modules $M$ and program configurations $\sigma$ and $\sigma'$ such that
%\begin{itemize}
%\item
%$M;\ M'\ \sigma\ \leadsto\ \sigma'$ and
%\item
%$\forall \sigma_1,\ \sigma_n$ such that 
%$M\circ M'\ \sigma\ \leadsto\ \sigma_1\ \leadsto^*\ \sigma_n\ \leadsto\ \sigma'$  and $classOf(\sigma_i.(\texttt{this}), \sigma_i) \in M$ where $1 \leq i \leq n$ and
%\item
%$M;\ M'\ \sigma\ \vDash\ A$
%\end{itemize}
%then 
%$M;\ M'\ \sigma'\ \vDash\ A'$
%% all classes 
%%$C\ \in\ M$, method definitions $\texttt{method}\ m(\overline{x})\{ s \}\ \in\ M(C).(\texttt{mths})$, 
%%then for any internal method call $y.m(\overline{v})$, if $A_1$ is true before $y.m(\overline{v})$, $A_2$ will 
%%be true after.
%\end{definition}
%Being able to prove statements of the form $\vdash\hoare{A}{M}{A'}$ allows us 
%to rephrase necessary conditions as $\vdash\hoare{A\ \wedge\ \neg A'}{M}{A}$.
%This states that internal module code only allows a change in satisfaction of $A$
%in the case where $A'$ was true immediately prior to the call to internal module code.
%
%Before we can prove such assertions, we first 
%note that assertions $A$ and $A'$ in Def. \ref{def:hoareMdl} are holistic, 
%and are not typically expressible by traditional specification languages.
%Ideally we would like to lean on prior Hoare logics in order to avoid
%straying too far from the topic of this paper.
%To this end we note that only the \Chainmail assertions of the form
%$\access{x}{y}$, $\internal{x}$, $\external{y}$, and $\calls{x}{y}{m}{\overline{z}}$
%are not featured in traditional modern specification techniques.
%We further note that we are generally only concerned with
%how module code modifies the heap over time, specifically 
%we are concerned with modifications of the following two forms:
%\begin{itemize}
%\item
%\emph{Mutation}: which module internal methods mutate which field values
%\item
%\emph{Leaking}: which module internal methods leak encapsulated data
%\end{itemize}
%Proving specifications about specific forms of \emph{Mutation} and \emph{Leaking} 
%using a traditional specification language is much more tractable
%than encoding proofs of general holistic specifications. Simple guarantees about mutation
%can be expressed largely using expressions, i.e assertions that 
%are already present in many specification languages. Simple guarantees 
%about encapsulation can be derived from slightly more sophisticated 
%reasoning, but still using the tools present in many specification languages.
%
%\begin{figure}
%\[
%\begin{syntax}
%\syntaxElement{\mathcal{T}}{}
%		{
%		\syntaxline
%				{\hoare{e_1\ \wedge\ \neg P}{M}{e_2}}
%%		\endsyntaxline
%%		}
%%		{
%%		\syntaxline
%				{\hoare{\wrapped{\alpha}\ \wedge\ \neg P}{M}{\wrapped{\alpha}}}
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\syntaxElement{P}{}
%		{
%		\syntaxline
%				{\alpha_1 : C\ \wedge\ \calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \wedge\ e}
%				{P\ \vee\ P}
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\end{syntax}
%\]
%\caption{Restricted \Chainmail Specifications}
%\label{f:traditional-to-holistic}
%\end{figure}
%
%For simplicity we start by defining a \Chainmail predicate \texttt{wrapped}:
%$$\wrapped{\alpha}\ \equiv\ \forall x.[\internal{x}\ \vee\ \neg \access{x}{\alpha}]$$
%In Fig. \ref{f:traditional-to-holistic}, we introduce a narrower syntactic 
%form of \Chainmail assertions that can be expressed using only using 
%traditional specification languages. It is not immediately obvious how 
%specifications of the form $\mathcal{T}$ can be expressed in a traditional
%manner, as they include non-traditional holistic specification forms $\wrapped{\alpha}$,
%and $\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}$.
%
%\paragraph{Wrapped as a Traditional Specification}
%Consider the specification 
%$$\hoare{\wrapped{\alpha}\ \wedge\ \neg P}{M}{\wrapped{\alpha}}$$
%$\wrapped{\alpha}$ may only be used in a restricted manner, i.e. at the top 
%level of the specification. That is that if access to $\alpha$ is restricted 
%to only internal objects before entry to internal module code, 
%then it is similarly restricted after if $\neg P$ is true. We now note that 
%access to an object $\alpha$ may only be granted by internal code in one of four ways
%\begin{enumerate}
%\item
%Writing $\alpha$ to some field
%\item
%A method call where $\alpha$ is passed as an argument
%\item
%A constructor call where $\alpha$ is passed as an argument
%\item
%Returning $\alpha$ as a method return
%\end{enumerate}
%Considering each case, 
%it is easy to see that the only possible method that 
%internal code may use to expose $\alpha$ is as a method
%return from some internal method.
%\begin{enumerate}
%\item
%The semantics of \Loo prohibit internal code 
%writing to the field of an external object.
%\item
%We prohibit external method calls from internal code.
%\item
%We prohibit external constructor calls from internal code.
%\end{enumerate}
%Most traditional specification languages include the ability 
%to write specifications about returned values of methods, and 
%thus we can rewrite $\hoare{\wrapped{\alpha}\ \wedge\ \neg P}{M}{\wrapped{\alpha}}$
%as $\hoare{\neg P}{M}{\texttt{ret}\ \neq\ \alpha}$, assuming we can find an appropriate 
%way to express $P$.
%
%
%\paragraph{Calls as a Traditional Specification}
%The only remaining aspect of $\mathcal{T}$ that needs be
%expressed using traditional means is $\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}$.
%Again, we first look at the restricted shape of $P$, specifically that
%$\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}$ forms part a program condition
%under which the core property we are concerned with 
%(either \emph{field mutation} or \emph{data leaking})
%may occur. Further, the $\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}$
%only occurs once in an assertion constructed out of a
%conjunction with some expression. Thus, to capture \emph{calls}
%we differ the specifications for each possible method call in an
%internal module. 
%
%We provide some proof rules for a 
%restricted version of the semantics in 
%Def. \ref{def:hoareMdl} in Fig. \ref{f:hoareMdlProof}.
%\begin{figure}
%\begin{mathpar}
%\infer
%	{
%	\forall \alpha,\ m,\ \overline{v},\ e', P = \ldots\ \vee\ \alpha : C \wedge \calls{\_}{\alpha}{m}{\overline{v}}\ \wedge\ e'\ \vee\ \ldots\ \Rightarrow\ C\ \in\ M\ \textit{and}\ \\\\ 
%	\vdash\hoare{e_1 \wedge \neg e'}{\alpha.m(\overline{v})}{e_2}\ \textit{and}\ \\\\
%	\vdash\hoare{e_1 \wedge e'}{\alpha.m(\overline{v})}{\neg e_2}\
%	}
%	{\vdash\hoare{e_1\ \wedge\ \neg P}{M}{e_2}}
%	\and
%\infer
%	{
%	\forall \alpha,\ m,\ \overline{v},\ e', P = \ldots\ \vee\ \alpha : C \wedge \calls{\_}{\alpha}{m}{\overline{v}}\ \wedge\ e'\ \vee\ \ldots\ \Rightarrow\ C\ \in\ M\ \textit{and}\ \\\\ 
%	\vdash\hoare{\neg e'}{\alpha.m(\overline{v})}{\texttt{ret} \neq \alpha}
%	}
%	{\vdash\hoare{\wrapped{\alpha}\ \wedge\ \neg P}{M}{\wrapped{\alpha}}}
%\end{mathpar}
%\caption{Proof Rules for Restricted Holistic Guarantees}
%\label{f:hoareMdlProof}
%\end{figure}




%We start by defining several judgments
%\begin{definition}[Chainmail Satisfaction]
%For all modules $M$ and $M'$, program configuration $\sigma$,
%and \Chainmail assertion $A$,
%$$M;\ M',\ \sigma\ \vdash\ A$$ 
%if and only if satisfaction of $A$ is provable in $\sigma$ with internal module $M$ and external module $M'$.
%\end{definition}
%It is often useful to refer to \Chainmail properties that hold for all
%possible program configurations and external modules given some internal module. For 
%this purpose we provide the following definition:
%\begin{definition}[Chainmail Module Satisfaction]
%For all modules $M$ and \Chainmail assertions $A$,
%$M\ \vdash\ A$ holds
%iff for all external modules $M'$ and program configurations $\sigma$ we have
%$M; M,\ \sigma \vdash\ A$
%\end{definition}
%
%Since the core of Chainmail's
%reasoning is about the boundary between known, traditionally specified code,
%and unknown, unspecified, and potentially malicious code, we first 
%present a mechanism for reasoning about changes to program state
%due to internal computation. For this we define a form of specification
%for internal computation:
%\begin{definition}[Internal Necessary Conditions]
%For all modules $M$ and \Chainmail assertions $A_1$, $A_2$, and $A$, we say $\oiInternal{A_1}{A_2}{M}{A}$ iff
%for all possible method calls $\calls{x}{y}{m}{args}$ on $M$, we are able to prove 
%$M\ \vdash\ \hoare{A_1\ \wedge\ \neg A}{y.m(args)}{\neg A_2}$
%\end{definition}
%Informally we express this as $A$ is a necessary precondition to reach $A_2$ from $A_1$ 
%through a single internal method call. 
%From this we define a core proof rule for constructing proofs in Chainmail.
%\begin{mathpar}
%\infer
%		{
%		\oiInternal{A}{\neg A}{M}{A'}\\\\
%		M;\ M',\ \sigma\ \vdash\ \changes{\I}{A}
%		}
%		{
%		M;\ M',\ \sigma\ \vdash\ A'
%		}
%		\quad(\textsc{Changes-Int})
%\end{mathpar}
%That is, if $A'$ is a necessary precondition to changing $A$, and
%we know that the internal module $M$ changes $A$, with external module $M'$, and program configuration $\sigma$, then we can conclude
%that $A'$ is true.
%
%In Fig. \ref{f:chainmail_proof_rules} we provide some more proof rules for 
%Chainmail that largely provide reasoning about topological encapsulation and 
%changing of program state. 

%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \calls{x}{y}{m}{\ldots}}
%		{
%		M;\ M',\ \sigma\ \vdash\ \access{x}{y}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \calls{x}{y}{m}{\ldots,z,\ldots}}
%		{
%		M;\ M',\ \sigma\ \vdash\ \access{x}{z}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \calls{x}{y}{m}{\ldots}}
%		{
%		M;\ M',\ \sigma\ \vdash\ (\internal{x}\ \wedge\ \external{y})\ \vee\ (\external{x}\ \wedge\ \internal{y})
%		}
%		\quad(\textsc{Calls-Ext/Int})
%		\and
%\infer
%		{
%		M;\ M',\ \sigma\ \vdash\ \calls{x}{y}{m}{\ldots} \\
%		M;\ M',\ \sigma\ \vdash\ \external{x}
%		}
%		{
%		M;\ M',\ \sigma\ \vdash\ x = \texttt{this}
%		}
%		\quad(\textsc{Calls-}\texttt{this})
%		\and
%\infer
%		{
%		M;\ M',\ \sigma\ \vdash\ \exists y.[A]\\
%		\textit{fresh}(x)
%		}
%		{M;\ M',\ \sigma\ \vdash\ [x/y]A}
%		\quad(\textsc{Exists})
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \changes{\_}{A}}
%		{M;\ M',\ \sigma\ \vdash\ A}
%		\quad(\textsc{Changes}\longrightarrow)
%		\and
%\infer
%		{
%		M\;\ M',\ \sigma \vdash\ \changes{\_}{\encapsulates{B}{I}}
%		}
%		{M;\ M',\ \sigma\ \vdash\ \changes{X_B}{\encapsulates{B}{I}}}
%		\quad(\textsc{Changes-Encap})
%		\and
%\infer
%		{}
%		{M;\ M',\ \sigma\ \vdash\ \neg\encapsulated{\texttt{this}}}
%		\quad(\textsc{Encap}-\texttt{this})
%		\and
%\infer
%		{
%		M;\ M',\ \sigma\ \vdash\ \encapsulates{B}{x} \\
%		M;\ M',\ \sigma\ \vdash\ \access{y}{x}
%		}
%		{M;\ M',\ \sigma\ \vdash\ y \in B\ \vee\ \encapsulates{B}{y}}
%		\quad(\textsc{Encap-Access})
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \encapsulates{B}{I}}
%		{M;\ M',\ \sigma\ \vdash\ \encapsulates{B \cup S}{I}}
%		\quad(\textsc{Encap}-\cup)
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ x \in B}
%		{M;\ M',\ \sigma\ \vdash\ \encapsulates{B}{x.f}}
%		\quad(\textsc{Encap-f}_1)
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \encapsulates{B}{x}}
%		{M;\ M',\ \sigma\ \vdash\ \encapsulates{B}{x.f}}
%		\quad(\textsc{Encap-f}_2)
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \changes{\_}{\encapsulated{x.f}}\ \wedge\ \internal{x}}
%		{M;\ M',\ \sigma\ \vdash\ \texttt{false}}
%		\quad(\textsc{Change-Encap-Int-f})
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \changes{\_}{\encapsulated{x.f}}\ \wedge\ \external{x}}
%		{M;\ M',\ \sigma\ \vdash\ \changes{\I}{\encapsulated{x}}}
%		\quad(\textsc{Change-Encap-Ext-f}_1)
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ \changes{\I}{\encapsulated{x}}\ \wedge\ \external{x}}
%		{M;\ M',\ \sigma\ \vdash\ \changes{\I}{\encapsulated{x.f}}}
%		\quad(\textsc{Change-Encap-Ext-f}_2)
%%		\and
%%\infer
%%		{
%%		M\ \vdash\ \encapsulates{B}{y}\\
%%		M\ \vdash\ \changes{\_}{\neg\access{x}{y}}\ \longrightarrow\ \changes{\_}{A}
%%		}
%%		{
%%		M\ \vdash\ \bencapsulates{B}{A}
%%		}
%%		\quad(\textsc{Encap-Read}_1)
%%		\and
%%\infer
%%		{
%%		M\ \vdash\ \bencapsulates{B}{y}\\
%%		M\ \vdash\ \changes{\_}{\neg\access{x}{y}}\ \longrightarrow\ \changes{\_}{A}
%%		}
%%		{
%%		M\ \vdash\ \encapsulates{B}{A}
%%		}
%%		\quad(\textsc{Encap-Read}_2)
%%		\and
%%\infer
%%		{
%%		M\ \vdash\ \encapsulates{B}{x.f}\\
%%		M\ \vdash\ \changes{\_}{x.f = y}\ \longrightarrow\ \changes{\_}{A}
%%		}
%%		{
%%		M\ \vdash\ \bencapsulates{B}{A}
%%		}
%%		\quad(\textsc{Encap-Write}_1)
%%		\and
%%\infer
%%		{
%%		M\ \vdash\ \bencapsulates{B}{x.f}\\
%%		M\ \vdash\ \changes{\_}{x.f = y}\ \longrightarrow\ \changes{\_}{A}
%%		}
%%		{
%%		M\ \vdash\ \encapsulates{B}{A}
%%		}
%%		\quad(\textsc{Encap-Write}_2)
%%		\and
%%\infer
%%		{}
%%		{
%%		M\ \vdash\ 
%%			\changes {\_}{x.f = y}\ \wedge\ 
%%			\encapsulates{S}{x.f} \longrightarrow\ \\\\
%%			\exists\ S.[\changes{S}{x.f = y}\ \wedge\ \forall\ z.[z \not\in S\ \vee\ \internal{z}]]
%%		}
%%		\quad(\textsc{Int-Mut})
%%		\and
%%\infer
%%		{
%%		A_\texttt{encap} = \encapsulates{S_1}{S_2}\\
%%		S_C = \{x\ |\ x : C\}
%%		}
%%		{M\ \vdash\ A_\texttt{encap}\ \wedge\ x\ \in\ S_2\ \wedge \changes {\_}{x.f = y}\ \longrightarrow\ \\\\ 
%%		\exists\ z,\ C.[z\ :\ C\ \wedge\ z\ \in\ S_1\ \wedge\ \changes{S_C}{x.f = y}]}
%%		\quad(\textsc{Mut})
%%		\and
%%\infer
%%		{
%%		A_\texttt{encap} = \encapsulates{S_1}{S_2}\\
%%		S_C = \{x\ |\ x : C\}
%%		}
%%		{
%%		M\ \vdash\ A_\texttt{encap}\ \wedge\ y\ \in\ S_2\ \wedge\ x\ \not\in\ S_1\ \cup\ S_2\ \vee\ \changes {\_}{\access{x}{y}} \longrightarrow\ \\\\
%%		\exists\ x',\ z,\ C.[x'\ \not\in\ S_1\ \cup\ S_2\ \wedge\ z : C\ \wedge\ z\ \in\ S_1\ \wedge\ \changes{S_C}{\access {x'}{z}}]
%%		}
%%		\quad(\textsc{Gives})
%\end{mathpar}
%\caption{Chainmail Consequence Proof Rules}
%\label{f:chainmail_proof_rules}
%\end{figure}

\subsection{Single-Step Necessary Conditions}
\label{s:singleStep-proof}

\subsection{Holistic Specifications for Emergent Behavior}
\label{s:emergent-proof}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{M\ \vdash\ \onlyIfSingle{A}{\neg A}{A'}}
	{
	M\ \vdash\ \onlyThrough{A}{\neg A}{A'}
	}
	\quad(\textsc{Changes})
%	\and
%\infer
%	{}
%	{
%	M\ \vdash\ \onlyThrough{\bencapsulates{B}{A}}{\changes{\_}{A}}{\changes{X_B}{A}\ \vee\ \changes{X_B}{\bencapsulates{B}{A}}}
%	}
%	\quad(\textsc{Encap})
%	\and
%\infer
%	{
%	A = \encapsulates{B}{y}
%	}
%	{
%	M\ \vdash\ \onlyThrough{A}{\changes{\_}{\neg\access{x}{y}}}{A \wedge\ (\changes{X_B}{\neg\access{x}{y}}\ \vee\ \changes{X_B}{A})}
%	}
%	\quad(\textsc{Encap-Read})
%	\and
%\infer
%	{
%	A = \encapsulates{B}{x.f}
%	}
%	{
%	M\ \vdash\ \onlyThrough{A}{\changes{\_}{x.f=y}}{A \wedge\ (\changes{X_B}{x.f=y}\ \vee\ \changes{X_B}{A})}
%	}
%	\quad(\textsc{Encap-Write})
%	\and
%\infer
%	{
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{\exists x.[A_3]}\\
%	y\ \not\in A_1,\ A_2,\ A_3
%	}
%	{
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{[y/x]A_3}
%	}
%	\quad(\exists_3)
	\and
\infer
	{
	M\ \vdash\ A_1\ \longrightarrow\ A_1'\\
	M\ \vdash\ A_2\ \longrightarrow\ A_2'\\
	M\ \vdash\ A_3'\ \longrightarrow\ A_3\\
	M\ \vdash\ \onlyThrough{A_1'}{A_2'}{A_3'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyThrough{A_1'}{A_2}{A'}
	}
	{M\ \vdash\ \onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyThrough{A_1}{A_2'}{A'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A'}{\texttt{false}} \\\\
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \vee\ A'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A'}{\texttt{false}} \\\\
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \vee\ A'}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3} \\\\
	M\ \vdash\ \onlyThrough{A_1}{A_3}{A}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3} \\\\
	M\ \vdash\ \onlyThrough{A_3}{A_2}{A}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A}}
	\quad(\textsc{If})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{\neg A_1}{\false}
	}
	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A_1}}
	\quad(\textsc{Invariant})
%	\and
%\infer
%	{
%	M,\ A_1\ \vdash\ \alpha : C
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ \alpha : C}}
%	\quad(\textsc{Class-Inv})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only_through}
\footnotesize
\begin{mathpar}
\infer
	{}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A_1}}
	\quad(\textsc{If-Start})
	\and
\infer
	{
	M\ \vdash\ A_1\ \longrightarrow\ A_1'\\
	M\ \vdash\ A_2\ \longrightarrow\ A_2'\\
	M\ \vdash\ A_3'\ \longrightarrow\ A_3\\
	M\ \vdash\ \onlyIf{A_1'}{A_2'}{A_3'}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A_3}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyIf{A_1'}{A_2}{A'}
	}
	{M\ \vdash\ \onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyIf{A_1}{A_2'}{A'}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A\ \vee\ A'} \\\\
	M\ \vdash\ \onlyThrough{A'}{A_2}{\texttt{false}}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	M\ \vdash\ \onlyIf{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A'}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A\ \wedge\ A'}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_3} \\
	M\ \vdash\ \onlyIf{A_1}{A_3}{A}
	}
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
	\quad(\textsc{If-Trans)}
%	\and
%\infer
%	{
%	M\ \vdash\ \onlyThrough{A_1}{A_2}{A_2}
%	}
%	{M\ \vdash\ \onlyIf{A_1}{A_2}{A_2}}
%	\quad(\textsc{If-Ind)}
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only_if}
\end{figure}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{M\ \vdash\ \onlyIf{A_1}{A_2}{A}}
	{M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	M\ \vdash\ A_1 \longrightarrow A_1'\\
	M\ \vdash\ A_2 \longrightarrow A_2'\\
	M\ \vdash\ A_3' \longrightarrow A_3\\
	M\ \vdash\ \onlyIfSingle{A_1'}{A_2'}{A_3'}
	}
	{M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyIfSingle{A_1'}{A_2}{A'}
	}
	{M\ \vdash\ \onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A} \\\\
	M\ \vdash\ \onlyIfSingle{A_1}{A_2'}{A'}
	}
	{M\ \vdash\ \onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A\ \vee\ A'} \\\\
	M\ \vdash\ \onlyThrough{A_1}{A'}{\texttt{false}}
	}
	{M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A}}
	\quad(\textsc{If1-$\vee$E})
\end{mathpar}
\caption{\emph{Only If Single Step}}
\label{f:only-if-single}
\end{figure}

\begin{figure}[t]
\begin{mathpar}
\infer
		{}
		{
		M\ \vdash \calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}
		}
		\quad(\textsc{Caller-Ext})
		\and
\infer
		{}
		{
		M\ \vdash \calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}
		}
		\quad(\textsc{Calls-Recv})
		\and
\infer
		{}
		{
		M\ \vdash \calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}
		}
		\quad(\textsc{Calls-Args})
		\and
%\infer
%		{}
%		{
%		M,\ \Gamma\ \vdash\ e_1 = e_2\ \wedge\ e_2 = e_3\ \longrightarrow\ e_1 = e_3
%		}
%		\and
\infer
		{
		C\ \in\ M
		}
		{
		M\ \vdash \alpha : C\ \longrightarrow\ \internal{\alpha}
		}
		\and
\infer
		{
		(\texttt{field}\ \_\ f\ :\ D)\ \in\ M(C).(\texttt{flds})
		}
		{
		M\ \vdash e : C\ \longrightarrow\ e.f : D
		}
		\and
\infer
		{
		(\texttt{class}\ \texttt{intrnl}\ C \{\_; \_\})\ \in\ M
		}
		{
		M\ \vdash \alpha : C\ \longrightarrow\ \wrapped{\alpha}
		}
		\quad(\textsc{Intrnl-Wrapped})
		\and
\infer
		{}
		{
		M\ \vdash \false\ \longrightarrow\ A
		}
		\quad(\textsc{Absurd})
		\and
\infer
		{}
		{
		M\ \vdash A\ \vee\ \neg A
		}
		\quad(\textsc{Excluded Middle})
\end{mathpar}
\caption{Assertion Satisfaction Proof Rules}
\label{f:sat-proof}
\end{figure}