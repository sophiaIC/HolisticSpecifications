\section{Proving Necessity}
\label{s:inference}

In this Section we provide \jm[changed from ``an inference'']{a proof} system for constructing 
proofs of the \Nec specifications defined in \S \ref{s:holistic-guarantees}.
\sophiaPonder[dropped" Section \ref{s:approach} provides a high level outline ..."]{}
%for how proofs of
%\Nec specifications are constructed. The outline in Section \ref{s:approach} 
%was top down, from proofs of emergent behaviour, down to proofs of which functions
%are required to modify program state. This Section describes the same reasoning in detail, 
%however it takes a bottom up approach to avoid referring to concepts before they are defined.}
%%The inference system for proving a \NecessitySpecification consists of several steps:
%Proving a specification requires several steps, from the following four
%categories:
%\begin{description} 
%\item
%Proving Assertion Encapsulation (\S \ref{s:encaps-proof})
%\item
%Proving \Nec specifications from classical specifications for \jm[]{a single} internal method (\S \ref{s:classical-proof})
%\item
%Proving module-wide \jm[]{Single-Step} \Nec specifications by combining per-method \Nec specifications (\S \ref{s:module-proof})
%\item
%Raising necessary conditions to construct proofs of emergent behaviour (\S \ref{s:emergent-proof})
%\end{description}
\sd{As discussed in \S \ref{s:approach},} 
\sophiaPonder[used to say "proving a specification requires four steps:" but they are not steps]{four concerns
are involved in the proof of \Nec specifications:}
\begin{description} 
\item[(Part 1)]
Proving Assertion Encapsulation (\S \ref{s:encaps-proof})
\item[(Part 2)]
Proving Per-Method \Nec specifications from \funcSpecs for a single internal method (\S \ref{s:classical-proof})
\item[(Part 3)]
Proving \jm[]{Per-Step} \Nec specifications by combining per-method \Nec specifications (\S \ref{s:module-proof})
\item[(Part 4)]
Raising necessary conditions to construct proofs of emergent behaviour (\S \ref{s:emergent-proof})
\end{description}

\subsection {Assertion Encapsulation}
\label{s:encaps-proof}
%
%In Section \ref{s:outline} we needed to prove that an assertion
%was encapsulated within a module while showing adherence to \Nec specifications.
\jm[]{
A key component of constructing program wide \Nec proofs 
is identifying properties that require internal (and thus known)
computation to be invalidated. 
\jm[]{We refer to this property as \emph{Assertion Encapsulation}.}
}
    \Nec is parametric over the details of the encapsulation
    model \cite{TAME2003}:  appendix~\ref{s:encap-proof} and
    Figure~\ref{f:asrt-encap}  present a 
    rudimentary system that is sufficient to support our example
    proof.  The key judgement we rely  upon is \textit{assertion
      encapsulation} that describes whether an assertion is
    encapsulated within a module. 


\subsubsection{Assertion Encapsulation Semantics}

%%% WHY THE FUCK IS A' the subject and A the aux assertion???

Assertion encapsulation models the informal notion that if an
assertion $A'$ is encapsulated by module $M$, then the validity of that
assertion can only be changed via that module. In \Loo, that means by
calls to objects defined in $M$ but that are accessible from the
outside.
%
We provide an intensional defintion: $A'$ is encapsulated if whenever
we go from state $\sigma$ to $\sigma'$, and when the value of $A'$
changes (i.e.\ to $\neg A'$) then we must have called a method on one
of $M$'s internal objects.
%
In fact we rely on a slightly more subtle underlying definition,
``conditional'' encapsulation where 
$M\ \vDash A\ \Rightarrow\ \encaps{A'}$ expresses that in states which satisfy $A$, the assertion 
$A'$ cannot be invalidated, unless a method from $M$ was called.


\begin{definition}[Assertion Encapsulation]
\label{def:encapsulation}
An assertion $A'$ is \emph{encapsulated} by module $M$ and assertion $A$, written as\ \  $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, \ \ if and only if
for all external modules $M'$, and all states $\sigma$, $\sigma'$
such that $\arising{M'}{M}{\sigma}$:

\begin{tabular}{lr}
$\;\;\;\;$- $\reduction{M'}{M}{\sigma}{\sigma'}$  & \rdelim\}{3}{4mm}[$\;\;\;\Rightarrow\;\;\;$  $\exists x,\ m,\ \overline{z}. (\ \satisfiesA{M}{\sigma}{\calls{\_}{x}{m}{\overline{z}} \wedge\ \internal{x}}\ )$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{\neg A'}$ \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A \wedge  A'}$ \\
\end{tabular} 
\end{definition}


\noindent
This definition   uses adaptation 
${\sigma' \triangleleft \sigma}$
because we have to interpret one assertion in two different states.
Revisiting the examples from \S~\ref{s:outline}, % we can see
both \ModB and \ModC encapsulate the \prg{balance} of an
account, because any change \sd{to it} requires calling a method on an internal object.
%
\\
\strut \hspace{1cm}
$\ModB\ \vDash \prg{a}:\prg{Account}\ \Rightarrow\ \encaps{\prg{a.balance}=\prg{bal}}$
\\
\strut \hspace{1cm}
$\ModC\ \vDash \prg{a}:\prg{Account}\ \Rightarrow\ \encaps{\prg{a.balance}=\prg{bal}}$

%\susan[Does this help the story move on? I would omit it]{
%Note that encapsulation of an assertion does not imply encapsulation of its negation; 
%for example $\wrapped{o}$ is encapsulated, but $\neg  \wrapped{o}$ is not.}

\sophiaPonder[from rebuttal]{Put differently, a piece of code that does not contain 
calls to a certain module is guaranteed not to invalidate any assertions encapsulated by that module.
 Assertion encapsulation has been used in proof systems to solve the \susan[]{frame} problem
 \cite{objInvars,encaps}.}

\subsubsection{Proving Assertion Encapsulation}

%As we have already stated at the beginning of this section,
%encapsulation is a deep topic that is well studied in the literature, 
%and is not the focus of this paper. For now, we simply assume the existence 
%of a proof system for encapsulation as it is secondary to the central topic 
%of this paper. We need only assert that such an algorithmic proof system 
%must be sound (Definition \ref{lem:encap-soundness}).
%% \susan[I commented out what was there as I thought it was repetious]
%% {We are assuming the existence of a proof system for encapsulation and only need to assert that such an algorithmic proof system nust be sound.}
%% The construction of the algorithmic system is not central to our work,
%% because, as we shall see in later sections, our logic 
%% does not rely on the specifics of an encapsulation algorithm, only its soundness.

Our logic does not rely on the specifics of the encapsulation
  model, but only its soundness:

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgment of the form $\proves{M}{\givenA{A}{\encaps{A}}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A_1$ and $A_2$, if 
$\proves{M}{\givenA{A_1}{\encaps{A_2}}}$ then $\satisfies{M}{\givenA{A_1}{\encaps{A_2}}}$.
\end{definition}

\noindent 
The key consequence of soundness is that an object inside a
  module ($\wrapped{o}$) 
  will always be encapsulated, in the sense that it can only leak out
  of the module via an internal call.

%% % For the purposes of the examples presented later in the paper, 
%% \jm[]{For the purposes of proving examples, we define a rudimentary system for proving encapsulation in Appendix \ref{s:encap-proof}, Figure \ref{f:asrt-encap}.}
%% \jm[]{This encapsulation system is sound but not complete,
%% and is based, in part, on the footprint of expressions, and 
%% the fact that the evaluation of expressions containing no external objects
%% cannot change from state to state, except as a result of internal computation.
%% The encapsulation system also includes several rules for proving 
%% the encapsulation of assertions containing \susan[do you want permission?]{
%% access}, 
%% most importantly

%\jm[]{We use that proof system for the proofs in Section \ref{s:examples}, but, as
%we said, the exact nature of that system is of little importance to this work. }



\subsubsection{Types}
\label{types}

To allow for an easy way to judge encapsulation of
assertions, we assume a very simple type system, where field, method arguments
and method results are annotated with classes, and the type system checks 
that field assignments, method calls, and method returns adhere to these expectations.
Because the type system is so simple, we do not include its specification in the paper.
Note however, that the type system has one further implication: modules are typed 
in isolation, thereby implicitly prohibiting
method calls from internal objects to external objects. 

Based on this type system, we define a predicate $\intrnl{e}$, in Appendix \ref{s:encap-proof},
which asserts that any object reads during the evaluation of $e$ are internal.
Thus, any assertion that only involves $\intrnl{\_}$ expressions is encapsulated, more in Appendix \ref{s:encap-proof}.

Finally, a further small addition to the type system 
assists the knowledge that an object is \inside: Classes may
be annotated as \enclosed. A \enclosed object  
cannot be accessed by external objects; that is, it is always \inside. 
The type system needs to ensure that objects of \enclosed type
are never returned from method bodies, this is even simpler than in \cite{confined}. 
Again, we omit the detailed description of this
simple type system.

\subsection{Per-Method \Nec Specifications}
\label{s:classical-proof}
In this section we detail how we use \funcSpecs
to \jm[]{prove} per-method \Nec specifications. 
That is, for some method $m$ in class $C$, we construct a specifications of the form:
$$\onlyIfSingle{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\ldots}}{A_2}{A}$$
Thus, $A$ is a necessary precondition to reaching $A_2$ from $A_1$ via a method call $m$ to an object of class $C$.
%In order to do this
\jm[]{Our first breakthrough observation (\S \ref{intro:this:work})
is that if} a precondition and a certain statement is \emph{sufficient}
to achieve a particular result, then the negation of that precondition
is \emph{necessary} to achieve the negation of the result after executing that statment.
Specifically, 
using \jm[]{a} classical Hoare \jm[]{triple}, if $\hoare{P}{s}{Q}$ is true, then 
it follows that $\neg P$ is a \emph{necessary precondition} for $\neg Q$ to 
hold following the execution of $\prg{s}$.

We do not define a new assertion language and Hoare logic.
 Rather, we rely on prior work on such Hoare logics,
  and assume some underlying logic that can be used 
to prove  \emph{classical assertions}. 
Classical assertions are a subset of \SpecO, comprising only those 
assertions that are commonly present in other specification languages.
We provide this subset in Definition \ref{f:classical-syntax}. That is, classical assertions
are restricted to expressions, class assertions, the usual connectives, negation, 
implication, and the usual quantifiers.


\begin{definition}
%\begin{figure}[tbp]
% \footnotesize
Classical assertions, $P$, $Q$, are defined as follows 

\[
\begin{syntax}
\syntaxElement{P, Q} {} % {Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{P\ \longrightarrow\ P}
				{\neg P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
% \caption{Classical Assertion Syntax}
\label{f:classical-syntax}
% \end{figure}
\end{definition}


We assume that there exists some \funcSpec
\jm[changed from ``inference'']{proof} system  that allows us to prove 
specifications of the form  $M\ \vdash\ \hoare{P}{\prg{s}}{Q}$. 
This implies that we can also have guarantees of  
$$M\ \vdash\ \hoare{P}{\prg{res} = x.m(\overline{z})}{Q}$$
That is,   % if we assume we are able to prove for some method $m$
% defined in module $M$,
 the execution of $x.m(\overline{z})$ 
with the precondition $P$ results in a program state that 
satisfies postcondition $Q$, where the returned value is represented
by \prg{res} in $Q$.

\jm[]{
Proofs of per-method specifications are captured by the two rules in 
Figure \ref{f:classical->singlestep}. \textsc{If1-Classical} and \textsc{If1-Inside}
raise \funcSpecs to \Nec specifications.
These are rules whose conclusion have the form Single-Step Only If.}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\prg{res} \neq y}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{y}\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}{\neg \wrapped{y}}{P}}
	}
	\quad(\textsc{If1-Inside})
\end{mathpar}
\caption{Per-Method \Nec specifications}
\label{f:classical->singlestep}
\end{figure}

 

 \textsc{If1-Classical} states that  
\jm[]{if by some classical logic, the execution of $x.m(\overline{z})$, with precondition $P \wedge \neg P_1$,
has a resulting state satisfying postcondition $\neg P_2$, then $P_1$ is a \emph{necessary} precondition to the 
resulting state satisfying $P_2$.}

\jm[I removed the old bit that was here because I felt we had already explained this several times before.]{}
% any state which satisfies $P_1$ and $\neg P$ and executes  the method $m$ on an \jm[typo]{object} of class $C$, leads to a state that satisfies $\neg P_2$, then, any state which satisfies $P_1$ and calls $m$ on an object of class $C$ will lead to a state that satisfies $P_2$ only if the original state also satisfied $P$.
%We can explain this also as follows: If the triple $.. \vdash \{R_1 \wedge R2\}\ s\ \{Q\}$ holds, then any state that satisfies $R_1$ and which upon execution of \prg{s} leads to a state that satisfies $\neg Q$, cannot satisfy $R_2$ -- because  if it did, then the ensuing state would have to satisfy $Q$,
 


 
\textsc{If1-Inside} states that a method which does not return an object $y$ 
preserves the ``insidedness'' of $y$. 
In more detail,  \textsc{If1-Inside} states that if $P$ is
a necessary precondition for returning an object $y$, then 
it follows that $P$ is a necessary precondition \jm[]{for a call $x.m(\overline{z}$) to 
result in an external object gaining access to} $y$.
\jm[]{At first glance this rule might seem unsound, however the restriction on 
external calls ensures soundness of this rule.}
\jm[]{There are only four ways
an object $x$ might gain access to another object $y$: 
(1) $y$ is created by $x$ as the result of a \prg{new} expression, 
(2) $y$ is written to some field of $x$, 
(3) $y$ is passed to $x$ as an argument to a method call on $x$,
or (4) $y$ is returned to $x$ as the result of a method call from an object $z$ that has access to $y$.}
\jm[]{The rules in Fig. \ref{f:classical->singlestep} are only concerned with 
effects on program state resulting from a method call to some internal object, and thus (1) and (2) need not be considered as 
neither object creation or field writes may result in an external object gaining access from an internal object.
Since we are only concerned with describing how internal objects grant access to external objects,
our restriction on external method calls within internal code prohibits (3) from occuring. Finally,
(4) is described by \textsc{If1-Inside}.}
In further work we plan to weaken \jm[]{the restriction on external method calls}, and will  
strengthen this rule.
\jm[]{Note that}\textsc{If1-Inside}  is essentially  a specialized version of \textsc{If1-Classical}
for the $\wrapped{\_}$ predicate. Since $\wrapped{\_}$ is not a classical
assertion, we cannot use \jm[]{\funcSpecs} to reason about necessary conditions
for invalidating $\wrapped{\_}$.
 
 
 

\subsection{Per-Step \Nec Specifications}
\label{s:module-proof}

\begin{figure}[thb]
\footnotesize
\begin{mathpar}
\infer
	{
	\textit{for all}\ \ C \in dom(M)\ \ \textit{and}\ \  m \in M(C).\prg{mths}, \ \ \ \
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\overline{z}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
	\and
%\infer
%	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
%	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
%	\quad(\textsc{If1-If})
%	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
%\infer
%	{
%	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\
%	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
%	}
%	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
%	\quad(\textsc{If1-$\vee$I$_1$})
%	\and
%\infer
%	{
%	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\
%	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
%	}
%	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
%	\quad(\textsc{If1-$\vee$I$_2$})
%	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
	\and
%\infer
%	{
%	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
%	\proves{M}{\onlyIfSingle{A_1}{A_2}{A'}}
%	}
%	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
%	\quad(\textsc{If1-$\wedge$I})
%	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyIfSingle{([y / x]A_1)}{A_2}{A}}
	}
	{\proves{M}{\onlyIfSingle{\exists x. [A_1]}{A_2}{A}}}
	\quad(\textsc{If1-$\exists_1$})
%	\and
%\infer
%	{
%	\forall y,\; \proves{M}{\onlyIfSingle{A_1}{([y / x]A_2)}{A}}
%	}
%	{\proves{M}{\onlyIfSingle{A_1}{\exists x. [A_2]}{A}}}
%	\quad(\textsc{If1-$\exists_2$})
\end{mathpar}
\caption{Selected rules for Single-Step \emph{Only If}}
\label{f:only-if-single}
\end{figure}

We now \jm[]{use our second breakthrough observation (\S \ref{intro:this:work}):}
\jm[]{if an assertion is encapsulated, and all methods within the internal module
have the same necessary pre-condition to invalidating that assertion, then 
we are able to generalize} 
per-method \Nec specifications 
to per-step \Nec specifications. 
\jm[]{We further present a set of more general rules for constructing Single Step Only If proofs.}
\jm[]{A selection of the more interesting} rules appear in Figure \ref{f:only-if-single}, 
\jm[]{while the full rule set can be found in Fig. \ref{f:app:only-if-single}}.

\textsc{If1-Internal} 
 lifts a per-method \Nec \jm[]{specifications} to a per-step \Nec specification.
Any \Nec specification which is satisfied for any method
calls sent to any object in a module, is satisfied for \emph{any step}, even
an external step, provided that the effect involved, \ie going from $A_1$ states to
$A_2$ states, is encapsulated.

 The remaining rules are more standard, and are reminiscent of the Hoare logic rule of consequence.
\jm[]{We present a few of the more interesting rules here}:
 
The  rule for implication (\textsc{If1-$\longrightarrow$}) may strengthen
 properties of either the starting or ending state, or 
weaken the necessary precondition. 

%There are two disjunction introduction rules: 
%(a) \textsc{If1-$\vee$I1} states that any execution
%starting from a state satisfying some disjunction that reaches some future state, 
%must pass through either a necessary 
%intermediate state for the first branch, or a necessary 
%intermediate state for the second branch.
%(b) \textsc{If1-$\vee$I2} states that any execution 
%starting from some state and ending in a state satisfying a disjunction
%must pass through either a necessary intermediate state for 
%the first branch, or a necessary intermediate state for the second branch.


The disjunction
elimination rule (\textsc{IF1-$\vee$E}), 
is of note, as it mirrors typical disjunction elimination
rules, with a variation stating that if it is not possible  to reach 
the end state from one branch of the disjunction, then we can eliminate 
that branch. 

Two rules support existential elimination on the left hand side. \jm[]{We present one here.}
\textsc{If1-$\exists_1$} states that if any single step of execution starting
from a state satisfying $[y/x]A_1$ for all possible $y$, reaching some state satisfying
$A_2$ has $A$ as a necessary precondition, it follows that any single step execution
starting in a state where such a $y$ exists, and ending in a state satisfying $A_2$,
must have $A$ as a necessary precondition.

\jm[]{The full set of proof rules for \emph{Single Step Only If} can be found in Fig. \ref{f:app:only-if-single}.}

%Note that given the rule for implication, there is \jm[removed: no]{a} need 
%for conjunction introduction (\textsc{IF1-$\wedge$I}), but a rule 
%for conjunction elimination is derivable from the rule for implication. 

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
	\and
\infer
	{}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_2}}}
	\quad(\textsc{End})
\end{mathpar}
\caption{\scd{Selected rules for} \emph{Only Through} -- rest in Figure \ref{app:f:only-through-full}}
\label{f:only-through}
\end{figure}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
	\and
\infer
	{}
	{\proves{M}{\onlyIf{x\ :\ C}{\neg\ x\ :\ C}{\false}}}
	\quad(\textsc{If-Class})
	\and	
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
\end{mathpar}
\caption{\scd{Selected rules for} \emph{Only If} -- the rest in Figure \ref{app:f:only-if-full}}
\label{f:only-if}
\end{figure}





%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
\subsection{Emergent \Nec Specifications}
\label{s:emergent-proof}

We \jm[]{present our third breakthrough (\S \ref{intro:this:work}):} 
per-step \Nec specifications \jm[]{are} raised to 
multiple step \Nec specifications, allowing the specification
of emergent behaviour. Figure \ref{f:only-through} \jm[typo]{presents} some of the rules for the 
construction of proofs for \emph{Only Through}, while Figure \ref{f:only-if}
provides some of the rules for the construction of proofs of \emph{Only If}. 
The full rules can be found in Appendix \ref{a:necSpec}, and are not presented here 
in full so as not to repeat rules from Figure \ref{f:only-if-single}.

%The rules for both of these relations are fairly similar to each other, 
%and to those of the single step \Nec specification from 
%section \ref{s:module-proof}. 
%Both relations include 
%rules for implication along with disjunction introduction and elimination.
%%
%While Fig. \ref{f:only-if} includes a rule for conjunction introduction (\textsc{If-$\wedge$I}),
%such a rule is not possible for \emph{only through}, as unlike \emph{only if}, where
%the necessary condition must hold, specifically, in the starting state, 
%there is no such specific moment in time in which the necessary condition 
%for \emph{only through} must hold. 
%Both relations also include rules for existentials on the left hand side ($\exists_1$, $\exists_2$, \textsc{If-$\exists_1$}, and \textsc{If-$\exists_2$}) \jm[]{(Appendix \ref{a:necSpec})}.
%These rules follow the corresponding \textsc{If1-$\exists_1$} and \textsc{If1-$\exists_2$}.

\emph{Only Through} has several notable rules. \textsc{Changes}, in Figure \ref{f:only-through}, 
states that if the satisfaction of some assertion changes over time, 
then there must be some specific intermediate state where that change occurred.
 \textsc{Changes} is an important rule in the logic, and is an enabler for
 % in allowing for 
 proofs of 
emergent properties. It is this rule that ultimately connects program 
execution to encapsulated properties.

It may seem natural that \textsc{Changes} should take the more
general form:
$$\infer{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}$$
This would not be sound as a 
transition from a state satisfying one assertion to one satisfying another assertion  is not required to occur in a single step;
however this is true for a change in satisfaction for a specific assertion (\ie $A$ to $\neg A$).


\emph{Only Through} also includes two transitivity rules (\textsc{Trans}$_1$ and \textsc{Trans}$_2$)
that say that necessary conditions to reach intermediate states or 
proceed from intermediate states are themselves necessary intermediate states. 

Finally, \emph{Only Through} includes \textsc{End}, stating that the ending condition is 
a necessary intermediate condition.

Moreover, any \emph{Only If} specification entails the corresponding
 \emph{Only Through} specification (\textsc{If}).
\emph{Only If} also includes a transitivity rule (\textsc{If-Trans}), but 
since the necessary condition must be true in the beginning state,
there is only a single rule. \textsc{If-Class} captures the invariant that 
an object's class never changes.
Finally, any starting condition is
itself a necessary precondition (\textsc{If-Start}). 



\subsection{Soundness of the \Nec Logic}

\label{s:soundness}

\begin{theorem}[Soundness]
\label{thm:soundness}
Assuming a sound \SpecO proof system, $\proves{M}{A}$, and
a sound encapsulation inference system, $\proves{M}{\givenA{A}{\encaps{A'}}}$,
 and  and that on top of these systems we built
 the \Nec logic according to the rules in Figures \ref{f:classical->singlestep},  and \ref{f:only-if-single}, and \ref{f:only-if},  and \ref{f:only-through},   then, for    all modules $M$, and all \Nec specifications  $S$:
 
 $$\proves{M}{S}\ \ \ \ \ \ \ \mbox{implies}\ \ \ \ \ \  \ \ \ \satisfies{M}{S}$$
\end{theorem}

\begin{proof}
by induction on the derivation of $\proves{M}{S}$.
\end{proof}
%\jm[]{The proof of soundness (Theorem. \ref{thm:soundness}) proves
%that our proof system for \Nec adheres to the semantics of \Nec specifications.
%We make two assumptions for soundness: (1) a sound proof system for assertion encapsulation, 
%and (2) a sound proof system for \SpecO. It is notable that \Nec is parametric with both 
%of these judgments.}

Theorem. \ref{thm:soundness} demonstrates 
 that the   \Nec logic is sound with respect to the semantics of \Nec specifications.
 The \Nec logic parametric wrt to the algorithms for proving validity of assertions
 $\proves{M}{A}$, and 
 assertion encapsulation ($\proves{M}{\givenA{A}{\encaps{A'}}}$), and is sound
 provided that these two proof systems are sound.


% and the 
%The  two assumptions for soundness: (1) a sound proof system for assertion encapsulation, 
% and (2) a sound proof system for \SpecO. It is notable that \Nec is parametric with both 
%%of these judgments.

% We have mechanized
The mechanized  the proof of Theorem \ref{thm:soundness} in Coq 
can be found in the associated artifact. 
The   Coq formalism deviates slightly from the system as
presented here,  mostly in the formalization of the 
\SpecO language. The Coq version of \SpecO restricts variable usage to expressions, and allows only addresses to 
be used as part of non-expression syntax. 
For example, in the Coq formalism
we can write assertions like $x.f==\prg{this}$ and
$x==\alpha_y$ and  $\access{\alpha_x}{\alpha_y}$, but we cannot write assertions 
like $\access{x}{y}$, where $x$ and $y$ are variables, and $\alpha_x$ and $\alpha_y$ are
addresses.
The reason for this restriction in the Coq formalism is to avoid spending % sizable 
significant effort encoding variable
renaming and substitution, a well-known difficulty for languages such as Coq. 
% This is justifiable, as we are still 
This restriction does not affect the expressiveness of %assertions in the
our  Coq formalism: we are
able to express assertions such as $\access{x}{y}$, by using addresses and introducing equality expressions % as part of expressions 
to connect variables to address, \ie
 $\access{\alpha_x}{\alpha_y} \wedge \alpha_x == x \wedge \alpha_y == y$.



