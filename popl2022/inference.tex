
\section{Proving Necessity}  
\label{s:inference}

In this Section we provide an inference system for constructing 
proofs of the Necessity Specifications defined in Section \ref{s:holistic-guarantees}.
%The inference system for proving a Necessity Specification consists of several steps:
\sd{Proving}   Necessity Specifications requires several steps, \sd{from the} following four
categories:
\begin{enumerate} 
\item
\sd{Proving Assertion Encapsulation} (Section \ref{s:encaps-proof})
\item
Proving Necessity Specifications from classical specifications for a particular internal method (Section \ref{s:classical-proof})
\item
Proving module-wide Necessity Specifications by combining per-method Necessity Specifications (Section \ref{s:module-proof})
\item
Raising necessary conditions to construct proofs of emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}

\subsection{Assertion Encapsulation}
\label{s:encaps-proof}

\sd{As   already stated in section 2, the first step in proving adherence to Necessity Specifications
is to prove that an assertion is encapsulated.}
And as also  already stated, we assume the existence of  
an inference system for constructing proofs of assertion encapsulation, 
written $\proves{M}{\givenA{A_1}{\encaps{A_2}}}$.
\sd{Such an algorithmic system should be sound, in the sense  defined below:}

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgment of the form $\proves{M}{\givenA{A}{\encaps{A}}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A_1$ and $A_2$, if 
$\proves{M}{\givenA{A_1}{\encaps{A_2}}}$ then $\satisfies{M}{\givenA{A_1}{\encaps{A_2}}}$.
\end{definition}


\sd{The construction of such an algorithmic system is not central to our work,
because, as we shall see in later sections, } the Logic of Necessity\sophia[do we still have the term "logic of necessity|]{} 
does not rely on the specifics of any one encapsulation system, only its soundness.

% For the purposes of the examples presented later in the paper, 
\sd{A rudimentary such inference system for encapsulations
can be defined on top of a simple type system, while 
more powerful inference systems are also possible.} 
In the appendix we define such a system where \sd{internal classes
may be annotated as \prg{enclosed}, and any path that starts at an internal object and
only navigates through \prg{enclosed} fields is encapsulated.} 
We will use that inference system for the proofs in Section \ref{s:examples}, but, as
we said, the exact nature of that system is of little importance to this work.\sophia[remove the last  para and the lemma from the end of section 3.4]{}

\begin{figure}[tbp]
\footnotesize
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{P\ \longrightarrow\ P}
				{\neg P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}

\subsection{Per-Method Necessity Specifications from Classical Specifications}
\label{s:classical-proof}
In this section we detail how we use Classical Specifications
to construct per-method Necessity Specifications. In order to do this
note that if a precondition \sd{and a certain statement} is \emph{sufficient}
to achieve a particular result, then the negation of that precondition
is \emph{necessary} to achieve the negation of the result \sd{after executing that statment.} 
Specifically, 
using classical Hoare logic, if $\hoare{P}{\sd{s}}{Q}$ is true, then 
it follows that $\neg P$ is a \emph{necessary precondition} for $\neg Q$ to 
hold following the execution of $\prg{s}$.

We do not define a new assertion language and Hoare logic
  this is a field that has seen much work, and any contribution we would provide 
would be uninteresting. Rather, we rely on this 
prior work, and assume some underlying logic that can be used 
to prove \sd{\emph{classical assertions}}, i.e. a limited subset of \SpecO, comprising only those 
assertions that are commonly present in other specification languages.
We provide this subset in Fig. \ref{f:chainmail-syntax}. That is, classical assertions
are restricted to expressions, class assertions, the usual connectives, negation, 
implication, and the usual quantifiers.


We assume that there exists some classical specification
inference system  that allows us to prove 
specifications of the form  $M\ \vdash\ \hoare{P}{\prg{s}}{Q}$. 
\sd{This implies that we can also have proofs of}
$$M\ \vdash\ \hoare{P}{\prg{res} = x.m(\overline{z})}{Q}$$
That is,   % if we assume we are able to prove for some method $m$
% defined in module $M$,
 the execution of $x.m(\overline{z})$ 
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \prg{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces % the first of the proof 
\sd{proof rules to infer per-method Necessary Specifications}.
\sd{These are rules whose conclusion have the  Single-Step Only If form.}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\prg{res} \neq y}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{y}\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}{\neg \wrapped{y}}{P}}
	}
	\quad(\textsc{If1-Wrapped})
\end{mathpar}
\caption{Deriving Per-Method Necessity Specifications for Known Module Code}
\label{f:classical->singlestep}
\end{figure}


\sophia[In general, the rules do not say that if we are to prove XX Xthen we can prove YY; they say that XXX implies YY; so, please avoid saying "prove"]{}

\sd{\textsc{If1-Classical} states that  
if any state which satifies $P_1$ and $\neg P$ and executes  the method $m$ on an obejct of class $C$, leads to a state that satisfies $\neg P_2$, then, any state which satisfies $P_1$ and calls $m$ on an object of class $C$ will lead to a state that satisfies $P_2$ only if the original state also satisfied $P$.
We can explain this also as follows: If the triple $.. \vdash \{R_1 \wedge R2\}\ s\ \{Q\}$ holds, then any state that satisfies $R_1$ and which upon execution of \prg{s} leads to a state that satisfies $\neg Q$, cannot satisfy $R_2$ -- because  if it did, then the ensuing state would have to satisfy $Q$,
}




 \textsc{If1-Encaps} states that if we are able to prove that $P$ is 
a necessary precondition to method $m$ to go from a state where 
$P_1$ is true to a state where $P_2$ is true, then we can raise 
that to say that for a single step of execution where that method 
is called we can go from $P_1$ to $P_2$ only if $P$ was initially true.]\sophia[ where is rule textsc{If1-Encaps}]{}

\susan[We don't say what wrapped means]{}

\sophia[\textsc{If1-Wrapped} raises a classical proof about necessary preconditions 
for leaking of data by a single internal method to a the more general form of 
Single-Step Only If.]{Add explanations as for previous}

\sophia[can we pat ourselves in back here? This section is the achievement we we grappling with for months]{}

\subsection{Necessity Specifications for Any Single Step}
\label{s:module-proof}

We now raise per-method Necessity Specifications 
to per-step Necessity Specifications. \textsc{If1-Internal} provides a more general proof step that says
if a proof of a Classical Specification can be proven for all internal 
methods, and that the Classical Specification requires internally encapsulated
data, then we can construct a more general proof that does not rely on
statements about specific method calls.


Once we are able to derive proofs of more general Necessity Specifications, 
we can further extend these rules to allow for the construction of more complex 
necessary conditions. We provide such rules in Fig. \ref{f:only-if-single}. 
\jm{By the rule for implication (\textsc{If1-$\longrightarrow$}), we are able 
to strengthen properties of either the starting or ending state, or 
weaken the necessary pre-condition. There are two disjunction introduction 
rules (\textsc{If1-$\vee$I1} and \textsc{If1-$\vee$I2}). The disjunction
elimination rule is of note, it mirrors typical disjunction elimination
rules, with a variation stating that if it is not possible  to reach 
the end state from one branch of the disjunction, then we can eliminate 
that branch. Note, given the rule for implication, there is no need 
for conjunction introduction (\textsc{IF1-$\wedge$I}), but a rule 
for conjunction elimination is derivable from the rule for implication.}

\begin{figure}[b]
\footnotesize
\begin{mathpar}
\infer
	{
%	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall C \in dom(M),\ \ m \in M(C).\prg{mths},
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\overline{z}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
\end{mathpar}
\caption{Combining per-method necessary conditions to achieve module-wide necessary conditions.}
\label{f:singlestep->module}
\end{figure}


\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If1-$\wedge$I})
\end{mathpar}
\caption{\emph{Only If Single Step}}
\label{f:only-if-single}
\end{figure}


%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
\subsection{Necessity Specifications for Emergent Behavior}
\label{s:emergent-proof}

The final step is to raise per-step Necessity Specifications to 
multiple step Necessity Specifications, allowing the specification
of emergent behavior. Fig. \ref{f:only-through} allows for the 
construction of proofs for \emph{Only Through}, while Fig. \ref{f:only-if}
provides rules for the construction of proofs of \emph{Only If}. 
\jm[]{The rules for both of these relations are fairly similar to each other, 
and that of the single step necessity specification from 
section \ref{s:module-proof}. Definitions of both relations include 
rules for implication along with disjunction introduction and elimination.
While Fig. \ref{f:only-if} includes a rule for conjunction introduction (\textsc{If-$\wedge$I}),
such a rule is not possible for \emph{only through}, as unlike \emph{only if} where
the necessary condition must hold, specifically, in the starting configuration, 
there is no such specific moment in time in which the necessary condition 
for \emph{only through} must hold.
Another rule of note is \textsc{Changes}
that states that if the satisfaction of some assertion changes over time, 
then there must be some specific intermediate state where that change occurred.
It may seem natural that \textsc{Changes} should take the more
general form:
$$\infer{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}$$
This however would not be sound as in general a transition from
one state to another is not require to occur in a single step,
however this is true for a change in satisfaction for a specific assertion (i.e. $A$ to $\neg A$).
This is an important rule in the logic, and in allowing for proofs of 
emergent properties. It is this rule that ultimately connects program 
execution to encapsulated properties. 
\emph{Only through} also includes two transitivity rules (\textsc{Trans}$_1$ and \textsc{Trans}$_2$)
that say that necessary conditions to reach intermediate states or 
proceed from intermediate states are themselves intermediate states. 
Finally any proof of an \emph{only if} specification, is itself a proof
of an \emph{only through} specification (\textsc{If}).
\emph{Only if} also includes a transitivity rule (\textsc{If-Trans}), but 
since the necessary condition must be true in the beginning state,
there is only a single rule. Finally, any starting condition is
itself a necessary precondition (\textsc{If-Start}).}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyThrough{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
	\and
\infer
	{}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_2}}}
	\quad(\textsc{End})
%	\and
%\infer
%	{
%	\proves{M}{\onlyThrough{A_1}{\neg A_1}{\false}}
%	}
%	{\proves{M}{\onlyThrough{A_1}{A_2}{A_1}}}
%	\quad(\textsc{Invariant})
%	\and
%\infer
%	{
%	M,\ A_1\ \vdash\ \alpha : C
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ \alpha : C}}
%	\quad(\textsc{Class-Inv})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only-through}
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyIf{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_3}}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
	\and
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only-if}
\end{figure}


%\subsection{Reasoning About \Chainmail Specifications}
%
%\jm[should we move this section to the examples section? if it's 
%here it might look like the soundness of the logic of necessity relies on it, when we only use these rules in the examples.]{
%As we have stated at the beginning of this section, 
%we assume the existence of a logic for constructing proofs
%of the form $\proves{M}{A}$. For the purposes of the 
%examples in Section \ref{s:examples}, we state several 
%rules that under any such logic should be provable. Also, this is not relevant to soundness.}
%\jm[]
%{\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \external{x}}}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \access{x}{y}}}
%		\quad(\textsc{Caller-Recv})
%		\and
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\ldots, z_i, \ldots}\ \longrightarrow\ \access{x}{z_i}}}
%		\quad(\textsc{Caller-Args})
%		\and
%\infer
%		{C \in M}
%		{\proves{M}{x\ :\ C\ \longrightarrow\ \internal{x}}}
%		\quad(\textsc{Class-Int})
%		\and
%\infer
%		{(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})}
%		{\proves{M}{e : C\ \longrightarrow\ e.f : D}}
%		\quad(\textsc{Fld-Class})
%		\and
%\infer
%		{(\prg{class}\ \enclosed\ C \{\_; \_\})\ \in\ M}
%		{\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}}
%		\quad(\textsc{Wrapped-Int})
%		\and
%\infer
%		{}
%		{\proves{M}{\false\ \longrightarrow\ A}}
%		\quad(\textsc{Absurd})
%		\and
%\infer
%		{}
%		{\proves{M}{A\ \vee\ \neg A}}
%		\quad(\textsc{Excluded Middle})
%\end{mathpar}}

%\begin{lemma}[\textsc{Caller-Ext}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Caller-Recv}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Caller-Args}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\alpha_i$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots, \alpha_i, \ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Internal Class}]
%For all $M$, $\alpha$, and $C$, if $C\ \in\ M$, then we have $\proves{M}{\alpha\ :\ C\ \longrightarrow\ \internal{\alpha}}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Field Class}]
%For all $M$, $e$, $f$, $C$, and $D$ if $(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})$, then we have $\proves{M}{e : C\ \longrightarrow\ e.f : D}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Internal-Wrapped}]
%For all $M$, $\alpha$, and $C$, if $(\prg{class}\ \prg{intrnl}\ C \{\_; \_\})\ \in\ M$, then we have $\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Absurd}]
%For all $M$, $A$ we have $\false\ \longrightarrow\ A$
%\end{lemma}
%\begin{lemma}[\textsc{Excluded Middle}]
%For all $M$, $A$ we have $\proves{M}{A\ \vee\ \neg A}$
%\end{lemma}




%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}
%		}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{
%		C\ \in\ M
%		}
%		{
%		\proves{M}{\alpha : C\ \longrightarrow\ \internal{\alpha}}
%		}
%		\and
%\end{mathpar}
%\caption{Assertion Satisfaction Proof Rules}
%\label{f:sat-proof}
%\end{figure}

\subsection{Soundness of the Necessity Logic}
\sophia[Do we still use that term?]{}
\label{s:soundness}

\begin{theorem}[Soundness]
\sd{Assuming a sound \SpecO proof system, $\proves{M}{A}$, and
a sound encapsulation inference system, $\proves{M}{\givenA{A}{\encaps{A'}}}$,}
 and  and that on top of these systems we built
 the Necessity Logic according to the rules in Figures  \ref{f:classical->singlestep}, and 
 \ref{f:singlestep->module}, and \ref{f:only-if-single}, and \ref{f:only-if},  and \ref{f:only-through}, \\
 then for    all modules $M$, and all Necessity Specifications  $H$:
 
 $$\proves{M}{H}\ \ \ \ \ \ \ \mbox{implies}\ \ \ \ \ \  \ \ \ \satisfies{M}{H}$$
\end{theorem}

\begin{proof}
% The soundness proof of the Logic of Necessity proceeds by 
by induction on the derivation of $\proves{M}{H}$.
%The proof relies on two secondary results:
%\begin{description}
%\item - Soundness of the encapsulation relation: $\proves{M}{\givenA{A}{\encaps{A'}}}$
%\item - Soundness of \SpecO proof system: $\proves{M}{A}$
% \end{description}
\end{proof}

\kjx{CAN WE SAY A BIT MORE HERE?}
