\section{Inference System}  
\label{s:inference}

In this Section we provide an inference system for constructing 
proofs of the Necessity Specifications defined in Section \ref{s:holistic-guarantees}.
The inference system for proving Holistic Guarantees consists of several steps:
\begin{enumerate}
\item
Proving encapsulation of module data (Section \ref{s:encap-proof})
\item
Proving module level holistic guarantees of encapsulated data from classic specifications (Section \ref{s:classical-proof})
\item
Proving single step necessary conditions from module level holistic guarantees (Section \ref{s:singleStep-proof})
\item
Proving general necessary conditions for emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}

\subsection{Proving Encapsulation}
\label{s:encap-proof}

%We start by giving providing the syntax for type contexts in Fig. \ref{f:context-syntax}.
%\begin{figure}[t]
%\[
%\begin{syntax}
%\syntaxElement{\Gamma}{Type Context}
%		{
%		\syntaxline
%				{\emptyset}
%				{\alpha : C,\ \Gamma}
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\end{syntax}
%\]
%\caption{}
%\label{f:context-syntax}
%\end{figure}
%We construct type contexts out of assertions using the following rules:
%\begin{mathpar}
%\infer
%		{}
%		{\textit{Env}(\alpha : C) = \alpha : C,\ \emptyset}
%		\and
%\infer
%		{}
%		{\textit{Env}(A_1\ \wedge\ A_2) = \textit{Env}(A_1) \cup \textit{Env}(A_2)}
%\end{mathpar}
%\begin{definition}[Assertion Encapsulation]
%For all modules $M$, and assertions $A$, and $A'$ we say $M\ \vdash\ A\ \Rightarrow\ A'$ if and only if M
%\end{definition}
We provide a simple inference system for assertion encapsulation (Definition \ref{def:encapsulation}),
that is proving a change in satisfaction of an assertion depends on computation from the internal module. 
As encapsulation is not the core topic of this paper, we keep this relatively simple. As discussed before, 
we assume the existence of a simple ownership type system to ensure certain forms of encapsulation.

To assist in the definition of a proof system to proof assertion encapsulation,
we define proof rules for expressions that depend entirely on internal objects (or primitves)
for their evaluation.
\begin{definition}[Internal Expressions]
For all modules $M$, assertions $A$, and expressions $e$, 
$\satisfies{M}{\givenA{A}{\intrnl{e}}}$ if and only if for all external modules 
$M'$, heaps $\chi$, frame stacks $\psi$, and values $v$,
such that $\satisfiesA{M}{M'}{(\chi, \psi)}{A}$ and
$\eval{M \circ M'}{(\chi, \psi)}{e}{v}$
then 
$\eval{M \circ M'}{(\chi', \psi)}{e}{v}$, 
where $\chi'$ is the portion of $\chi$ internal to $M$, i.e. 
$\chi' = \{[\alpha \mapsto o]| [\alpha \mapsto o] \in \chi\ \textit{and}\ o.(\texttt{class}) \in M \}$
\end{definition}


The encapsulation proof system thus consists of two relations 
\begin{itemize}
\item
Purely internal expressions: $\proves{M}{\givenA{A}{\intrnl{e}}}$ and
\item
Assertion encapsulation: $\proves{M}{\givenA{A}{\encaps{A'}}}$
\end{itemize}

Fig. \ref{f:intrnl} gives proof rules for evaluation of an expression comprising of purely module internal objects.
Fig. \ref{f:asrt-encap} gives proof rules for whether an assertion is encapsulated, that is whether 
a change in satisfaction of an assertion requires interaction with the internal module.

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{i}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\nul}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\true}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\false}}}}
		\and
\infer
		{
		\proves{M}{A\ \longrightarrow\ \alpha : C}\\
		C\ \in\ M
		}
		{
		\proves{M}{\givenA{A}{\intrnl{\alpha}}}
		}
		\quad(\textsc{Intrnl-Obj})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\intrnl{e}}}\\
		\proves{M}{A\ \longrightarrow\ e : C}\\
		[\texttt{field}\ \_\ f\ :\ D]\ \in\ M(C).(\texttt{flds}) \\
		D\ \in\ M
		}
		{
		\proves{M}{\givenA{A}{\intrnl{e.f}}}
		}
		\quad(\textsc{Intrnl-Field})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\intrnl{e_1}}}\\
		\proves{M}{\givenA{A}{\intrnl{e_2}}}\\
%		\proves{M}{\givenA{A}{\intrnl{e}}} \\
		\proves{M}{A\ \longrightarrow\ e_1 : C} \\
		\texttt{ghost}\ \texttt{intrnl}\ g(x : \_)\{e\} \in M(C).(\texttt{gflds})
		}
		{
		\proves{M}{\givenA{A}{\intrnl{e_1.g(e_2)}}}
		}
		\quad(\textsc{Intrnl-Ghost})
\end{mathpar}
\caption{Internal Proof Rules}
\label{f:intrnl}
\end{figure}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
		{\proves{M}{\givenA{A}{\intrnl{e}}}}
		{\proves{M}{\givenA{A}{\encaps{e}}}}
		\quad(\textsc{Enc-Intrnl})
		\and
\infer
		{\proves{M}{\givenA{A}{\intrnl{e}}}}
		{\proves{M}{\givenA{A}{\encaps{e.f}}}}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 = e_2}}}
		}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 + e_2}}}
		}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 < e_2}}}
		}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e}}} \\
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{\texttt{if}\ e\ \texttt{then}\ e_1\ \texttt{else}\ e_2}}}
		}
		\and
\infer
		{\proves{M}{A\ \longrightarrow\ \internal{\alpha_1}}}
		{\proves{M}{\givenA{A}{\encaps{\access{\alpha_1}{\alpha_2}}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\encaps{\wrapped{\alpha}}}}}
		\quad(\textsc{Enc-Wrapped})
		\and
\infer
		{\proves{M}{A\ \longrightarrow\ \wrapped{\alpha_2}}}
		{\proves{M}{\givenA{A}{\encaps{\neg \access{\alpha_1}{\alpha_2}}}}}
		\and
\infer
		{
		\proves{M}{A_1\ \longrightarrow\ A_2} \\
		\proves{M}{A\ \longrightarrow\ A_1} \\
		\proves{M}{\givenA{A}{\encaps{A_1}}}
		}
		{\proves{M}{\givenA{A}{\encaps{A_2}}}}
\end{mathpar}
\caption{Assertion Encapsulation Proof Rules}
\label{f:asrt-encap}
\end{figure}

\begin{lemma}[Intrnl is Encapsulated]
For all modules $M$, assertions $A$, and expressions $e$, 
if $\proves{M}{\givenA{A}{\intrnl{e}}}$, 
then $\satisfies{M}{\givenA{A}{\encaps{e}}}$
\end{lemma}

\begin{lemma}[Encapsulation Soundness]
For all modules $M$, and assertions $A$ and $A'$, 
if $\proves{M}{\givenA{A}{\encaps{A'}}}$ then $\satisfies{M}{\givenA{A}{A'}}$
\end{lemma}
\begin{proof}asdf
\begin{case}asdf
\end{case}
\end{proof}


\subsection{Module-Level Necessity Specifications from Classical Specifications}
\label{s:classical-proof}
Classical specification languages are very useful, 
and have a long history in specifying the behavior 
of known programs. Necessity Specifications on the 
other hand allow us to specify all possible programs, 
including potentially unknown code. In order to do this
we assume that known, internal module code is specified
using some classical specification language. In this Section
we raise classical specifications to prove holistic guarantees
for internal module code.

We do not define a new assertion language and Hoare logic
as this is a field that has seen much work. We rely on this 
prior work, and assume some underlying specification language
that makes use of common features of existing specification 
languages. Notably the syntax in Fig. \ref{f:chainmail-syntax}
contains assertion forms that are not present in common 
specification languages. For this purpose we define a subset 
of $A$, $P$ in Fig. \ref{f:classical-syntax}, that consists only 
of syntactic forms commonly found in classical specification 
languages.
\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}
We assume that there is some classical specification
inference system exists that allows us to prove 
specifications of the form
$$M\ \vdash\ \hoare{P}{\texttt{res} = \alpha.m(\overline{v})}{Q}$$
That is we assume we are able to prove for some method $m$
defined in module $M$, the execution of $\alpha.m(\overline{v})$
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \texttt{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces the first of the proof 
rules for Single-Step Only If.
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
%	M,\ \textit{Env}(A) \vdash\ \encaps{e}\\
	\proves{M}{\hoare
						{\alpha : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\texttt{res} = \alpha.m(\overline{v})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ \alpha : C \wedge\ \calls{\_}{\alpha}{m}{\overline{v}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{\alpha : C \ \wedge\ \neg P}
						{\texttt{res} = \alpha.m(\overline{v})}
						{\texttt{res} \neq \alpha'}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{\alpha'}\ \wedge\ \alpha : C \wedge\ \calls{\_}{\alpha}{m}{\overline{v}}}{\neg \wrapped{\alpha'}}{P}}
	}
	\quad(\textsc{If1-Wrapped})
	\and
\infer
	{
	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall i\ \in\ 1\ \ldots\ n,\ k\ \in\ 1 \ldots j,\ m_1\ \ldots\ m_j\ \in\ C_i,
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ \alpha : C_i\ \wedge\ \calls{\_}{\alpha}{m_k}{\overline{\alpha}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
\end{mathpar}
\caption{Deriving Per-Method Holistic Guarantees for Known Module Code}
\label{f:classical->singlestep}
\end{figure}

\textsc{If1-Encaps} states that if we are able to prove that $P$ is 
a necessary precondition to method $m$ to go from a state where 
$P_1$ is true to a state where $P_2$ is true, then we can raise 
that to say that for a single step of execution where that method 
is called we can go from $P_1$ to $P_2$ only if $P$ was initially true.

\textsc{If1-Wrapped} raises a classical proof about necessary preconditions 
for leaking of data by a single internal method to a the more general form of 
Single-Step Only If.

Finally, \textsc{If1-Internal} provides a more general proof step that says
if a proof of a classical specification can be proven for all internal 
methods, and that classical specification requires internally encapsulated
data, then we can construct a more general proof that does not rely on
statements about specific method calls.

%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
%\subsection{Holistic Specifications for Emergent Behavior}
%\label{s:emergent-proof}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyThrough{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\texttt{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\texttt{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{\neg A_1}{\false}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_1}}}
	\quad(\textsc{Invariant})
%	\and
%\infer
%	{
%	M,\ A_1\ \vdash\ \alpha : C
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ \alpha : C}}
%	\quad(\textsc{Class-Inv})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only_through}
\footnotesize
\begin{mathpar}
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyIf{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_3}}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\texttt{false}}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}h} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only_if}
\end{figure}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	{\proves{M}{\vdash\ \onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A_1}{A'}{\texttt{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
\end{mathpar}
\caption{\emph{Only If Single Step}}
\label{f:only-if-single}
\end{figure}


\subsection{Helper Lemmas}

\begin{lemma}[\textsc{Caller-Ext}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}$.
\end{lemma}

\begin{lemma}[\textsc{Caller-Recv}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}$.
\end{lemma}

\begin{lemma}[\textsc{Caller-Args}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\alpha_i$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots, \alpha_i, \ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}$.
\end{lemma}

\begin{lemma}[\textsc{Internal Class}]
For all $M$, $\alpha$, and $C$, if $C\ \in\ M$, then we have $\proves{M}{\alpha\ :\ C\ \longrightarrow\ \internal{\alpha}}$
\end{lemma}

\begin{lemma}[\textsc{Field Class}]
For all $M$, $e$, $f$, $C$, and $D$ if $(\texttt{field}\ \_\ f\ :\ D)\ \in\ M(C).(\texttt{flds})$, then we have $\proves{M}{e : C\ \longrightarrow\ e.f : D}$
\end{lemma}

\begin{lemma}[\textsc{Internal-Wrapped}]
For all $M$, $\alpha$, and $C$, if $(\texttt{class}\ \texttt{intrnl}\ C \{\_; \_\})\ \in\ M$, then we have $\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}$
\end{lemma}

\begin{lemma}[\textsc{Absurd}]
For all $M$, $A$ we have $\false\ \longrightarrow\ A$
\end{lemma}
\begin{lemma}[\textsc{Excluded Middle}]
For all $M$, $A$ we have $\proves{M}{A\ \vee\ \neg A}$
\end{lemma}




%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}
%		}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{
%		C\ \in\ M
%		}
%		{
%		\proves{M}{\alpha : C\ \longrightarrow\ \internal{\alpha}}
%		}
%		\and
%\end{mathpar}
%\caption{Assertion Satisfaction Proof Rules}
%\label{f:sat-proof}
%\end{figure}

\subsection{Soundness}
\begin{theorem}[Soundness]
For all modules $M$, and necessary specifications $H$, if
$\proves{M}{H}$ then $\satisfies{M}{H}$
\end{theorem}
\begin{proof}
\end{proof}
