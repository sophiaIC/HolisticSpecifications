\section{Inference System}  
\label{s:inference}

In this Section we provide an inference system for constructing 
proofs of the necessary specifications defined in Section \ref{s:holistic-guarantees}.
The inference system for proving necessary specification consists of several steps:
\begin{enumerate}
\item
Proving necessity specifications from classical specifications for a particular internal method (Section \ref{s:classical-proof})
\item
Proving module-wide necessity specifications by combining per-method necessity specifications (Section \ref{s:module-proof})
\item
Raising necessary conditions to construct proofs of emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}


\subsection{Per-Method Necessity Specifications from Classical Specifications}
\label{s:classical-proof}
In this section we detail how we use classical specifications
to construct per-method necessary specifications. In order to do this
note that if a precondition is \emph{sufficient}
to achieve a particular result, then the negation of that precondition
is \emph{necessary} to achieve the negation of the result. Specifically, 
using classical Hoare logic, if $\hoare{P}{C}{Q}$ is true, then 
it follows that $\neg P$ is a \emph{necessary precondition} for $\neg Q$ to 
hold following the execution of $C$.

We do not define a new assertion language and Hoare logic
as this is a field that has seen much work, and any contribution we would provide 
would be uninteresting. Rather, we rely on this 
prior work, and assume some underlying logic that can be used 
to prove a limited subset of \Chainmail, comprising only those 
assertions that are commonly present in other specification languages.
We provide this subset in Fig. \ref{f:chainmail-syntax}. That is, classical assertions
are restricted to expressions, class assertions, the usual connectives, negation, 
implication, and the usual quantifiers.
\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{P\ \longrightarrow\ P}
				{\neg P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}
We assume that there is some classical specification
inference system exists that allows us to prove 
specifications of the form
$$M\ \vdash\ \hoare{P}{\prg{res} = x.m(\overline{z})}{Q}$$
That is we assume we are able to prove for some method $m$
defined in module $M$, the execution of $x.m(\overline{z})$
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \prg{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces the first of the proof 
rules for Single-Step Only If.
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\prg{res} \neq y}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{y}\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}{\neg \wrapped{y}}{P}}
	}
	\quad(\textsc{If1-Wrapped})
\end{mathpar}
\caption{Deriving Per-Method Necessary Specifications for Known Module Code}
\label{f:classical->singlestep}
\end{figure}

\textsc{If1-Encaps} states that if we are able to prove that $P$ is 
a necessary precondition to method $m$ to go from a state where 
$P_1$ is true to a state where $P_2$ is true, then we can raise 
that to say that for a single step of execution where that method 
is called we can go from $P_1$ to $P_2$ only if $P$ was initially true.

\textsc{If1-Wrapped} raises a classical proof about necessary preconditions 
for leaking of data by a single internal method to a the more general form of 
Single-Step Only If.

\subsection{Module Wide Necessary Specifications}
\label{s:module-proof}

We now raise per-method necessary specifications 
to per-step necessary specifications. \textsc{If1-Internal} provides a more general proof step that says
if a proof of a classical specification can be proven for all internal 
methods, and that classical specification requires internally encapsulated
data, then we can construct a more general proof that does not rely on
statements about specific method calls.

\begin{figure}
\footnotesize
\begin{mathpar}
\infer
	{
%	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall C \in dom(M),\ \ m \in M(C).\prg{mths},
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\overline{z}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
\end{mathpar}
\caption{Combining per-method necessary conditions to achieve module-wide necessary conditions.}
\end{figure}
Once we are able to derive proofs of more general necessity specifications, 
we can further extend these rules to allow for the construction of more complex 
necessary conditions. We provide such rules in Fig. \ref{f:only-if-single}.
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	{\proves{M}{\vdash\ \onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A_1}{A'}{\prg{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
\end{mathpar}
\caption{\emph{Only If Single Step}}
\label{f:only-if-single}
\end{figure}


%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
\subsection{Necessary Specifications for Emergent Behavior}
\label{s:emergent-proof}

The final step is to raise per-step necessary specifications to 
multiple step necessary specifications, allowing the specification
of emergent behavior. Fig. \ref{f:only-through} allows for the 
construction of rules for \emph{Only Through}, while Fig. \ref{f:only-if}
provides rules for the construction of proofs of \emph{Only If}.

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyThrough{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{\neg A_1}{\false}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_1}}}
	\quad(\textsc{Invariant})
%	\and
%\infer
%	{
%	M,\ A_1\ \vdash\ \alpha : C
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ \alpha : C}}
%	\quad(\textsc{Class-Inv})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only_through}
\footnotesize
\begin{mathpar}
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyIf{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_3}}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}h} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only_if}
\end{figure}


\subsection{Helper Lemmas}

\begin{lemma}[\textsc{Caller-Ext}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}$.
\end{lemma}

\begin{lemma}[\textsc{Caller-Recv}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}$.
\end{lemma}

\begin{lemma}[\textsc{Caller-Args}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\alpha_i$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots, \alpha_i, \ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}$.
\end{lemma}

\begin{lemma}[\textsc{Internal Class}]
For all $M$, $\alpha$, and $C$, if $C\ \in\ M$, then we have $\proves{M}{\alpha\ :\ C\ \longrightarrow\ \internal{\alpha}}$
\end{lemma}

\begin{lemma}[\textsc{Field Class}]
For all $M$, $e$, $f$, $C$, and $D$ if $(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})$, then we have $\proves{M}{e : C\ \longrightarrow\ e.f : D}$
\end{lemma}

\begin{lemma}[\textsc{Internal-Wrapped}]
For all $M$, $\alpha$, and $C$, if $(\prg{class}\ \prg{intrnl}\ C \{\_; \_\})\ \in\ M$, then we have $\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}$
\end{lemma}

\begin{lemma}[\textsc{Absurd}]
For all $M$, $A$ we have $\false\ \longrightarrow\ A$
\end{lemma}
\begin{lemma}[\textsc{Excluded Middle}]
For all $M$, $A$ we have $\proves{M}{A\ \vee\ \neg A}$
\end{lemma}




%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}
%		}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{
%		C\ \in\ M
%		}
%		{
%		\proves{M}{\alpha : C\ \longrightarrow\ \internal{\alpha}}
%		}
%		\and
%\end{mathpar}
%\caption{Assertion Satisfaction Proof Rules}
%\label{f:sat-proof}
%\end{figure}

\subsection{Soundness}
\begin{theorem}[Soundness]
For all modules $M$, and necessary specifications $H$, if
$\proves{M}{H}$ then $\satisfies{M}{H}$
\end{theorem}
\begin{proof}
\end{proof}
