\section{Proving Necessity}
\label{s:inference}

In this Section we provide an inference system for constructing 
proofs of the Necessity Specifications defined in Section \ref{s:holistic-guarantees}.
%The inference system for proving a Necessity Specification consists of several steps:
Proving Necessity Specifications requires several steps, from the following four
categories:
\begin{enumerate} 
\item
Proving Assertion Encapsulation (Section \ref{s:encaps-proof})
\item
Proving Necessity Specifications from classical specifications for a particular internal method (Section \ref{s:classical-proof})
\item
Proving module-wide Necessity Specifications by combining per-method Necessity Specifications (Section \ref{s:module-proof})
\item
Raising necessary conditions to construct proofs of emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}

\begin{figure}[tbp]
\footnotesize
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{P\ \longrightarrow\ P}
				{\neg P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}


\subsection{Assertion Encapsulation}
\label{s:encaps-proof}

As   already stated in section 2, the first step in proving adherence to Necessity Specifications
is to prove that an assertion is encapsulated. 
And as also  already stated, we assume the existence of  
an inference system for constructing proofs of assertion encapsulation, 
written $\proves{M}{\givenA{A_1}{\encaps{A_2}}}$.
Such an algorithmic system should be sound, in the sense  defined below:

\begin{definition}[Encapsulation Soundness]
\label{lem:encap-soundness}
A judgment of the form $\proves{M}{\givenA{A}{\encaps{A}}}$  is\  \emph{sound}, \ if 
for all modules $M$, and assertions $A_1$ and $A_2$, if 
$\proves{M}{\givenA{A_1}{\encaps{A_2}}}$ then $\satisfies{M}{\givenA{A_1}{\encaps{A_2}}}$.
\end{definition}


The construction of such an algorithmic system is not central to our work,
because, as we shall see in later sections,  the Logic of Necessity 
does not rely on the specifics of an encapsulation algorithm, only it's soundness.

% For the purposes of the examples presented later in the paper, 
A rudimentary such inference system for encapsulation 
can be defined on top of a simple type system, while 
more powerful inference systems are also possible. 
In the appendix we define such a system where internal classes
may be annotated as \prg{enclosed}, and any path that starts at an internal object and
only navigates through \prg{enclosed} fields is encapsulated. 
We will use that inference system for the proofs in Section \ref{s:examples}, but, as
we said, the exact nature of that system is of little importance to this work. 


\subsection{Per-Method Necessity Specifications from Classical Specifications}
\label{s:classical-proof}
In this section we detail how we use Classical Specifications
to construct per-method Necessity Specifications. 
That is, for some method $m$ in class $C$, we construct a necessity specification of the form:
$$\onlyIfSingle{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\ldots}}{A_2}{A}$$
Thus, $A$ is a necessary precondition to reaching $A_2$ from $A_1$ via a method call $m$ to an object of class $C$.
In order to do this
note that if a precondition and a certain statement is \emph{sufficient}
to achieve a particular result, then the negation of that precondition
is \emph{necessary} to achieve the negation of the result after executing that statment.
Specifically, 
using classical Hoare logic, if $\hoare{P}{s}{Q}$ is true, then 
it follows that $\neg P$ is a \emph{necessary precondition} for $\neg Q$ to 
hold following the execution of $\prg{s}$.

We do not define a new assertion language and Hoare logic.
 Rather, we rely on prior work on such Hoare logics,
  and assume some underlying logic that can be used 
to prove  \emph{classical assertions}. 
Classical assertions are a subset of \SpecO, comprising only those 
assertions that are commonly present in other specification languages.
We provide this subset in Fig. \ref{f:classical-syntax}. That is, classical assertions
are restricted to expressions, class assertions, the usual connectives, negation, 
implication, and the usual quantifiers.


We assume that there exists some classical specification
inference system  that allows us to prove 
specifications of the form  $M\ \vdash\ \hoare{P}{\prg{s}}{Q}$. 
This implies that we can also have guarantees of  
$$M\ \vdash\ \hoare{P}{\prg{res} = x.m(\overline{z})}{Q}$$
That is,   % if we assume we are able to prove for some method $m$
% defined in module $M$,
 the execution of $x.m(\overline{z})$ 
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \prg{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces  %the first of the proof 
proof rules to infer per-method Necessary Specifications.
These are rules whose conclusion have the  form Single-Step Only If. 

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\prg{res} \neq y}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{y}\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}{\neg \wrapped{y}}{P}}
	}
	\quad(\textsc{If1-Wrapped})
\end{mathpar}
\caption{Per-Method Necessity Specifications}
\label{f:classical->singlestep}
\end{figure}

 

 \textsc{If1-Classical} states that  
if any state which satisfies $P_1$ and $\neg P$ and executes  the method $m$ on an obejct of class $C$, leads to a state that satisfies $\neg P_2$, then, any state which satisfies $P_1$ and calls $m$ on an object of class $C$ will lead to a state that satisfies $P_2$ only if the original state also satisfied $P$.
We can explain this also as follows: If the triple $.. \vdash \{R_1 \wedge R2\}\ s\ \{Q\}$ holds, then any state that satisfies $R_1$ and which upon execution of \prg{s} leads to a state that satisfies $\neg Q$, cannot satisfy $R_2$ -- because  if it did, then the ensuing state would have to satisfy $Q$,
 


 
\textsc{If1-Wrapped} essentially states that a method which does not return an object $y$ 
preserves the ``wrappedness'' of that object $y$. 
This rule is sound, 
because we do not support calls from internal code to external code
-- in further work we plan to weaken this requirement, and will  
strengthen this rule.
In more detail,  \textsc{If1-Wrapped}   states that if $P$ is
a necessary precondition for returning an object $y$, then  
since we do not support calls from internal code to external code,
it follows that $P$ is a necessary precondition to leak $y$.
\textsc{If1-Wrapped}  is essentially  a specialized version of \textsc{If1-Classical}
for the $\wrapped{}$ predicate. Since $\wrapped{}$ is not a classical
assertion, we cannot use Hoare logic to reason about necessary conditions
for leaking of data.
 
 
 

\subsection{Necessity Specifications for Any Single Step}
\label{s:module-proof}

\begin{figure}[thb]
\footnotesize
\begin{mathpar}
\infer
	{
%	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall C \in dom(M).\forall m \in M(C).\prg{mths}, \ \ \
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\overline{z}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
%\end{mathpar}
%\caption{Combining per-method necessary conditions to achieve module-wide necessary conditions.}
%\label{f:singlestep->module}
%\end{figure}
%
%
%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}

\infer
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\
	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\
	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyIfSingle{([y / x]A_1)}{A_2}{A}}
	}
	{\proves{M}{\onlyIfSingle{\exists x. [A_1]}{A_2}{A}}}
	\quad(\textsc{If1-$\exists_1$})
	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyIfSingle{A_1}{([y / x]A_2)}{A}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{\exists x. [A_2]}{A}}}
	\quad(\textsc{If1-$\exists_2$})
\end{mathpar}
\caption{Single-Step Necessity Specifications, $OnlyIf\_1$}
\label{f:only-if-single}
\end{figure}

We now raise per-method Necessity Specifications 
to per-step Necessity Specifications. 
The rules appear in Fig. \ref{f:only-if-single}.

\textsc{If1-Internal} is central. It
 lifts a per-method Necessity Specification to a per-step Necessity Specification.
Essentially, any Necessity Specification which is satisfied for any method
calls sent to any object in a module, is satisfied for \emph{any step}, even
an external step, provided that the effect involved, i.e. going from $A_1$ states to
$A_2$ states, is encapsulated.

 The remaining rules are more standard, and remind of Hoare logic rule of consequence.
 We have five such rules:
 
The  rule for implication (\textsc{If1-$\longrightarrow$}) may strengthen
 properties of either the starting or ending state, or 
weaken the necessary pre-condition. 

There are two disjunction introduction rules: 
(a) \textsc{If1-$\vee$I1} states that any execution
starting from a state satisfying some disjunction and reaches some future state, 
must pass through the either a necessary 
intermediate state for the first branch, or a necessary 
intermediate state for the second branch.
(b) \textsc{If1-$\vee$I2} states that any execution 
starting from some state and ending in a state satisfying a disjunction
must pass through either a necessary intermediate state for 
the first branch, or a necessary intermediate state for the second branch.


The disjunction
elimination rule (\textsc{IF1-$\vee$E}), 
is of note, as it mirrors typical disjunction elimination
rules, with a variation stating that if it is not possible  to reach 
the end state from one branch of the disjunction, then we can eliminate 
that branch. 

There are two rules for existential elimination on the left hand side.
\textsc{If1-$\exists_1$} states that if any single step of execution starting
from a state satisfying $[y/x]A_1$ for all possible $y$, reaching some state satisfying
$A_2$ has $A$ as a necessary precondition, it follows that any single step execution
starting in a state where such a $y$ exists, and ending in a state satisfying $A_2$,
must have $A$ as a necessary precondition. \textsc{If1-$\exists_2$} is a similar rule
for an existential in the state resulting from the execution.

%Note that given the rule for implication, there is \jm[removed: no]{a} need 
%for conjunction introduction (\textsc{IF1-$\wedge$I}), but a rule 
%for conjunction elimination is derivable from the rule for implication. 

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyThrough{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
	\and
\infer
	{}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_2}}}
	\quad(\textsc{End})
	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyThrough{([y / x]A_1)}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{\exists x. [A_1]}{A_2}{A}}}
	\quad(\textsc{$\exists_1$})
	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyThrough{A_1}{([y / x]A_2)}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\exists_2$})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only-through}
\end{figure}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyIf{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_3}}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
	\and
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyIf{([y / x]A_1)}{A_2}{A}}
	}
	{\proves{M}{\onlyIf{\exists x. [A_1]}{A_2}{A}}}
	\quad(\textsc{If-$\exists_1$})
	\and
\infer
	{
	\forall y,\; \proves{M}{\onlyIf{A_1}{([y / x]A_2)}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\exists_2$})
\end{mathpar}
\caption{\emph{Only If}}
\label{f:only-if}
\end{figure}





%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
\subsection{Necessity Specifications for Emergent Behavior}
\label{s:emergent-proof}

The final step is to raise per-step Necessity Specifications to 
multiple step Necessity Specifications, allowing the specification
of emergent behavior. Fig. \ref{f:only-through} allows for the 
construction of proofs for \emph{Only Through}, while Fig. \ref{f:only-if}
provides rules for the construction of proofs of \emph{Only If}. 

The rules for both of these relations are fairly similar to each other, 
and to those of the single step necessity specification from 
section \ref{s:module-proof}. 
Both relations include 
rules for implication along with disjunction introduction and elimination.
%
While Fig. \ref{f:only-if} includes a rule for conjunction introduction (\textsc{If-$\wedge$I}),
such a rule is not possible for \emph{only through}, as unlike \emph{only if}, where
the necessary condition must hold, specifically, in the starting state, 
there is no such specific moment in time in which the necessary condition 
for \emph{only through} must hold. 
Both relations also include rules for existentials on the left hand side ($\exists_1$, $\exists_2$, \textsc{If-$\exists_1$}, and \textsc{If-$\exists_2$}).
These rules follow the corresponding \textsc{If1-$\exists_1$} and \textsc{If1-$\exists_2$}.

Another rule of note is \textsc{Changes}, in Fig. \ref{f:only-through}, 
it states that if the satisfaction of some assertion changes over time, 
then there must be some specific intermediate state where that change occurred.
 \textsc{Changes} is an important rule in the logic, and in allowing for proofs of 
emergent properties. It is this rule that ultimately connects program 
execution to encapsulated properties. 


It may seem natural that \textsc{Changes} should take the more
general form:
$$\infer{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}$$
This however would not be sound as in general a transition from
one state to another is not required to occur in a single step,
however this is true for a change in satisfaction for a specific assertion (i.e. $A$ to $\neg A$).


\emph{Only through} also includes two transitivity rules (\textsc{Trans}$_1$ and \textsc{Trans}$_2$)
that say that necessary conditions to reach intermediate states or 
proceed from intermediate states are themselves necessary intermediate states. 

Moreover, any \emph{only if} specification entails the corresponding
 \emph{only through} specification (\textsc{If}).
\emph{Only if} also includes a transitivity rule (\textsc{If-Trans}), but 
since the necessary condition must be true in the beginning state,
there is only a single rule. Finally, any starting condition is
itself a necessary precondition (\textsc{If-Start}). 



%\subsection{Reasoning About \Chainmail Specifications}
%
%\jm[should we move this section to the examples section? if it's 
%here it might look like the soundness of the logic of necessity relies on it, when we only use these rules in the examples.]{
%As we have stated at the beginning of this section, 
%we assume the existence of a logic for constructing proofs
%of the form $\proves{M}{A}$. For the purposes of the 
%examples in Section \ref{s:examples}, we state several 
%rules that under any such logic should be provable. Also, this is not relevant to soundness.}
%\jm[]
%{\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \external{x}}}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \access{x}{y}}}
%		\quad(\textsc{Caller-Recv})
%		\and
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\ldots, z_i, \ldots}\ \longrightarrow\ \access{x}{z_i}}}
%		\quad(\textsc{Caller-Args})
%		\and
%\infer
%		{C \in M}
%		{\proves{M}{x\ :\ C\ \longrightarrow\ \internal{x}}}
%		\quad(\textsc{Class-Int})
%		\and
%\infer
%		{(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})}
%		{\proves{M}{e : C\ \longrightarrow\ e.f : D}}
%		\quad(\textsc{Fld-Class})
%		\and
%\infer
%		{(\prg{class}\ \enclosed\ C \{\_; \_\})\ \in\ M}
%		{\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}}
%		\quad(\textsc{Wrapped-Int})
%		\and
%\infer
%		{}
%		{\proves{M}{\false\ \longrightarrow\ A}}
%		\quad(\textsc{Absurd})
%		\and
%\infer
%		{}
%		{\proves{M}{A\ \vee\ \neg A}}
%		\quad(\textsc{Excluded Middle})
%\end{mathpar}}

%\begin{lemma}[\textsc{Caller-Ext}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Caller-Recv}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Caller-Args}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\alpha_i$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots, \alpha_i, \ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Internal Class}]
%For all $M$, $\alpha$, and $C$, if $C\ \in\ M$, then we have $\proves{M}{\alpha\ :\ C\ \longrightarrow\ \internal{\alpha}}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Field Class}]
%For all $M$, $e$, $f$, $C$, and $D$ if $(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})$, then we have $\proves{M}{e : C\ \longrightarrow\ e.f : D}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Internal-Wrapped}]
%For all $M$, $\alpha$, and $C$, if $(\prg{class}\ \prg{intrnl}\ C \{\_; \_\})\ \in\ M$, then we have $\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Absurd}]
%For all $M$, $A$ we have $\false\ \longrightarrow\ A$
%\end{lemma}
%\begin{lemma}[\textsc{Excluded Middle}]
%For all $M$, $A$ we have $\proves{M}{A\ \vee\ \neg A}$
%\end{lemma}




%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}
%		}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{
%		C\ \in\ M
%		}
%		{
%		\proves{M}{\alpha : C\ \longrightarrow\ \internal{\alpha}}
%		}
%		\and
%\end{mathpar}
%\caption{Assertion Satisfaction Proof Rules}
%\label{f:sat-proof}
%\end{figure}

\subsection{Soundness of the Necessity Logic}

\label{s:soundness}

\begin{theorem}[Soundness]
\label{thm:soundness}
Assuming a sound \SpecO proof system, $\proves{M}{A}$, and
a sound encapsulation inference system, $\proves{M}{\givenA{A}{\encaps{A'}}}$,
 and  and that on top of these systems we built
 the Necessity Logic according to the rules in Figures  \ref{f:classical->singlestep},  and \ref{f:only-if-single}, and \ref{f:only-if},  and \ref{f:only-through},   then, for    all modules $M$, and all Necessity Specifications  $H$:
 
 $$\proves{M}{H}\ \ \ \ \ \ \ \mbox{implies}\ \ \ \ \ \  \ \ \ \satisfies{M}{H}$$
\end{theorem}

\begin{proof}
% The soundness proof of the Logic of Necessity proceeds by 
by induction on the derivation of $\proves{M}{H}$.
%The proof relies on two secondary results:
%\begin{description}
%\item - Soundness of the encapsulation relation: $\proves{M}{\givenA{A}{\encaps{A'}}}$
%\item - Soundness of \SpecO proof system: $\proves{M}{A}$
% \end{description}
\end{proof}
We have mechanized the proof of Theorem \ref{thm:soundness} in Coq. This can be found in the associated artifact. 
The mechanized Coq formalism deviates slightly from the system as
presented here,  mostly in the expression of the 
\SpecO language. The Coq version of \SpecO restricts variable usage to expressions, and allows only addresses to 
be used as part of non-expression syntax. The reason for this is to avoid spending sizable effort encoding variable
renaming and substitution, a well-known difficulty for languages such as Coq. This is justifiable, as we are still 
able to express assertions such as $\access{x}{y}$, but using addresses and introducing equality statements as part of expressions to connect
variables to address, i.e. $\access{\alpha_x}{\alpha_y} \wedge \alpha_x == x \wedge \alpha_y == y$.


%\jm[]{
%As we have already discussed, ``robust safety'' is a property commonly 
%referred to in security literature that is informally defined as ``bad stuff doesn't happen,
%even in the presence of arbitrary, hostile code''. This is very closely connected to 
%the domain of \Chainmail. An informal 
%definition of robust safety for \Chainmail, is that if a module satisfies some 
%necessity specification, then that necessity specification is adhered to by 
%the module, even when linked with some arbitrary code.
%The semantics of necessity specifications in \Chainmail implicitly considers arbitrary 
%(potentially hostile code) 
%as part of Definition \ref{def:necessity-semantics}.
%Robust safety is thus a corollary of Theorem \ref{thm:soundness}.
%This is formally expressed in Corollary \ref{cor:robust}.
%\begin{corollary}[Robust Safety]
%\label{cor:robust}
%$\bullet$ \ If $\proves{M}{\onlyIf {A_1}{A_2}{A}}$ \ \ then\ \  for any arbitrary external module $M'$, and progam states $\sigma$ and $\sigma'$, such that $\arising{M}{M'}{\sigma}$; \\
%\begin{tabular}{lr}
%$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\satisfiesA{M}{\sigma}{A}$] \\
%$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
%$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma'}$   \\
%\end{tabular}\\ 
%$\bullet$ \  $\proves{M}{\onlyIfSingle {A_1}{A_2}{A}}$\ \ iff\ \   for any arbitrary, external module $M'$, and program states $\sigma$,   $\sigma'$, such that $\arising{M}{M'}{\sigma}$: \\
%\begin{tabular}{lr}
%$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\satisfiesA{M}{\sigma}{A}$] \\
%$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
%$\;\;\;\;$- $\reduction{M}{M'}{\sigma}{\sigma'}$   \\
%\end{tabular}  \\
%$\bullet$ \  $\proves{M}{\onlyThrough {A_1}{A_2}{A}}$ \ \ iff\ \  for any arbitrary, external module $M'$, and program states $\sigma_1$,   $\sigma_n$, such that $\arising{M}{M'}{\sigma_1}$: \\
%\begin{tabular}{lr}
%$\;\;\;\;$- $\satisfiesA{M}{\sigma_1}{A_1}$  & 
%\rdelim\}{3}{3mm}%[\makecell{Some really \\ longer text}]
%[$\;\;\;\Rightarrow\;\;\;$\pbox{9cm}{$\forall \sigma_2, \ldots, \sigma_{n-1}$.  \\ 
%(\ \ $\forall i\!\in\![1..n).\ \reduction{M}{M'}{\sigma_i}{\sigma_{i+1}}$   \ $\Rightarrow$
%$\exists i\!\in\![1..n]. \  \satisfiesA{M}{\sigma_i \triangleleft \sigma_1}{A}$ \ \ )   }] \\
%$\;\;\;\;$- $\satisfiesA{M}{\sigma_n\triangleleft \sigma}{A_2}$   \\
%$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma_n}$   \\
%\end{tabular} \\ 
%\end{corollary}
%Note that Corollary \ref{cor:robust} is essentially a restatement of Definition \ref{def:necessity-semantics}
%}



%As we state above, assume the existence of a sound, algorithmic proof
%system for encapsulation and \SpecO specifications, along with the
%soundness of the Hoare logic required for the encoding of
%rules \textsc{If1-Classical} and \textsc{If1-Wrapped}.

% We further make several simplifying assumptions that allow us to avoid
% proving tedious properties about variable substitution and renaming.

