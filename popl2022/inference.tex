\section{Proving Necessity}  
\label{s:inference}

In this Section we provide an inference system for constructing 
proofs of the necessary specifications defined in Section \ref{s:holistic-guarantees}.
The inference system for proving necessary specification consists of several steps:
\begin{enumerate}
\item
Proving necessity specifications from classical specifications for a particular internal method (Section \ref{s:classical-proof})
\item
Proving module-wide necessity specifications by combining per-method necessity specifications (Section \ref{s:module-proof})
\item
Raising necessary conditions to construct proofs of emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}

\subsection{Per-Method Necessity Specifications from Classical Specifications}
\label{s:classical-proof}
In this section we detail how we use classical specifications
to construct per-method necessary specifications. In order to do this
note that if a precondition is \emph{sufficient}
to achieve a particular result, then the negation of that precondition
is \emph{necessary} to achieve the negation of the result. Specifically, 
using classical Hoare logic, if $\hoare{P}{C}{Q}$ is true, then 
it follows that $\neg P$ is a \emph{necessary precondition} for $\neg Q$ to 
hold following the execution of $C$.

We do not define a new assertion language and Hoare logic
as this is a field that has seen much work, and any contribution we would provide 
would be uninteresting. Rather, we rely on this 
prior work, and assume some underlying logic that can be used 
to prove a limited subset of \SpecO, comprising only those 
assertions that are commonly present in other specification languages.
We provide this subset in Fig. \ref{f:chainmail-syntax}. That is, classical assertions
are restricted to expressions, class assertions, the usual connectives, negation, 
implication, and the usual quantifiers.
\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{P\ \longrightarrow\ P}
				{\neg P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}
We assume that there is some classical specification
inference system exists that allows us to prove 
specifications of the form
$$M\ \vdash\ \hoare{P}{\prg{res} = x.m(\overline{z})}{Q}$$
That is we assume we are able to prove for some method $m$
defined in module $M$, the execution of $x.m(\overline{z})$
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \prg{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces the first of the proof 
rules for Single-Step Only If.
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{x : C \ \wedge\ \neg P}
						{\prg{res} = x.m(\overline{z})}
						{\prg{res} \neq y}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{y}\ \wedge\ x : C \wedge\ \calls{\_}{x}{m}{\overline{z}}}{\neg \wrapped{y}}{P}}
	}
	\quad(\textsc{If1-Wrapped})
\end{mathpar}
\caption{Deriving Per-Method Necessity Specifications for Known Module Code}
\label{f:classical->singlestep}
\end{figure}

\textsc{If1-Encaps} states that if we are able to prove that $P$ is 
a necessary precondition to method $m$ to go from a state where 
$P_1$ is true to a state where $P_2$ is true, then we can raise 
that to say that for a single step of execution where that method 
is called we can go from $P_1$ to $P_2$ only if $P$ was initially true.

\textsc{If1-Wrapped} raises a classical proof about necessary preconditions 
for leaking of data by a single internal method to a the more general form of 
Single-Step Only If.

\subsection{Necessity Specifications for Any Single Step}
\label{s:module-proof}

We now raise per-method necessity specifications 
to per-step necessity specifications. \textsc{If1-Internal} provides a more general proof step that says
if a proof of a classical specification can be proven for all internal 
methods, and that classical specification requires internally encapsulated
data, then we can construct a more general proof that does not rely on
statements about specific method calls.

\begin{figure}
\footnotesize
\begin{mathpar}
\infer
	{
%	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall C \in dom(M),\ \ m \in M(C).\prg{mths},
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ x : C\ \wedge\ \calls{\_}{x}{m}{\overline{z}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
\end{mathpar}
\caption{Combining per-method necessary conditions to achieve module-wide necessary conditions.}
\end{figure}
Once we are able to derive proofs of more general necessity specifications, 
we can further extend these rules to allow for the construction of more complex 
necessary conditions. We provide such rules in Fig. \ref{f:only-if-single}. 
\jm{By the rule for implication (\textsc{If1-$\longrightarrow$}), we are able 
to strengthen properties of either the starting or ending state, or 
weaken the necessary pre-condition. There are two disjunction introduction 
rules (\textsc{If1-$\vee$I1} and \textsc{If1-$\vee$I2}). The disjunction
elimination rule is of note, it mirrors typical disjunction elimination
rules, with a variation stating that if it is not possible  to reach 
the end state from one branch of the disjunction, then we can eliminate 
that branch. Note, given the rule for implication, there is no need 
for conjunction introduction (\textsc{IF1-$\wedge$I}), but a rule 
for conjunction elimination is derivable from the rule for implication.}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If1-$\wedge$I})
\end{mathpar}
\caption{\emph{Only If Single Step}}
\label{f:only-if-single}
\end{figure}


%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
\subsection{Necessity Specifications for Emergent Behavior}
\label{s:emergent-proof}

The final step is to raise per-step necessity specifications to 
multiple step necessity specifications, allowing the specification
of emergent behavior. Fig. \ref{f:only-through} allows for the 
construction of proofs for \emph{Only Through}, while Fig. \ref{f:only-if}
provides rules for the construction of proofs of \emph{Only If}. 
\jm[]{The rules for both of these relations are fairly similar to each other, 
and that of the single step necessity specification from 
section \ref{s:module-proof}. Definitions of both relations include 
rules for implication along with disjunction introduction and elimination.
While Fig. \ref{f:only-if} includes a rule for conjunction introduction (\textsc{If-$\wedge$I}),
such a rule is not possible for \emph{only through}, as unlike \emph{only if} where
the necessary condition must hold, specifically, in the starting configuration, 
there is no such specific moment in time in which the necessary condition 
for \emph{only through} must hold.
Another rule of note is \textsc{Changes}
that states that if the satisfaction of some assertion changes over time, 
then there must be some specific intermediate state where that change occurred.
This is an important rule in the logic, and in allowing for proofs of 
emergent properties. It is this rule that ultimately connects program 
execution to encapsulated properties. 
\emph{Only through} also includes two transitivity rules (\textsc{Trans}$_1$ and \textsc{Trans}$_2$)
that say that necessary conditions to reach intermediate states or 
proceed from intermediate states are themselves intermediate states. 
Finally any proof of an \emph{only if} specification, is itself a proof
of an \emph{only through} specification (\textsc{If}).
\emph{Only if} also includes a transitivity rule (\textsc{If-Trans}), but 
since the necessary condition must be true in the beginning state,
there is only a single rule. Finally, any starting condition is
itself a necessary precondition (\textsc{If-Start}).}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyThrough{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
%	\and
%\infer
%	{
%	\proves{M}{\onlyThrough{A_1}{\neg A_1}{\false}}
%	}
%	{\proves{M}{\onlyThrough{A_1}{A_2}{A_1}}}
%	\quad(\textsc{Invariant})
%	\and
%\infer
%	{
%	M,\ A_1\ \vdash\ \alpha : C
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ \alpha : C}}
%	\quad(\textsc{Class-Inv})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only-through}
\footnotesize
\begin{mathpar}
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyIf{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_3}}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\prg{false}}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
	\and
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only-if}
\end{figure}


%\subsection{Reasoning About \Chainmail Specifications}
%
%\jm[should we move this section to the examples section? if it's 
%here it might look like the soundness of the logic of necessity relies on it, when we only use these rules in the examples.]{
%As we have stated at the beginning of this section, 
%we assume the existence of a logic for constructing proofs
%of the form $\proves{M}{A}$. For the purposes of the 
%examples in Section \ref{s:examples}, we state several 
%rules that under any such logic should be provable. Also, this is not relevant to soundness.}
%\jm[]
%{\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \external{x}}}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \access{x}{y}}}
%		\quad(\textsc{Caller-Recv})
%		\and
%\infer
%		{}
%		{\proves{M}{\calls{x}{y}{m}{\ldots, z_i, \ldots}\ \longrightarrow\ \access{x}{z_i}}}
%		\quad(\textsc{Caller-Args})
%		\and
%\infer
%		{C \in M}
%		{\proves{M}{x\ :\ C\ \longrightarrow\ \internal{x}}}
%		\quad(\textsc{Class-Int})
%		\and
%\infer
%		{(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})}
%		{\proves{M}{e : C\ \longrightarrow\ e.f : D}}
%		\quad(\textsc{Fld-Class})
%		\and
%\infer
%		{(\prg{class}\ \enclosed\ C \{\_; \_\})\ \in\ M}
%		{\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}}
%		\quad(\textsc{Wrapped-Int})
%		\and
%\infer
%		{}
%		{\proves{M}{\false\ \longrightarrow\ A}}
%		\quad(\textsc{Absurd})
%		\and
%\infer
%		{}
%		{\proves{M}{A\ \vee\ \neg A}}
%		\quad(\textsc{Excluded Middle})
%\end{mathpar}}

%\begin{lemma}[\textsc{Caller-Ext}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Caller-Recv}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Caller-Args}]
%For all $M$, $\alpha_1$, $\alpha_2$, and $\alpha_i$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots, \alpha_i, \ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}$.
%\end{lemma}
%
%\begin{lemma}[\textsc{Internal Class}]
%For all $M$, $\alpha$, and $C$, if $C\ \in\ M$, then we have $\proves{M}{\alpha\ :\ C\ \longrightarrow\ \internal{\alpha}}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Field Class}]
%For all $M$, $e$, $f$, $C$, and $D$ if $(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})$, then we have $\proves{M}{e : C\ \longrightarrow\ e.f : D}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Internal-Wrapped}]
%For all $M$, $\alpha$, and $C$, if $(\prg{class}\ \prg{intrnl}\ C \{\_; \_\})\ \in\ M$, then we have $\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}$
%\end{lemma}
%
%\begin{lemma}[\textsc{Absurd}]
%For all $M$, $A$ we have $\false\ \longrightarrow\ A$
%\end{lemma}
%\begin{lemma}[\textsc{Excluded Middle}]
%For all $M$, $A$ we have $\proves{M}{A\ \vee\ \neg A}$
%\end{lemma}




%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}
%		}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{
%		C\ \in\ M
%		}
%		{
%		\proves{M}{\alpha : C\ \longrightarrow\ \internal{\alpha}}
%		}
%		\and
%\end{mathpar}
%\caption{Assertion Satisfaction Proof Rules}
%\label{f:sat-proof}
%\end{figure}

\subsection{Soundness}
\begin{theorem}[Soundness]
For all modules $M$, and necessity specifications $H$, if
$\proves{M}{H}$ then $\satisfies{M}{H}$
\end{theorem}
\begin{proof}
The soundness proof of the logic of necessity proceeds by 
induction on the derivation of $\proves{M}{H}$.
The proof relies on two secondary results:
\begin{description}
\item - Soundness of the encapsulation relation: $\proves{M}{\givenA{A}{\encaps{A'}}}$
\item - Soundness of \SpecO proof system: $\proves{M}{A}$
\end{description}
\end{proof}
