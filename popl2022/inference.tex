\section{Inference System}  
\label{s:inference}

In this Section we provide an inference system for constructing 
proofs of the Necessity Specifications defined in Section \ref{s:holistic-guarantees}.
The inference system for proving Holistic Guarantees consists of several steps:
\begin{enumerate}
\item
Proving encapsulation of module data (Section \ref{s:encap-proof})
\item
Proving module level holistic guarantees of encapsulated data from classic specifications (Section \ref{s:classical-proof})
\item
Proving single step necessary conditions from module level holistic guarantees (Section \ref{s:singleStep-proof})
\item
Proving general necessary conditions for emergent behavior (Section \ref{s:emergent-proof})
\end{enumerate}


\subsection{Module-Level Necessity Specifications from Classical Specifications}
\label{s:classical-proof}
Classical specification languages are very useful, 
and have a long history in specifying the behavior 
of known programs. Necessity Specifications on the 
other hand allow us to specify all possible programs, 
including potentially unknown code. In order to do this
we assume that known, internal module code is specified
using some classical specification language. In this Section
we raise classical specifications to prove holistic guarantees
for internal module code.

We do not define a new assertion language and Hoare logic
as this is a field that has seen much work. We rely on this 
prior work, and assume some underlying specification language
that makes use of common features of existing specification 
languages. Notably the syntax in Fig. \ref{f:chainmail-syntax}
contains assertion forms that are not present in common 
specification languages. For this purpose we define a subset 
of $A$, $P$ in Fig. \ref{f:classical-syntax}, that consists only 
of syntactic forms commonly found in classical specification 
languages.
\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{P, Q}{Classical Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{P\ \wedge\ P}
				{P\ \vee\ P}
				{\forall x.[P]}
				{\exists x.[P]}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Classical Assertion Syntax}
\label{f:classical-syntax}
\end{figure}
We assume that there is some classical specification
inference system exists that allows us to prove 
specifications of the form
$$M\ \vdash\ \hoare{P}{\texttt{res} = \alpha.m(\overline{v})}{Q}$$
That is we assume we are able to prove for some method $m$
defined in module $M$, the execution of $\alpha.m(\overline{v})$
with the pre-condition $P$ results in a program state that 
satisfies post-condition $Q$, where the returned value is represented
by \texttt{res} in $Q$.

Fig. \ref{f:classical->singlestep} introduces the first of the proof 
rules for Single-Step Only If.
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{
%	M,\ \textit{Env}(A) \vdash\ \encaps{e}\\
	\proves{M}{\hoare
						{\alpha : C \ \wedge\ P_1\ \wedge\ \neg P}
						{\texttt{res} = \alpha.m(\overline{v})}
						{\neg P_2}}
	}
	{
	\proves{M}{\onlyIfSingle
			{P_1\ \wedge\ \alpha : C \wedge\ \calls{\_}{\alpha}{m}{\overline{v}}}
			{P_2}
			{P}}
	}
	\quad(\textsc{If1-Classical})
	\and
\infer
	{
	\proves{M}{\hoare
						{\alpha : C \ \wedge\ \neg P}
						{\texttt{res} = \alpha.m(\overline{v})}
						{\texttt{res} \neq \alpha'}}
	}
	{
	\proves{M}{\onlyIfSingle{\wrapped{\alpha'}\ \wedge\ \alpha : C \wedge\ \calls{\_}{\alpha}{m}{\overline{v}}}{\neg \wrapped{\alpha'}}{P}}
	}
	\quad(\textsc{If1-Wrapped})
	\and
\infer
	{
	\textit{dom}(M) = \{C_1, \ldots, C_n\}\\
	\forall i\ \in\ 1\ \ldots\ n,\ k\ \in\ 1 \ldots j,\ m_1\ \ldots\ m_j\ \in\ C_i,
				\proves{M}{\onlyIfSingle
								{A_1\ \wedge\ \alpha : C_i\ \wedge\ \calls{\_}{\alpha}{m_k}{\overline{\alpha}}}
								{A_2}
								{A_3}}\\
	\proves{M}{A_1\ \longrightarrow\ \neg A_2}\\
	\proves{M}{\givenA{A_1}{\encaps{A_2}}}
	}
	{
	M\ \vdash\ \onlyIfSingle{A_1}{A_2}{A_3}
	}
	\quad(\textsc{If1-Internal})
\end{mathpar}
\caption{Deriving Per-Method Holistic Guarantees for Known Module Code}
\label{f:classical->singlestep}
\end{figure}

\textsc{If1-Encaps} states that if we are able to prove that $P$ is 
a necessary precondition to method $m$ to go from a state where 
$P_1$ is true to a state where $P_2$ is true, then we can raise 
that to say that for a single step of execution where that method 
is called we can go from $P_1$ to $P_2$ only if $P$ was initially true.

\textsc{If1-Wrapped} raises a classical proof about necessary preconditions 
for leaking of data by a single internal method to a the more general form of 
Single-Step Only If.

Finally, \textsc{If1-Internal} provides a more general proof step that says
if a proof of a classical specification can be proven for all internal 
methods, and that classical specification requires internally encapsulated
data, then we can construct a more general proof that does not rely on
statements about specific method calls.

%\subsection{Single-Step Necessary Conditions}
%\label{s:singleStep-proof}
%
%\subsection{Holistic Specifications for Emergent Behavior}
%\label{s:emergent-proof}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIfSingle{A}{\neg A}{A'}}}
	{
	\proves{M}{\onlyThrough{A}{\neg A}{A'}}
	}
	\quad(\textsc{Changes})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyThrough{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_3}}}
	\quad(\textsc{$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\texttt{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A'}{\texttt{false}}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A\ \vee\ A'}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{$\vee$E$_2$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_1$})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\\\
	\proves{M}{\onlyThrough{A_3}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{Trans$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A}}}
	\quad(\textsc{If})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{\neg A_1}{\false}}
	}
	{\proves{M}{\onlyThrough{A_1}{A_2}{A_1}}}
	\quad(\textsc{Invariant})
%	\and
%\infer
%	{
%	M,\ A_1\ \vdash\ \alpha : C
%	}
%	{M\ \vdash\ \onlyThrough{A_1}{A_2}{A\ \wedge\ \alpha : C}}
%	\quad(\textsc{Class-Inv})
\end{mathpar}
\caption{\emph{Only Through}}
\label{f:only_through}
\footnotesize
\begin{mathpar}
\infer
	{}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_1}}}
	\quad(\textsc{If-Start})
	\and
\infer
	{
	\proves{M}{A_1\ \longrightarrow\ A_1'}\\
	\proves{M}{A_2\ \longrightarrow\ A_2'}\\
	\proves{M}{A_3'\ \longrightarrow\ A_3}\\
	\proves{M}{\onlyIf{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A_3}}}
	\quad(\textsc{If-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIf{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A'}{A_2}{\texttt{false}}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-$\vee$E})
	\and
\infer
	{
	\proves{M}{\onlyIf{A_1}{A_2}{A}h} \\\\
	\proves{M}{\onlyThrough{A_1}{A_2}{A'}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A\ \wedge\ A'}}}
	\quad(\textsc{If-$\wedge$I})
	\and
\infer
	{
	\proves{M}{\onlyThrough{A_1}{A_2}{A_3}} \\
	\proves{M}{\onlyIf{A_1}{A_3}{A}}
	}
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	\quad(\textsc{If-Trans)}
\end{mathpar}
\caption{\emph{Only if}}
\label{f:only_if}
\end{figure}
\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
	{\proves{M}{\onlyIf{A_1}{A_2}{A}}}
	{\proves{M}{\vdash\ \onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-If})
	\and
\infer
	{
	\proves{M}{A_1 \longrightarrow A_1'}\\
	\proves{M}{A_2 \longrightarrow A_2'}\\
	\proves{M}{A_3' \longrightarrow A_3}\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2'}{A_3'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A_3}}}
	\quad(\textsc{If1-$\longrightarrow$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1'}{A_2}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1\ \vee\ A_1'}{A_2}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_1$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A}} \\\\
	\proves{M}{\onlyIfSingle{A_1}{A_2'}{A'}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2\ \vee\ A_2'}{A\ \vee\ A'}}}
	\quad(\textsc{If1-$\vee$I$_2$})
	\and
\infer
	{
	\proves{M}{\onlyIfSingle{A_1}{A_2}{A\ \vee\ A'}} \\\\
	\proves{M}{\onlyThrough{A_1}{A'}{\texttt{false}}}
	}
	{\proves{M}{\onlyIfSingle{A_1}{A_2}{A}}}
	\quad(\textsc{If1-$\vee$E})
\end{mathpar}
\caption{\emph{Only If Single Step}}
\label{f:only-if-single}
\end{figure}


\subsection{Helper Lemmas}

\begin{lemma}[\textsc{Caller-Ext}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}$.
\end{lemma}

\begin{lemma}[\textsc{Caller-Recv}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\overline{v}$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}$.
\end{lemma}

\begin{lemma}[\textsc{Caller-Args}]
For all $M$, $\alpha_1$, $\alpha_2$, and $\alpha_i$ we have $\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots, \alpha_i, \ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}$.
\end{lemma}

\begin{lemma}[\textsc{Internal Class}]
For all $M$, $\alpha$, and $C$, if $C\ \in\ M$, then we have $\proves{M}{\alpha\ :\ C\ \longrightarrow\ \internal{\alpha}}$
\end{lemma}

\begin{lemma}[\textsc{Field Class}]
For all $M$, $e$, $f$, $C$, and $D$ if $(\texttt{field}\ \_\ f\ :\ D)\ \in\ M(C).(\texttt{flds})$, then we have $\proves{M}{e : C\ \longrightarrow\ e.f : D}$
\end{lemma}

\begin{lemma}[\textsc{Internal-Wrapped}]
For all $M$, $\alpha$, and $C$, if $(\texttt{class}\ \texttt{intrnl}\ C \{\_; \_\})\ \in\ M$, then we have $\proves{M}{\alpha : C\ \longrightarrow\ \wrapped{\alpha}}$
\end{lemma}

\begin{lemma}[\textsc{Absurd}]
For all $M$, $A$ we have $\false\ \longrightarrow\ A$
\end{lemma}
\begin{lemma}[\textsc{Excluded Middle}]
For all $M$, $A$ we have $\proves{M}{A\ \vee\ \neg A}$
\end{lemma}




%\begin{figure}[t]
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \external{\alpha_1}}
%		}
%		\quad(\textsc{Caller-Ext})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}\ \longrightarrow\ \access{\alpha_1}{\alpha_2}}
%		}
%		\quad(\textsc{Calls-Recv})
%		\and
%\infer
%		{}
%		{
%		\proves{M}{\calls{\alpha_1}{\alpha_2}{m}{\ldots,\alpha_i,\ldots}\ \longrightarrow\ \access{\alpha_1}{\alpha_i}}
%		}
%		\quad(\textsc{Calls-Args})
%		\and
%\infer
%		{
%		C\ \in\ M
%		}
%		{
%		\proves{M}{\alpha : C\ \longrightarrow\ \internal{\alpha}}
%		}
%		\and
%\end{mathpar}
%\caption{Assertion Satisfaction Proof Rules}
%\label{f:sat-proof}
%\end{figure}

\subsection{Soundness}
\begin{theorem}[Soundness]
For all modules $M$, and necessary specifications $H$, if
$\proves{M}{H}$ then $\satisfies{M}{H}$
\end{theorem}
\begin{proof}
\end{proof}
