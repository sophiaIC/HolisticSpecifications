\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{definitions}

\newcommand{\rev}[1]{\emph #1}
\newcommand{\us}[1]{\bf #1}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{filecontents}
\begin{filecontents}{Response1.bib}
@article{Grossman,
author = {Grossman, Shelly and Abraham, Ittai and Golan-Gueta, Guy and Michalevsky, Yan and Rinetzky, Noam and Sagiv, Mooly and Zohar, Yoni},
title = {Online Detection of Effectively Callback Free Objects with Applications to Smart Contracts},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158136},
doi = {10.1145/3158136},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {48},
numpages = {28},
keywords = {Program analysis, Modular reasoning, Smart contracts}
}
@article{Albert,
author = {Albert, Elvira and Grossman, Shelly and Rinetzky, Noam and Rodr\'{\i}guez-N\'{u}\~{n}ez, Clara and Rubio, Albert and Sagiv, Mooly},
title = {Taming Callbacks for Smart Contract Modularity},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428277},
doi = {10.1145/3428277},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {209},
numpages = {30},
keywords = {blockchain, program verification, program analysis, logic and verification, smart contracts, invariants}
}

@article{Permenev,
  title={VerX: Safety Verification of Smart Contracts},
  author={Anton Permenev and Dimitar I. Dimitrov and Petar Tsankov and Dana Drachsler-Cohen and Martin T. Vechev},
  journal={2020 IEEE Symposium on Security and Privacy (SP)},
  year={2020},
  pages={1661-1677}
  }
  
  @inproceedings{Drossopoulou,
author="Drossopoulou, Sophia and Noble, James and Mackay, Julian and Eisenbach, Susan",
editor="Wehrheim, Heike and Cabot, Jordi",
title="Holistic Specifications for Robust Programs",
booktitle="Fundamental Approaches to Software Engineering",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="420--440",
}

@misc{Chlipala,
  author = "Adam Chlipala",
  title = "Certified Programming with Dependent Types",
 url = "http://adam.chlipala.net/cpdt/",
 year = 2019,
 date = "2021-12-02",
}

%@misc{Chlipala,
%  author = "Adam Chlipala",
%  title = "frap: Formal Reasoning about Programs",
% url = "https://github.com/achlipala/frap",
% year = 2019,
% date = "2021-12-02",
%}

\end{filecontents}


\usepackage{natbib}

\title{OOPSLA 2022 Round 2 Resubmission Changes}
%\author{The Author}
%\date{3 December 2021}     

\newcommand\multibrace[3]{\rdelim\}{#1}{3mm}[\pbox{#2}{#3}]}

\newcommand{\kjx}[1]{{\color{orange}{#1}}}
\newcommand{\scd}[1]{{\color{blue}{#1}}}
%\newcommand{\sdN}[1]{{\color{dkgreen}{#1}}}
%\newcommand{\jm}[1]{{\color{magenta}{JM: #1}}}
\newcommand{\sdcomment}[1]{{\ensuremath{\blacksquare}}\footnote{\color{dkgreen}{SD: #1}}}
\newcommand{\secomment}[1]{{\ensuremath{\blacksquare}}\footnote{\se{#1}}}
\newcommand{\jncomment}[1]{{\ensuremath{\blacksquare}}\footnote{\kjx{#1}}}

\newcommand{\sd}[1]{{\color{blue}{#1}}}
 \newcommand{\tobyM}[1]{#1} %[1]{{\color{purple}{Toby: #1}}}
\newcommand{\se}[1]{{\color{green}{#1}}}


\newcommand{\ponders}[3]{\marginpar{\tiny\itshape\raggedright\textcolor{#2}{\textbf{#1:} #3}}\ignorespaces}
\marginparwidth=1.6cm \marginparsep=0cm
\newcommand{\TODO}[1]{} % {{\color{red}#1}}
\newcommand{\sophia}[1]{{\color{blue}#1}}
\newcommand{\toby}[1]{} % {\ponders{Toby}{purple}{#1}}
\newcommand{\susan}[2][]{\ponders{Susan}{brown}{#1} \textcolor{brown}{#2}\xspace}
\newcommand{\james}[1]{\ponders{James}{orange}{#1}}
\newcommand{\jm}[2][]{\ponders{Julian}{magenta}{#1} \textcolor{magenta}{#2}\xspace}
\newcommand{\mrr}[2][]{\ponders{Matthew Ross}{offblue}{{#1}} \textcolor{offblue}{{#2}}\xspace}
\newcommand{\mrrz}[1]{\textcolor{offblue}{{#1}}\xspace}
\newcommand{\Mrr}[2][]{\ponders{Matthew Ross}{teal}{{#1}} \textcolor{teal}{{#2}}\xspace}
\newcommand{\Mrrz}[1]{\textcolor{teal}{{#1}}\xspace}

\newcommand{\sophiaPonder}[2][]{\ponders{Sophia}{blue}{#1} \textcolor{blue}{#2}\xspace}
\renewcommand{\sophia}[2][]                                      % Activate to display a given date or no date

\begin{document}
\maketitle
 We detail here what changes we have made to our 
 round 1 submission after feedback and advice by 
 the reviewers. Firstly, the reviewers requested 
 the following changes be made:
 
 \section{Mandatory Changes}

 \begin{description}
 
 \item[1]
 \emph{Clarify novelty/increment over existing work. In particular (but not only) over Chainmail} 
 \begin{itemize}
 \item
 
  	We have rewritten the introduction to better place in the related work (lines 12-19),
	and more explicitly address the novelty of our contribution (lines 55-60), and how it differs from
  	existing systems such as Chainmail and VerX (lines 60-64). In the related work section,
	we compare with VerX/Chainmail in more depth than before (lines 1163-1174).
	In addition, we compare with temporal loig (lines 5450554)
  \end{itemize}
 
 \item[2]
 \emph{
 Vastly expand on explanation/intuition of the 
 $\triangleleft$-operator. The explanation from the author response is not at all 
 convincing nor intuitive. It is yet too terse. Both an example and/or a picture 
 would also help greatly. It would also help greatly if later when the operator is 
 used in other definitions, it was explained just exactly how this operator works 
 in those definitions (e.g. semantics of encapsulation).
 }
 \begin{itemize}
 \item
  	We have expanded on the description and intuition of the 
  	$\triangleleft$-operator, provided a better description, as well
  	an example and a figure demonstrating how it is used for variable rewrites (section 3.3.2)
 
 \end{itemize}
 
 \item[3]
 \emph{
 Streamline Section 2.4.
 }
 \begin{itemize}
 \item
  	We have significantly restructured and rewritten Section 2.4 (now Sections 2.5 and 2.6).
  	We initially followed advice from the reviewers to take a more
  	top down approach to the the description of the system, but we 
  	found that this did not suit the complexity of the system
  	and ultimately obfuscated detail rather than clarify. Instead 
  	we have attempted to capture the intent of the reviewers' 
  	advice, and present the system bottom up, however starting from 
  	a more abstract description that includes the three main insights, and 
	a figure demonstrating 
  	the structure Necessity.
  	We believe that Section 2.5 now presents a much clearer picture of our
  	system. In Section 2.6 we apply the parts described in Section 2.5 to develop a proof.
 
 \end{itemize}
 
 \item[4]
 \emph{
 Avoid sudden/unmotivated topic changes.
 }
 \begin{itemize}
 \item
 The reviewers correctly identified that certain
  	aspects of the original submission lacked flow and changed 
  	topic frequently. This mainly occurred in the introduction 
  	(with sudden switches to related work), and in the description
  	of our case studies in Section 3. We have reworked the introduction
  	with the reviewers' advice in mind, and have essentially
	organized it into three parts: The problem we are tackling, relation to earlier work, our contribution.
	 % significantly reduced the amount of related work in the introduction, and introduced what 
  	We introduced related work   in a way that does not interfere with the flow 
  	of the paper. 
	% SD  remoced that as it always was in Section 3.4
	% We further moved the Expressiveness section (now Section 3.4) that 
  	%contained the case studies to the end of Section 3, 
	% SD also remoced, as we did not do it -- I think 
  	% and placed much of the case studies in Appendix C.
 \end{itemize}
 
 \item[5]
 \emph{
 Comment on calls from internal to external modules.
 }
 \begin{itemize}
 \item
 We have included an explanation that most of the related work does not support external calls  {(lines 260-263)}, 
 have discussed in more depth in related work (lines 1198 onwards) and outlined our thoughts on possible solutions in lines 1201-1203.
  \end{itemize}
 
 \item[6]
 \emph{
 The Coq proof should be completed: currently it has so many admits.
 }
 \begin{itemize}
 \item
The reviewers requested that we make the following changes to the Coq proofs:

\begin{description}
\item[P1] 
In the original Coq proof there was an admitted proof in a file that was 
not used by the main Coq model.
We proposed to address this by deleting the file.
\begin{itemize}
\item we have deleted the file
\end{itemize}

\item[P2]  The original Coq proof included some admitted 
proofs of properties of an assumed specification language for
the purposes of proving examples. We agreed to rename these 
proofs to \prg{Hypothesis} per the reviewers' request.
\begin{itemize}
\item we have renamed the the proofs using the Hypothesis keyword
\end{itemize}

\item[P3] The original Coq formalism included a 
proof involving some variable renaming that we 
had admitted as it was not central to the main results.
The reviewers advised us to complete the proof.
\begin{itemize}
\item We have completed the omitted proof
\end{itemize}

\item[P4] The reviewers advised us to include a description of
each Coq file, and why different properties have been admitted
\begin{itemize}
\item We have included this as part of the readme file

\end{itemize}
\end{description}
 
 \end{itemize}
 
 \item[7]
 \emph{
 The motivating password example is still not realistic. The example does not provide any interface to allow someone to get the correct password, or at least initialize the password. I think the example should be extended in such a way, which may require a more powerful logic. If this doesn't work, the paper should provide another example and clarify the weakness of the logic.
 }
 \begin{itemize}
 \item
 As we already discussed with the reviewers after the rebuttal period, the language Loo does support object initialization. To demonstrate this, we introduced a method init in lines 136-137.
 \end{itemize}
 
 \end{description}
 
 \section{Strongly Recommended Changes}

 \begin{description}
 
 \item[8]
 \emph{
 Clarify what you mean by "emergent behavior".
 }
 \begin{itemize}
 \item
We have included a description of \emph{emergent behaviour}
in the new introduction, lines 40-43.
 
 \end{itemize}
 
 \item[9]
 \emph{
 More clearly separate introduction from related work. In general streamline flow of the paper.
 }
 \begin{itemize}
 \item
We have followed the reviewers' advice, and 
this has greatly improved the flow and conciseness of the introduction.
 
 \end{itemize}
 
 \end{description}
 
 \section{Recommended Changes}
 The reviewers also requested that we address all of the other minor 
 changes requested by each reviewer. Here we detail those changes.

 

\subsection{Reviewer A}

\begin{enumerate}
\item
\emph{In l. 36-55, the introduction suddenly becomes/mixes with a part on related work. To my opinion, this completely distracts from the description of the problem that this paper is attacking. I'd rather that this part is moved to the dedicated related work section.}

\begin{itemize}
\item We have restricted the related work in the introduction to only lines 13-15 and 55-65.
\end{itemize}
\item
\emph{l. 68. At this point (and also many points later), it was completely unclear to me what "emergent behaviour" is supposed to mean. }

\begin{itemize}
\item We describe this in line 41
\end{itemize}
\item
\emph{
Section 2.4, I must say, I find extremely tedious and very difficult to follow. I firmly believe that this can be streamlined to that one must not mentally follow through 9 steps (a - i). Many notions are also only explained later. E.g. it is not clear (and also does not become apparent from the explanations in Sec. 2.4) why one needs to construct from per-method conditions the single-step conditions. And is this really important in order to get an overview of the approach that the paper is taking?
}
\begin{itemize}
\item We have separated the notion of assertion encapsulation, and then described the three parts of the proof system.
\end{itemize}

\item
\emph{
.102: I have two problems with the notion of being encapsulated:
   - Maybe a minor comment, actually, but again - I'm sorry - I do not understand the name "encapsulated". The fact that the concept  "only by executing a pice of code C one can invalidate a logical assertion A"  is called "C encapsulates A" does not make much sense to me because "encapsulating" - to me - suggests rather that A is somehow part of C or that A is somehow wrapped/surrounded by C.
   } 
   \\
\emph{   
   - More severely, I still cannot get my head around the notion that only by executing C one can invalidate A. Imagine \prg{C'=C;x:=x}. Obviously \prg{C'}$\neq$\prg{C}, but if \prg{C} can invalidate \prg{A}, so can \prg{C'}. How can there be a piece of code 
   \prg{C}, so that only \prg{C} but not \prg{C;x:=x} can invalidate \prg{A}?
}
\begin{itemize}
\item The invalidation is done by methods of the module, not by a single, specific piece of code.
\end{itemize}

 

\item
\emph{
says "Note that our proofs of necessity do not inspect method bodies" This makes absolutely no sense to me. How can I infer - or more: prove - anything about an object C (the code) without looking at C? This needs an explanation. In the explanation that follows you mention pre and postconditions of methods, but how can I prove pre- and postconditions of methods, if I cannot look at the methods?
}

\begin{itemize}
\item We assume that the proofs of the pre- and post-conditions come from some external system. We have added a Fig.1 in which the functional specifications are indicated in gray, indicating that \Nec  is parametric with these parts.
\end{itemize}

\item
\emph{
l.263 following: At this point I was wondering, which of Mod1, Mod2, Mod3 is internal, what is external? It would be good to refer back to that example and point out to the reader what is supposed to be internal and what external.
}
\begin{itemize}
\item We now give descriptive names to the modules.
\end{itemize}

\item
\emph{
Def. 3.2: Why would one write Arising(M, Y, sigma) iff ... Y; M, $sigma_0$ ... Why flip the order of M and Y? Does that not cause unnecessary confusion? Or is there a good reason to flip the order?
}
\begin{itemize}
\item There was no good reason. We have adopted the order you suggested -- thank you.
\end{itemize}
\item
\emph{
Def. 3.8: It would be good to ostentatiously clarify that necessity specifications cannot nest, i.e. the nonterminal S does not appear on the right-hand side of the grammar. Only nonterminals A and those come from the language Assert, I suppose.
}

\begin{itemize}
\item This, indeed, is crucial. It follows from the syntax, since $S$ (necessity specifications) do not nest in Def. 3.8. We stress this in lines 86-89.
\end{itemize}

\item
\emph{
l.442-456: It is totally unclear how/why the $\triangleleft$-operator does the trick for you necessity modalities. Part of the reason is that the definition $\triangleleft$ is described/explained in not enough detail (for me). But I also firmly believe that the definition of the semantics of the necessity modalities deserves to be provided some intuition. In particular an intuition of how $\triangleleft$ defines these semantics.
}

\begin{itemize}
\item You are right. We have taken your suggestions at hand, and gave a longer explanation, and a diagram, in \S 3.3.2. We were also able to simplify the definition. Thank you for pointing this out.
\end{itemize}

\item
\emph{
l.482: I believe that it deserves an explenation why no module satisfies \prg{NecessityBankSpec}$_\prg{c}$. It is not obvious to me.
}
\begin{itemize}
\item We have expanded section 3.4.1, and have given explanations for the cases where specifications are not satisfied.
\end{itemize}
\end{enumerate}

\subsection{Reviewer B}
\begin{enumerate}
\item
\emph{
90: this is the first example I noticed of a weird transition. The authors go straight from saying that there are three new operators to a lot of detail on the first of those. The paper here would flow better if the authors gave an informal description of all three operators (to give the reader an intuition for what’s coming next) rather than going straight into gory detail.
}
\begin{itemize}
\item  
we took this suggestion at heart, and gave an informal introduction to the operators in section 2.2, and then used them in section 2.3 
\end{itemize}

\item
\emph{
99: the authors state that necessity operators are second-class, but don’t really justify this choice or explore its consequences, and it is never returned to. I’m not sure if the necessity operators being second-class is actually the right choice, and especially at this point in the paper, where I as a reader don’t yet fully understand them, this statement throws me off.
}
\begin{itemize}
\item  
We now explain that this is what allowed us to develop the proof logic -- lines 86-89.
\end{itemize}

\item
\emph{
200: when you make an assumption like this one, please justify it to the reader rather than simply saying “Note ...“ Especially for such an important assumption, as this one, it is unsatisfying as a reader to be left wondering why you have done this.}
\begin{itemize}
\item  
We now explain that this is in agreement with lots of related work
\end{itemize}

\item
\emph{
205: you refer to Mod1, Mod2, Mod3, etc. many times, but their names are not descriptive at all. This was the point where I got mildly annoyed at having to go back and check which implementation Mod3 was. I suggest renaming the modules to something that describes their properties, e.g. Mod3 could become “SafePwdSet” or something like that.}
\begin{itemize}
\item  
 We have now given them more descriptive names, i.e. \prg{Mod}$_{good}$, \prg{Mod}$_{bad}$, and \prg{Mod}$_{better}$.
\end{itemize}

\item
\emph{
243: you might consider emphasizing this point more: it is a strength of your approach that it doesn’t make many assumptions about how these annotations are checked, and so is compatible with lots of existing work.}
\begin{itemize}
\item  
Thank you. We added such an argument in lines 99-102.
\end{itemize}

\item
\emph{
351: I have a serious concern about definition 8 (x access y) here. It seems to me that it is saying that if y’s value is exactly the value of one of x’s fields (f), then x can access y. That seems reasonable, but I don’t see any notion of multi-step access paths here, which seems suspicious to me. After all, intuitively I would expect that (x access y) would be true if for example the value of the expression x.f.g is the same as the value of y (and so on for any arbitrary number of field accesses). Did I miss something about your setup/language that forbids fields themselves having fields? Or is it the case that (x access y) is defined to be false in a case like the one I mentioned above? If so, that seems to me like a “soundness” problem in the sense that it violates what I as a specification writer would expect that specification to mean, and therefore might result in incorrectly-specified code.}
\begin{itemize}
\item  
We now clarify that access is not deep, and why it should not be. C.f. lines 484-487.
\end{itemize}

\emph{
382: inside is a very useful concept. I might consider mentioning it earlier, perhaps by working it into one of the examples in section 2.}
\begin{itemize}
\item  
We experimented with that, but we found that this would require too many explanations too early, so we gave up. 
\end{itemize}

\item
\emph{
459: this is another case where the flow of the text is jarring. There is no explanation for why now is the appropriate time to consider more examples of specifications. This might make more sense as a separate section rather than as a subsection, with a short justification saying something like “we now present some examples to give the reader an idea of the expressiveness of our approach”; you didn’t explain that that was the goal of the example section in this draft until the very end of the section!}
\begin{itemize}
\item  
Done
\end{itemize}

\item
\emph{
1036-1042: there seems to be a lot of overlap between the present work and Chainmail. You might want to spend another sentence or two here discussing the differences.}
\begin{itemize}
\item  
Differences are now described in some depth in lines 1163-1174.
\end{itemize}

\end{enumerate}

\subsection{Reviewer C}
\begin{enumerate}
\item
\emph{
Section 1: I'm not sure if paraphrasing liveness and safety is a good idea because liveness/safety verification in the traditional sense is also reasoning about sufficient conditions for good things to eventually happen or for bad things to never happen. The point here is the distinction between sufficient and necessary conditions about the behavior of a program.}
\begin{itemize}
\item  
We have drastically reworked that part, and no longer talk of liveness.
\end{itemize}

\item
\emph{
Section 2.4 doesn't work very well (at least for a first reading) because it is written in a bottom-up manner. I had no idea why assertion encapsulation is the first step because I didn't have a big picture how necessity specification might be verified. Explaining backwards from Part 4 to 1 may work better (but I'm not sure...).}
\begin{itemize}
\item  
We have tried this, but it did noit work that well. Nevertheless, we have re-worked Section 2.4 (now 2.5) and hope it is mush better now
\end{itemize}

\item
\emph{
It seem to me that it can be hard to show assertion encapsulation because of universal quantification over all external modules and states. The existence of a type system and a proof system for assertion encapusulation, which is discussed in 4.1.3, is nice and plausible but I find the discussion on Enc(A) handwaving and the derivation in Section 5.1 is hard to follow. I think you should explicitly state that the bank account example is typed by the assumed simple type system for confinement.}
\begin{itemize}
\item  
We say that now in lines 318-319
\end{itemize}

\item
\emph{
I'm not sure why Section 5 extends the simple bank account example so much. Is the extension needed to demonstrate the verification framework, or you thought the examples in Section 2 would be too simple? Maybe they are simple but I think it is a good exercise to show verification of the first examples. It was hard for me to follow the extended example as a first verification exercise.}
\begin{itemize}
\item  
We now prove  the original example in Section 5, and the extended example in the appendix. The reason we also prove the extended example is in order to show the use of ghost fields, and encapsulated classes.
\end{itemize}

\end{enumerate}

\subsection{Reviewer D}

\begin{enumerate}
\item
\emph{
 First, the way to connect the "from" and "to" conditions seems to involve unnecessary complications, which may restrict the applicability of the work to other languages. Updating physical states using fresh variables sounds too restrictive. For example, in assembly, one cannot create fresh registers. Here it is unclear to me why the authors cannot use logical auxiliary variables as done in modern separation logics.
 }
 \begin{itemize}
\item  
 We assume that the reviewer refers to the adaptation operator, whose explanations we have improved and expanded.
 \end{itemize}
 
\item
\emph{
 Second, the allowed control flow between the external and internal modules is restricted (ie, the internal module cannot invoke external modules). Since reasoning about the internal module should be essentially independent of external modules (because external modules are completely arbitrary), similar reasoning as presented in this paper should be possible even when the internal module invokes functions of external modules. }
 \begin{itemize}
\item  
 We discuss more the issues around calls from internal to external objects in lines  260-263, line 1198 onwards, and outlined our thoughts on possible solutions in lines 1201-1203.
 \end{itemize}

\item
\emph{
Finally, more importantly, although the paper claims the (S3) condition instead of (S2) as an advance over Chainmail, the condition (S3) is not so convincing. There are two concerns. First, (S3) does not say anything useful in the presence of an external module that has access to the password, which is the case in general. In other words, (S3) cannot distinguish between external modules that have access to the password and those that do not. On the other hand, (S2) implies that external modules without knowing the correct password cannot change the balance. Second, (S3) seems to relying on the setting that the password is an unforgeable object instead of a string, which is rather artificial. On the other hand, (S2) seems to work even when the password is a string. }
 \begin{itemize}
\item  
 We discuss this in section 2.3.1.
 \end{itemize}
 
 \end{enumerate} 


\end{document}

\newpage



\section{Copied from hotcrp discussion}


 
 
  We will make all the minor changes suggested by the reviewers.
 \subsection*{External calls}
 We cannot promise a full treatment of external calls by the end of February, but we can share out current thinking:  As a first approach, we will require that the arguments to external calls do not include internal objects, except for the receiver and parameters (thus ensuring that external accessibility of internal methods does not increase); we would rely on the classical pre- and post- conditions of the internal methods -- as we currently do. As a more advanced approach, we will develop extensions to classical Hoare Logics, which would allow us to reason about points in the code where external calls are being made. This would be the first time we could be inspecting the code in the bodies of the functions.
 \subsection*{Novelty}
 We will strengthen our statements about VerX and Chainmail in line with what we said above.
 
 \subsection*{Presentation}
 
 For adaption, access, and encapsulation we will amend the explanations as stated above. Susan: or do you want to discuss Julian's cleaner definition for adaption he sent yesterday???
 
 For emergent behaviour we will include the reviewer's statement and also say that ``(S2) does not take account of the module's \emph{emergent behaviour}. That is, (S2) does not consider the behavior that emerges from the interaction between the 
\texttt{transfer} method, and the other methods of the bank module. What if the module leaks the password?''
 
 We will replace the current Bank Account proof with a simpler Coq proof that matches the straightforward introductory example. We will put the current example in an appendix so that we can 
show reasoning about ghost fields and more complex data structures. 

We will move the clarifying examples to Section 2.

The largest piece of work is the proof and that shouldn't take more than a week so we believe that we can make substantial improvements in presentation before mid January.


\subsubsection*{Reviewer A}
\begin{itemize}
\item Streamline Introduction: we will move the related work to the related work section
\item Rework Section 2 to be clearer: we will make the outline of the proof structure in Section 2 clearer, at a higher level, and more concise.
\item We will change the order of $M$ and $M'$ in the definition of Arising.
\item We will make clear which state is the original state.
\item We will clarify Def. 3.9, provide a clearer description and definition.
\item Ensure consistent usage of Section vs. section.
\end{itemize}

\subsubsection*{Reviewer B}
\begin{itemize}
\item Fix the flow of the paper. Present a ``consistent high-level story``
\item Clarify the differences between Necessity and Chainmail and VerX.
\item Be more explicit about the reasons and justifications for restricting external method calls
\item Provide better names for Mod1, Mod2, Mod3, etc
\item Emphasize the separation of Necessity from the inspection of code.
\item Clarify why shallow access is necessary
\item Restate NecessityBankSpec in 3.4.1
\item Provide better justification, explanation, and intuition for the example specifications in 3.4
\item Include a brief description of the expressiveness earlier in the paper than 3.4.3
\item Explain why the restriction on return values is sufficient in If1-Inside
\end{itemize}

\subsubsection*{Reviewer C}
\begin{itemize}
\item Rephrase the liveness and safety verification in the Section 1.
\item Rewrite Section 2.4. (Julian: Reviewer B appreciated this, but neither C nor A did)
\item Replace Section 5 with the simpler, original bank account example, and move the current one to the appendix.
\end{itemize}


  
\section{Proposed Changes}

\subsection{Unrealistic motivating example}

> The motivating password example is still not realistic. The example does not 
provide any interface to allow someone to get the correct password, or at 
least initialize the password. ... example should be extended in such a way, 
which may require a more powerful logic..*

This is a good point, and we thank the reviewers for pointing out that we should
have expanded:

We are not clear what is meant by "an interface to allow someone to get the 
correct password". Such a function (called, say, `getPassword`) is expressible
in the language, and we could add it to our example. But if the module allowed 
a client to read an account's password without prior knowledge of the password, 
then the module would no longer be robust, because anybody with access to
the account would be able to take the money out of the account. 

On the other hand, \ModC does support initialization of the password, through
execution of the following code

	p1=new Object; a=new Account(); a.setPassword(null,p1)

Namely, object creation, (`new Account()`) initializes the account's password
to `null`, and thus the call `a.setPassword(null,p1)` will succesfully set the password
to `p1`. 

*Our proposal* 

`P5`: We will add explanations as per above, showing how object intialization works 
in our approach. 

------
**Appendix**

More details about point 2, for the interested reviewer.

If we assumed some "unknown" method `m\_unknown`, and "untrusted" 
object `o\_untrust`, and some account `a0` with some money in it, and with password
`p0`, then, the following code

         `a=new Account(); a0.transfer(p0,100); o\_untrust.m\_unknown(a)`

gives \_no\_ guarantee about the call `o\_untrust.m\_unknown(a)` not removing the money in the account `a`, while

        `p1=new Object; a=new Account();  a.setPassword(null,p1);`
        `a0.transfer(p0,100);  o\_untrust.m\_unknown(a)`

\_does\_ guarantee that no money will be removed during the call `o\_untrust.m\_unknown(a)`
-- because no external objects involved in that call have access to `p1`.  

One may now ask how we would initialize the account so that it contains some money, 
without adding methods to class `Account` which make it possible to just create money
out of thin air. We can do this (initialize the money) in the language we have
provided: add a function, which pays money into the account only while the password 
is still `null`. Or, even better, we could follow the approach  from [Mark Samuel Miller, 
Chip Morningstar, and Bill Frantz. 2000. Capability-based Financial Instruments: 
From Object to Capabilities] and have a `Bank` object, with `Account`s belonging 
to that `Bank`. The `Account`s may transfer moneys across 
each other only if they belong to the same `Bank`, and only `Bank`s may create `Account`s 
belonging to them. We could give the code for this, but it would require another page, 
discussing issues that are not central to the contribution of this work. Therefore,
we propose not to do that, but are happy to take the reviewers' guidance.

------
We are looking forward to your answer whether you agree with our proposals `P1`,`P2`,`P3`, `P4` and `P5`, and thank you, again, for your interest.
 



\bibliographystyle{plainnat}
\bibliography{Response1} 


\end{document}  
%
% For emergent behaviour we will include the reviewer's statement and also say that ``(S2) does not take account of the module's \emph{emergent behaviour}. That is, (S2) does not consider the behavior that emerges from the interaction between the 
%\texttt{transfer} method, and the other methods of the bank module. What if the module leaks the password?''
% 
% We will replace the current Bank Account proof with a simpler Coq proof that matches the straightforward introductory example. We will put the current example in an appendix so that we can 
%show reasoning about ghost fields and more complex data structures. 
%
%We will move the clarifying examples to Section 2.
%
%The largest piece of work is the proof and that shouldn't take more than a week so we believe that we can make substantial improvements in presentation before mid January.
%
%
%
% 
%
%
% 
% %We propose the following amended explanation to clarify both it's importance, and it's meaning:
%
% 
% A list of the changes that you plan to make in
%  response to the reviews and the timeline for those changes.
%  
% 
%  
%\section{Response} A reviewer-by-reviewer list of answers to questions
%  with context extracted from the reviews. Use markdown syntax.
%
%\bibliographystyle{plainnat}
%\bibliography{Response1} 
%
%
%\end{document}  