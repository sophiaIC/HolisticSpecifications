\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage{definitions}

\newcommand{\rev}[1]{\emph #1}
\newcommand{\us}[1]{\bf #1}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{filecontents}
\begin{filecontents}{Response1.bib}
@article{Grossman,
author = {Grossman, Shelly and Abraham, Ittai and Golan-Gueta, Guy and Michalevsky, Yan and Rinetzky, Noam and Sagiv, Mooly and Zohar, Yoni},
title = {Online Detection of Effectively Callback Free Objects with Applications to Smart Contracts},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158136},
doi = {10.1145/3158136},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {48},
numpages = {28},
keywords = {Program analysis, Modular reasoning, Smart contracts}
}
@article{Albert,
author = {Albert, Elvira and Grossman, Shelly and Rinetzky, Noam and Rodr\'{\i}guez-N\'{u}\~{n}ez, Clara and Rubio, Albert and Sagiv, Mooly},
title = {Taming Callbacks for Smart Contract Modularity},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428277},
doi = {10.1145/3428277},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {209},
numpages = {30},
keywords = {blockchain, program verification, program analysis, logic and verification, smart contracts, invariants}
}

@article{Permenev,
  title={VerX: Safety Verification of Smart Contracts},
  author={Anton Permenev and Dimitar I. Dimitrov and Petar Tsankov and Dana Drachsler-Cohen and Martin T. Vechev},
  journal={2020 IEEE Symposium on Security and Privacy (SP)},
  year={2020},
  pages={1661-1677}
  }
  
  @inproceedings{Drossopoulou,
author="Drossopoulou, Sophia and Noble, James and Mackay, Julian and Eisenbach, Susan",
editor="Wehrheim, Heike and Cabot, Jordi",
title="Holistic Specifications for Robust Programs",
booktitle="Fundamental Approaches to Software Engineering",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="420--440",
}

@misc{Chlipala,
  author = "Adam Chlipala",
  title = "Certified Programming with Dependent Types",
 url = "http://adam.chlipala.net/cpdt/",
 year = 2019,
 date = "2021-12-02",
}

%@misc{Chlipala,
%  author = "Adam Chlipala",
%  title = "frap: Formal Reasoning about Programs",
% url = "https://github.com/achlipala/frap",
% year = 2019,
% date = "2021-12-02",
%}

\end{filecontents}


\usepackage{natbib}

\title{OOPSLA 2022 Round 2 Resubmission Changes}
%\author{The Author}
%\date{3 December 2021}     

\newcommand\multibrace[3]{\rdelim\}{#1}{3mm}[\pbox{#2}{#3}]}

\newcommand{\kjx}[1]{{\color{orange}{#1}}}
\newcommand{\scd}[1]{{\color{blue}{#1}}}
%\newcommand{\sdN}[1]{{\color{dkgreen}{#1}}}
%\newcommand{\jm}[1]{{\color{magenta}{JM: #1}}}
\newcommand{\sdcomment}[1]{{\ensuremath{\blacksquare}}\footnote{\color{dkgreen}{SD: #1}}}
\newcommand{\secomment}[1]{{\ensuremath{\blacksquare}}\footnote{\se{#1}}}
\newcommand{\jncomment}[1]{{\ensuremath{\blacksquare}}\footnote{\kjx{#1}}}

\newcommand{\sd}[1]{{\color{blue}{#1}}}
 \newcommand{\tobyM}[1]{#1} %[1]{{\color{purple}{Toby: #1}}}
\newcommand{\se}[1]{{\color{green}{#1}}}


\newcommand{\ponders}[3]{\marginpar{\tiny\itshape\raggedright\textcolor{#2}{\textbf{#1:} #3}}\ignorespaces}
\marginparwidth=1.6cm \marginparsep=0cm
\newcommand{\TODO}[1]{} % {{\color{red}#1}}
\newcommand{\sophia}[1]{{\color{blue}#1}}
\newcommand{\toby}[1]{} % {\ponders{Toby}{purple}{#1}}
\newcommand{\susan}[2][]{\ponders{Susan}{brown}{#1} \textcolor{brown}{#2}\xspace}
\newcommand{\james}[1]{\ponders{James}{orange}{#1}}
\newcommand{\jm}[2][]{\ponders{Julian}{magenta}{#1} \textcolor{magenta}{#2}\xspace}
\newcommand{\mrr}[2][]{\ponders{Matthew Ross}{offblue}{{#1}} \textcolor{offblue}{{#2}}\xspace}
\newcommand{\mrrz}[1]{\textcolor{offblue}{{#1}}\xspace}
\newcommand{\Mrr}[2][]{\ponders{Matthew Ross}{teal}{{#1}} \textcolor{teal}{{#2}}\xspace}
\newcommand{\Mrrz}[1]{\textcolor{teal}{{#1}}\xspace}

\newcommand{\sophiaPonder}[2][]{\ponders{Sophia}{blue}{#1} \textcolor{blue}{#2}\xspace}
\renewcommand{\sophia}[2][]                                      % Activate to display a given date or no date

\begin{document}
\maketitle

 \section{Change List}
 
 \begin{description}
 
 \item[1]
 Clarify novelty/increment over existing work. In particular (but not only) over Chainmail 
 
 \item[2]
 Vastly expand on explanation/intuition of the 
 $\triangleleft$-operator. The explanation from the author response is not at all 
 convincing nor intuitive. It is yet too terse. Both an example and/or a picture 
 would also help greatly. It would also help greatly if later when the operator is 
 used in other definitions, it was explained just exactly how this operator works 
 in those definitions (e.g. semantics of encapsulation).
 
 \item[3]
 Streamline Section 2.4.
 
 \item[4]
 Avoid sudden/unmotivated topic changes.
 
 \item[5]
 Comment on calls from internal to external modules.
 
 \item[6]
 The Coq proof should be completed: currently it has so many admits.
 \begin{itemize}
 \item See \ref{s:coq:changes}
 \end{itemize}
 
 \item[7]
 The motivating password example is still not realistic. The example does not provide any interface to allow someone to get the correct password, or at least initialize the password. I think the example should be extended in such a way, which may require a more powerful logic. If this doesn't work, the paper should provide another example and clarify the weakness of the logic.
 
 \item[8]
 Clarify what you mean by "emergent behavior".
 
 \item[9]
 More clearly separate introduction from related work. In general streamline flow of the paper.
 
 \item[10]
 All other (minor) comments of the reviewers.
 
 \end{description}
 
 \section{Changes Description}
 
 

\subsection{Changes to Coq Formalism}
\label{s:coq:changes}


The reviewers requested that we make some changes to the Coq proofs:

\begin{description}
\item[P1] 
In the original Coq proof there was an admitted proof in a file that was 
not used by the main Coq model.
We proposed to address this by deleting the file.
\begin{itemize}
\item we have deleted the file
\end{itemize}

\item[P2]  The original Coq proof included some admitted 
proofs of properties of an assumed specification language for
the purposes of proving examples. We agreed to rename these 
proofs to \prg{Hypothesis} per the reviewers' request.
\begin{itemize}
\item we have renamed the the proofs
\end{itemize}

\item[P3] The original Coq formalism included a 
proof involving some variable renaming that we 
had admitted as it was not central to the main results.
The reviewers advised us to complete the proof.
\begin{itemize}
\item We have completed the omitted proof
\end{itemize}

\item[P4] The reviewers advised us to include a description of
each Coq file, and why different properties have been admitted
\begin{itemize}
\item We have included this description in the readme
\jm[I still need to finish this]{}
\end{itemize}
\end{description}

\section{Copied from hotcrp discussion}


 
 
  We will make all the minor changes suggested by the reviewers.
 \subsection*{External calls}
 We cannot promise a full treatment of external calls by the end of February, but we can share out current thinking:  As a first approach, we will require that the arguments to external calls do not include internal objects, except for the receiver and parameters (thus ensuring that external accessibility of internal methods does not increase); we would rely on the classical pre- and post- conditions of the internal methods -- as we currently do. As a more advanced approach, we will develop extensions to classical Hoare Logics, which would allow us to reason about points in the code where external calls are being made. This would be the first time we could be inspecting the code in the bodies of the functions.
 \subsection*{Novelty}
 We will strengthen our statements about VerX and Chainmail in line with what we said above.
 
 \subsection*{Presentation}
 
 For adaption, access, and encapsulation we will amend the explanations as stated above. Susan: or do you want to discuss Julian's cleaner definition for adaption he sent yesterday???
 
 For emergent behaviour we will include the reviewer's statement and also say that ``(S2) does not take account of the module's \emph{emergent behaviour}. That is, (S2) does not consider the behavior that emerges from the interaction between the 
\texttt{transfer} method, and the other methods of the bank module. What if the module leaks the password?''
 
 We will replace the current Bank Account proof with a simpler Coq proof that matches the straightforward introductory example. We will put the current example in an appendix so that we can 
show reasoning about ghost fields and more complex data structures. 

We will move the clarifying examples to Section 2.

The largest piece of work is the proof and that shouldn't take more than a week so we believe that we can make substantial improvements in presentation before mid January.


\subsubsection*{Reviewer A}
\begin{itemize}
\item Streamline Introduction: we will move the related work to the related work section
\item Rework Section 2 to be clearer: we will make the outline of the proof structure in Section 2 clearer, at a higher level, and more concise.
\item We will change the order of $M$ and $M'$ in the definition of Arising.
\item We will make clear which state is the original state.
\item We will clarify Def. 3.9, provide a clearer description and definition.
\item Ensure consistent usage of Section vs. section.
\end{itemize}

\subsubsection*{Reviewer B}
\begin{itemize}
\item Fix the flow of the paper. Present a ``consistent high-level story``
\item Clarify the differences between Necessity and Chainmail and VerX.
\item Be more explicit about the reasons and justifications for restricting external method calls
\item Provide better names for Mod1, Mod2, Mod3, etc
\item Emphasize the separation of Necessity from the inspection of code.
\item Clarify why shallow access is necessary
\item Restate NecessityBankSpec in 3.4.1
\item Provide better justification, explanation, and intuition for the example specifications in 3.4
\item Include a brief description of the expressiveness earlier in the paper than 3.4.3
\item Explain why the restriction on return values is sufficient in If1-Inside
\end{itemize}

\subsubsection*{Reviewer C}
\begin{itemize}
\item Rephrase the liveness and safety verification in the Section 1.
\item Rewrite Section 2.4. (Julian: Reviewer B appreciated this, but neither C nor A did)
\item Replace Section 5 with the simpler, original bank account example, and move the current one to the appendix.
\end{itemize}


  
\section{Proposed Changes}

\subsection{Unrealistic motivating example}

> The motivating password example is still not realistic. The example does not 
provide any interface to allow someone to get the correct password, or at 
least initialize the password. ... example should be extended in such a way, 
which may require a more powerful logic..*

This is a good point, and we thank the reviewers for pointing out that we should
have expanded:

We are not clear what is meant by "an interface to allow someone to get the 
correct password". Such a function (called, say, `getPassword`) is expressible
in the language, and we could add it to our example. But if the module allowed 
a client to read an account's password without prior knowledge of the password, 
then the module would no longer be robust, because anybody with access to
the account would be able to take the money out of the account. 

On the other hand, \ModC does support initialization of the password, through
execution of the following code

	p1=new Object; a=new Account(); a.setPassword(null,p1)

Namely, object creation, (`new Account()`) initializes the account's password
to `null`, and thus the call `a.setPassword(null,p1)` will succesfully set the password
to `p1`. 

*Our proposal* 

`P5`: We will add explanations as per above, showing how object intialization works 
in our approach. 

------
**Appendix**

More details about point 2, for the interested reviewer.

If we assumed some "unknown" method `m\_unknown`, and "untrusted" 
object `o\_untrust`, and some account `a0` with some money in it, and with password
`p0`, then, the following code

         `a=new Account(); a0.transfer(p0,100); o\_untrust.m\_unknown(a)`

gives \_no\_ guarantee about the call `o\_untrust.m\_unknown(a)` not removing the money in the account `a`, while

        `p1=new Object; a=new Account();  a.setPassword(null,p1);`
        `a0.transfer(p0,100);  o\_untrust.m\_unknown(a)`

\_does\_ guarantee that no money will be removed during the call `o\_untrust.m\_unknown(a)`
-- because no external objects involved in that call have access to `p1`.  

One may now ask how we would initialize the account so that it contains some money, 
without adding methods to class `Account` which make it possible to just create money
out of thin air. We can do this (initialize the money) in the language we have
provided: add a function, which pays money into the account only while the password 
is still `null`. Or, even better, we could follow the approach  from [Mark Samuel Miller, 
Chip Morningstar, and Bill Frantz. 2000. Capability-based Financial Instruments: 
From Object to Capabilities] and have a `Bank` object, with `Account`s belonging 
to that `Bank`. The `Account`s may transfer moneys across 
each other only if they belong to the same `Bank`, and only `Bank`s may create `Account`s 
belonging to them. We could give the code for this, but it would require another page, 
discussing issues that are not central to the contribution of this work. Therefore,
we propose not to do that, but are happy to take the reviewers' guidance.

------
We are looking forward to your answer whether you agree with our proposals `P1`,`P2`,`P3`, `P4` and `P5`, and thank you, again, for your interest.
 



\bibliographystyle{plainnat}
\bibliography{Response1} 


\end{document}  
%
% For emergent behaviour we will include the reviewer's statement and also say that ``(S2) does not take account of the module's \emph{emergent behaviour}. That is, (S2) does not consider the behavior that emerges from the interaction between the 
%\texttt{transfer} method, and the other methods of the bank module. What if the module leaks the password?''
% 
% We will replace the current Bank Account proof with a simpler Coq proof that matches the straightforward introductory example. We will put the current example in an appendix so that we can 
%show reasoning about ghost fields and more complex data structures. 
%
%We will move the clarifying examples to Section 2.
%
%The largest piece of work is the proof and that shouldn't take more than a week so we believe that we can make substantial improvements in presentation before mid January.
%
%
%
% 
%
%
% 
% %We propose the following amended explanation to clarify both it's importance, and it's meaning:
%
% 
% A list of the changes that you plan to make in
%  response to the reviews and the timeline for those changes.
%  
% 
%  
%\section{Response} A reviewer-by-reviewer list of answers to questions
%  with context extracted from the reviews. Use markdown syntax.
%
%\bibliographystyle{plainnat}
%\bibliography{Response1} 
%
%
%\end{document}  