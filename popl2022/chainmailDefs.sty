\ProvidesPackage{chainmailDefs}[2021/05/18 v1.0 chainmailDefs]

\usepackage{xspace}


%constrained reduction
\newcommand{\constrained}{\mathrel{\leadsto\ \!\!\!\!{\raisebox{1pt}{$\mathsmaller{\mathsmaller{\mathsmaller{\mathsmaller\rvert}}}$}}}}
\newcommand{\reduction}[4]{#1\ ;\ #2\ \bullet\ #3\ \leadsto\ #4}
\newcommand{\reductions}[4]{#1\ ;\ #2\ \bullet\ #3\ \leadsto^*\ #4}
\newcommand{\constrainedReduction}[4]{#1\ ;\ #2\ \bullet\ #3\ \constrained\ #4}
\newcommand{\constrainedReductions}[4]{#1\ ;\ #2\ \bullet\ #3\ \constrained^*\ #4}
\newcommand{\satisfies}[4]{#1\ ;\ #2,\ #3 \vDash\ #4}

\newcommand\trans{\mathlarger{\mathlarger \leadsto}}
\newcommand\intstep{\hspace{1.5mm}{\raisebox{3pt}{$\bullet$}}\hspace{-1.5mm}{\hookrightarrow}}
\newcommand\en{\hspace{1.5mm}{\raisebox{0pt}{$\bullet$}}\hspace{-4mm}{\hookrightarrow}}
\newcommand\oi{\hspace{1mm}{\raisebox{1pt}{$\bullet$}}\hspace{-1mm}{\trans}}
\newcommand\ot{\hspace{2mm}{\raisebox{1pt}{$\bullet$}}\hspace{-3mm}{\trans}}
\newcommand\otAlt{\hspace{2mm}{\raisebox{0.5pt}{$\bullet$}}\hspace{-2.75mm}{\trans}}
\newcommand\mut[3]{\langle #1\ \texttt{mut}\ #2.#3 \rangle}
\newcommand\gives[3]{\langle #1\ \texttt{gives}\ #2\ \texttt{to}\ #3 \rangle}
\newcommand\exposes[2]{#1\ \texttt{exposes}\ #2}
\newcommand\univ{U}
\newcommand\onlyIf[3]{#1\ {\color{blue}\texttt{to}}\ #2\ {\color{blue}\texttt{onlyIf}}\ #3}
\newcommand\oiInternal[4]{#1\ {\color{blue}\texttt{to}}\ #2\ {\color{blue}\texttt{through}}\ #3\ {\color{blue}\texttt{onlyIf}}\ #4}
\newcommand\ensures[3]{#1,\ #2\ \en\ #3}
\newcommand\onlyThrough[3]{#1\ {\color{blue}\texttt{to}}\ #2\ {\color{blue}\texttt{onlyThough}}\ #3}
\newcommand\onlyIfSingle[3]{#1\ {\color{blue}\texttt{to1}}\ #2\ {\color{blue}\texttt{onlyIf}}\ #3}
\newcommand\onlyIfProof[4]{#1\ \vdash\ #2,\ #3\ \texttt{only if}\ #4}
\newcommand\onlyThroughProof[4]{#1\ \vdash\ #2,\ #3\ \texttt{only if}\ #4}
\newcommand\hoare[3]{\{#1\}\ #2\ \{#3\}}
\newcommand\hoareIf[4]{#1,\ #2,\ \{#3\}\ \intstep\ #4}
\newcommand\rtrns[3]{\{#1\}\ #2\ \texttt{returns}\ #3}

\newcommand\encapsulated[1]{\langle {\color{blue}\texttt{encapsulated}}\ #1 \rangle}
\newcommand\encapsulates[2]{\langle #1\ {\color{blue}\texttt{encapsulates}}\ #2 \rangle}
\newcommand\bencapsulated[1]{\langle {\color{blue}\texttt{encapsulated}_{\mathcal{B}}}\ #1 \rangle}
\newcommand\bencapsulates[2]{\langle #1\ {\color{blue}\texttt{encapsulates}_{\mathcal{B}}}\ #2 \rangle}
\newcommand\encapsulatesStrong[2]{\langle #1\ \texttt{encapsulates}_\texttt{strong}\ #2 \rangle}
\newcommand\encapsulatesMdl[1]{\langle \texttt{encapsulating}_\texttt{int}\ #1 \rangle}
\newcommand\calls[4]{\langle #1\ {\color{blue}\texttt{calls}}\ #2.#3(#4) \rangle}
\newcommand\changes[2]{\langle #1\ {\color{blue}\texttt{changes}}\ #2 \rangle}
\newcommand\access[2]{\langle #1\ {\color{blue}\texttt{access}}\ #2 \rangle}
\newcommand\internal[1]{\langle #1\ {\color{blue}\texttt{internal}}\rangle}
\newcommand\external[1]{\langle #1\ {\color{blue}\texttt{external}}\rangle}
\newcommand\comprehension[2]{\{#1 | #2\}}
\newcommand\internalStep{\langle \texttt{internal step}\rangle}
\newcommand\I{\textit{Int}\xspace}
\newcommand\Chainmail{\textit{Chainmail}\xspace}
\newcommand\Loo{\text{$\mathcal{L}_\textit{oo}$}\xspace}
\newcommand\new[2]{\texttt{new}\ #1(#2)}
\newcommand\return[1]{\texttt{return}\ #1}
\newcommand\true{\texttt{true}}
\newcommand\false{\texttt{false}}
\newcommand\nul{\texttt{null}}
\newcommand\all[2]{\forall #1.[#2]}
\newcommand\ex[2]{\exists\ #1.[#2]}

\newcommand\IntSet{\mathbb{Z}}

\newcommand{\synbar}{\;\; | \;\;}
	
\newcommand{\red}[1]{
	\color{red}#1 \color{black}
}
\newcommand{\blue}[1]{
	\color{blue}#1 \color{black}
}


%--------------------------------------------------------------------------------------------------	
	
% Syntax Construct
\makeatletter 

\newenvironment{syntax}
    {
    \begin{array}{lllr}
    }
    { 
    \end{array}
    }
    
\newcommand{\syntaxID}[2]{
		#1 & & & \text{\bf{#2}}\\
}
    
\newcommand{\syntaxInSet}[3]{
		#1 & \in & #2 & \text{\bf{#3}}\\
}

\newcommand{\syntaxElement}[3]{%
		#1 & ::= & #3 & \text{\bf{#2}} \\
			\@syntaxEntry
}

\newcommand\@syntaxEntry{\@ifnextchar\endSyntaxElement{\@syntaxElementEnd}{\@syntaxEntryCheck}}

\newcommand\@syntaxEntryCheck[1]{%
  \@syntaxEntryMake{\synbar #1}
  \@syntaxEntry
}
\newcommand\@syntaxEntryMake[1]{%
	& & #1 & \\
	}
\newcommand\@syntaxElementEnd[1]{
	\vspace*{-\bigskipamount}
	}
\makeatother


%--------------------------------------------------------------------------------------------------	
	
% Syntax Line
\makeatletter

\newcommand{\syntaxline}[1]{%
		#1 \@syntaxLineNext
}

\newcommand\@syntaxLineNext{\@ifnextchar\endsyntaxline{\@syntaxLineEnd}{\@syntaxLineCheck}}

\newcommand\@syntaxLineCheck[1]{%
  \@syntaxLineMake{#1}
  \@syntaxLineNext
}
\newcommand\@syntaxLineMake[1]{%
	\synbar #1
	}
\newcommand\@syntaxLineEnd[1]{}
\makeatother