\section{Logic of Necessity Semantics}
\label{s:semantics}

\subsection{\Loo}
We introduce a simple object-oriented language, \Loo, upon 
which our specification language sits. \Loo is a typical, imperative,
class based, object oriented language. A \Loo configuration $\sigma$ consists of a 
heap $\chi$, and a frame stack $\psi$. A frame $\phi$ consists of
local variable map, and sequence of statements to be executed called 
a continuation. A statement may create new objects and push them to the heap, 
perform field reads and writes on objects, and call methods on those objects. 
Program execution is performed in the context of a module which is a mapping
of class names to class definitions. Given the simplicity of \Loo, we do not
define \Loo here, rather we direct the reader to Appendix \ref{app:loo} for 
the full syntax and operational semantics. There are several properties 
of \Loo that are important to the central topic of this paper. Firstly,
we define two forms of execution for \Loo, one in Fig. \ref{f:loo-semantics}
that is unsurprising and details the execution of specific 
statements in the language, and a second called \emph{module pair execution} 
that models that open world, where the components of a program can
have both known (\internalO) and unknown (\externalO) provenance.
\begin{definition}[Module Pair Execution]
\label{def:pair-reduce}
For all internal modules $M_1$, external modules $M_2$, and program configurations $\sigma$ and $\sigma'$, 
we say that $\reduction{M_1}{M_2}{\sigma}{\sigma'}$ if and only if
\begin{itemize}
\item
$\class{\sigma}{\sigma.\prg{this}}\ \in\ M_2$ and
\item
$\class{\sigma'}{\sigma'.\prg{this}}\ \in\ M_2$ and 
\end{itemize} 
%and
%\begin{itemize}
%\item
%$\exec{M_1\ \circ\ M_2}{\sigma}{\sigma'}$ or
%\item
$M_1 \circ M_2, \sigma \leadsto \sigma_1 \leadsto \ldots \sigma_n \leadsto \sigma'$ and $\class{\sigma_i}{\sigma_i.\prg{this}} \in M_1$ for all $0 \leq i \leq n$
%\end{itemize}
\end{definition}
The definition of module pair execution makes reference to a function
$\class{\sigma}{x}$ that is defined in Appendix \ref{app:loo}, and
is a class lookup function for a specific variable in a specific program.
Secondly, we reference module linking ($M_1\ \circ\ M_2$), a function
that results in the union of two disjoint modules.
An \emph{Arising} program configuration is defined as any program configuration
that arises from some initial program configuration through module pair execution.
\begin{definition}[Arising Program Configuration]
\label{def:arising}
For internal module $M_1$ and external module $M_2$, a program configuration $\sigma$ is 
said to be an arising configuration ($\arising{M_1}{M_2}{\sigma}$)
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$\reductions{M_1}{M_2}{\sigma_0}{\sigma}$
\end{definition}
Definition \ref{def:arising} uses the definition for \emph{Initial} configurations 
the definition of which can be found in Definition \ref{def:initial}. Informally, 
an initial configuration, heap of which contains a single object of class \prg{Object}, and
the stack consists of a single frame, where the local variable map contains only the 
mapping of \prg{this} to the single object, and the continuation is some statement
to be executed.

%Finally, we assume that there is some type system defined for \Loo that enforces 
%two encapsulation properties:
%\begin{itemize}
%\item
%Classes may be optionally annotated as \enclosed, and objects of \enclosed classes
%may not be returned as method results from non-\enclosed objects
%\item
%Ghost fields may be optionally annotated as \prg{intrnl}, meaning only references to objects 
%internal to the defining module may be used in the definition of that ghost field.
%\end{itemize}
%We do not define this type system for two reasons: (1) such a type system is fairly straightforward
%in it's definition, and largely orthogonal to the central topic of this paper, and (2) while we
%specify a type system, we are only interested in the encapsulation properties that it affords,
%and there are several other equally appropriate mechanisms able to provide such encapsulation 
%properties.


\subsection{\Chainmail}
\Chainmail extends expressiveness of standard specification languages
with assertion forms capturing key concepts of software security:
 \emph{permission}, \emph{viewpoint}, and \emph{control}.
%That is, \Chainmail specifications are able to specify which objects have
%access to which other object (\emph{permission}), whether an object's origin
%is internal or external to known code (\emph{viewpoint}), or which objects call which 
%methods (\emph{control}). 

\subsubsection{Syntax}

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{A}{\Chainmail Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{x}{y}}
				{\internal{x}}
				{\external{x}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\calls{x}{y}{m}{\overline{z}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Chainmail Assertions}
\label{f:chainmail-syntax}
\end{figure}

Fig. \ref{f:chainmail-syntax} gives the assertion syntax of the \Chainmail specification language.
An assertion may be an expression, a class assertion, the usual connectives and quantifiers, along 
with several non-standard assertion forms:
\begin{itemize}
\item
\emph{Permission} ($\access{x}{y}$): Which objects have access to which other objects (i.e. $x$ has access to $y$).
\item
\emph{Viewpoint} ($\internal{x}$ and $\external{y}$): Which objects are internal or external to our component.
\item
\emph{Control} ($\calls{x}{m}{y}{\overline{z}}$): Which objects call which functions on which other objects. 
\end{itemize}

\subsubsection{Semantics}
The semantics of \Chainmail assertions is given in Definition \ref{def:chainmail-semantics}. 
The definition of the semantics of \Chainmail makes use of several language features of 
\Loo that can be found in Appendix \ref{app:loo}. Specifically, $\eval{M}{\sigma}{e}{v}$
is the evaluation relation for expressions, and is interpreted as expression $e$ evaluates
to value $v$ in the context of program configuration $\sigma$, with module $M$. The full
semantics of expression evaluation are given in Fig. \ref{f:evaluation}. It should 
be noted that expressions in \Loo may be recursively defined, and thus evaluation may not
necessarily terminate, however the logic remains classical because recursion is restricted
to expressions, and not generally to assertions.

Further, Definition \ref{def:chainmail-semantics} uses the interpretation of variables
within a specific frame or configuration: i.e. $\interpret{\phi}{x} = v$, meaning that $x$ maps to
value $v$ in the local variable map of frame $\phi$, and $\interpret{\sigma}{x} = v$ meaning $x$ 
maps to value $v$ in the top most frame of $\sigma$'s stack.
\begin{definition}[Satisfaction of \Chainmail Assertions] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a program configuration $\sigma$ with internal module $M$ as:
\begin{itemize}
\item
$\satisfiesA{M}{\sigma}{e}$ iff $\eval{M \circ M'}{\sigma}{e}{\true}$
\item
$\satisfiesA{M}{\sigma}{e : C}$ iff $\eval{M \circ M'}{\sigma}{e}{\alpha}$ \textit{and} $\class{\sigma}{\alpha} = C$
\item
$\satisfiesA{M}{\sigma}{\neg A}$ iff $\notsatisfies{M}{M'}{\sigma}{A}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \wedge\ A_2}$ iff $\satisfiesA{M}{\sigma}{A_1}$ and 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \vee\ A_2}$ iff $\satisfiesA{M}{\sigma}{A_1}$ or 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{\all{x}{A}}$ iff 
$\satisfiesA{M}{\sigma'}{A}$,\\
where $x$ is fresh in $\sigma$ and $\sigma' = \sigma[x \mapsto \alpha]$
for all $\alpha \in \sigma.\prg{heap}$
\item
$\satisfiesA{M}{\sigma}{\ex{x}{A}}$ iff 
$\satisfiesA{M}{\sigma}{A}$ \\
where $x$ is fresh in $\sigma$ and $\sigma' = \sigma[x \mapsto \alpha]$
for some $\alpha \in \sigma.\prg{heap}$
\item
$\satisfiesA{M}{\sigma}{\access{x}{y}}$ iff 
\begin{itemize}
\item
$\exists\ f$ such that $\interpret{\sigma}{x.f}={\interpret{\sigma}{y}}$ or
\item
there exists some $\phi$ in the stack of $\sigma$ such that $\interpret{\phi}{x}=\interpret{\phi}{\prg{this}}$ 
and there exists $z$ such that $\interpret{\phi}{y}=\interpret{\phi}{z}$
\end{itemize}
\item
$\satisfiesA{M}{\sigma}{\internal{x}}$ iff 
$\textit{classOf}(\sigma,x) \in M$
\item
$\satisfiesA{M}{\sigma}{\external{x}}$ iff 
$\textit{classOf}(\sigma,x) \not\in M$
\item
$\satisfiesA{M}{\sigma}{\calls{x}{y}{m}{z_1, \ldots, z_n}}$ iff
\begin{itemize}
\item
$\sigma.\prg{contn} = (\_ := y'.m(z'_1,\ldots,z'_n))$ and 
\item
$\interpret{\sigma}{x} = \interpret{\sigma}{\prg{this}}$ and
\item
$\interpret{\sigma}{x} = \interpret{\sigma}{\prg{this}}$ and
\item
$\interpret{\sigma}{z_i} = \interpret{\sigma}{z'_i}$ for all $1 \leq i \leq n$
\end{itemize}
\end{itemize}
\end{definition}

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \prg{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \prg{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \prg{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \prg{int} & \\
%%	| & \prg{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection{Necessity Specifications}
\label{s:holistic-guarantees}

In this Section we define syntactic forms and semantics of
\emph{Necessity Specifications}. Fig. \ref{f:holistic-syntax} 
gives the syntax.
We express satisfaction of Necessity Specifications as $\satisfies{M}{H}$.
That is, a module $M$ satisfies a necessity specification $H$. This allows 
the construction of proofs without considering either the details 
of the program configuration or the external client module.

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{H}{Necessity Specification}
		{
		\syntaxline
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Syntax for Necessity Specifications}
\label{f:holistic-syntax}
\end{figure}

\paragraph{Only If}
[$\onlyIf{A_1}{A_2}{A}$]: If an arising program configuration starts at some state $A_1$, and reaches some state $A_2$, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account's password.

\paragraph{Single-Step Only If}
[$\onlyIfSingle{A_1}{A_2}{A}$]: If an arising program configuration starts at some state $A_1$, and reaches some state $A_2$ after a single execution step, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the bank \prg{transfer} method.

\paragraph{Only Through}
[$\onlyThrough{A_1}{A_2}{A}$]: If an arising program configuration starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.
e.g. if the balance of an account changes over time, then the bank's \prg{transfer} method must have been called 
in some intermediate state. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
or final state ($\sigma_2$). 

We define the semantics of the Necessity Specifications in Definition \ref{def:necessity-semantics}.
\begin{definition}[Necessity Specifications]
\label{def:necessity-semantics}
For all, $A_1$, $A_2$, and $A$ we have \\
$\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ iff for all $M'$, $\sigma$, and $\sigma'$ such that $\arising{M}{M'}{\sigma}$, and\\
\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$then $\satisfiesA{M}{\sigma}{A}$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma'}{A_2}$   \\
$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 
$\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$ iff for all $M'$, $\sigma$, and $\sigma'$ such that $\arising{M}{M'}{\sigma}$, and \\
\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$then $\satisfiesA{M}{\sigma}{A}$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma'}{A_2}$   \\
$\;\;\;\;$- $\reduction{M}{M'}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 
$\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ iff for all $M'$, $\sigma$, and $\sigma'$ such that $\arising{M}{M'}{\sigma}$, and \\
\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & 
\rdelim\}{3}{3mm}%[\makecell{Some really \\ longer text}]
[$\;\;\;\Rightarrow\;\;\;$\pbox{9cm}{then for all $\sigma_1, \ldots, \sigma_n$ such that $\reduction{M}{M'}{\sigma}{\sigma_1}\leadsto \ldots \sigma_n \leadsto \sigma'$
there exists some $\sigma_i$ such that $\satisfiesA{M}{\sigma_i}{A}$ where $0\leq i \leq n$, or $\satisfiesA{M}{\sigma}{A}$, or $\satisfiesA{M}{\sigma'}{A}$}] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma'}{A_2}$   \\
$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 
\end{definition} 

%\begin{definition}[\textsc{Only If Single-Step}]
%\label{def:oi-single}
%$\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$ if and only if for all
%$M'$, $\sigma_1$, and $\sigma_2$, such that 
%\begin{itemize}
%\item
%$\arising{M}{\sigma_1}$,
%\item
%$\satisfiesA{M}{\sigma_1}{A_1}$,
%\item
%$\satisfiesA{M}{\sigma_2}{A_2}$, and
%\item
%$\reduction{M}{M'}{\sigma_1}{\sigma_2}$
%\end{itemize}
%then $\satisfiesA{M}{\sigma_1}{A}$
%\end{definition}
%
%\begin{definition}[\textsc{Only Through}]
%\label{def:ot}
%$\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ if and only if for all
%$M'$, $\sigma_1$, and $\sigma_2$, such that 
%\begin{itemize}
%\item
%$\arising{M}{\sigma_1}$,
%\item
%$\satisfiesA{M}{\sigma_1}{A_1}$,
%\item
%$\satisfiesA{M}{\sigma_2}{A_2}$, and
%\item
%$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
%\end{itemize}
%then there exists $\sigma,$ such that
%\begin{itemize}
%\item
%$\reductions{M}{M'}{\sigma_1}{\sigma}$,
%\item
%$\reductions{M}{M'}{\sigma}{\sigma_2}$,
%\item
%$\satisfiesA{M}{M'}{\sigma}{A}$.
%\end{itemize}
%\end{definition}

\subsection{Encapsulation}
In order to reason about necessary requirements in an open world,
we differentiate between those assertions that require computation
by internal, known code, and those assertions that may change due 
to computation by external, unknown code.

\begin{definition}[Assertion Encapsulation]
\label{def:encapsulation}
For an internal module $M$ and assertion $A$, we define an assertion $A'$ as being 
encapsulated, written $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program configurations $\sigma$ and $\sigma'$
such that 
\begin{itemize}
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$ and 
\item
$\satisfiesA{M}{\sigma}{A}$ and
\item
$\satisfiesA{M}{\sigma}{A'}$ and
\item
$\satisfiesA{M}{\sigma'}{\neg A'}$
\end{itemize}
then there exists some $x$, $m$, $\overline{z}$ such that
$\satisfiesA{M}{\sigma}{\calls{\_}{x}{m}{\overline{v}}\ \wedge\ \internal{x}}$
\end{definition}