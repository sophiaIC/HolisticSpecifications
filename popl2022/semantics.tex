\section{Semantics of \Chainmail}
\label{s:semantics}

\subsection{\Loo}
We introduce a simple object-oriented language called \Loo upon 
which our specification language sits. \Loo is a typical, imperative,
class based, object oriented language, where a program $\sigma$ consists of a 
heap $\chi$, and a frame stack $\psi$. A frame $\phi$ consists of
local variable map, and sequence of statements to be executed called 
a continuation. A statement may create new objects and push them to the heap, 
perform field reads and writes on objects, and call methods on those objects. 
Program execution is performed in the context of a module which is a mapping
of class names to class definitions. Given the simplicity of \Loo, we do not
define \Loo here, rather we direct the reader to Appendix \ref{app:loo}

\subsection{\Chainmail}
\Chainmail extends expressiveness of standard specification languages
with assertion forms capturing \emph{permission}, \emph{viewpoint}, and \emph{control}.
That is, \Chainmail specifications are able to specify which objects have
access to which other object (\emph{permission}), whether an object's origin
is internal or external to known code (\emph{viewpoint}), or which objects call which 
methods (\emph{control}). Chainmail \cite{FASE} 
is also able to express specifications of these forms, however we have improved
upon these specification forms by considerably simplifying their semantics.
We do however exclude several assertion forms that \citeauthor{FASE} does include, 
namely \emph{space} and \emph{time}. We are still are able to model some
of the expressiveness of the temporal operators of \citeauthor{FASE} by
introducing our novel Necessity Logic, the core contribution of this paper.

\subsubsection{Syntax}

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{A}{\Chainmail Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{\alpha_1}{\alpha_2}}
				{\internal{\alpha}}
				{\external{\alpha}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Chainmail Assertions}
\label{f:chainmail-syntax}
\end{figure}

Figure \ref{f:chainmail-syntax} gives the assertion syntax of the \Chainmail specification language.
An assertion may be an expression, a class assertion, the usual connectives and quantifiers, along 
with several non-standard assertion forms:
\begin{itemize}
\item
\emph{Permission} ($\access{\alpha_1}{\alpha_2}$): Which objects have access to which other objects (i.e. $\alpha_1$ has access to $\alpha_2$).
\item
\emph{Viewpoint} ($\internal{\alpha}$ and $\external{\alpha}$): Which objects are internal or external to our component.
\item
\emph{Control} ($\calls{\alpha_1}{m}{\alpha_2}{\overline{v}}$): Which objects call which functions on which other objects. 
\end{itemize}

\subsubsection{Semantics}
The semantics of \Chainmail assertions is given in Def. \ref{def:chainmail-semantics}.
\begin{definition}[Satisfaction of \Chainmail Assertions] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a program configuration $\sigma$ with internal module $M$ and external module $M'$ as:
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{e}$ iff $\eval{M \circ M'}{\sigma}{e}{\true}$
\item
$\satisfiesA{M}{M'}{\sigma}{e : C}$ iff $\eval{M \circ M'}{\sigma}{e}{\alpha}$ \textit{and} $\textit{classOf}(\sigma, \alpha) = C$
\item
$\satisfiesA{M}{M'}{\sigma}{\neg A}$ iff $\notsatisfies{M}{M'}{\sigma}{A}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \wedge\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ and 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \vee\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ or 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{\all{x}{A}}$ iff 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$,
$\forall \alpha \in \sigma.(\texttt{heap})$
\item
$\satisfiesA{M}{M'}{\sigma}{\ex{x}{A}}$ iff 
$\exists \alpha \in \sigma.(\texttt{heap})$ such that 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$
\item
$\satisfiesA{M}{M'}{\sigma}{\access{\alpha_1}{\alpha_2}}$ iff 
\begin{itemize}
\item
$\exists\ o,\ f$ such that $[\alpha_1\ \mapsto\ o]\ \in\ \sigma.(\texttt{heap})$ and $[f\ \mapsto\ \alpha_2]\ \in\ o.(\texttt{flds})$ or
\item
$\exists\ \phi,\ x$ such that $\phi \in \sigma.(\texttt{stack})$ and $[x\ \mapsto\ \alpha_2]\in\phi.(\texttt{local})$ and $[\texttt{this}\ \mapsto\ \alpha_1]\in\phi.(\texttt{local})$
\end{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{\internal{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\external{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \not\in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\calls{\alpha_1}{\alpha_2}{m}{v_1, \ldots, v_n}}$ iff
\begin{itemize}
\item
$\sigma.(\texttt{contn} = x := y.m(z_1,\ldots,z_n))$ and 
\item
$[\texttt{this}\mapsto \alpha_1]\in\sigma.(\texttt{local})$ and
\item
$[y\mapsto \alpha_2]\in\sigma.(\texttt{local})$ and
\item
$[z_i\mapsto v_i]\in\sigma.(\texttt{local})$ for all $1 \leq i \leq n$
\end{itemize}
\end{itemize}
\end{definition}

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \texttt{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \texttt{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \texttt{int} & \\
%%	| & \texttt{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection{Holistic Guarantees}
\label{s:holistic-guarantees}

\Chainmail generalizes holistic properties about internal data 
across execution. To do this we define syntactic forms for 
\emph{Necessity Specifications} in Fig. \ref{f:holistic-syntax}.
We express provability of satisfaction of Necessity Specifications as $\satisfies{M}{H}$.
That is, a module $M$ satisfies a necessity specification $H$. This allows 
the construction of proofs without considering either the details 
of the program configuration or the external client module.

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{H}{Necessity Specification}
		{
		\syntaxline
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Syntax for Necessity Specifications}
\label{f:holistic-syntax}
\end{figure}

\subsubsection{Only If}
[$\onlyIf{A_1}{A_2}{A}$]: If program execution starts at some state $A_1$, and reaches some state $A_2$, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account's password.

We give the definition of ``only if'' in Def. \ref{def:oi}.
\begin{definition}[Necessary Specifications]
\label{def:oi}
$\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition} 

\subsubsection{Single-Step Only If}
[$\onlyIfSingle{A_1}{A_2}{A}$]: If program execution starts at some state $A_1$, and reaches some state $A_2$ after a single execution step, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the bank \prg{transfer} method.

We give the definition of ``single-step only if'' in Def. \ref{def:oi-single}.
\begin{definition}[\textsc{Only If Single-Step}]
\label{def:oi-single}
$\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\textit{Arising}(M, M', \sigma_1)$
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reduction{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition}

\subsubsection{Only Through}
[$\onlyThrough{A_1}{A_2}{A}$]: If a program execution starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.\\
e.g.if the balance of an account changes over time, then the bank's \prg{transfer} method must have been called 
in some intermediate state.
We give the definition of ``only  through'' in Def. \ref{def:ot}. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
or final state ($\sigma_2$). 

\begin{definition}[\textsc{Only Through}]
\label{def:ot}
$\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\exists\ \sigma,$ such that
\begin{itemize}
\item
$\reductions{M}{M'}{\sigma_1}{\sigma}$
\item
$\reductions{M}{M'}{\sigma}{\sigma_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A}$
\end{itemize}
\end{definition}

\subsection{Encapsulation}
In order to reason about necessary requirements in an open world,
we differentiate between those assertions that require computation
by internal, known code, and those assertions that may change due 
to computation by external, unknown code.

\begin{definition}[Encapsulation]
\label{def:encapsulation}
For an internal module $M$ and assertion $A$, we define an assertion $A'$ as being 
encapsulated, written $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program configurations $\sigma$ and $\sigma'$
such that 
\begin{itemize}
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$ and 
\item
$\satisfiesA{M}{M'}{\sigma}{A}$ and
\item
$\satisfiesA{M}{M'}{\sigma}{A'}$ and
\item
$\satisfiesA{M}{M'}{\sigma'}{\neg A'}$
\end{itemize}
then there exists some $\alpha$, $m$, $\overline{v}$ such that
$\satisfiesA{M}{M'}{\sigma}{\calls{\_}{\alpha}{m}{\overline{v}}\ \wedge\ \internal{\alpha}}$
\end{definition}