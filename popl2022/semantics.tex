\section{Semantics}

\subsection{\Loo}

\begin{figure}[t]
\[
\begin{syntax}
\syntaxID{x, y, z}{Variable}
\syntaxID{C, D}{Class Id.}
\syntaxID{f}{Field Id.}
\syntaxID{g}{Ghost Field Id.}
\syntaxID{m}{Method Id.}
\syntaxID{\alpha}{Address Id.}
\syntaxInSet{i}{\IntSet}{Integer}
\syntaxElement{v}{Value}
		{
		\syntaxline
				{\alpha}
				{i}
				{\true}
				{\false}
				{\nul}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{e}{Expression}
		{
		\syntaxline
				{x}
				{v}
				{e + e}
				{e = e}
		\endsyntaxline
		}
		{
		\syntaxline
				{\texttt{if}\ e\ \texttt{then}\ e\ \texttt{else}\ e}
				{e.f}
				{e.g(e)}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{o}{Object}
		{\{\texttt{class}:=C;\ \texttt{flds}:=\overline{f \mapsto v} \}}
\endSyntaxElement\\
\syntaxElement{s}{Statement}
		{
		\syntaxline
				{x:=y.f}
				{x.f:=y}
				{x:=y.m(\overline{z})}
		\endsyntaxline
		}
		{
		\syntaxline
				{\new{C}{\overline{x}}}
				{\return{x}}
				{s;\ s}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{\chi}{Heap}
		{\overline{\alpha \mapsto o}}
\endSyntaxElement\\
\syntaxElement{\phi}{Frame}
		{\{\texttt{local}:=\overline{x\mapsto v};\ \texttt{contn}:=s\}}
\endSyntaxElement\\
\syntaxElement{\psi}{Stack}
		{\syntaxline{\phi}{\phi : \psi}\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{\sigma}{Program Config.}
		{(\texttt{heap}:=\chi,\texttt{stack}:=\psi)}
\endSyntaxElement\\
\syntaxElement{mth}{Method Def.}
		{
		\texttt{method}\ m\ (\overline{x})\{\ s\ \}
		}
\endSyntaxElement\\
\syntaxElement{fld}{Field Def.}
		{\syntaxline
			{\texttt{field}\ f\ :\ C}
			{\texttt{field}\ \texttt{intrnl}\ f\ :\ C}
		\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{gfld}{Ghost Field Def.}
		{\syntaxline
			{\texttt{ghost}\ g\ (x)\{\ e\ \}}
			{\texttt{ghost}\ \texttt{intrnl}\ g\ (x)\{\ e\ \}}
		\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{E}{Class Encapsulation}
		{\syntaxline{\texttt{internal}}{\texttt{boundary}}\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{ClassDef}{Class Def.}
		{
		E\ \texttt{class}\ C\ \{\ \texttt{flds}:=\overline{f};\ \texttt{gflds}:=\overline{gfld};\ \texttt{mths}:=\overline{mth}\ \}
		}
\endSyntaxElement\\
\syntaxElement{Mdl}{Module Def.}
		{
		\syntaxline{\overline{C\ \mapsto\ ClassDef}}\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Loo Syntax}
\label{f:loo-syntax}
\end{figure}

The \Loo syntax is given in Figure \ref{f:loo-syntax}, and is largely unchanged from
that of \citeauthor{FASE}. What does differ is the class annotation $E$ for encapsulation.
Classes can be annotated as either \texttt{internal} or \texttt{boundary}, and we assume 
that the type system enforces some guarantees about aliasing of \texttt{internal} classes,
specifically that \texttt{internal} classes may only be initialized by module internal objects,
and instances of classes annotated as \texttt{boundary} may not return \texttt{internal} 
objects. This is a straightforward property that is a simple extension to a type system, and
is assumed here only to elide language features that do not fall in the bounds of this paper.
It is conceivable that any other of a number encapsulation mechanisms could be used from
prior language designs that have already been studied. To accompany this, \Loo also includes
an optional annotation on ghost fields \texttt{intrnl} that enforces the requirement that 
the body of the ghost field includes only references to obejcts that are defined by the internal 
module. The semantics of \Loo are unchanged from
that of \cite{FASE}, and are given in Appendix \ref{app:Loo}.

\subsection{\Chainmail}

\subsubsection{Syntax}

\begin{figure}[t]
\[
\begin{syntax}
\syntaxElement{A}{\Chainmail Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{\alpha_1}{\alpha_2}}
				{\internal{\alpha}}
				{\external{\alpha}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Chainmail Assertions}
\label{f:chainmail-syntax}
\end{figure}

Figure \ref{f:chainmail-syntax} gives the syntax of \Chainmail used in this paper.
The syntax is a modified, and largely simplified version of the syntax of \cite{FASE}.

\subsubsection{Semantics}
\begin{definition}[Satisfaction of \Chainmail Assertions] 
We define satisfaction of an assertion $A$ by a program configuration $\sigma$ with internal module $M$ and external module $M'$ as:
\begin{itemize}
\item
$M;\ M',\ \sigma\ \vDash\ e$ iff $M \circ M',\ \sigma\ \vdash\ e\ \hookrightarrow \true$
\item
$M;\ M',\ \sigma\ \vDash\ e : C$ iff $M \circ M',\ \sigma\ \vdash\ e\ \hookrightarrow \alpha$ \textit{and} $\textit{classOf}(\sigma, \alpha) = C$
\item
$M;\ M',\ \sigma\ \vDash\ \neg A$ iff $M;\ M',\ \sigma\ \not\vDash\ A$
\item
$M;\ M',\ \sigma\ \vDash\ A_1\ \wedge\ A_2$ iff $M;\ M',\ \sigma\ \vDash\ A_1$ and $M;\ M', \sigma\ \vDash\ A_2$
\item
$M;\ M',\ \sigma\ \vDash\ A_1\ \vee\ A_2$ iff $M;\ M',\ \sigma\ \vDash\ A_1$ or $M;\ M', \sigma\ \vDash\ A_2$
\item
$M;\ M',\ \sigma\ \vDash\ \all{x}{A}$ iff $\forall \alpha \in \sigma.(\texttt{heap})$ we have $M;\ M',\ \sigma\ \vDash\ [\alpha/x]A$
\item
$M;\ M',\ \sigma\ \vDash\ \ex{x}{A}$ iff $\exists \alpha \in \sigma.(\texttt{heap})$ such that $M;\ M',\ \sigma\ \vDash\ [\alpha/x]A$
\item
$M;\ M',\ \sigma\ \vDash\ \access{\alpha_1}{\alpha_2}$ iff 
\begin{itemize}
\item
$\exists\ o,\ f$ such that $[\alpha_1\ \mapsto\ o]\ \in\ \sigma.(\texttt{heap})$ and $[f\ \mapsto\ \alpha_2]\ \in\ o.(\texttt{flds})$ or
\item
$\exists\ \phi,\ x$ such that $\phi \in \sigma.(\texttt{stack})$ and $[x\ \mapsto\ \alpha_2]\in\phi.(\texttt{local})$ and $[\texttt{this}\ \mapsto\ \alpha_1]\in\phi.(\texttt{local})$
\end{itemize}
\item
$M;\ M',\ \sigma\ \vDash\ \internal{\alpha}$ iff $\textit{classOf}(\sigma,\alpha) = C$ and $C \in M$
\item
$M;\ M',\ \sigma\ \vDash\ \external{\alpha}$ iff $\textit{classOf}(\sigma,\alpha) = C$ and $C \not\in M$
\item
$M;\ M',\ \sigma\ \vDash\ \calls{\alpha_1}{\alpha_2}{m}{v_1, \ldots, v_n}$ iff
\begin{itemize}
\item
$\sigma.(\texttt{contn} = x := y.m(z_1,\ldots,z_n))$ and 
\item
$[\texttt{this}\mapsto \alpha_1]\in\sigma.(\texttt{local})$ and
\item
$[y\mapsto \alpha_2]\in\sigma.(\texttt{local})$ and
\item
$[z_i\mapsto v_i]\in\sigma.(\texttt{local})$ for all $1 \leq i \leq n$
\end{itemize}
\end{itemize}
\end{definition}

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \texttt{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \texttt{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \texttt{int} & \\
%%	| & \texttt{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection{Holistic Guarantees}
\label{s:holistic-guarantees}

\Chainmail generalizes holistic properties about internal data 
across execution. To do this we define syntactic forms for 
\emph{Holistic Guarantees} in Fig. \ref{f:holistic-syntax}.
We express provability of satisfaction of Holistic Guarantees as $M\ \vdash\ \mathcal{H}$.
That is, a module $M$ proves the satisfaction of holistic guarantee $\mathcal{H}$. This allows 
the construction of proofs without considering either the details 
of the program configuration or the external client module.

\begin{figure}[t]
\[
\begin{syntax}
\syntaxElement{\mathcal{H}}{Holistic Guarantee}
		{
		\syntaxline
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Syntax for Holistic Guarantees}
\label{f:holistic-syntax}
\end{figure}
\subsubsection{Only Through/Only If/Only-If Single}

\begin{enumerate}
\item
\emph{Only Through} [$\onlyThrough{A_1}{A_2}{A}$]: If a program execution starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.\\
e.g.if the balance of the bank account changes over time, then the paths connecting the two states must contain 
an intermediate program state where the balance is changed.
\item
\emph{Only If} [$\onlyIf{A_1}{A_2}{A}$]: If program execution starts at some $A_1$ state, and reaches some $A_2$ state, 
then the original program state must have also satisfied $A$.\\
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account.
\item
\emph{Single-Step Only If} [$\onlyIfSingle{A_1}{A_2}{A}$]: If program execution starts at some $A_1$ state, and reaches some $A_2$ state after a single execution step, 
then the original program state must have also satisfied $A$.\\
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the account.
\end{enumerate}

We give the definition of ``only  through'' in Def. \ref{def:ot}. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
or final state ($\sigma_2$). 
\begin{definition}[\textsc{Only Through}]
\label{def:ot}
$M \vDash\ \onlyThrough {A_1}{A_2}{A}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$M ; M', \sigma_1\ \vDash A_1$
\item
$M ; M', \sigma_2\ \vDash\ A_2$ and
\item
$M ; M'\ \bullet\ \sigma_1\ \leadsto^*\ \sigma_2$
\end{itemize}
then $\exists\ \sigma,$ such that
\begin{itemize}
\item
$\sigma\ =\ \sigma_1$ or $M ; M'\ \bullet\ \sigma_1\ \leadsto^*\ \sigma$
\item
$\sigma\ =\ \sigma_2$ or $M ; M'\ \bullet\ \sigma\ \leadsto^*\ \sigma_2$
\item
$M ; M',\ \sigma\ \vDash\ A$
\end{itemize}
\end{definition}

We give the definition of ``only if'' in Def. \ref{def:oi}.
\begin{definition}[\textsc{Only If}]
\label{def:oi}
$M \vDash\ \onlyIf {A_1}{A_2}{A}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$M ; M', \sigma_1\ \vDash A_1$
\item
$M ; M', \sigma_2\ \vDash\ A_2$ and
\item
$M ; M'\ \bullet\ \sigma_1\ \leadsto^*\ \sigma_2$
\end{itemize}
then $M ; M',\ \sigma_1\ \vDash\ A$
\end{definition} 

We give the definition of ``single-step only if'' in Def. \ref{def:oi-single}.
\begin{definition}[\textsc{Only If Single-Step}]
\label{def:oi-single}
$M \vDash\ \onlyIfSingle {A_1}{A_2}{A}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$M ; M', \sigma_1\ \vDash A_1$
\item
$M ; M', \sigma_2\ \vDash\ A_2$ and
\item
$M ; M'\ \bullet\ \sigma_1\ \leadsto\ \sigma_2$
\end{itemize}
then $M ; M',\ \sigma_1\ \vDash\ A$
\end{definition}

\subsection{Encapsulation}

\begin{definition}[Encapsulation]
For an internal module $M$, we define an assertion $A$ as being 
encapsulated, written $M\ \vDash \encaps{A}$, if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program configurations $\sigma$ and $\sigma'$
such that 
\begin{itemize}
\item
$M;\ M',\ \sigma\ \leadsto\ \sigma'$ and 
\item
$M;\ M',\ \sigma\ \vDash\ A$ and
\item
$M;\ M',\ \sigma'\ \vDash\ \neg A$
\end{itemize}
then there exists some $\sigma_1$, $\ldots$, $\sigma_n$ such that
\begin{itemize}
\item
$M \circ M',\ \sigma\ \leadsto\ \sigma_1\ \leadsto\ \ldots\ \leadsto\ \sigma_n\ \leadsto\ \sigma'$ where $n \geq 1$ and 
\item
$classOf(\texttt{this}, \sigma_i) \in M$ where $1 \leq i \leq n$
\end{itemize}
\end{definition}