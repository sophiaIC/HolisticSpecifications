\section{Semantics}

\subsection{\Loo}

\subsubsection{Syntax}

The syntax of \Loo is given in Fig. \ref{f:loo-syntax}.


\begin{figure}[t]
\[
\begin{syntax}
\syntaxID{x, y, z}{Variable}
\syntaxID{C, D}{Class Id.}
\syntaxElement{T}{Type}
		{
		\syntaxline
				{\_}
				{C}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxID{f}{Field Id.}
\syntaxID{g}{Ghost Field Id.}
\syntaxID{m}{Method Id.}
\syntaxID{\alpha}{Address Id.}
\syntaxInSet{i}{\IntSet}{Integer}
\syntaxElement{v}{Value}
		{
		\syntaxline
				{\alpha}
				{i}
				{\true}
				{\false}
				{\nul}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{e}{Expression}
		{
		\syntaxline
				{x}
				{v}
				{e + e}
				{e = e}
		\endsyntaxline
		}
		{
		\syntaxline
				{\texttt{if}\ e\ \texttt{then}\ e\ \texttt{else}\ e}
				{e.f}
				{e.g(e)}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{o}{Object}
		{\{\texttt{class}:=C;\ \texttt{flds}:=\overline{f \mapsto v} \}}
\endSyntaxElement\\
\syntaxElement{s}{Statement}
		{
		\syntaxline
				{x:=y.f}
				{x.f:=y}
				{x:=y.m(\overline{z})}
		\endsyntaxline
		}
		{
		\syntaxline
				{\new{C}{\overline{x}}}
				{\return{x}}
				{s;\ s}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{c}{Continuation}
		{
		\syntaxline
				{s}
				{x:=\bullet; s}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{\chi}{Heap}
		{\overline{\alpha \mapsto o}}
\endSyntaxElement\\
\syntaxElement{\phi}{Frame}
		{\{\texttt{local}:=\overline{x\mapsto v};\ \texttt{contn}:=c\}}
\endSyntaxElement\\
\syntaxElement{\psi}{Stack}
		{\syntaxline{\phi}{\phi : \psi}\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{\sigma}{Program Config.}
		{(\texttt{heap}:=\chi,\texttt{stack}:=\psi)}
\endSyntaxElement\\
\syntaxElement{mth}{Method Def.}
		{
		\texttt{method}\ m\ (\overline{x : T})\{\ s\ \}
		}
\endSyntaxElement\\
\syntaxElement{fld}{Field Def.}
		{\syntaxline
			{\texttt{field}\ f\ :\ T}
		\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{gfld}{Ghost Field Def.}
		{\syntaxline
			{\texttt{ghost}\ g\ (x : T)\{\ e\ \} : T}
			{\texttt{ghost}\ \texttt{intrnl}\ g\ (x : T)\{\ e\ \} : T}
		\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{E}{Class Annotation}
		{\syntaxline{\texttt{inside}}{\texttt{boundary}}\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{ClassDef}{Class Def.}
		{
		E\ \texttt{class}\ C\ \{\ \texttt{flds}:=\overline{fld};\ \texttt{gflds}:=\overline{gfld};\ \texttt{mths}:=\overline{mth}\ \}
		}
\endSyntaxElement\\
\syntaxElement{Mdl}{Module Def.}
		{
		\syntaxline{\overline{C\ \mapsto\ ClassDef}}\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Loo Syntax}
\label{f:loo-syntax}
\end{figure}

\subsubsection{Semantics}

We provide the definition of module linking in Def. \ref{def:linking}
\begin{definition}
\label{def:linking}
For all modules $M_1$ and $M_2$, if the domains of $M_1$ and $M_2$ are disjoint, 
we define the module linking function as $M_1\ \circ\ M_2\ \triangleq\ M_1\ \cup\ M_2$.
\end{definition}

We provide the definition of reference interpretation in Def. \ref{def:interpret}
\begin{definition}
For a program configuration $\sigma = (\chi, \phi : \psi)$, we provide the following function definitions:
\begin{itemize}
\item
$\interpret{\sigma}{x}\ \triangleq\ \phi.(\texttt{local})(x)$
\item
$\interpret{\sigma}{\alpha.f}\ \triangleq\ \chi(\alpha).(\texttt{flds})(f)$
\item
$\interpret{\sigma}{x.f}\ \triangleq\ \interpret{\sigma}{\alpha.f}$ where $\interpret{\sigma}{x}=\alpha$
\end{itemize}
\end{definition}

Definition Def. \ref{def:class-lookup} defines the class lookup function for \Loo.
\begin{definition}[Class Lookup]
\label{def:class-lookup}
For program configuration $\sigma = (\chi, \phi : \psi)$, class lookup is defined as 
$$\class{\sigma}{x}\ \triangleq\ \chi(\interpret{\sigma}{x}).(\texttt{class})$$
\end{definition}

Definition Def. \ref{def:meth-lookup} defines the method lookup function for \Loo.
\begin{definition}[Method Lookup]
\label{def:meth-lookup}
For module $M$, class $C$, and method name $m$, method lookup is defined as 
$$\meth{M}{C}{m}\ \triangleq\ M(C).\texttt{mths}(m)$$
\end{definition}

Fig. \ref{f:loo-semantics} gives the operational semantics of \Loo.

\begin{figure}[t]
\begin{mathpar}
\infer
	{
	\sigma_1 = (\chi, \phi_1 : \psi)\\
	\sigma_2 = (\chi, \phi_2 : \phi_1' : \psi)\\
	\phi_1.(\texttt{contn}) = (x := y.m(\overline{z}); s)\\
	\phi_1' = \phi_1[\texttt{contn} := (x := \bullet; s)]\\
	\meth{M}{\class{\sigma_1}{x}}{m} = m(\overline{p})\{body\}\\
	\phi_2 = \{\texttt{local}:= ([\texttt{this}\ \mapsto\ \interpret{\sigma_1}{x}]\overline{[p_i\ \mapsto\ \interpret{\sigma_1}{z_i}]}), \texttt{contn}:=body\}
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	\quad(\textsc{Call})
	\and
\infer
	{
	\sigma_1 = (\chi, \phi_1 : \psi) \\
	\sigma_2 = (\chi, \phi_2 : \psi) \\
	\phi_1.(\texttt{contn}) = (x := y.f; s)\\
	\interpret{\sigma_1}{x.f} = v \\
	\phi_2 = \{\texttt{local}:=\phi_1.(\texttt{local})[x\ \mapsto\ v],\ \texttt{contn}:=s\}
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	\quad(\textsc{Read})
	\and
\infer
	{
	\sigma_1 = (\chi_1, \phi_1 : \psi) \\
	\sigma_2 = (\chi_2, \phi_2 : \psi) \\
	\phi_1.(\texttt{contn}) = (x.f := y; s)\\
	\interpret{\sigma_1}{y} = v \\
	\phi_2 = \{\texttt{local}:=\phi_1.(\texttt{local}),\ \texttt{contn}:=s\}\\
	\chi_2 = \chi_1[\interpret{x}{\sigma_1}.f \mapsto\ v]
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	{}
	\quad(\textsc{Write})
	\and
\infer
	{
	\sigma_1 = (\chi, \phi : \psi) \\
	\phi.(\texttt{contn}) = (x := \texttt{new}\ C(\overline{z}); s)\\
	M(C).(\texttt{flds}) = \overline{\texttt{field}\ f : T} \\
	\sigma_2 = (\chi[\alpha\ \mapsto\ \{\texttt{class}:=C, \texttt{flds}:=\overline{f\ \mapsto\ \interpret{\sigma_1}{z}}\}], \phi[x\ \mapsto\ \alpha] : \psi)
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	\quad(\textsc{New})
	\and
\infer
	{
	\sigma_1 = (\chi, \phi_1 : \phi_2 : \psi) \\
	\phi_1.(\texttt{contn}) = (\texttt{return}\ x; s)\ \textit{or}\ \phi_1.(\texttt{contn}) = (\texttt{return}\ x)\\
	\phi_2.(\texttt{contn}) = (y := \bullet; s)\\
	\sigma_2 = (\chi, \phi_2[y\ \mapsto\ \interpret{\sigma_1}{x}] : \psi)
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	{}
	\quad(\textsc{Return})
\end{mathpar}
\caption{Operational Semantics of \Loo}
\label{f:loo-semantics}
\end{figure}

We give the semantics of module pair execution in Def. \ref{def:pair-reduce}
\begin{definition}[Module Pair Execution]
\label{def:pair-reduce}
For all internal modules $M_1$, external modules $M_2$, and program configurations $\sigma$ and $\sigma'$, 
we say that $\reduction{M_1}{M_2}{\sigma}{\sigma'}$ if and only if
\begin{itemize}
\item
$\class{\sigma}{\sigma.(\texttt{this})}\ \in\ M_2$ and
\item
$\class{\sigma'}{\sigma'.(\texttt{this})}\ \in\ M_2$ and 
\end{itemize} 
and
\begin{itemize}
\item
$\exec{M_1\ \circ\ M_2}{\sigma}{\sigma'}$ or
\item
$M_1\ \circ\ M_2,\ \sigma \leadsto\ \sigma_1\ \leadsto\ \ldots\ \sigma_n\ \leadsto \sigma'$ and $\class{\sigma_i}{\sigma_i.(\texttt{this})}\ \in\ M_1$ for all $1\ \leq\ i\ \leq\ n$
\end{itemize}
\end{definition}

Expression evaluation is given in Fig. \ref{f:evaluation}
\begin{figure}
\begin{mathpar}
\infer
		{}
		{\eval{M}{\sigma}{v}{v}}
		\quad(\textsc{E-Val})
		\and
\infer
		{}
		{\eval{M}{\sigma}{x}{\interpret{\sigma}{x}}}
		\quad(\textsc{E-Var})
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{i_1}\\
		\eval{M}{\sigma}{e_2}{i_2}\\
		i_1 + i_2 = i
		}
		{
		\eval{M}{\sigma}{e_1 + e_2}{i}
		}
		\quad(\textsc{E-Add})
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{v}\\
		\eval{M}{\sigma}{e_2}{v}
		}
		{
		\eval{M}{\sigma}{e_1 = e_2}{\true}
		}
		\quad(\textsc{E-Eq}_1)
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{v_1}\\
		\eval{M}{\sigma}{e_2}{v_2}\\
		v_1 \neq\ v_2
		}
		{
		\eval{M}{\sigma}{e_1 = e_2}{\false}
		}
		\quad(\textsc{E-Eq}_2)
		\and
\infer
		{
		\eval{M}{\sigma}{e}{\true}\\
		\eval{M}{\sigma}{e_1}{v}
		}
		{
		\eval{M}{\sigma}{\ifthenelse{e}{e_1}{e_2}}{v}
		}
		\quad(\textsc{E-If}_1)
		\and
\infer
		{
		\eval{M}{\sigma}{e}{\false}\\
		\eval{M}{\sigma}{e_2}{v}
		}
		{
		\eval{M}{\sigma}{\ifthenelse{e}{e_1}{e_2}}{v}
		}
		\quad(\textsc{E-If}_2)
		\and
\infer
		{
		\eval{M}{\sigma}{e}{\alpha}
		}
		{
		\eval{M}{\sigma}{e.f}{\interpret{\sigma}{\alpha.f}}
		}
		\quad(\textsc{E-Field})
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{\alpha}\\
		\eval{M}{\sigma}{e_2}{v'}\\
		\texttt{ghost}\ g(x : T)\{e\} : T'\ \in\ M(\class{\sigma}{\alpha}).(\texttt{gflds})\\
		\eval{M}{\sigma}{[v'/x]e}{v}
		}
		{
		\eval{M}{\sigma}{e_1.g(e_2)}{v}
		}
		\quad(\textsc{E-Ghost})
\end{mathpar}
\caption{\Loo expression evaluation}
\label{f:evaluation}
\end{figure}

\subsection{\Chainmail}

\subsubsection{Syntax}

\begin{figure}[t]
\[
\begin{syntax}
\syntaxElement{A}{\Chainmail Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{\alpha_1}{\alpha_2}}
				{\internal{\alpha}}
				{\external{\alpha}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Chainmail Assertions}
\label{f:chainmail-syntax}
\end{figure}

Figure \ref{f:chainmail-syntax} gives the syntax of the \Chainmail specification language used in this paper. \Chainmail 

\subsubsection{Semantics}
\begin{definition}[Satisfaction of \Chainmail Assertions] 
We define satisfaction of an assertion $A$ by a program configuration $\sigma$ with internal module $M$ and external module $M'$ as:
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{e}$ iff $\eval{M \circ M'}{\sigma}{e}{\true}$
\item
$\satisfiesA{M}{M'}{\sigma}{e : C}$ iff $\eval{M \circ M'}{\sigma}{e}{\alpha}$ \textit{and} $\textit{classOf}(\sigma, \alpha) = C$
\item
$\satisfiesA{M}{M'}{\sigma}{\neg A}$ iff $\notsatisfies{M}{M'}{\sigma}{A}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \wedge\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ and 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \vee\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ or 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{\all{x}{A}}$ iff 
$\forall \alpha \in \sigma.(\texttt{heap})$ we have 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$
\item
$\satisfiesA{M}{M'}{\sigma}{\ex{x}{A}}$ iff 
$\exists \alpha \in \sigma.(\texttt{heap})$ such that 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$
\item
$\satisfiesA{M}{M'}{\sigma}{\access{\alpha_1}{\alpha_2}}$ iff 
\begin{itemize}
\item
$\exists\ o,\ f$ such that $[\alpha_1\ \mapsto\ o]\ \in\ \sigma.(\texttt{heap})$ and $[f\ \mapsto\ \alpha_2]\ \in\ o.(\texttt{flds})$ or
\item
$\exists\ \phi,\ x$ such that $\phi \in \sigma.(\texttt{stack})$ and $[x\ \mapsto\ \alpha_2]\in\phi.(\texttt{local})$ and $[\texttt{this}\ \mapsto\ \alpha_1]\in\phi.(\texttt{local})$
\end{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{\internal{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\external{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \not\in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\calls{\alpha_1}{\alpha_2}{m}{v_1, \ldots, v_n}}$ iff
\begin{itemize}
\item
$\sigma.(\texttt{contn} = x := y.m(z_1,\ldots,z_n))$ and 
\item
$[\texttt{this}\mapsto \alpha_1]\in\sigma.(\texttt{local})$ and
\item
$[y\mapsto \alpha_2]\in\sigma.(\texttt{local})$ and
\item
$[z_i\mapsto v_i]\in\sigma.(\texttt{local})$ for all $1 \leq i \leq n$
\end{itemize}
\end{itemize}
\end{definition}

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \texttt{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \texttt{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \texttt{int} & \\
%%	| & \texttt{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection{Holistic Guarantees}
\label{s:holistic-guarantees}

\Chainmail generalizes holistic properties about internal data 
across execution. To do this we define syntactic forms for 
\emph{Holistic Guarantees} in Fig. \ref{f:holistic-syntax}.
We express provability of satisfaction of Holistic Guarantees as $\satisfies{M}{H}$.
That is, a module $M$ satisfies a holistic guarantee $H$. This allows 
the construction of proofs without considering either the details 
of the program configuration or the external client module.

\begin{figure}[t]
\[
\begin{syntax}
\syntaxElement{H}{Holistic Guarantee}
		{
		\syntaxline
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Syntax for Holistic Guarantees}
\label{f:holistic-syntax}
\end{figure}
\subsubsection{Only Through/Only If/Only-If Single}

\begin{enumerate}
\item
\emph{Only Through} [$\onlyThrough{A_1}{A_2}{A}$]: If a program execution starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.\\
e.g.if the balance of the bank account changes over time, then the paths connecting the two states must contain 
an intermediate program state where the balance is changed.
\item
\emph{Only If} [$\onlyIf{A_1}{A_2}{A}$]: If program execution starts at some $A_1$ state, and reaches some $A_2$ state, 
then the original program state must have also satisfied $A$.\\
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account.
\item
\emph{Single-Step Only If} [$\onlyIfSingle{A_1}{A_2}{A}$]: If program execution starts at some $A_1$ state, and reaches some $A_2$ state after a single execution step, 
then the original program state must have also satisfied $A$.\\
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the account.
\end{enumerate}

We give the definition of ``only  through'' in Def. \ref{def:ot}. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
or final state ($\sigma_2$). 
\begin{definition}[\textsc{Only Through}]
\label{def:ot}
$\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\exists\ \sigma,$ such that
\begin{itemize}
\item
$\reductions{M}{M'}{\sigma_1}{\sigma}$
\item
$\reductions{M}{M'}{\sigma}{\sigma_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A}$
\end{itemize}
\end{definition}

We give the definition of ``only if'' in Def. \ref{def:oi}.
\begin{definition}[\textsc{Only If}]
\label{def:oi}
$\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition} 

We give the definition of ``single-step only if'' in Def. \ref{def:oi-single}.
\begin{definition}[\textsc{Only If Single-Step}]
\label{def:oi-single}
$\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\textit{Arising}(M, M', \sigma_1)$
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reduction{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition}

\subsection{Encapsulation}
In order to reason about necessary requirements in an open world,
we differentiate between those assertions that require computation
by internal, known code, and those assertions that may change due 
to computation by external, unknown code.

\begin{definition}[Encapsulation]
\label{def:encapsulation}
For an internal module $M$ and assertion $A$, we define an assertion $A'$ as being 
encapsulated, written $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program configurations $\sigma$ and $\sigma'$
such that 
\begin{itemize}
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$ and 
\item
$\satisfiesA{M}{M'}{\sigma}{A}$ and
\item
$\satisfiesA{M}{M'}{\sigma}{A'}$ and
\item
$\satisfiesA{M}{M'}{\sigma'}{\neg A'}$
\end{itemize}
then there exists some $\alpha$, $m$, $\overline{v}$ such that
$\satisfiesA{M}{M'}{\sigma}{\calls{\_}{\alpha}{m}{\overline{v}}\ \wedge\ \internal{\alpha}}$
\end{definition}