\section{Semantics of \Chainmail}
\label{s:semantics}

\subsection{\Loo}
We introduce a simple object-oriented language, \Loo, upon 
which our specification language sits. \Loo is a typical, imperative,
class based, object oriented language. A \Loo program $\sigma$ consists of a 
heap $\chi$, and a frame stack $\psi$. A frame $\phi$ consists of
local variable map, and sequence of statements to be executed called 
a continuation. A statement may create new objects and push them to the heap, 
perform field reads and writes on objects, and call methods on those objects. 
Program execution is performed in the context of a module which is a mapping
of class names to class definitions. Given the simplicity of \Loo, we do not
define \Loo here, rather we direct the reader to Appendix \ref{app:loo} for 
the full syntax and operational semantics. There are several properties 
of \Loo that are important to the central topic of this paper. Firstly,
we define two forms of execution for \Loo, one in Fig. \ref{f:loo-semantics}
that is unsurprising and details the execution of specific 
statements in the language, and a second called \emph{module pair execution} 
that models that open world, where the components of a program can
have both known (\internalO) and unknown (\externalO) provenance.
\begin{definition}[Module Pair Execution]
\label{def:pair-reduce}
For all internal modules $M_1$, external modules $M_2$, and program configurations $\sigma$ and $\sigma'$, 
we say that $\reduction{M_1}{M_2}{\sigma}{\sigma'}$ if and only if
\begin{itemize}
\item
$\class{\sigma}{\sigma.\texttt{this}}\ \in\ M_2$ and
\item
$\class{\sigma'}{\sigma'.\texttt{this}}\ \in\ M_2$ and 
\end{itemize} 
%and
%\begin{itemize}
%\item
%$\exec{M_1\ \circ\ M_2}{\sigma}{\sigma'}$ or
%\item
$M_1\ \circ\ M_2,\ \sigma \leadsto\ \sigma_1\ \leadsto\ \ldots\ \sigma_n\ \leadsto \sigma'$ and $\class{\sigma_i}{\sigma_i.\texttt{this}}\ \in\ M_1$ for all $0\ \leq\ i\ \leq\ n$
%\end{itemize}
\end{definition}
The definition of module pair execution makes reference to a function
$\class{\sigma}{x}$ that is defined in Appendix \ref{app:loo}, and
is a class lookup function for a specific variable in a specific program.
Secondly, we reference module linking ($M_1\ \circ\ M_2$), a function
that results in the union of two disjoint modules.

An \emph{Initial} program configuration contains a single frame 
with a single local variable \prg{this} pointing to a single object 
in the heap of class \prg{Object}, and a continuation.
\begin{definition}[Initial Program Configuration]
\label{def:initial}
A program configuration $\sigma$ is said to be an initial configuration ($\initial{\sigma}$)
if and only if
\begin{itemize}
\item
$\sigma.\prg{heap} = [\alpha\ \mapsto\ \{\prg{class}:=\prg{Object};\ \prg{flds}:=\emptyset\}]$ and
\item
$\sigma.\prg{stack} = \{\prg{local}:=[\prg{this}\ \mapsto\ \alpha];\ \prg{contn}:= s\}$
\end{itemize} 
for some address $\alpha$ and some statement $s$.
\end{definition}

An \emph{Arising} program configuration is defined as any program configuration
that arises from some initial program configuration through module pair execution.
\begin{definition}[Arising Program Configuration]
\label{def:arising}
For internal module $M_1$ and external module $M_2$, a program configuration $\sigma$ is 
said to be an arising configuration ($\arising{M_1}{M_2}{\sigma}$)
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$\reductions{M_1}{M_2}{\sigma_0}{\sigma}$
\end{definition}

Finally, we assume that there is some type system defined for \Loo that enforces 
two encapsulation properties:
\begin{itemize}
\item
Classes may be optionally annotated as \enclosed, and objects of \enclosed classes
may not be returned as method results from non-\enclosed objects
\item
Ghost fields may be optionally annotated as \prg{intrnl}, meaning only references to objects 
internal to the defining module may be used in the definition of that ghost field.
\end{itemize}
We do not define this type system for two reasons: (1) such a type system is fairly straightforward
in it's definition, and largely orthogonal to the central topic of this paper, and (2) while we
specify a type system, we are only interested in the encapsulation properties that it affords,
and there are several other equally appropriate mechanisms able to provide such encapsulation 
properties.


\subsection{\Chainmail}
\Chainmail extends expressiveness of standard specification languages
with assertion forms capturing key concepts of software security:
 \emph{permission}, \emph{viewpoint}, and \emph{control}.
%That is, \Chainmail specifications are able to specify which objects have
%access to which other object (\emph{permission}), whether an object's origin
%is internal or external to known code (\emph{viewpoint}), or which objects call which 
%methods (\emph{control}). 

\subsubsection{Syntax}

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{A}{\Chainmail Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{\alpha_1}{\alpha_2}}
				{\internal{\alpha}}
				{\external{\alpha}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Chainmail Assertions}
\label{f:chainmail-syntax}
\end{figure}

Fig. \ref{f:chainmail-syntax} gives the assertion syntax of the \Chainmail specification language.
An assertion may be an expression, a class assertion, the usual connectives and quantifiers, along 
with several non-standard assertion forms:
\begin{itemize}
\item
\emph{Permission} ($\access{\alpha_1}{\alpha_2}$): Which objects have access to which other objects (i.e. $\alpha_1$ has access to $\alpha_2$).
\item
\emph{Viewpoint} ($\internal{\alpha}$ and $\external{\alpha}$): Which objects are internal or external to our component.
\item
\emph{Control} ($\calls{\alpha_1}{m}{\alpha_2}{\overline{v}}$): Which objects call which functions on which other objects. 
\end{itemize}

\subsubsection{Semantics}
The semantics of \Chainmail assertions is given in Definition \ref{def:chainmail-semantics}.
\begin{definition}[Satisfaction of \Chainmail Assertions] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a program configuration $\sigma$ with internal module $M$ and external module $M'$ as:
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{e}$ iff $\eval{M \circ M'}{\sigma}{e}{\true}$
\item
$\satisfiesA{M}{M'}{\sigma}{e : C}$ iff $\eval{M \circ M'}{\sigma}{e}{\alpha}$ \textit{and} $\textit{classOf}(\sigma, \alpha) = C$
\item
$\satisfiesA{M}{M'}{\sigma}{\neg A}$ iff $\notsatisfies{M}{M'}{\sigma}{A}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \wedge\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ and 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \vee\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ or 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{\all{x}{A}}$ iff 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$,
for all $\alpha \in \sigma.\texttt{heap}$
\item
$\satisfiesA{M}{M'}{\sigma}{\ex{x}{A}}$ iff 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$ for some 
$\alpha \in \sigma.\texttt{heap}$
\item
$\satisfiesA{M}{M'}{\sigma}{\access{\alpha_1}{\alpha_2}}$ iff 
\begin{itemize}
\item
$\exists\ o,\ f$ such that $[\alpha_1\ \mapsto\ o]\ \in\ \sigma.(\texttt{heap})$ and $[f\ \mapsto\ \alpha_2]\ \in\ o.(\texttt{flds})$ or
\item
$\exists\ \phi,\ x$ such that $\phi \in \sigma.(\texttt{stack})$ and $[x\ \mapsto\ \alpha_2]\in\phi.(\texttt{local})$ and $[\texttt{this}\ \mapsto\ \alpha_1]\in\phi.(\texttt{local})$
\end{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{\internal{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\external{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \not\in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\calls{\alpha_1}{\alpha_2}{m}{v_1, \ldots, v_n}}$ iff
\begin{itemize}
\item
$\sigma.(\texttt{contn} = x := y.m(z_1,\ldots,z_n))$ and 
\item
$[\texttt{this}\mapsto \alpha_1]\in\sigma.(\texttt{local})$ and
\item
$[y\mapsto \alpha_2]\in\sigma.(\texttt{local})$ and
\item
$[z_i\mapsto v_i]\in\sigma.(\texttt{local})$ for all $1 \leq i \leq n$
\end{itemize}
\end{itemize}
\end{definition}

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \texttt{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \texttt{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \texttt{int} & \\
%%	| & \texttt{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection{Necessity Specifications}
\label{s:holistic-guarantees}

In this Section we define syntactic forms and semantics of
\emph{Necessity Specifications}. Fig. \ref{f:holistic-syntax} 
gives the syntax.
We express satisfaction of Necessity Specifications as $\satisfies{M}{H}$.
That is, a module $M$ satisfies a necessity specification $H$. This allows 
the construction of proofs without considering either the details 
of the program configuration or the external client module.

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{H}{Necessity Specification}
		{
		\syntaxline
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Syntax for Necessity Specifications}
\label{f:holistic-syntax}
\end{figure}

\paragraph{Only If}
[$\onlyIf{A_1}{A_2}{A}$]: If an arising program execution starts at some state $A_1$, and reaches some state $A_2$, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account's password.

\paragraph{Single-Step Only If}
[$\onlyIfSingle{A_1}{A_2}{A}$]: If an arising program execution starts at some state $A_1$, and reaches some state $A_2$ after a single execution step, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the bank \prg{transfer} method.

\paragraph{Only Through}
[$\onlyThrough{A_1}{A_2}{A}$]: If an arising program execution starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.
e.g. if the balance of an account changes over time, then the bank's \prg{transfer} method must have been called 
in some intermediate state. We give the definition of ``only  through'' in Definition \ref{def:ot}. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
or final state ($\sigma_2$). 

We define the semantics of the Necessity Specifications in Definitions \ref{def:oi}, \ref{def:oi-single}, and \ref{def:ot}.
\begin{definition}[Only If]
\label{def:oi}
$\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ if and only if for all
$M'$, $\sigma_1$, and $\sigma_2$, such that 
\begin{itemize}
\item
$\arising{M}{M'}{\sigma_1}$,
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$,
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$, and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$.
\end{definition} 

\begin{definition}[\textsc{Only If Single-Step}]
\label{def:oi-single}
$\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$ if and only if for all
$M'$, $\sigma_1$, and $\sigma_2$, such that 
\begin{itemize}
\item
$\arising{M}{M'}{\sigma_1}$,
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$,
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$, and
\item
$\reduction{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition}

\begin{definition}[\textsc{Only Through}]
\label{def:ot}
$\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ if and only if for all
$M'$, $\sigma_1$, and $\sigma_2$, such that 
\begin{itemize}
\item
$\arising{M}{M'}{\sigma_1}$,
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$,
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$, and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then there exists $\sigma,$ such that
\begin{itemize}
\item
$\reductions{M}{M'}{\sigma_1}{\sigma}$,
\item
$\reductions{M}{M'}{\sigma}{\sigma_2}$,
\item
$\satisfiesA{M}{M'}{\sigma}{A}$.
\end{itemize}
\end{definition}

\subsection{Encapsulation}
In order to reason about necessary requirements in an open world,
we differentiate between those assertions that require computation
by internal, known code, and those assertions that may change due 
to computation by external, unknown code.

\begin{definition}[Encapsulation]
\label{def:encapsulation}
For an internal module $M$ and assertion $A$, we define an assertion $A'$ as being 
encapsulated, written $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program configurations $\sigma$ and $\sigma'$
such that 
\begin{itemize}
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$ and 
\item
$\satisfiesA{M}{M'}{\sigma}{A}$ and
\item
$\satisfiesA{M}{M'}{\sigma}{A'}$ and
\item
$\satisfiesA{M}{M'}{\sigma'}{\neg A'}$
\end{itemize}
then there exists some $\alpha$, $m$, $\overline{v}$ such that
$\satisfiesA{M}{M'}{\sigma}{\calls{\_}{\alpha}{m}{\overline{v}}\ \wedge\ \internal{\alpha}}$
\end{definition}