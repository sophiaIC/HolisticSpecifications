\section{Semantics of \Chainmail}
\label{s:semantics}

\subsection{\Loo}

We introduce \Loo, a simple, typed, class-based, object oriented language that underlies the necessary specifications
introduced in this paper. \Loo includes ghost fields, recursive definitions that may only be
used in the specification language.
While typed, we do not define \Loo's
full type system, however we assume several properties enforced by the type system, including 
simple ownership properties:
\begin{itemize}
\item
Method calls may not be made to external, non-library methods.
\item
Classes may be annotated as \texttt{inside} or \texttt{boundary}, and objects of \texttt{inside} classes may not be returned by methods of \texttt{boundary} classes.
\item
Ghost fields may be annotated as \texttt{intrnl} and thus may only include and be passed references to objects belonging to module internal classes.
\end{itemize}
These encapsulation properties are easily enforceable, and we
do not define the type system as ownership types have been 
well covered in the literature. 
We specifically use a simple ownership system to model 
encapsulation as the theory has been well established by others, 
however there is no reason other encapsulation mechanisms could 
not be substituted without affecting the Necessity Logic that 
is the central contribution of this paper.

\subsubsection{\Loo Syntax}
The syntax of \Loo is given in Fig. \ref{f:loo-syntax}.
\Loo modules ($M$) map class names ($C$) to class definitions ($\textit{ClassDef}$).
A class definition consists of a list of a class annotation ($\texttt{inside}$ or $\texttt{boundary}$),
a list of field definitions, ghost field definitions, and method definitions.
A program configuration ($\sigma$) is represented as a heap ($\chi$), stack ($\psi$) pair, 
where a heap is a map from addresses ($\alpha$) to objects ($o$), and a stack is a non-empty list of frames ($\phi$). A frame consists of a local variable
map and a continuation ($c$) that represents the statements that are yet to be executed ($s$),
or a hole waiting to be filled by a method return in the frame above ($x := \bullet; s$).
A statement is either a field read ($x := y.f$), a field write ($x.f := y$), a method call
($x := y.m(\overline{z})$), a constructor call ($\texttt{new}\ C(\overline{x})$), a method return statement
($\texttt{return}\ x$), or a sequence of statements ($s;\ s$).

\Loo also includes syntax for expressions $e$ that may only be used in writing
specifications or the definition of ghost fields.


\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxID{x, y, z}{Variable}
\syntaxID{C, D}{Class Id.}
\syntaxElement{T}{Type}
		{
		\syntaxline
				{\_}
				{C}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxID{f}{Field Id.}
\syntaxID{g}{Ghost Field Id.}
\syntaxID{m}{Method Id.}
\syntaxID{\alpha}{Address Id.}
\syntaxInSet{i}{\IntSet}{Integer}
\syntaxElement{v}{Value}
		{
		\syntaxline
				{\alpha}
				{i}
				{\true}
				{\false}
				{\nul}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{e}{Expression}
		{
		\syntaxline
				{x}
				{v}
				{e + e}
				{e = e}
		\endsyntaxline
		}
		{
		\syntaxline
				{\texttt{if}\ e\ \texttt{then}\ e\ \texttt{else}\ e}
				{e.f}
				{e.g(e)}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{o}{Object}
		{\{\texttt{class}:=C;\ \texttt{flds}:=\overline{f \mapsto v} \}}
\endSyntaxElement\\
\syntaxElement{s}{Statement}
		{
		\syntaxline
				{x:=y.f}
				{x.f:=y}
				{x:=y.m(\overline{z})}
		\endsyntaxline
		}
		{
		\syntaxline
				{\new{C}{\overline{x}}}
				{\return{x}}
				{s;\ s}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{c}{Continuation}
		{
		\syntaxline
				{s}
				{x:=\bullet; s}
		\endsyntaxline
		}
\endSyntaxElement\\
\syntaxElement{\chi}{Heap}
		{\overline{\alpha \mapsto o}}
\endSyntaxElement\\
\syntaxElement{\phi}{Frame}
		{\{\texttt{local}:=\overline{x\mapsto v};\ \texttt{contn}:=c\}}
\endSyntaxElement\\
\syntaxElement{\psi}{Stack}
		{\syntaxline{\phi}{\phi : \psi}\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{\sigma}{Program Config.}
		{(\texttt{heap}:=\chi,\texttt{stack}:=\psi)}
\endSyntaxElement\\
\syntaxElement{mth}{Method Def.}
		{
		\texttt{method}\ m\ (\overline{x : T})\{\ s\ \}
		}
\endSyntaxElement\\
\syntaxElement{fld}{Field Def.}
		{\syntaxline
			{\texttt{field}\ f\ :\ T}
		\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{gfld}{Ghost Field Def.}
		{\syntaxline
			{\texttt{ghost}\ g\ (x : T)\{\ e\ \} : T}
			{\texttt{ghost}\ \texttt{intrnl}\ g\ (x : T)\{\ e\ \} : T}
		\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{An}{Class Annotation}
		{\syntaxline{\texttt{inside}}{\texttt{boundary}}\endsyntaxline}
\endSyntaxElement\\
\syntaxElement{CDef}{Class Def.}
		{
		An\ \texttt{class}\ C\ \{\ \texttt{constr}:= (\overline{x : T})\{s\};\ \texttt{flds}:=\overline{fld};\ \texttt{gflds}:=\overline{gfld};\ \texttt{mths}:=\overline{mth}\ \}
		}
\endSyntaxElement\\
\syntaxElement{Mdl}{Module Def.}
		{
		\syntaxline{\overline{C\ \mapsto\ ClassDef}}\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Loo Syntax}
\label{f:loo-syntax}
\end{figure}

\subsubsection{Semantics}
\Loo is a simple object oriented language, and the operational semantics 
(given in Fig. \ref{f:loo-semantics} and discussed later)
do not introduce any novel or surprising features. The operational 
semantics make use of several helper definitions that we 
define here.

We provide a definition of reference interpretation in Def. \ref{def:interpret}
\begin{definition}
\label{def:interpret}
For a program configuration $\sigma = (\chi, \phi : \psi)$, we provide the following function definitions:
\begin{itemize}
\item
$\interpret{\sigma}{x}\ \triangleq\ \phi.(\texttt{local})(x)$
\item
$\interpret{\sigma}{\alpha.f}\ \triangleq\ \chi(\alpha).(\texttt{flds})(f)$
\item
$\interpret{\sigma}{x.f}\ \triangleq\ \interpret{\sigma}{\alpha.f}$ where $\interpret{\sigma}{x}=\alpha$
\end{itemize}
\end{definition}
That is, a variable $x$, or a field access on a variable $x.f$ 
has an interpretation within a program configuration of value $v$
if $x$ maps to $v$ in the local variable map, or the field
$f$ of the object identified by $x$ points to $v$.

Definition Def. \ref{def:class-lookup} defines the class lookup function an object 
identified by variable $x$.
\begin{definition}[Class Lookup]
\label{def:class-lookup}
For program configuration $\sigma = (\chi, \phi : \psi)$, class lookup is defined as 
$$\class{\sigma}{x}\ \triangleq\ \chi(\interpret{\sigma}{x}).(\texttt{class})$$
\end{definition}

Definition Def. \ref{def:meth-lookup} defines the method lookup function for a method
call $m$ on an object of class $C$.
\begin{definition}[Method Lookup]
\label{def:meth-lookup}
For module $M$, class $C$, and method name $m$, method lookup is defined as 
$$\meth{M}{C}{m}\ \triangleq\ M(C).\texttt{mths}(m)$$
\end{definition}

Fig. \ref{f:loo-semantics} gives the operational semantics of \Loo. 
Program configuration $\sigma_1$ reduces to $\sigma_2$ in the context of
module $M$ if $\exec{M}{\sigma_1}{\sigma_2}$. The semantics in Fig. \ref{f:loo-semantics}
are unsurprising, but it is notable that reads (\textsc{Read}) and writes (\textsc{Write})
are restricted to the class that the field belongs to.
\begin{figure}[t]
\begin{minipage}{\textwidth}
\begin{minipage}{\textwidth}
\footnotesize
\begin{mathpar}
\infer
	{
	\sigma_1 = (\chi, \phi_1 : \psi)\\
	\sigma_2 = (\chi, \phi_2 : \phi_1' : \psi)\\
	\phi_1.(\texttt{contn}) = (x := y.m(\overline{z}); s)\\
	\phi_1' = \phi_1[\texttt{contn} := (x := \bullet; s)]\\
	\meth{M}{\class{\sigma_1}{x}}{m} = m(\overline{p})\{body\}\\
	\phi_2 = \{\texttt{local}:= ([\texttt{this}\ \mapsto\ \interpret{\sigma_1}{x}]\overline{[p_i\ \mapsto\ \interpret{\sigma_1}{z_i}]}), \texttt{contn}:=body\}
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	\quad(\textsc{Call})
	\and
\infer
	{
	\sigma_1 = (\chi, \phi_1 : \psi) \\
	\sigma_2 = (\chi, \phi_2 : \psi) \\
	\phi_1.(\texttt{contn}) = (x := y.f; s)\\
	\interpret{\sigma_1}{x.f} = v \\
	\phi_2 = \{\texttt{local}:=\phi_1.(\texttt{local})[x\ \mapsto\ v],\ \texttt{contn}:=s\}\\
	\class{\sigma_1}{\this} = \class{\sigma_1}{y}
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	\quad(\textsc{Read})
	\and
\infer
	{
	\sigma_1 = (\chi_1, \phi_1 : \psi) \\
	\sigma_2 = (\chi_2, \phi_2 : \psi) \\
	\phi_1.(\texttt{contn}) = (x.f := y; s)\\
	\interpret{\sigma_1}{y} = v \\
	\phi_2 = \{\texttt{local}:=\phi_1.(\texttt{local}),\ \texttt{contn}:=s\}\\
	\chi_2 = \chi_1[\interpret{x}{\sigma_1}.f \mapsto\ v]\\
	\class{\sigma_1}{\this} = \class{\sigma_2}{x}
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	{}
	\quad(\textsc{Write})
	\and
\infer
	{
	\sigma_1 = (\chi, \phi : \psi) \\
	\phi.(\texttt{contn}) = (x := \texttt{new}\ C(\overline{z}); s)\\
	M(C).(\texttt{constr}) = (\overline{p : T})\{ s' \} \\
	\phi' = \{\texttt{local}:=[\texttt{this} \mapsto \alpha],\overline{[p_i \mapsto \lfloor z_i \rfloor_{\sigma_1}}], \texttt{contn} := s'\}\\
	\sigma_2 = (\chi[\alpha\ \mapsto\ \{\texttt{class}:=C, \texttt{flds}:=\overline{f\ \mapsto\ \nul}], \phi' : \phi[\texttt{contn}\ :=\ (x := \bullet; s)] : \psi)
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	\quad(\textsc{New})
	\and
\infer
	{
	\sigma_1 = (\chi, \phi_1 : \phi_2 : \psi) \\
	\phi_1.(\texttt{contn}) = (\texttt{return}\ x; s)\ \textit{or}\ \phi_1.(\texttt{contn}) = (\texttt{return}\ x)\\
	\phi_2.(\texttt{contn}) = (y := \bullet; s)\\
	\sigma_2 = (\chi, \phi_2[y\ \mapsto\ \interpret{\sigma_1}{x}] : \psi)
	}
	{\exec{M}{\sigma_1}{\sigma_2}}
	{}
	\quad(\textsc{Return})
\end{mathpar}
\caption{\Loo operational Semantics}
\label{f:loo-semantics}
\end{minipage}
\begin{minipage}{\textwidth}
\footnotesize
\begin{mathpar}
\infer
		{}
		{\eval{M}{\sigma}{v}{v}}
		\quad(\textsc{E-Val})
		\and
\infer
		{}
		{\eval{M}{\sigma}{x}{\interpret{\sigma}{x}}}
		\quad(\textsc{E-Var})
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{i_1}\\
		\eval{M}{\sigma}{e_2}{i_2}\\
		i_1 + i_2 = i
		}
		{
		\eval{M}{\sigma}{e_1 + e_2}{i}
		}
		\quad(\textsc{E-Add})
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{v}\\
		\eval{M}{\sigma}{e_2}{v}
		}
		{
		\eval{M}{\sigma}{e_1 = e_2}{\true}
		}
		\quad(\textsc{E-Eq}_1)
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{v_1}\\
		\eval{M}{\sigma}{e_2}{v_2}\\
		v_1 \neq\ v_2
		}
		{
		\eval{M}{\sigma}{e_1 = e_2}{\false}
		}
		\quad(\textsc{E-Eq}_2)
		\and
\infer
		{
		\eval{M}{\sigma}{e}{\true}\\
		\eval{M}{\sigma}{e_1}{v}
		}
		{
		\eval{M}{\sigma}{\ifthenelse{e}{e_1}{e_2}}{v}
		}
		\quad(\textsc{E-If}_1)
		\and
\infer
		{
		\eval{M}{\sigma}{e}{\false}\\
		\eval{M}{\sigma}{e_2}{v}
		}
		{
		\eval{M}{\sigma}{\ifthenelse{e}{e_1}{e_2}}{v}
		}
		\quad(\textsc{E-If}_2)
		\and
\infer
		{
		\eval{M}{\sigma}{e}{\alpha}
		}
		{
		\eval{M}{\sigma}{e.f}{\interpret{\sigma}{\alpha.f}}
		}
		\quad(\textsc{E-Field})
		\and
\infer
		{
		\eval{M}{\sigma}{e_1}{\alpha}\\
		\eval{M}{\sigma}{e_2}{v'}\\
		\texttt{ghost}\ g(x : T)\{e\} : T'\ \in\ M(\class{\sigma}{\alpha}).(\texttt{gflds})\\
		\eval{M}{\sigma}{[v'/x]e}{v}
		}
		{
		\eval{M}{\sigma}{e_1.g(e_2)}{v}
		}
		\quad(\textsc{E-Ghost})
\end{mathpar}
\caption{\Loo expression evaluation}
\label{f:evaluation}
\end{minipage}
\end{minipage}
\end{figure}

While the small-step operational semantics of \Loo is given in Fig. \ref{f:loo-semantics},
specification satisfaction is defined over an abstracted notion of 
execution that models the open world, called \emph{module pair execution}. 
That is, execution occurs in the context of not just an internal, trusted module, but 
an external, untrusted module. We borrow the definition of pair execution 
from \citeauthor{FASE}, along with the related definition of module linking, given in Def. \ref{def:linking}.
\begin{definition}
\label{def:linking}
For all modules $M_1$ and $M_2$, if the domains of $M_1$ and $M_2$ are disjoint, 
we define the module linking function as $M_1\ \circ\ M_2\ \triangleq\ M_1\ \cup\ M_2$.
\end{definition}
That is, given an internal, trusted module $M_1$, and an external, untrusted module $M_2$, 
we take their linking as the union of the two if their domains are disjoint.

We give the semantics of module pair execution in Def. \ref{def:pair-reduce}
\begin{definition}[Module Pair Execution]
\label{def:pair-reduce}
For all internal modules $M_1$, external modules $M_2$, and program configurations $\sigma$ and $\sigma'$, 
we say that $\reduction{M_1}{M_2}{\sigma}{\sigma'}$ if and only if
\begin{itemize}
\item
$\class{\sigma}{\sigma.(\texttt{this})}\ \in\ M_2$ and
\item
$\class{\sigma'}{\sigma'.(\texttt{this})}\ \in\ M_2$ and 
\end{itemize} 
and
\begin{itemize}
\item
$\exec{M_1\ \circ\ M_2}{\sigma}{\sigma'}$ or
\item
$M_1\ \circ\ M_2,\ \sigma \leadsto\ \sigma_1\ \leadsto\ \ldots\ \sigma_n\ \leadsto \sigma'$ and $\class{\sigma_i}{\sigma_i.(\texttt{this})}\ \in\ M_1$ for all $1\ \leq\ i\ \leq\ n$
\end{itemize}
\end{definition}

Finally, we provide a semantics for expression evaluation is given in Fig. \ref{f:evaluation}. 
That is, given a module $M$ and a program configuration $\sigma$, expression $e$ evaluates to $v$
if $\eval{M}{\sigma}{e}{v}$. Note, the evaluation of expressions is separate from the operational
semantics of \Loo, and thus there is no restriction on field access.
%\begin{figure}
%\footnotesize
%\begin{mathpar}
%\infer
%		{}
%		{\eval{M}{\sigma}{v}{v}}
%		\quad(\textsc{E-Val})
%		\and
%\infer
%		{}
%		{\eval{M}{\sigma}{x}{\interpret{\sigma}{x}}}
%		\quad(\textsc{E-Var})
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e_1}{i_1}\\
%		\eval{M}{\sigma}{e_2}{i_2}\\
%		i_1 + i_2 = i
%		}
%		{
%		\eval{M}{\sigma}{e_1 + e_2}{i}
%		}
%		\quad(\textsc{E-Add})
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e_1}{v}\\
%		\eval{M}{\sigma}{e_2}{v}
%		}
%		{
%		\eval{M}{\sigma}{e_1 = e_2}{\true}
%		}
%		\quad(\textsc{E-Eq}_1)
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e_1}{v_1}\\
%		\eval{M}{\sigma}{e_2}{v_2}\\
%		v_1 \neq\ v_2
%		}
%		{
%		\eval{M}{\sigma}{e_1 = e_2}{\false}
%		}
%		\quad(\textsc{E-Eq}_2)
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e}{\true}\\
%		\eval{M}{\sigma}{e_1}{v}
%		}
%		{
%		\eval{M}{\sigma}{\ifthenelse{e}{e_1}{e_2}}{v}
%		}
%		\quad(\textsc{E-If}_1)
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e}{\false}\\
%		\eval{M}{\sigma}{e_2}{v}
%		}
%		{
%		\eval{M}{\sigma}{\ifthenelse{e}{e_1}{e_2}}{v}
%		}
%		\quad(\textsc{E-If}_2)
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e}{\alpha}
%		}
%		{
%		\eval{M}{\sigma}{e.f}{\interpret{\sigma}{\alpha.f}}
%		}
%		\quad(\textsc{E-Field})
%		\and
%\infer
%		{
%		\eval{M}{\sigma}{e_1}{\alpha}\\
%		\eval{M}{\sigma}{e_2}{v'}\\
%		\texttt{ghost}\ g(x : T)\{e\} : T'\ \in\ M(\class{\sigma}{\alpha}).(\texttt{gflds})\\
%		\eval{M}{\sigma}{[v'/x]e}{v}
%		}
%		{
%		\eval{M}{\sigma}{e_1.g(e_2)}{v}
%		}
%		\quad(\textsc{E-Ghost})
%\end{mathpar}
%\caption{\Loo expression evaluation}
%\label{f:evaluation}
%\end{figure}

\subsection{\Chainmail}
\Chainmail extends expressiveness of standard specification languages
with assertion forms capturing \emph{permission}, \emph{viewpoint}, and \emph{control}.
That is, \Chainmail specifications are able to specify which objects have
access to which other object (\emph{permission}), whether an object's origin
is internal or external to known code (\emph{viewpoint}), or which objects call which 
methods (\emph{control}). Chainmail \cite{FASE} 
is also able to express specifications of these forms, however we have improved
upon these specification forms by considerably simplifying their semantics.
We do however exclude several assertion forms that \citeauthor{FASE} does include, 
namely \emph{space} and \emph{time}. We are still are able to model some
of the expressiveness of the temporal operators of \citeauthor{FASE} by
introducing our novel Necessity Logic, the core contribution of this paper.

\subsubsection{Syntax}

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{A}{\Chainmail Assertion}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{\alpha_1}{\alpha_2}}
				{\internal{\alpha}}
				{\external{\alpha}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\calls{\alpha_1}{\alpha_2}{m}{\overline{v}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{\Chainmail Assertions}
\label{f:chainmail-syntax}
\end{figure}

Figure \ref{f:chainmail-syntax} gives the assertion syntax of the \Chainmail specification language.
An assertion may be an expression, a class assertion, the usual connectives and quantifiers, along 
with several non-standard assertion forms:
\begin{itemize}
\item
\emph{Permission} ($\access{\alpha_1}{\alpha_2}$): Which objects have access to which other objects (i.e. $\alpha_1$ has access to $\alpha_2$).
\item
\emph{Viewpoint} ($\internal{\alpha}$ and $\external{\alpha}$): Which objects are internal or external to our component.
\item
\emph{Control} ($\calls{\alpha_1}{m}{\alpha_2}{\overline{v}}$): Which objects call which functions on which other objects. 
\end{itemize}

\subsubsection{Semantics}
The semantics of \Chainmail assertions is given in Def. \ref{def:chainmail-semantics}.
\begin{definition}[Satisfaction of \Chainmail Assertions] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a program configuration $\sigma$ with internal module $M$ and external module $M'$ as:
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{e}$ iff $\eval{M \circ M'}{\sigma}{e}{\true}$
\item
$\satisfiesA{M}{M'}{\sigma}{e : C}$ iff $\eval{M \circ M'}{\sigma}{e}{\alpha}$ \textit{and} $\textit{classOf}(\sigma, \alpha) = C$
\item
$\satisfiesA{M}{M'}{\sigma}{\neg A}$ iff $\notsatisfies{M}{M'}{\sigma}{A}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \wedge\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ and 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A_1\ \vee\ A_2}$ iff $\satisfiesA{M}{M'}{\sigma}{A_1}$ or 
$\satisfiesA{M}{M'}{\sigma}{A_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{\all{x}{A}}$ iff 
$\forall \alpha \in \sigma.(\texttt{heap})$ we have 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$
\item
$\satisfiesA{M}{M'}{\sigma}{\ex{x}{A}}$ iff 
$\exists \alpha \in \sigma.(\texttt{heap})$ such that 
$\satisfiesA{M}{M'}{\sigma}{[\alpha/x]A}$
\item
$\satisfiesA{M}{M'}{\sigma}{\access{\alpha_1}{\alpha_2}}$ iff 
\begin{itemize}
\item
$\exists\ o,\ f$ such that $[\alpha_1\ \mapsto\ o]\ \in\ \sigma.(\texttt{heap})$ and $[f\ \mapsto\ \alpha_2]\ \in\ o.(\texttt{flds})$ or
\item
$\exists\ \phi,\ x$ such that $\phi \in \sigma.(\texttt{stack})$ and $[x\ \mapsto\ \alpha_2]\in\phi.(\texttt{local})$ and $[\texttt{this}\ \mapsto\ \alpha_1]\in\phi.(\texttt{local})$
\end{itemize}
\item
$\satisfiesA{M}{M'}{\sigma}{\internal{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\external{\alpha}}$ iff 
$\textit{classOf}(\sigma,\alpha) = C$ and $C \not\in M$
\item
$\satisfiesA{M}{M'}{\sigma}{\calls{\alpha_1}{\alpha_2}{m}{v_1, \ldots, v_n}}$ iff
\begin{itemize}
\item
$\sigma.(\texttt{contn} = x := y.m(z_1,\ldots,z_n))$ and 
\item
$[\texttt{this}\mapsto \alpha_1]\in\sigma.(\texttt{local})$ and
\item
$[y\mapsto \alpha_2]\in\sigma.(\texttt{local})$ and
\item
$[z_i\mapsto v_i]\in\sigma.(\texttt{local})$ for all $1 \leq i \leq n$
\end{itemize}
\end{itemize}
\end{definition}

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \texttt{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \texttt{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \texttt{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \texttt{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \texttt{int} & \\
%%	| & \texttt{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection{Holistic Guarantees}
\label{s:holistic-guarantees}

\Chainmail generalizes holistic properties about internal data 
across execution. To do this we define syntactic forms for 
\emph{Necessity Specifications} in Fig. \ref{f:holistic-syntax}.
We express provability of satisfaction of Necessity Specifications as $\satisfies{M}{H}$.
That is, a module $M$ satisfies a necessity specification $H$. This allows 
the construction of proofs without considering either the details 
of the program configuration or the external client module.

\begin{figure}[t]
\footnotesize
\[
\begin{syntax}
\syntaxElement{H}{Necessity Specification}
		{
		\syntaxline
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
\caption{Syntax for Necessity Specifications}
\label{f:holistic-syntax}
\end{figure}

\subsubsection{Only If}
[$\onlyIf{A_1}{A_2}{A}$]: If program execution starts at some state $A_1$, and reaches some state $A_2$, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account's password.

We give the definition of ``only if'' in Def. \ref{def:oi}.
\begin{definition}[\textsc{Only If}]
\label{def:oi}
$\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition} 

\subsubsection{Single-Step Only If}
[$\onlyIfSingle{A_1}{A_2}{A}$]: If program execution starts at some state $A_1$, and reaches some state $A_2$ after a single execution step, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the bank \prg{transfer} method.

We give the definition of ``single-step only if'' in Def. \ref{def:oi-single}.
\begin{definition}[\textsc{Only If Single-Step}]
\label{def:oi-single}
$\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\textit{Arising}(M, M', \sigma_1)$
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reduction{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\satisfiesA{M}{M'}{\sigma_1}{A}$
\end{definition}

\subsubsection{Only Through}
[$\onlyThrough{A_1}{A_2}{A}$]: If a program execution starts at some $A_1$ state, and reaches some $A_2$ state, then program execution must have passed through some $A$ state.\\
e.g.if the balance of an account changes over time, then the bank's \prg{transfer} method must have been called 
in some intermediate state.
We give the definition of ``only  through'' in Def. \ref{def:ot}. Note 
that the intermediate state where $A$ is true might be the initial state ($\sigma_1$),
or final state ($\sigma_2$). 

\begin{definition}[\textsc{Only Through}]
\label{def:ot}
$\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ if and only if
$\forall M',\ \sigma_1,\ \sigma_2,$ such that 
\begin{itemize}
\item
$\satisfiesA{M}{M'}{\sigma_1}{A_1}$
\item
$\satisfiesA{M}{M'}{\sigma_2}{A_2}$ and
\item
$\reductions{M}{M'}{\sigma_1}{\sigma_2}$
\end{itemize}
then $\exists\ \sigma,$ such that
\begin{itemize}
\item
$\reductions{M}{M'}{\sigma_1}{\sigma}$
\item
$\reductions{M}{M'}{\sigma}{\sigma_2}$
\item
$\satisfiesA{M}{M'}{\sigma}{A}$
\end{itemize}
\end{definition}

\subsection{Encapsulation}
In order to reason about necessary requirements in an open world,
we differentiate between those assertions that require computation
by internal, known code, and those assertions that may change due 
to computation by external, unknown code.

\begin{definition}[Encapsulation]
\label{def:encapsulation}
For an internal module $M$ and assertion $A$, we define an assertion $A'$ as being 
encapsulated, written $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program configurations $\sigma$ and $\sigma'$
such that 
\begin{itemize}
\item
$\reduction{M}{M'}{\sigma}{\sigma'}$ and 
\item
$\satisfiesA{M}{M'}{\sigma}{A}$ and
\item
$\satisfiesA{M}{M'}{\sigma}{A'}$ and
\item
$\satisfiesA{M}{M'}{\sigma'}{\neg A'}$
\end{itemize}
then there exists some $\alpha$, $m$, $\overline{v}$ such that
$\satisfiesA{M}{M'}{\sigma}{\calls{\_}{\alpha}{m}{\overline{v}}\ \wedge\ \internal{\alpha}}$
\end{definition}