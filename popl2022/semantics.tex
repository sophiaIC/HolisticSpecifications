\section{The Meaning of Necessity}
\label{s:semantics}

 
In this section we define \sd{the}  \Nec specification language.  
We first
define an underlying programming language, \Loo (\S \ref{sub:Loo}).
We then define an assertion language, \SpecO, which can talk about the
contents of the state, as well as about provenance, permission and
control (\S \ref{sub:SpecO}).  Finally, we define the syntax and
semantics of our full language for writing \Nec
specifications (\S \ref{s:holistic-guarantees}).


\subsection{\Loo}
\label{sub:Loo} 
%\jm[TODO: mention the type system and the restriction on external method calls]{}
%% We introduce a simple object-oriented language, \Loo, upon 
%% which our specification language sits.
 \Loo is a formal model of an unsurprising, imperative, sequential, 
class based, typed, object-oriented language.
%\susan[Java fields are package private not class private - are fields so important that we need to say this?]{Fields are private to the class where they are defined.}
\Loo is straightforward:
%Given its simplicity, %  the simplicity of \Loo, we do notdefine it here, instead, 
% we direct the reader to
Appendix \ref{app:loo} contains 
the full definitions.
%%and introduce here only % syntax and operational semantics.
%% the concepts relevant to the
%%treatment of the open world guarantees.
%\jm[]{\Loo fields are private in the way fields in Java are private,
%the privacy is class-wide, i.e. they may only be read or written to by 
%objects of the same class.}
\Loo is based on \LangOO 
\cite{FASE}, with some small variations, as well as 
the addition of a % while \LangOO is untyped, \Loo 
 a simple type system -- more in \ref{types}.
%has type based restrictions on external access to private data.}
%\sophiaPonder[added]{Note that the operational semantics only allows filed
%update if the receiver and the object being updated belong to the same class,
%and only allows method calls }
%
%
A \Loo state $\sigma$ consists of a 
heap $\chi$, and a  {stack $\psi$ which is a sequence of frames}.
A frame $\phi$ consists of
local variable map, and a continuation, \ie a sequence of statements to be executed.
 A statement may assign to variables, create new objects and push them to the heap, 
perform field reads and writes on objects,  or
 call methods on those objects. 

%Program 
 Modules are mappings
from class names to class definitions. 
Execution 
%takes place
is in the context of  a module $M$ and   a state $\sigma$,
%It is % Execution
 defined via unsurprising small-step semantics of the form \ \ 
   $M, \sigma \leadsto \sigma'$.
The   top frame's continuation contains the statements to be % currently being 
executed next.
 % chopped, as generic 
 % There are several properties  of \Loo that are important to the central topic of this paper. 
 
As discussed in \S \ref{s:approach}, we are interested in guarantees which hold
during execution of an internal, 
known, trusted module $M$ when linked together with any
unknown, untrusted, module $M'$. These guarantees need only hold 
when the external module is executing; we are not concerned if they are
temporarily broken by the internal module. Therefore, we are only interested in states where the
executing object (\prg{this}) is an external object. 
To express our focus on external states, we define the  \emph{external states semantics}, of the form 
$\reduction{M'}{M}{\sigma}{\sigma'}$, where $M'$ is the external
module, and $M$ is the internal module, and where we
collapse all internal steps into one single step.

 

\begin{definition}[External States Semantics]
\label{def:pair-reduce}
For  
% If we say "internal module", it is sounds as something makes the module be internal
  modules $M$,  $M'$, and % program
   states $\sigma$, $\sigma'$, 
we say that $\ \ \ \ \ \ \ \ \reduction{M'}{M}{\sigma}{\sigma'}\ \ \ \ \ \ \ \ $ if and only if there exist 
$n\in\mathbb{N}$, and states $\sigma_0$,...$\sigma_n$, such that
\begin{itemize}
\item
$\sigma$=$\sigma_1$, and  $\sigma'$=$\sigma_n$,
\item
$M' \circ M, \sigma_i \leadsto \sigma_{i+1}$  \ \ \ for all $i\in [0..n)$,
\item
$\class{\sigma}{\scd{\prg{this}}}, \class{\sigma'}{\scd{\prg{this}}}\in M'$,
\item
$\class{\sigma_i}{\scd{\prg{this}}} \in M$\ \ \ for all $i\in [1..n)$.
\end{itemize} 
\end{definition}
The function $\class{\sigma}{\_}$ is overloaded:
  applied to a variable, 
$\class{\sigma}{x}$  looks up the variable $x$ in the top frame of $\sigma$, and returns the 
class of the corresponding object in the  heap of $\sigma$,
while  applied to an address, $\class{\sigma}{\alpha}$  returns
the class of   the object referred by address $\alpha$ in the heap of $\sigma$.
 The module linking operator $\circ$, applied to two modules, $M'\circ M$, 
 combines the two modules into one module in the obvious way, provided their
domains are disjoint.
Full details in  Appendix \ref{app:loo}.
\begin{figure}[htb]
\input{external_states}
   \caption{External States Semantics
     (Def. \ref{def:pair-reduce}). %
     % 
     (A) $\exec{{\color{hotpink}M'} \circ {\color{lightseagreen}M}}{\sigma_1}{\ldots}\leadsto \sigma_9$\ \ \and \ \ \ 
     (B) $\reduction{{\color{hotpink}M'}}{{\color{lightseagreen}M}}{\sigma_2}{\ldots}\leadsto \sigma_9$
    %  (c) $\reduction{{\color{orange}M'}}{{\color{blue}M}}{\sigma_1}{\ldots}\leadsto \sigma_8$
    }
   \label{fig:VisibleStates}
 \end{figure}
 
Fig. \ref{fig:VisibleStates} inspired by \citeasnoun{FASE} provides a simple graphical description of 
our external states semantics: (A) is the ``normal'' execution after 
linking two modules into one: \ $M' \circ M, ... \leadsto ...$ whereas (B) is the
 external states execution when $M'$ is external,\   $\reduction{M'}{M}{...}{...}$.
Note that whether a module is external or internal depends on our
perspective -- nothing in a module itself renders it internal or external. For example, in
 $\reduction{M_1}{M_2}{...}{...}$ the external module is $M_1$,
  while in  $\reduction{M_2}{M_1}{...}{...}$  the external module is $M_2$.

We  use the notation\ \  $\reductions{M'}{M}{\sigma}{\sigma'}$ \ 
to denote
zero or more % reduction 
steps starting at state $\sigma$ and ending at state $\sigma'$, in the context of internal module 
$M$ and external module $M'$.
 %Not only are we unconcerned 
%with internal states,  we are also unconcerned with  states which cannot ever arise from execution.
We are not concerned with either internal states nor states that cannot ever arise.
\emph{Arising} states are those that  may arise by external states execution
starting at some initial configuration:



\begin{definition}[Arising  States]
\label{def:arising}
For   modules $M$ and  $M'$, a % program
 state $\sigma$ is 
called an \emph{arising} state, formally \ \ \ $\arising{M}{M'}{\sigma}$,\ \ \ 
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$\reductions{M'}{M}{\sigma_0}{\sigma}$.
\end{definition}

An \emph{Initial} state's heap
contains a single object of class \prg{Object}, and
its  stack   consists of a single frame, whose local variable map is a
mapping from \prg{this} to the single object, and whose continuation is  any statement.
(See Definitions \ref{def:initial} and \ref{def:arising}).

\subsection{\SpecO}
\label{sub:SpecO}

\SpecO is a subset of the \emph{Chainmail} assertions language, \ie
a basic assertion language extended with
object-capability assertions. 


\subsubsection{Syntax of of \SpecO}
The syntax of \SpecO   is given in
Definition \ref{f:chainmail-syntax}.
An assertion may be an expression,   a query of the defining class of
  an object, the usual connectives and quantifiers, along 
with three non-standard assertion forms:
(1) \emph{Permission} and (2) \emph{Provenance}, inspired by the capabilities literature, and
(3) \emph{Control} which allows tighter  characterisation of the cause of effects --  
useful for the specification of large APIs.
\begin{itemize}
\item
\emph{Permission} ($\access{x}{y}$):  
  $x$ has access to $y$.
\item
{\emph{Provenance}} ($\internal{x}$ and $\external{y}$):   $x$ is internal, and $y$ is external.
\item
\emph{Control} ($\calls{x}{y}{m}{\overline{z}}$): 
$x$ calls method $m$ on object $y$ with arguments $\overline{z}$.
\end{itemize}


\begin{definition}
Assertions ($A$) in
\SpecO are defined as follows:

\label{f:chainmail-syntax}
 \[
\begin{syntax}
\syntaxElement{A}{}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{x}{y}}
				{\internal{x}}
				{\external{x}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
				{\calls{x}{y}{m}{\overline{z}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]


\end{definition}



\subsubsection{Semantics of \SpecO}
The semantics of \SpecO   
is given in Definition \ref{def:chainmail-semantics}. 
We   use the evaluation relation, $\eval{M}{\sigma}{e}{v}$,
which says that the expression $e$ evaluates
to value $v$ in the context of state $\sigma$ and module $M$.
Note that expressions in \Loo may be recursively defined, and thus evaluation 
need not always % may not necessarily 
 terminate. Nevertheless, the logic of $A$ remains classical because recursion is restricted
to expressions, and not generally to assertions.
We have taken this approach from \citeasnoun{FASE}, which also contains a mechanized Coq proof that assertions are classical \citeasnoun{coqFASE}.
%  The full
The semantics of $\hookrightarrow$ are unsurprising (see Fig.\ref{f:evaluation}).

Shorthands: 
 $\interpret{\phi}{x} = v$  means that $x$ maps to
value $v$ in the local variable map of frame $\phi$, $\interpret{\sigma}{x} = v$ means that $x$ 
maps to $v$ in the top most frame of $\sigma$'s stack, and $\interpret{\sigma}{x.f} = v$
has the obvious meaning. The terms $\sigma.\prg{stack}$,  
%resp. 
$\sigma.\prg{contn}$, 
%resp. 
$\sigma.\prg{heap}$     mean the stack, 
%resp. 
the continuation at the
top frame of $\sigma$, %resp. 
and the heap of $\sigma$.
The term $\alpha\!\in\!\sigma.\prg{heap}$ means that $\alpha$ is in the domain of the heap of $\sigma$, and \emph{$x$ fresh in $\sigma$} means that 
$x$ isn't in the variable map of the top frame of $\sigma$, 
while the substitution  $\sigma[x \mapsto \alpha]$ is applied to the top frame of $\sigma$.
$C\in M$ means that class $C$ is in the domain of module $M$. 

\begin{definition}[Satisfaction % of \SpecO 
of Assertions by a module and a state] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a % program 
state $\sigma$ with 
 module $M$ as:
\begin{enumerate}
\item
\label{cExpr}
$\satisfiesA{M}{\sigma}{e}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{e}{\true}$
\item
\label{cClass}
$\satisfiesA{M}{\sigma}{e : C}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{e}{\alpha}$ \textit{and} $\class{\sigma}{\alpha} = C$
\item
$\satisfiesA{M}{\sigma}{\neg A}$ \ \ \ iff \ \ \  ${M},{\sigma}\nvDash{A}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \wedge\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}$ and 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \vee\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}$ or 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{\all{x}{A}}$ \ \ \ iff \ \ \  
$\satisfiesA{M}{\sigma[x \mapsto \alpha]}{A}$, \ 
\ \ \ for some $x$ fresh in $\sigma$, and for all $\alpha\!\in\!\sigma.\prg{heap}$.
\item
$\satisfiesA{M}{\sigma}{\ex{x}{A}}$ \ \ \ iff \ \ \  
$\satisfiesA{M}{\sigma[x \mapsto \alpha]}{A}$, \ 
\ \ for some $x$ fresh in $\sigma$, and for some $ \alpha\!\in\!\sigma.\prg{heap}$. 
\item
\label{cAccess}
$\satisfiesA{M}{\sigma}{\access{x}{y}}$ \ \ \ iff \ \ \  
\begin{enumerate}
\item
\label{c1}
$\interpret{\sigma}{x.f}={\interpret{\sigma}{y}}$ for some $f$, \\
  or
\item
\label{c2}
{$\interpret{\sigma}{x}=\interpret{\phi}{\prg{this}}$}, {$\interpret{\sigma}{y}=\interpret{\phi}{z}$}, \jm[added this. this is necessary otherwise I don't think \Nec is sound]{and $z\ \in\ \phi.\prg{contn}$}\ \ \ \
for some variable $z$, and some frame $\phi$ in $\sigma.
\prg{stack}$.
\end{enumerate}
\item
\label{cInternal}
$\satisfiesA{M}{\sigma}{\internal{x}}$ \ \ \ iff \ \ \  
$\textit{classOf}(\sigma,x) \in M$
\item
\label{cExternal}
$\satisfiesA{M}{\sigma}{\external{x}}$ \ \ \ iff \ \ \  
$\textit{classOf}(\sigma,x) \not\in M$
\item
\label{cCall}
$\satisfiesA{M}{\sigma}{\calls{x}{y}{m}{z_1, \ldots, z_n}}$ \ \ \ iff \ \ \ 
\begin{enumerate}
\item
$\sigma.\prg{contn} = (w := y'.m(z'_1,\ldots,z'_n)\scd{; s})$,\ \ for some 
variable $w$, and some statement $s$,
\item
$\satisfiesA{M}{\sigma}{x = \prg{this}}$
\ \ and \ \ 
$\satisfiesA{M}{\sigma}{y = y'}$,
\item
$\satisfiesA{M}{\sigma}{z_i = z'_i}$\ \ \ for all $1\!\leq i\!\leq n$
\end{enumerate}
\end{enumerate}
\end{definition}

 
The assertion ${\access{x}{y}}$ (defined in  \ref{cAccess})
requires  that $x$ has access to $y$
either through a field of $x$ (case \ref{c1}),
or through some call in the stack, where $x$ is the receiver and $y$ is one of the
arguments (case \ref{c2}).
 The assertion %$\satisfiesA{M}{\sigma}
 ${\calls{x}{y}{m}{z_1, \ldots, z_n}}$  (defined in \ref{cCall}) 
requires that the current receiver (\prg{this}) is $x$, and that it calls the method $m$ on $y$ with
 arguments $z_1$, ... $z_n$.\footnote{It does \emph{not} mean  that somewhere in the 
 call stack there exists a call from $x$ to $y.m(...)$.}
 Note that in most cases, satisfaction of an assertion not only depends on the state $\sigma$, but 
also depends on the module in the case of expressions (\ref{cExpr}), class membership
(\ref{cClass}), and internal or external provenance (\ref{cInternal} and \ref{cExternal}).


We now define what it means for a module to satisfy an assertion:
 $M$ satisfies  $A$ if any state arising from external steps execution of that
module with any other external module  satisfies $A$. 
 
\begin{definition} [Satisfaction % of \SpecO 
of Assertions
by a module] 
\label{def:mdl-sat}
For a module $M$ and assertion $A$, we say that\ \  $\satisfies{M}{A}$ \ \ if and only if 
for all modules $M'$, and all $\sigma$, if $\arising{M'}{M}{\sigma}$, then $\satisfiesA{M}{\sigma}{A}$.
\end{definition}

 
In the current work we assume the existence of a proof system that judges
$\proves{M}{A}$, to prove  satisfaction of assertions. 
 We will not define such a judgment, but will rely on its existence see Theorem \ref{thm:soundness}).
We define soundness of such a judgment in the usual way:

\begin{definition}[Soundness of \SpecO Provability]
\label{ax:specW-prove-soundness}
A judgment of the form $M \vDash A$ is \emph{sound}, if for all
 modules $M$ and assertions $A$, \ if $\proves{M}{A}$ then $\satisfies{M}{A}$.
\end{definition}

 
\subsubsection{Inside}

We define
a final shorthand 
predicate $\wrapped{\prg{o}}$ which states 
that only \internalO objects have access to \prg{o}.
The object \prg{o} may be either \internalO or \externalO.
\begin{definition}[Inside]
$\wrapped{o}\ \triangleq\ \all{x}{\access{x}{o}\ \Rightarrow\ \internal{x}} $ 
\end{definition}

 
\inside is a very useful concept. For example, the balance of an account whose
  password is \inside  will not decrease in the next step.
  Often, API implementations contain objects whose capabilities, while  crucial for the implementation, if exposed,
would break the intended guarantees of the API. Such objects need to remain \inside - see
such an example in Section \ref{s:examples}. 
 
% \jm[adaptation doesn't fit here. perhaps we move to 3.3? i.e. in the discussion of the \Nec specs?]{}
%\subsubsection{The meaning of adaptation}   
%\sophiaPonder[new]{We introduce the adaptation operation $\adapt {\_} {\_}$ to allow us to
%``see a  state   through the lens of another state''.
%Assume, for example a state $\sigma_0$ which satisfies $A_0$ where $A_0 \triangleq \prg{a}:\prg{Account} \wedge \prg{a.balance}=100$.
%Assume that $\sigma_1$ is the result of executing $\prg{a.transfer(p,10)}$ where \prg{p} is \prg{a}'s password, while $\sigma_2$ is the result of executing $\prg{a=new Account}$. 
%We have that $\satisfiesA {...}{\sigma_0} {A_0}$, and 
%${...},{\sigma_1} \nvDash{A_0}$, and $ {...}{\sigma_2}\nvDash {A_0}$. However, the difference between
%the two executions is that the former modified the object at \prg{a}, and the latter did not; it only modified
%the mapping for variable \prg{a}. Therefore, we want to define an adaptation operator, such that
%${...},{\adapt {\sigma_1} {\sigma_0}} \nvDash{A_0}$ but $\satisfiesA {...}{\adapt {\sigma_2} {\sigma_0}} {A_0}$.}
%
%\sophiaPonder[]{In the definition below, the heap of $\adapt{\sigma'}{\sigma}$ is taken from
%$\sigma'$, and the stack is   mostly taken from $\sigma'$, except that the variable map of the
%top frame consists of the variable map of the top frame of $\sigma$, expanded
%with fresh variables ($\overline{v}$) 
%to correspond to the variables of the top frame of $\sigma'$, and in the continuation the free variables are renamed to $\overline{v}$.}
%
%
%%
%%
%%  These assertions may contain variables, whose denotation might change during
%%program execution: the 
%%map may change, variables may be overwritten, or the entire local variable maps may be lost on a method return.
%%For this reason, before we provide the semantics of our \Nec specification language, we first introduce an adaptation operator
%%to account for variable renaming throughout the execution of a program.
%\begin{definition}
%\label{d:adapt}
%$\adapt{\sigma'}{\sigma} \triangleq (\chi', \{\prg{local} := \beta[\overline{v} \mapsto \beta\scd{'}(\overline{z}')], \prg{contn}:= [\overline{z'}/\overline{v}]c'\} : \psi)$
%where 
%\begin{itemize}
%\item
%$\sigma = (\_, \{\prg{local}:=\beta; \prg{contn}:=\_\} : \_)$, and
%$\sigma' = (\chi', \{\prg{local}:=\beta', \prg{contn}:=c'\} : \psi)$
%\item
%$dom(\beta') = \overline{z'}$, $dom(\beta) \cap \overline{v} = \emptyset$, and $|\overline{z'}| = |\overline{v}|$
%\end{itemize}
%\end{definition}

%\jm[]{Def. \ref{d:adapt} allows satisfaction to take variable renaming during evaluation into account. 
%As an example, consider the following code snippet.}
%\begin{lstlisting}[frame=lines]
%x.f := y
%x := z
%\end{lstlisting}
%\jm[]{After the evaluation of line 1 , \texttt{x} has access to \texttt{y}, however when we overwrite \texttt{x} in line 2, 
%this is no longer necessarily true, as \texttt{x} might now refer to a different object, even though the object previously referred to 
%by \texttt{x} has not changed. A similar issue might occur when either calling a method, or returning from a method, as 
%the entire variable map changes under such circumstances. Adaptation (Def. \ref{d:adapt}) provides a convenient way to refer to 
%objects across time, while ignoring rewrites and new frames.}




\subsection {\Nec Specifications}
\label{s:holistic-guarantees}

Our \Nec specification language extends \SpecO with novel 
 \emph{necessity operators}.
In this section we define its syntax (Definition \ref{f:holistic-syntax}) and semantics 
(Definition \ref{def:necessity-semantics}).
We have the following three operators:
 



\begin{description}
\item[Only If]
[$\onlyIf{A_1}{A_2}{A}$]: If an arising % program
  state satisfies $A_1$, and after some execution, a state % program 
 satisfying $A_2$ is reached, 
then the original  
state must have also satisfied $A$.
 %e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
%program  state that has access to the account's password.
% \paragraph{Single-Step Only If}
\item[Single-Step Only If]
[$\onlyIfSingle{A_1}{A_2}{A}$]: If an arising %program
  state satisfies $A_1$, and after a single step of execution, a state satisfying $A_2$ is reached, 
then the original %program 
state must have also satisfied $A$.
%e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the bank \prg{transfer} method.

%\paragraph{Only Through}
\item[Only Through]
[$\onlyThrough{A_1}{A_2}{A}$]: If an arising %program 
 state satisfies $A_1$, and after some execution, a state satisfying $A_2$ is reached, then  execution must have passed through some \emph{intermediate} state satisfying $A$ 
% e.g. if the balance of an account changes over time, then the bank's \prg{transfer} method must have been called 
% in some intermediate state. Note 
--  the   \emph{intermediate} state % state where $A$ is true
satisfying $A$ might be the \emph{starting}  
or the \emph{final} state.
\end{description} 

%\begin{figure}[t]
\begin{definition}[\Nec Syntax] The syntax of
\Nec  Specifications ($S$)
% in   \Chainmail   
is as follows:
% \footnotesize

\footnotesize
\[
\begin{syntax}
\syntaxElement{S}{}
		{
		\syntaxline
				{A}
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
%\caption{Syntax of \Chainmail Necessity Specifications}
\label{f:holistic-syntax}
\end{definition}
%\end{figure}
\normalsize



\paragraph{Relationship between \Nec Operators}
The three \Nec \sd{operators} % sd dropped " defined in Def. \ref{f:holistic-syntax}" as obvious
can be related by generality. 
%An 
\emph{Only If} ($\onlyIf{A_1}{A_2}{A}$) implies
  \emph{Single-Step Only If} ($\onlyIfSingle{A_1}{A_2}{A}$), since if $A$ is 
a necessary precondition for multiple steps, then it must be a necessary 
precondition for a single step. \emph{Only If} also implies 
an \emph{Only Through}, where the intermediate state is the starting state
of the execution.
%This relationship can be better observed when we 
%encode the \Nec operators with traditional temporal operators:
%\jm[]{\begin{description}
%\item[Only If:] $\onlyIf{A_1}{A_2}{A}\ \equiv\ A_1\ \wedge\ \Diamond A_2\ \longrightarrow\ A$
%\item[Single-Step Only If:] $\onlyIfSingle{A_1}{A_2}{A}\ \equiv\ A_1\ \wedge\ \bigcirc A_2\ \longrightarrow\ A$
%\item[Only Through:] $\onlyThrough{A_1}{A_2}{A}\ \equiv\ (A_1\ \longrightarrow\ (\Diamond (A\ \wedge\ \Diamond A_2) \vee \neg \Diamond A_2))$
%\end{description}
%}

%\subsection{\scd{SD's proposal for motivation of adaptation}}
%
%\scd{We will now give the semantics of the three necessity operators. To do that, we   need to define the auxiliary renaming operator 
%$\adapt{}{}$  defined on states: 
% $\adapt{\sigma'}{\sigma}$ is a state whose heap is as in  $\sigma'$, but which maps the variables in the top frame according to the the tope frame in
% ${\sigma}$. 
%
%\vspace{.02in}
%
% Here is why the operator $\adapt{}{}$ is needed: A naive, first approach to defining the semantics of 
%$\onlyIf{A_1}{A_2}{A}$, would have   the following form: %\footnote{roughly, as we omitted mentioning the module}  
%
%\noindent
%$\strut\ \ \ \           (Def\_1): \\
%\strut\ \ \ \        M \models \onlyIf{A_1}{A_2}{A}\\
%\strut\ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  \strut\ \ \ \ \ \ \ \  \mbox{iff} \\
%\strut\ \ \ \       \forall M', \sigma,\sigma'.[\  \arising{M}{M'}{\sigma}\ \wedge \ M, \sigma \models {A_1}\  \wedge\  M';M, \sigma \leadsto^* \sigma' \   \wedge \ M, \sigma' \models {A_2}\ \ \ \longrightarrow\  \  \  M, \sigma \models A \ ] $
%
%\vspace{.02in}
%
%$ (Def\_1)$ says that a module $M$ satisfies   $ \onlyIf{A_1}{A_2}{A}$ if for all states $\sigma$ that arise from execution of $M$ linked with any arbitrary further module $M'$, and any further s	tates $\sigma'$ which are reachable from  $\sigma$, if $\sigma$ satisfies $A_1$ and $\sigma'$ satisfies $A_2$, then $\sigma$ must also satisfy $A$.
%%
%$(Def\_1)$  captures the main aspects of $\onlyIf{\_}{\_}{\_}$ specifications, but has one problem:
% it does not take into account that the variable bindings in $\sigma'$ might be different from those in $\sigma$. We will explain
% why this is an issue in terms of an example.
% 
%Assume  we had a module  $M_{o\_imm}$ which defined accounts with immutable owners. We can express 
%that the owners are immutable through $(Spec_{o\_imm})$, defined below
%
%\noindent
%$\strut\ \ \ \        Spec_{o\_imm}  \ \ \ \ \ \ \  \triangleq \\
%% \strut\ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  \strut\ \ \ \ \ \ \ \  \triangleq\\
%\strut\ \ \ \        \onlyIf{\ \prg{a:Account} \wedge \prg{o}\!\neq\!\prg{null} \wedge \prg{a.owner}\!=\!{\prg{o}}\ }{\  \prg{a.owner}\!\neq\!{\prg{o}}\ }{\ \prg{false}\ }$
%
%\noindent
%Namely, $(Spec_{o\_imm})$ asserts that once initialized, the value of the field \prg{owner} becomes immutable. \footnote{There exists no state $\sigma$, where the value $\prg{a.owner}$ is not \prg{null}, and might change at some point in the future.} And we would have the expectation that $M_{o\_imm}$ would satisfy $Spec_{o\_imm}$,
%
%\noindent
%$\strut\ \ \ \        (Expectn) \ \ \ M_{o\_imm}\ \models Spec_{o\_imm}$
%
%\vspace{.02in}
%
%However, according to $(Def\_1)$, the $(Expectn)$ does not hold!  
%As a counterexample, consider a state $\sigma_1$ where   
%$M_{o\_imm},\sigma_1 \models \prg{o}\neq \prg{null} \wedge \prg{a.owner}=\prg{o}$, and 
%$\sigma_1$'s continuation is \prg{o:=new Object}. 
% By executing the continuation, 
% we obtain a $\sigma_2$, where $...;\sigma_1 \leadsto  \sigma_2$. 
% Then, because  the value of \prg{o} is different in $\sigma_1$ and $\sigma_2$, 
% we have that $M_{o\_imm},\sigma_2  \models \prg{a.owner}\neq{\prg{o}}$.  
% 
% \vspace{.02in}
% This means, that in $ (Def\_1)$, when we consider whether $\sigma'$ satisfies $A_2$, we need to use the heap from $\sigma'$, but the variable bindings from $\sigma$.
% This is what the renaming operator $\adapt{\sigma'}{\sigma}$   
% does -- more details in   Def.\ref{d:adapt}.   With such an operator, we refine our earlier attempt, and improve $(Def_1)$ as follows
%
%\noindent 
%$\strut\ \ \ \      (Def\_2): \\
%\strut\ \ \ \   M \models \onlyIf{A_1}{A_2}{A}\\
%\strut\ \ \ \ \ \ \ \  \ \ \ \ \ \ \ \  \strut\ \ \ \ \ \ \ \  \mbox{iff} \\
%\strut\ \ \ \ \ \   \forall M', \sigma,\sigma'.[\  \arising{M}{M'}{\sigma}\ \wedge \ M, \sigma \models {A_1}\  \wedge\  M';M, \sigma \leadsto^* \sigma' \   \wedge \ M,  \adapt{\sigma'}{\sigma}  \models {A_2}\ \ \ \longrightarrow\  \  \  M, \sigma \models A \ ] $
%
% \vspace{.04in}
% 
%We now consider the definition of $\adapt{\sigma'}{\sigma}$ in some more detail:
%We already said that $\adapt{\sigma'}{\sigma}$ should be a state whose heap is
%identical to that of ${\sigma'}$ and whose tope frame maps variables in the
%same manner as the top frame of $\sigma$. However, we cannot just copy the 
%top frame of ${\sigma}$ onto the top frame of $\adapt{\sigma'}{\sigma}$, because 
%....}
%% HERE TO EXPLAI WHY WE NEED TO RENAME IN THE CONTINUATUION 

\subsubsection{Adaptation: viewing the future through the lens of the \sd{present}.}
\label{sec:adapt:motivate}
In order to give \sd{semantics to \Nec operators we need the auxiliary concept 
of adaptation.}
%We will first describe why adaptation is needed, then will give the semantics of
%\Nec operators, and then will give the full definition of adaptation.
As a motivation,
\sd{consider the   specification  \Sadapt  from below. 
It says that for an account's balance to go  
from 100 down to 50 in \emph{one} step,   \prg{transfer}  must be called in
the current state: }
%% \onlyThrough{$\prg{a}:\prg{Account} \wedge \prg{a.balance}=100$}
%%   {$\prg{a.balance}=50$}
%%   {$\calls{\_}{a}{transfer}{\_,\_}$}
%
%%NecessityBankSpec  $\triangleq$
%

\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
$\text{\Sadapt}$  $\triangleq$  from a:Account $\wedge$ a.balance == 100
                    next a.balance == 50
                    onlyIf $\calls{\_}{\prg{a}}{\prg{transfer}}{\_,\_}$
\end{lstlisting}
%
%
%
%
\sd{\Sadapt  refers to two different states: at
the start, when the balance of \prg{a} is 100, and  after one step, when 
the balance of \prg{a} is 50.
 \Sadapt  requires that such a change in \prg{balance} can only be caused by a call to \prg{transfer}.}
The first approach to giving semantics of \Sadapt might be:  if $..,\sigma_1 \models \prg{a.balance==100}$,
and  $.., \sigma_1 \leadsto \sigma_2$ and $\sigma_2 \models \prg{a.balance==50}$,
then $\sigma_1$'s continuation starts with a call to \prg{a.transfer}.

\sd{But what if in $\sigma_1$ there were another account, \prg{a1} with balance 50, and what
if executed the assignment \prg{a=a1}? 
%If we allowed for such assignments to variables, we would be unable to satisfy \Sadapt!
Such an assignment would allow us to reach a $\sigma_2$ where $\sigma_2 \models \prg{a.balance==50}$
without calling \prg{a.transfer}. It looks as it \Sadapt cannot be satisfied!
}

\sd{Obviously, \Sadapt  \emph{is}   satisfied by \ModA, \ModB and \ModC. 
For this,  when we consider the future state, the binding for \prg{a}  must be the same 
as that from the current state, even though we may have assigned to \prg{a}  in the mean time.
This is the remit of the adaptation operator: $\adapt {\sigma'} {\sigma}$ keeps the heap from $\sigma'$,
and renames the variables
in the top stack frame of  $\sigma'$ so that    all variables defined in $\sigma$ have the same 
bindings  $\adapt {\sigma'} {\sigma}$ as in   $\sigma$.
The  semantics of \Sadapt is:\  if $..,\sigma_1 \models \prg{a.balance==100}$,
and  $.., \sigma_1 \leadsto \sigma_2$ and $..., \boldsymbol{\adapt {\sigma_2}{\sigma_1}} \models \prg{a.balance==50}$,
then $\sigma_1$'s continuation starts with a call to \prg{a.transfer}.
}
 \sophiaPonder[I want to drop: (Because \Loo's objects' classes, types, or fields never change
and are never deleted from the heap, we can at least be sure any
object that exists in some state will still exist in all arising future
states).]{}

We next use the operator $\adapt{}{}$ to give semantics to 
\Nec specifications, and after that will
give the full definition of $\adapt{}{}$ in section \ref{sub:adapt:full}.
 


 
%\begin{figure}[htb]
%\input{adaptation}
%   \caption{Example of the adaptation operator
%     (Def. \ref{d:adapt}). %
%     Note: in $\sigma$, $\sigma'$, and $\adapt{\sigma'}{\sigma}$, all but the top frame of the stack is elided for simplicity.
%    }
%   \label{fig:adaptation}
% \end{figure}
 

\subsubsection{Semantics of \Nec Specifications}


We    define  when a module $M$ satisfies  specifications $S$, written as $M \vDash S$, 
by cases over the four possible syntactic forms: 


\noindent
\begin{definition}[\Nec Semantics]
\label{def:necessity-semantics}
For any assertions   $A_1$, $A_2$, and $A$,  we define \\


$\bullet$ \ $\satisfies{M}{{A}}$ \ \ \ iff\ \ \ for all $M'$, $\sigma$,\ if $\arising{M}{M'}{\sigma}$, then $\satisfiesA{M}{\sigma}{A}$. (see Def. \ref{def:mdl-sat})\\

%$\bullet$ \ $\satisfies{M}{{A}}$ \ \ \ as defined in \ref{def:mdl-sat} \\

$\bullet$ \ $\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ \ \ iff\ \  for all $M'$, $\sigma$, $\sigma'$, such that $\arising{M'}{M}{\sigma}$; \\ % and\\

\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\satisfiesA{M}{\sigma}{A}$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
$\;\;\;\;$- $\reductions{M'}{M}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 

$\bullet$ \  $\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$\ \ iff\ \   for all $M'$, $\sigma$,   $\sigma'$, such that $\arising{M}{M'}{\sigma}$: \\

\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\satisfiesA{M}{\sigma}{A}$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
$\;\;\;\;$- $\reduction{M'}{M}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 
  
$\bullet$ \  $\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ \ \ iff\ \  for all $M'$, $\sigma_1$,   $\sigma_n$, such that $\arising{M}{M'}{\sigma_1}$: \\

\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma_1}{A_1}$  & 
\rdelim\}{3}{3mm}%[\makecell{Some really \\ longer text}]
[$\;\;\;\Rightarrow\;\;\;$\pbox{9cm}{$\forall \sigma_2, \ldots, \sigma_{n-1}$.  \\ 
(\ \ $\forall i\!\in\![1..n).\ \reduction{M'}{M}{\sigma_i}{\sigma_{i+1}}$   \ $\Rightarrow$
$\exists i\!\in\![1..n]. \  \satisfiesA{M}{\sigma_i \triangleleft \sigma_1}{A}$ \ \ )   }] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma_n\triangleleft \sigma}{A_2}$   \\
$\;\;\;\;$- $\reductions{M'}{M}{\sigma}{\sigma_n}$   \\
\end{tabular} 
\end{definition} 

\subsubsection{Adaptation - full definition}
\label{sub:adapt:full}
We now \sd{give the full definition of the $\adapt{}{}$ operator.}
\sd{We have already seen in section \ref{sec:adapt:motivate} that % the variable map % from the top frame 
  $\adapt  {\sigma'}{\sigma}$
must interpret the variable map from the viewpoint of $\sigma$. }
\sd{
In addition, it must also interpret the continuation in  $\adapt  {\sigma'}{\sigma}$
from the viewpoint of $\sigma$. }

\sd{To see why this is needed, take  states $\sigma$ and $\sigma'$ where 
$\interpret {\sigma}{\prg{a}}\neq \interpret {\sigma}{\prg{a1}}$,
  the continuation in $\sigma$ is $\prg{a=a1;}$ $\prg{a.transfer}(...)$, and where execution of \prg{a=a1} leads
  from $\sigma$  to $\sigma'$. 
  We then have that $.. \sigma'  \models {\calls{...}{\prg{a}}{\prg{transfer}}{...}}$ as well as 
  $... \sigma'  \models {\calls{...}{\prg{a1}}{\prg{transfer}}{...}}$. 
  The definition of $\adapt  {\sigma'}{\sigma}$ should be so that 
  $... \adapt  {\sigma'}{\sigma}  \not\models {\calls{...}{\prg{a}}{\prg{transfer}}{...}}$ and so that
   $... \adapt  {\sigma'}{\sigma} \models {\calls{...}{\prg{a1}}{\prg{transfer}}{...}}$
}

\sd{To achieve this, in Def.\ref{d:adapt} below,
 we introduce fresh variables  $\overline{y}$.  
We extend $\sigma$'s variable map ($\beta$), so that it also maps $\overline{y}$ 
in the way that  $\sigma'$'s variable map ($\beta'$) maps its local variables -- $\beta'' =  \beta[\overline{y} \mapsto \sd{\beta'(\overline{x})}]$. We rename $\overline{x}$   in $\sigma'$ continuation
to $\overline{y}$ --  $\kappa''=[\overline{y}/\overline{x}]\kappa'$.
}
Our Definition is equivalent to the  \emph{adaptation} operator \cite{FASE}. 
%We
%  write
%  $\adapt {\sigma'} {\sigma}$
%  to view a future state $\sigma'$ from the perspective of a current
%  (or past) state $\sigma$. 


%Def.\ref{d:adapt} shows how $\adapt{\sigma'}{\sigma}$ constructs a new
%state, taking the heap and most of the stack from the future state 
%$\sigma'$. We replace the top frame's variable map 
%with the variable map from the top frame of the past state $\sigma$,
%avoiding name clashes by renaming the 
%variables in the top frame of $\sigma'$ with fresh variables
%($\overline{v}$) and renaming free variables in the continuation similarly.


 
\begin{definition}
\label{d:adapt}
For any states $\sigma$, $\sigma'$, heaps $\chi$, $\chi'$, %frames $\phi$, $\phi'$, 
variable maps $\beta$, $\beta'$, 
and continuations $\kappa$, $\kappa'$, such that 
$\sigma$=$(\chi,(\beta,\kappa):\psi)$, and $\sigma$=$(\chi',(\beta',\kappa'):\psi')$, we define 
\begin{itemize}
\item $\adapt{\sigma'}{\sigma} \triangleq (\chi', (\beta'',\kappa'') : \psi')$ \\
where there exist variables $\overline{y}$ such that
\begin{itemize}
\item
$\beta'' =  \beta[\overline{y} \mapsto \sd{\beta'(\overline{x})}]$, \ and\  $\kappa''=[\overline{y}/\overline{x}]\kappa'$
\item
$dom(\beta')=\overline{x}$,  and $|\overline{y}| = |\overline{x}|$,\  and\  $\overline{y}$ are fresh in $\beta$ and $\beta'$.
\end{itemize}
\end{itemize}
\end{definition}

%\begin{definition}
%\label{d:adapt}
%$\adapt{\sigma'}{\sigma} \triangleq (\chi', \phi'' : \psi')$
%where 
%\begin{itemize}
%\item
%$\sigma = (\chi, \phi : \psi)$ 
%and
%$\sigma' = (\chi', \phi' : \psi')$
%\item
%$\phi = \{\prg{local}:=\beta; \prg{contn}:=\_\}$, and
%$\phi' = \{\prg{local}:=\beta', \prg{contn}:=c'\}$
%\item
%$\phi'' = \{\prg{local}:=\beta[\overline{y} \mapsto rng(\beta')]; \prg{contn}:=[\overline{y}/dom(\beta')]c'\}$
%\item
%$\overline{y}$ is fresh $\beta$ and $\beta'$, and $|\overline{y}| = |dom(\beta')|$
%\end{itemize}
%\end{definition}


%We are now able to state what the necessary preconditions to critical functions in 
%software are, including safety properties of software in the open world. The semantics
%of \emph{Single-Step Only If} allow for the statement of such necessary preconditions
%for any execution step for any program to achieve a certain outcome. The semantics
%of \emph{Only If} and \emph{Only Through} allow us to raise these necessary preconditions
%to any arbitrary number of execution steps, and thus allow for reasoning about 
%the execution of an entire program.
% 

\sd{Strictly speaking, $\adapt {}{}$  does not define one  unique state: Because the variables $\overline{y}$ 
are arbitrarily chosen,   $\adapt {}{}$ describes an infinite set of states. These states are   equivalent with each 
other, in the sense that  they satisfy the same assertions.
This is why it is sound to  use $\adapt {}{}$  as an operator, rather than as a set.
}

\sophiaPonder[Julian, you had written "Adaptation may seem complex, however ...." I find such sentences "defeatist" -- propose we remove it. yes?]{}


%SD chopped below; find it too "generic"
% Both of these specifications are important, and are both used as intermediate steps
%when we present the full proof of \prg{NecessityBankSpec} later in Section \ref{s:examples}.
%\Nec thus provides us with a rich language for talking about the necessary conditions
%under which critical actions within of our software are allowed to occur. 


%\jm[]{It is worth discussing the semantics of \Nec specifications and their 
%relation to typical logical consequence and Hoare logic. A classical Hoare triple, 
%$\hoare{P}{C}{Q}$, denotes that any program state that satisfies $P$, after execution 
%of program $C$, will result in a program state that satisfies $Q$. Thus, $P$ represents 
%a subset of program states that after execution of $C$ results in a program state satisfying $Q$.
%Conversely, $Q$ represents a superset of program states resulting from the execution of $C$ in 
%a program state satisfying $P$. Thus, we can soundly strengthen the left hand side ($P$), and weaken
%the right hand side ($Q$). This intuition extends to all three specifications. 
%For example, from \prg{NecessityBankSpec'}, while it is somewhat contrived, we are able to
%strengthen the ``left hand side'' by adding information, and weaken the ``right hand side'', 
%and conclude that}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%NecessityBankSpec'''  $\triangleq$  from a:Account $\wedge$ a.balance == bal $\wedge$ bal == x + y $\wedge$ y > 0
%                       nxt a.balance == x
%                       onlyIf $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\access{\prg{o}}{\prg{a}}$]
%\end{lstlisting}
%\jm[]{This follows because in the above specification, (a)\prg{x < bal}, and thus \prg{a.balance = x} implies and $a.balance < bal$,
%and (b) if an object calls a method on another object, it follows that it has access to that object.
%More generally, given a Single-Step Only-If specification, 
%$\onlyIfSingle{A_1}{A_2}{A}$, $A_1$ and $A_2$ represent a subset of single step execution paths starting from a program state 
%satisfying $A_1$ and reaching a program state satisfying $A_2$, that have $A$ as a necessary precondition. 
%In the same way the converse is true, i.e. $A$ represents a superset of initial program states
%for execution starting at a state satisfying $A_1$ and reaching a state satisfying $A_2$ after a single step of execution.
%As with Hoare logic, we are able to soundly strengthen the left hand side ($A_1$ and $A_2$)
%and strengthen the right hand side ($A$). This intuition also extends to Only-If and Only-Through specifications. 
%In some places later in this paper, we use the distinction ``\emph{left hand side}'' of a \Nec specification
%to denote the two left most assertions in the specification, and ``\emph{right hand side}'' to denote
%the necessity precondition.}
 
 
