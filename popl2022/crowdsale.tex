\section{Crowdsale}
\jm[]{It is notable that \Nec is able to encode the motivating example of \citeauthor{VerX}: 
an escrow smart contract that ensures that the contract may not be maliciously coerced.
The motivating \prg{Crowdsale} example consists of a \prg{Crowdsale} contract 
for crowd sourcing funding. A \prg{Crowdsale} object consists of an \prg{Escrow} object,
an amount raised, a funding goal, and a closing time in which the goal must be met for 
the fund to be successful. An \prg{Escrow} consists of a ledger of investors and how much
they have invested. There are several properties that \citeauthor{VerX} sought to encode,
and we have provided the encoding of those specifications in Fig. \ref{f:verx:encoding}.
\prg{R0} states that if an investor claims a refund from an escrow, then the balance of 
the escrow decreases by the amount the investor had deposited in the escrow. 
\prg{R1} states that if at anytime the escrow has not yet succeeded, then the deposits must
be less than the balance of the escrow. 
\prg{R2\_1} and \prg{R2\_2} combine to express a single property: no one may ever withdraw and 
then subsequently claim a refund or visa versa.
\prg{R3} states that if the funding goal is ever met, then no one may subsequently claim a refund.}

\begin{figure}[htb]
\begin{lstlisting}[language=chainmail]
contract Crowdsale {
Escrow escrow;
  uint256 closeTime;
  uint256 raised = 0;
  uint256 goal = 10000 * 10**18;
  function constructor() {
    escrow = new Escrow(0x1234);
    closeTime = now + 30 days;
  }
  function invest() payable {
    require(raised < goal);
    // fix: uncomment pre-condition below:
    // require(now<=closeTime);
    escrow.deposit.value(msg.value)(msg.sender);
    raised += msg.value;
  }
  function close() {
    require(now > closeTime || raised >= goal);
    if (raised >= goal) {
      escrow.close();
    } else {
      escrow.refund();
    }
  }
}
\end{lstlisting}
\caption{Crowdsale Contract}
\label{f:verx:crowdsale}
\end{figure}

\begin{figure}[htb]
\begin{lstlisting}[language=chainmail]
contract Escrow {
  address owner, beneficiary;
  mapping(address => uint256) deposits;
  enum State {OPEN, SUCCESS, REFUND}
  State state = OPEN;
  constructor(address b) {
    owner = msg.sender;
    beneficiary = b;
  }
  modifier onlyOwner {
    require(msg.sender == owner);
  }
  function close() onlyOwner {state = SUCCESS;}
  function refund() onlyOwner {state = REFUND;}
  function deposit(address p) onlyOwner payable {
    deposits[p] = deposits[p] + msg.value;
  }
  function withdraw() {
    require(state == SUCCESS);
    beneficiary.transfer(this.balance);
  }
  function claimRefund(address p) {
    require(state == REFUND);
    uint256 amount = deposits[p];
    deposits[p] = 0;
    p.call.value(amount)();
  }
}
\end{lstlisting}
\caption{Escrow Contract}
\label{f:verx:escrow}
\end{figure}

\begin{figure}[htb]
\begin{lstlisting}[mathescape=true, language=chainmail]
(R0) $\triangleq$ e : Escrow $\wedge$ $\calls{\_}{\prg{e}}{\prg{claimRefund}}{\prg{p}}$
          next e.balance = nextBal onlyIf nextBal = e.balance - e.deposits(p)
(R1) $\triangleq$ e : Escrow $\wedge$ e.state $\neq$ SUCCESS $\longrightarrow$ sum(deposits) $\leq$ e.balance
(R2_1) $\triangleq$ e : Escrow $\wedge$ $\calls{\_}{\prg{e}}{\prg{withdraw}}{\prg{\_}}$
           to $\calls{\_}{\prg{e}}{\prg{claimRefund}}{\prg{\_}}$ onlyIf false
(R2_2) $\triangleq$ e : Escrow $\wedge$ $\calls{\_}{\prg{e}}{\prg{claimRefund}}{\prg{\_}}$
           to $\calls{\_}{\prg{e}}{\prg{withdraw}}{\prg{\_}}$ onlyIf false
(R3) $\triangleq$ c : Crowdsale $\wedge$ sum(deposits) $\geq$ c.escrow.goal
         to $\calls{\_}{\prg{c.escrow}}{\prg{claimRefund}}{\prg{\_}}$ onlyIf false
\end{lstlisting}
\caption{Encoding VerX Crowdsale Example in Necessity}
\label{f:verx:encoding}
\end{figure}