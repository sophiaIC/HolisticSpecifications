\section{Proof of Adherence to \prg{NecessityBankSpec}}
\label{s:examples}

In this section we return to the Bank Account example, 
providing an elaborated proof. 
The accompanying Coq formalism includes a mechanized version of this proof,
however we provide an elaboration of this proof here to demonstrate the logic
and it's expressiveness.
%\subsection{Reasoning About \SpecO Specifications}
As we have stated Section \ref{s:inference}, 
we assume the existence of a logic for constructing proofs
of the form $\proves{M}{A}$, denoting that in 
any arising program state, with internal module $M$, $A$ is satisfied. 
For the purposes of the examples in this section, we state several 
rules that under any such logic should be sound. 
\jm[]{Further, recall that as per Def. \ref{def:necessity-semantics},
$\satisfies{M}{A}$ is defined for arising program states, and thus by Theorem \ref{thm:soundness},
if $\proves{M}{A}$, it follows that for all arising program states in the context fo internal 
module $M$, $A$ is satisfied.}
{\footnotesize
\begin{mathpar}
\infer
		{}
		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \external{x}}}
		\quad(\textsc{Caller-Ext})
		\and
\infer
		{}
		{\proves{M}{\calls{x}{y}{m}{\overline{z}}\ \longrightarrow\ \access{x}{y}}}
		\quad(\textsc{Caller-Recv})
		\and
\infer
		{}
		{\proves{M}{\calls{x}{y}{m}{\ldots, z_i, \ldots}\ \longrightarrow\ \access{x}{z_i}}}
		\quad(\textsc{Caller-Args})
		\and
\infer
		{C \in M}
		{\proves{M}{x\ :\ C\ \longrightarrow\ \internal{x}}}
		\quad(\textsc{Class-Int})
		\and
\infer
		{(\prg{field}\ \_\ f\ :\ D)\ \in\ M(C).(\prg{flds})}
		{\proves{M}{e : C\ \longrightarrow\ e.f : D}}
		\quad(\textsc{Fld-Class})
		\and
\infer
		{(\prg{class}\ \enclosed\ C \{\_; \_\})\ \in\ M}
		{\proves{M}{x : C\ \longrightarrow\ \wrapped{x}}}
		\quad(\textsc{Wrapped-Int})
		\and
\infer
		{}
		{\proves{M}{\false\ \longrightarrow\ A}}
		\quad(\textsc{Absurd})
		\and
\infer
		{}
		{\proves{M}{A\ \vee\ \neg A}}
		\quad(\textsc{Excluded Middle})
\end{mathpar}
\normalsize}

\begin{figure}[t]
\begin{lstlisting}[mathescape=true, frame=lines]
module Mod4
  class Account
    field password : Object
    method authenticate(pwd : Object) : bool
      (PRE:  a : Account $\wedge$ b : Bank
       POST: b.getBalance(a)$_\prg{old}$ == b.getBalance(a)$_\prg{new}$)
      (PRE:  a : Account
       POST: res != a.password)
      (PRE:  a : Account
       POST: a.password$_\prg{old}$ == a.password$_\prg{new}$)
      {return pwd == this.password}
    method changePassword(pwd : Object, newPwd : Object) : void
      (PRE:  a : Account
       POST: res != a.password)
      (PRE:  a : Account $\wedge$ b : Bank
       POST: b.getBalance(a)$_\prg{old}$ == b.getBalance(a)$_\prg{new}$)
      (PRE:  a : Account $\wedge$ pwd != this.password
       POST: a.password$_\prg{old}$ = a.password$_\prg{new}$)
      {if pwd == this.password
        this.password := newPwd}

  class enclosed Ledger
    field acc1 : Account
    field bal1 : int
    field acc2 : Account
    field bal2 : int
    ghost intrnl getBalance(acc) : int = 
      if acc == acc1
        bal1
      else if acc == acc2
        bal2
      else -1
    method transfer(amt : int, from : Account, to : Account) : void
      (PRE:  a : Account $\wedge$ b : Bank $\wedge$ (a != acc1 $\wedge$ a != acc2)
       POST: b.getBalance(a)$_\prg{old}$ == b.getBalance(a)$_\prg{new}$)
      (PRE:  a : Account
       POST: res != a.password)
      (PRE:  a : Account
       POST: a.password$_\prg{old}$ == a.password$_\prg{new}$)
      {if from == acc1 && to == acc2
         bal1 := bal1 - amt
         bal2 := bal2 + amt
       else if from == acc2 && to == acc1
         bal1 := bal1 + amt
         bal2 := bal2 - amt}
      

  class Bank
    field book : Ledger
    ghost intrnrl getBalance(acc) : int = book.getBalance(acc)
    method transfer(pwd : Object, amt : int, from : Account, to : Account) : void
      (PRE:  a : Account $\wedge$ b : Bank $\wedge$ $\neg$ (a == acc1 $\wedge$ a == acc2)
       POST: b.getBalance(a)$_\prg{old}$ a= b.getBalance(a)$_\prg{new}$)
      (PRE:  a : Account
       POST: res != a.password)
      (PRE:  a : Account
       POST: a.password$_\prg{old}$ == a.password$_\prg{new}$)
      {if (from.authenticate(pwd))
         book.transfer(amt, from, to)}
\end{lstlisting}
\caption{Bank Account Module}
\label{f:ex-bank}
\end{figure}
We devote the rest of this section to the elaborated \jm[]{proof} of \jm[]{a variation on} our
running example of a Bank Account, along with a proof 
of the bank account specification using our Logic of Necessity.
\jm[]{The Bank Account defined in this section introduces several 
complexities over that defined in Section \ref{s:outline}. Notably,
in the Bank Account defined in this section, we separate the balance 
of an account into a ledger that is stored within a bank. Thus, 
the module \texttt{Mod4} (Fig \ref{f:ex-bank}) consists of 3 classes: (1) \texttt{Account} that
maintiains a password, (2) \texttt{Bank}, a public interface 
for transfering money from one account to another, and (3) \texttt{Ledger},
a private class, annotated as \texttt{enclosed}, used to map \texttt{Account} objects
to their \texttt{balance}. }


\jm[]{We provide the implementation} of \jm[]{\prg{Mod4}} in Fig. \ref{f:ex-bank}.
A \prg{Bank} consists of a \prg{Ledger}, a method for transferring 
funds between accounts (\prg{transfer}), and a ghost field, \prg{balance}
for looking up the balance of an account at a bank.\footnote{A Necessity Specification is independent of the implementation details of the code. It would need to hold for an account whose implementation did not use a ledger or ghost variables to hold balances.}
A \prg{Ledger} is
a mapping from \prg{Account}s to their balances. Note, for brevity
our implementation only includes two accounts (\prg{acc1} and \prg{acc2}),
but it is easy to see how this could extend to a \prg{Ledger}
of arbitrary size. \prg{Ledger} is annotated as \enclosed, and as 
such the type system ensures our required encapsulation properties.
Finally, an \prg{Account} has some \prg{password} object, and 
methods to authenticate a provided password (\prg{authenticate}), 
change the password (\prg{changePassword}).
\jm[]{
The inclusion of the \texttt{Ledger} to the example, 
and the separation of the balance from the \texttt{Account} means that
we are required to consider the entire module, not just the single \texttt{Account} class.
Further, we now rewrite \texttt{NecessityBankSpec} to use a ghost field, \texttt{getBalance},
and not simply the balance field in \texttt{Mod1}, \texttt{Mod2}, and \texttt{Mod3}.
This further abstracts the implementation of the Bank Account from the necessity specification \texttt{NecessityBankSpec}. The new 
\texttt{NecessityBankSpec} is given below.
}
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
NecessityBankSpec $\triangleq$ from b : Bank $\wedge$ b.getBalance(a) = bal 
                     to b.getbalance(a) < bal
                     onlyIf $\neg\wrapped{\prg{a}}$
\end{lstlisting}
That is, if the balance of an account ever decreases, it must be true that some object external to
\prg{Mod4} has access to the password of that account. 

\jm[]{While both the implementation and the specification being proven have changed from that of
\ref{s:outline}, the structure of the proofs do retain some similarities. In particular in this section 
we still start by demonstrating the encapsulation of both the balance and password of an \texttt{Account}. 
Further, the broad structure remains the same, in that we first demonstrate that a reduction in the balance
of an \texttt{Account} necessitates a call to \texttt{transfer}, and thus knowledge of the password at some 
point in time. We then demonstrate that knowledge of the password can not be illicitly obtained by coercing 
the Bank Account interface to leak it. Thus we conclude that someone must have present knowledge of the password.}
An informal account of the construction of 
the overall proof follows the outline of our reasoning given in Section \ref{s:approach}:
\begin{description}
\item[Part 1:]
We use our rudimentary encapsulation system to prove that both \prg{b.getBalance(a) = bal} and \prg{a.password = pwd} are encapsulated assertions.
\item[Part 2:]
We use classical specifications to prove that only a call to \prg{Bank::transfer} 
with the correct password may be used to decrease the balance of an account. Similarly, we
use classical specifications to prove that no method can leak the password or overwrite of an account.
Note, it is this proof step that fails for \prg{Mod2}, as the password may be overwritten. Further note that in the 
proof, there is no distinction made between leaking and overwriting of the password, as both properties allow for external 
objects to have no access to the password, but in the next moment have access to that password, whether that is 
by gaining access to (leaking), or changing the password (overwriting).
\item[Part 3:]
We combine the per-method necessary preconditions along with the encapsulation of \prg{b.getBalance(a) = bal} to arrive at a per-step
necessary precondition for reducing the balance using \emph{any} method in \jm[]{\prg{Mod4}}. Similarly, 
we show that \emph{no} step may leak the password of an account.
\item[Part 4:]
Finally we use the Logic of Necessity and the results of A, B, and C, to prove the emergent behavior specified in \prg{NecessityBankSpec}.
\end{description}

%\clearpage
\subsection{A: The Encapsulation of Account Balance and Password}
\label{s:BA-encap}
We base the soundness of our encapsulation of the type system of \Loo, and use the proof rules given in Fig.s \ref{f:intrnl} and \ref{f:asrt-encap}.
We provide the proof for the encapsulation of \prg{b.getBalance(a)} below\\
%\begin{figure}[h]
\begin{proofexample}
\proofsteps{\prg{BalanceEncaps}}
	{\begin{proofexample}
		\proofsteps{\prg{aIntrnl}}
			{\proofstepwithrule
			{$\proves{\prg{Mod4}}{\givenA{\prg{b, b$^\prime$ : Bank $\wedge$ a : Account $\wedge$ b.getBalance(a) = bal}}{\intrnl{\prg{a}}}}$}
				{by \textsc{Intrnl-Obj}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{bIntrnl}}
			{\proofstepwithrule
			{$\proves{\prg{Mod4}}{\givenA{\prg{b, b$^\prime$ : Bank $\wedge$ a : Account $\wedge$ b.getBalance(a) = bal}}{\intrnl{\prg{b}}}}$}
				{by \textsc{Intrnl-Obj}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{getBalIntrnl}}
			{\proofstepwithrule
			{$\proves{\prg{Mod4}}{\givenA{\prg{b, b$^\prime$ : Bank $\wedge$ a : Account $\wedge$ b.getBalance(a) = bal}}{\intrnl{\prg{b.getBalance(a)}}}}$}
				{by \prg{aEncaps}, \prg{bEncaps}, and \textsc{Intrnl-Ghost}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{balIntrnl}}
			{\proofstepwithrule
			{$\proves{\prg{Mod4}}{\givenA{\prg{b, b$^\prime$ : Bank $\wedge$ a : Account $\wedge$ b.getBalance(a) = bal}}{\intrnl{\prg{bal}}}}$}
				{by \textsc{Intrnl-Int}}
		}
		\endproofsteps
	\end{proofexample}
		}
		{\proofstepwithrule
			{
			$\proves{\prg{Mod4}}{\givenA{\prg{b, b$^\prime$ : Bank $\wedge$ a : Account $\wedge$ b.getBalance(a) = bal}}{\encaps{\prg{b.getBalance(a) = bal}}}}$
			}{by \prg{getBalIntrnl}, \prg{balIntrnl}, \textsc{Enc-Intrnl}}}
\endproofsteps
\end{proofexample}\\
We omit the proof of $\encaps{\prg{a.password = pwd}}$, as its construction is very similar to that of $\encaps{\prg{b.getBalance(a) = bal}}$.
%\caption{Proof of encapsulation of \prg{b.getBalance(a) = bal}}
%\end{figure}

\subsection{B: Proving Necessary Preconditions from Classical Specifications}
\label{s:BA-classical}
We now provide proofs for necessary preconditions on a per-method basis, leveraging 
classical specifications.

First we use the classical specification of the \prg{authenticate} method in \prg{Account} to prove that a call to \prg{authenticate} can only result in 
a decrease in balance in a single step if there were in fact a call to \prg{transfer} to the \prg{Bank}. This may seem 
odd at first, and impossible to prove, however we leverage the fact that we are first able to prove that \prg{false}
is a necessary condition to decreasing the balance, or in other words, it is not possible to decrease the balance by a
call to \prg{authenticate}. We then use the proof rule \textsc{Absurd} to prove our desired necessary condition.
This proof is presented as \prg{AuthBalChange} below.
\\
\noindent
{
	\begin{proofexample}
		\proofsteps{AuthBalChange}
			{\proofstepwithrule
				{\hoareEx
						{a : Account $\wedge$ a$^\prime$ : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a$^\prime$) = bal}
						{a.authenticate(pwd)}
						{b.getbalance(a$^\prime$) == bal}
						}
					{by classical spec.}
			}
			{\proofstepwithrule
				{\hoareEx
						{a : Account $\wedge$ a$^\prime$ : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a$^\prime$) = bal $\wedge$ $\neg$ false}
						{a.authenticate(pwd)}
						{$\neg$ b.getbalance(a$^\prime$) < bal}
						}
					{by classical Hoare logic}
			}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{a : Account $\wedge$ a$^\prime$ : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a$^\prime$) = bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{authenticate}}{\prg{pwd}}$}
						{b.getbalance(a$^\prime$) < bal}
						{false}
						}
					{by \textsc{If1-Classical}}
			}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{a : Account $\wedge$ a$^\prime$ : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a$^\prime$) = bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{authenticate}}{\prg{pwd}}$}
						{b.getbalance(a$^\prime$) < bal}
						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a$^\prime$.password, amt, a$^\prime$, to}}$}
						}
					{by \textsc{Absurd} and \textsc{If1-}$\longrightarrow$}
			}
		\endproofsteps
	\end{proofexample}
}
We provide the statements of the proof results for the remaining methods in the module below,
%(\textbf{ChangePasswordBalChange}, \textbf{Ledger::TransferBalChange}, and \textbf{Bank::TransferBalChange}), 
but we elide most of the steps as they do not differ much from that of \textbf{AuthBalChange}.\\
{
	\begin{proofexample}
		\proofsteps{ChangePasswordBalChange}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{a, a$^\prime$ : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a$^\prime$) = bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{changePassword}}{\prg{pwd}}$}
						{b.getbalance(a$^\prime$) < bal}
						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a$^\prime$.password, amt, a$^\prime$, to}}$}
						}
					{by similar reasoning to \textbf{AuthBalChange}}
			}
		\endproofsteps
	\end{proofexample}
}
%\begin{minipage}{\textwidth}
%{
%	\begin{proofexample}
%		\proofsteps{Ledger::TransferBalChange}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l : Ledger $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getbalance(a) < bal}
%						{$\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						}
%					{by \textsc{If-Start} and \textsc{If1-If}}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l : Ledger $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getbalance(a) < bal}
%						{$\neg\wrapped{\prg{l}}$}
%						}
%					{by \textsc{If1-}$\longrightarrow$, \textsc{Caller-Ext}, and \textsc{Caller-Recv}}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l : Ledger $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getbalance(a) < bal}
%						{\false}
%						}
%					{by \textsc{Intrnl-Wrapped} and \textsc{If1-}$\longrightarrow$}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l : Ledger $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getbalance(a) < bal}
%						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
%						}
%					{by \textsc{Absurd} and \textsc{If1-}$\longrightarrow$}
%			}
%		\endproofsteps
%	\end{proofexample}
%}
%\end{minipage}
{
	\begin{proofexample}
		\proofsteps{Ledger::TransferBalChange}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{l : Ledger $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
						{b.getbalance(a) < bal}
						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
						}
					{by similar reasoning to \textbf{\prg{AuthBalChange}}}
			}
		\endproofsteps
	\end{proofexample}
}
{
	\begin{proofexample}
		\proofsteps{Bank::TransferBalChange}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{b$^\prime$ : Bank $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{b$^\prime$}}{\prg{transfer}}{\prg{pwd, amt, from, to}}$}
						{b.getbalance(a) < bal}
						{a == from $\wedge$ pwd == a.password $\wedge$ b$^\prime$ == b}
						}
					{by similar reasoning to \textbf{AuthBalChange}}
			}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ $\calls{\_}{\prg{b$^\prime$}}{\prg{transfer}}{\prg{pwd, amt, from, to}}$}
						{b.getbalance(a) < bal}
						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
						}
					{by \textsc{If1-}$\longrightarrow$}
			}
		\endproofsteps
	\end{proofexample}
}
Below we provide the proofs for each method in \jm[]{\prg{Mod4}} that they cannot
be used to leak the password of an account. \\
{
	\begin{proofexample}
		\proofsteps{AuthPwdLeak}
			{\proofstepwithrule
				{\hoareEx
						{a : Account $\wedge$ a$^\prime$ : Account $\wedge$ a.password == pwd}
						{\prg{res} = a$^\prime$.authenticate(\_)}
						{res != pwd}
						}
					{by classical spec.}
			}
			{\proofstepwithrule
				{\hoareEx
						{a : Account $\wedge$ a$^\prime$ : Account $\wedge$ a.password == pwd $\wedge$ $\neg$ false}
						{\prg{res} = a$^\prime$.authenticate(\_)}
						{res != pwd}
						}
					{by classical Hoare logic}
			}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{$\wrapped{\prg{pwd}}$ $\wedge$ a : Account $\wedge$ a$^\prime$ : Account $\wedge$ a.password = pwd $\wedge$ $\calls{\_}{\prg{a}^\prime}{\prg{authenticate}}{\_}$}
						{$\neg \wrapped{\_}$}
						{false}
						}
					{by \textsc{If1-Wrapped}}
			}
		\endproofsteps
	\end{proofexample}
	}
	{
	\begin{proofexample}
		\proofsteps{ChangePasswordLeak}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{$\wrapped{\prg{pwd}}$ $\wedge$ a : Account $\wedge$ a$^\prime$ : Account $\wedge$ a.password = pwd $\wedge$ $\calls{\_}{\prg{a}^\prime}{\prg{changePassword}}{\_, \_}$}
						{$\neg \wrapped{\prg{pwd}}$}
						{false}
						}
					{by similar reasoning to \textbf{AuthPwdLeak}}
			}
		\endproofsteps
	\end{proofexample}
	}
	{
	\begin{proofexample}
		\proofsteps{Ledger::TransferPwdLeak}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{$\wrapped{\prg{pwd}}$ $\wedge$ a : Account $\wedge$ l : Ledger $\wedge$ a.password = pwd $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\_, \_, \_}$}
						{$\neg \wrapped{\prg{pwd}}$}
						{false}
						}
					{by similar reasoning to \textbf{AuthPwdLeak}}
			}
		\endproofsteps
	\end{proofexample}
	}
	{
	\begin{proofexample}
		\proofsteps{Bank::TransferPwdLeak}
			{\proofstepwithrule
				{\onlyIfSingleEx
						{$\wrapped{\prg{pwd}}$ $\wedge$ a : Account $\wedge$ b : Bank $\wedge$ a.password = pwd $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\_, \_, \_, \_}$}
						{$\neg \wrapped{\prg{pwd}}$}
						{false}
						}
					{by similar reasoning to \textbf{AuthPwdLeak}}
			}
		\endproofsteps
	\end{proofexample}
	}

\subsection{C: Proving Per-Step Necessary Specifications}
The next step is to construct proofs of necessary conditions for
\emph{any} possible step in our external state semantics.
In order to prove the final result in the next section,
we need to prove three per-step necessity specifications: \prg{BalanceChange}, \prg{PasswordChange}, and \prg{PasswordLeak}.
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
BalanceChange $\triangleq$ from  a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal
                 to1 b.getBalance(a) < bal
                 onlyIf $\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password}, \_, \prg{a}, \_}$
\end{lstlisting}
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
PasswordChange $\triangleq$ from a : Account $\wedge$ a.password = p
                  to1 $\neg$ a.password $\neq$ p
                  onlyIf $\calls{\_}{\prg{a}}{\prg{changePassword}}{\prg{a.password}, \_}$
\end{lstlisting}
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
PasswordLeak $\triangleq$ from a : Account $\wedge$ a.password = p $\wedge$ wrapped<p>
                  to1 $\neg$ wrapped<p>
                  onlyIf false
\end{lstlisting}
We provide the proofs of these below. The proof of \prg{BalanceChange} is constructed
by combining the results from \ref{s:BA-encap} and \ref{s:BA-classical} using \textsc{If1-Internal}. 
Again, we elide the details of the proof of \prg{PasswordChange} and \prg{PasswordLeak} as they are similar to that
of \prg{BalanceChange}. \\
\noindent
\begin{proofexample}
\proofsteps{\prg{BalanceChange}}
	{\proofstepwithrule
			{\onlyIfSingleEx
					{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal}
					{b.getbalance(a) < bal}
					{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
					}
				{by \textbf{AuthBalChange}, \textbf{ChangePasswordBalChange}, \textbf{Ledger::TransferBalChange}, \textbf{Bank::TransferBalChange}, \textbf{BalanceEncaps}, and \textsc{If1-Internal}}
		}
\endproofsteps
\end{proofexample}
\begin{proofexample}
\proofsteps{\prg{PasswordChange}}
	{\proofstepwithrule{\onlyIfSingleEx
				{a : Account $\wedge$ a.password = p}
				{a.password $\neq$ p}
				{$\calls{\_}{\prg{a}}{\prg{changePassword}}{\prg{p}, \_}$}
				}
			{by similar reasoning to \textbf{BalanceChange}}
	}
\endproofsteps
\end{proofexample}
\begin{proofexample}
\proofsteps{\prg{PasswordLeak}}
	{\proofstepwithrule{\onlyIfSingleEx
				{a : Account $\wedge$ a.password = p $\wedge$ $\wrapped{\prg{p}}$}
				{$\neg \wrapped{\prg{p}}$}
				{false}
				}
			{by similar reasoning to \prg{Balancechange}}
	}
\endproofsteps
\end{proofexample}
\subsection{D: Proving Emergent Behavior}
Finally, we combine our module-wide single-step Necessity Specifications to 
prove emergent behavior of the entire system. Informally the
reasoning used in the construction of the proof of \prg{BankSpec} can be stated as
\begin{description}
\item [(1)]
If the balance of an account decreases, then
by \prg{BalanceChange} there must have been a call
to \prg{transfer} in \prg{Bank} with the correct password.
\item [(2)]
If there was a call where the \prg{Account}'s password 
was used, then there must have been an intermediate program state
when some external object had access to the password.
\item [(3)]
Either that password was the same password as in the initial 
program state, or it was different.
\item [(4 A)]
If it is the same as the initial password, then since by \prg{PasswordLeak}
it is impossible to leak the password, it follows that some external object 
must have had access to the password initially.
\item [(4 B)]
If the password is different from the initial password, 
then there must have been an intervening program state when it 
changed. By \prg{PasswordChange} we know that this must have occurred
by a call to change password with the correct password. Thus,
there must be a some intervening program state where the initial
password is known. From here we proceed by the same reasoning 
as \textbf{(4 A)}.
\end{description}
\begin{proofexample}
\proofsteps{\prg{NecessityBankSpec}}
	{\proofstepwithrule{\onlyThroughEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal}
				{b.getBalance(a) < bal}
				{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password}, \_, \prg{a}, \_}$}
				}
			{by \textsc{Changes} and \prg{BalanceChange}}}
	{\proofstepwithrule{\onlyThroughEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal}
				{b.getBalance(a) < bal}
				{$\exists$ o.[$\external{\prg{o}}$ $\wedge$ $\access{\prg{o}}{\prg{a.password}}$]}
				}
			{by $\longrightarrow$, \textsc{Caller-Ext}, and \textsc{Calls-Args}}}
	{\proofstepwithrule{\onlyThroughEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
				{b.getBalance(a) < bal}
				{$\neg$$\wrapped{\prg{a.password}}$}
				}
			{by $\longrightarrow$}}
	{\proofstepwithrule{\onlyThroughEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
				{b.getBalance(a) < bal}
				{$\neg$$\wrapped{\prg{a.password}}$ $\wedge$ (a.password = pwd $\vee$ a.password != pwd)}
				}
			{by $\longrightarrow$ and \textsc{Excluded Middle}}}
	{\proofstepwithrule{\onlyThroughEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
				{b.getBalance(a) < bal}
				{($\neg$$\wrapped{\prg{a.password}}$ $\wedge$ a.password = pwd) $\vee$\\
				($\neg$$\wrapped{\prg{a.password}}$ $\wedge$ a.password != pwd)}
				}
			{by $\longrightarrow$}}
	{\proofstepwithrule{\onlyThroughEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
				{b.getBalance(a) < bal}
				{$\neg$$\wrapped{\prg{pwd}}$ $\vee$
				a.password != pwd}
				}
			{by $\longrightarrow$}}
	{
	\begin{proofexample}
	\proofsteps{Case A ($\neg\wrapped{\prg{pwd}}$)}
			{\proofstepwithrule
				{\onlyIfEx
					{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
					{$\neg$$\wrapped{\prg{pwd}}$}
					{$\wrapped{\prg{pwd}}\ \vee \neg\wrapped{\prg{pwd}}$}
					}
				{by \textsc{If-}$\longrightarrow$ and \textsc{Excluded Middle}}}
			{\proofstepwithrule{\onlyIfEx
					{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
					{$\neg$$\wrapped{\prg{pwd}}$}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by $\vee$E and \prg{PasswordLeak}}}
	\endproofsteps
	\end{proofexample}
	}
	{
	\begin{proofexample}
	\proofsteps{Case B (\prg{a.password != pwd})}
		{\proofstepwithrule{\onlyThroughEx
					{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
					{a.password != pwd}
					{$\calls{\_}{\prg{a}}{\prg{changePassword}}{\prg{pwd}, \_}$}
					}
				{by \textsc{Changes} and \textsc{PasswordChange}}}
		{\proofstepwithrule{\onlyThroughEx
					{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
					{a.password != pwd}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by $\vee$E and \prg{PasswordLeak}}}
		{\proofstepwithrule{\onlyIfEx
					{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
					{a.password != pwd}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by \textbf{Case A} and \textsc{Trans}}}
	\endproofsteps
	\end{proofexample}
	}
	{\proofstepwithrule{\onlyIfEx
				{a : Account $\wedge$ b : Bank $\wedge$ b.getBalance(a) = bal $\wedge$ a.password = pwd}
				{b.getBalance(a) < bal}
				{$\neg\wrapped{\prg{pwd}}$}
				}
			{by \textbf{Case A}, \textbf{Case B}, \textsc{If-}$\vee$I$_2$, and \textsc{If-}$\longrightarrow$}}
\endproofsteps
\end{proofexample}


%\subsection{ERC20}
%The ERC20 is a widely used token standard describing the basic functionality of any Ethereum-based token 
%contract. This functionality includes issuing tokens, keeping track of tokens belonging to participants, and the 
%transfer of tokens between participants. Tokens may only be transferred if there is sufficient tokens in the 
%participant's account, and if either they or someone authorized the participant initiated the transfer. We 
%specify these necessary conditions here using \SpecO and the Logic of Necessity. Firstly, \prg{ERC20Spec1} 
%says that if the balance of a participant's account is ever reduced by some amount $m$, then
%that must have occurred as a result of a call to the \prg{transfer} method with amount $m$ by the participant,
%or the \prg{transferFrom} method with the amount $m$ by some other participant.
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%ERC20Spec1 $\triangleq$ from e : ERC20 $\wedge$ e.balance(p) = m + m' $\wedge$ m > 0
%              to1 e.balance(p) = m'
%              onlyIf $\exists$ p', p''.[$\calls{\prg{p}}{\prg{e}}{\prg{transfer}}{\prg{p', m}}$ $\vee$ $\calls{\prg{p''}}{\prg{e}}{\prg{transferFrom}}{\prg{p', m}}$]
%\end{lstlisting}
%Secondly, \prg{ERC20Spec2} specifies under what circumstances some participant \prg{p'} is authorized to 
%spend \prg{m} tokens on behalf of \prg{p}: either \prg{p} approved \prg{p'}, \prg{p'} was previously authorized,
%or \prg{p'} was authorized for some amount \prg{m + m'}, and spent \prg{m'}.
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%ERC20Spec2 $\triangleq$ from e : ERC20 $\wedge$ p : Object $\wedge$ p' : Object $\wedge$ m : Nat
%              to1 e.allowed(p, p') = m
%              onlyIf $\calls{\prg{p}}{\prg{e}}{\prg{approve}}{\prg{p', m}}$ $\vee$ 
%                     (e.allowed(p, p') = m $\wedge$ 
%                      $\neg$ ($\calls{\prg{p'}}{\prg{e}}{\prg{transferFrom}}{\prg{p, \_}}$ $\vee$ 
%                              $\calls{\prg{p}}{\prg{e}}{\prg{allowed}}{\prg{p, \_}}$)) $\vee$
%                     $\exists$ p''. [e.allowed(p, p') = m + m' $\wedge$ $\calls{\prg{p'}}{\prg{e}}{\prg{transferFrom}}{\prg{p'', m'}}$]
%\end{lstlisting}
%
%\subsection{DAO}
%The Decentralized Autonomous Organization (DAO) is a well-known Ethereum contract allowing 
%participants to invest funds. The DAO famously was exploited with a re-entrancy bug in 2016, 
%and lost \$50M. Here we provide specifications that would have secured the DAO against such a 
%bug. \prg{DAOSpec1} says that no participant's balance may ever exceed the ether remaining 
%in DAO.
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%DAOSpec1 $\triangleq$ from d : DAO
%            to d.balance(p) > d.ether
%            onlyIf false
%\end{lstlisting}
%The second specification \prg{DAOSpec2} states that if a participant's balance is \prg{m}, then 
%either this occurred as a result of joining the DAO with an initial investment of \prg{m}, or the
%balance is \prg{0}, and they've just withdrawn their funds.
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%DAOSpec2 $\triangleq$ from d : DAO
%            to1 d.balance(p) = m
%            onlyIf $\calls{\prg{p}}{\prg{d}}{\prg{repay}}{\prg{\_}}$ $\wedge$ m = 0 $\vee$ $\calls{\prg{p}}{\prg{d}}{\prg{join}}{\prg{m}}$ $\vee$ d.balance(p) = m
%\end{lstlisting}
%
%\subsection{DOM}
%The Domain Object Model (DOM) is the representation of the objects comprising a web document.
%The DOM has a recursive tree structure.
%
%\prg{DOMSpec} states that if the property of a node in a DOM tree changes,
%it follows that either some non-node, non-wrapper object presently has 
%access to a node of the DOM tree, or to some wrapper with access to some 
%ancestor of the node that was modified.
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%DOMSpec $\triangleq$ from nd : Node $\wedge$ n.property = p
%            to nd.property != p
%            onlyIf $\exists$ o.[$\neg$ o : Node $\wedge$ $\neg$ o : Wrapper $\wedge$ 
%                        ($\exists$ nd' : Node.[$\access{\prg{o}}{\prg{nd'}}$] $\vee$ 
%                         $\exists$ w : Wrapper, k : $\mathbb{N}$.[$\access{\prg{o}}{\prg{w}}$ $\wedge$ nd.parnt$^{\prg{k}}$ = w.node.parnt$^{\prg{w.height}}$] )]
%\end{lstlisting}







%\subsection{Bank Account 1 - Simple}
%\label{ex:bank1}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankSpec $\triangleq$  a : Account $\wedge$ a.balance = b to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ only if $\neg\ \encapsulated{\prg{a}}$
%\end{lstlisting}
%We assume that the method \prg{deposit} conforms to the following 
%specification
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%DepositSpec $\triangleq$  {a'.balance = b $\wedge$ a' $\neq$ a $\wedge$ a' $\neq$ from}
%					a.deposit(from, amt) 
%			   {a'.balance = b}
%\end{lstlisting}
%And all other methods \prg{m} in \prg{Account} conform to the 
%following spec
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%AccountMethSpec $\triangleq$  {a : Account $\wedge$ a.balance = b}
%					  a.m(...) 
%			       {a.balance = b}
%\end{lstlisting}
%From \prg{DepositSpec} and \prg{AccountMethSpec} we can derive \prg{BASafety}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%BASafety $\triangleq$  a : Account $\wedge$ a.balance = b 
%            to a.balance != b
%            through Bank
%            onlyIf $\exists$ a'. [a' : Account $\wedge$ $\calls{\_}{\prg{a'}}{\prg{deposit}}{\prg{a, \_}}$ $\vee$ $\calls{\_}{\prg{a}}{\prg{deposit}}{\prg{a'},\_}$
%\end{lstlisting}
%Then we assume that all methods $m$ in \prg{Account} observe the following specification:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%AccountEncapsulation $\triangleq$ {a : Account $\wedge$ $\encapsulated{\prg{a}}$}
%				          a.m(...)
%				       {$\encapsulated{\prg{a}}$}
%\end{lstlisting}
%And thus from \prg{AccoutnEncapsulation} and Definition \ref{def:module_necessary} we can derive \prg{BAEncapsulation}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BAEncapsulation $\triangleq$  a : Account $\wedge$ $\changes{\I}{\encapsulated{\prg{a}}}$
%                 onlyIf false
%\end{lstlisting}
%%\begin{figure}[p]
%\begin{minipage}{\linewidth}
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame = single]
%a : Account $\wedge$ a.balance = b 
%  to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%  onlyThrough $\changes{\prg{\_}}{\prg{a.balance = b}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Changes}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.balance = b $\wedge$ $\encapsulated{\prg{a.balance}}$ 
%  to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%  onlyThrough $\changes{\prg{\_}}{\prg{a.balance = b}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$ and \textsc{Encap-f}$_1s$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.balance = b $\wedge$ $\encapsulated{\prg{a.balance = b}}$ 
%  to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%  onlyThrough $\changes{\I}{\prg{a.balance = b}}$ $\vee$ 
%              $\changes{\I}{\encapsulated{\text{a.balance = b}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Write} and \textsc{Trans}$_1$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.balance = b $\wedge$ $\encapsulated{\prg{a.balance = b}}$ 
%  to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%  onlyThrough $\changes{I}{\prg{a.balance = b}}$ $\vee$ false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Int-f} and \textsc{Trans}$_3$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\scriptsize
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.balance = b $\wedge$ $\encapsulated{\prg{a.balance = b}}$ 
%  to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%  onlyThrough $\changes{I}{\prg{a.balance = b}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\vee$\textsc{E}$_1$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.balance = b $\wedge$ $\encapsulated{\prg{a.balance = b}}$ 
%  to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%  onlyThrough $\exists$ o.[$\access{\prg{o}}{\prg{a}}$ $\wedge$ $\external{\prg{o}}$]
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Int-Changes}, \textsc{BASafety}, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame = none]
%ResultA $\triangleq$ a : Account $\wedge$ a.balance = b  
%            to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%            onlyThrough $\neg\encapsulated{\prg{a}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$
%\end{minipage}
%\end{proofBox}
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%a : Account $\wedge$ $\encapsulated{\prg{a}}$ 
%  to $\neg\encapsulated{\prg{a}}$
%  onlyThrough $\changes{\_}{\encapsulated{\prg{a}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Changes}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ $\encapsulated{\prg{a}}$ 
%  to $\neg\encapsulated{\prg{a}}$
%  onlyThrough $\changes{I}{\encapsulated{\prg{a}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=none]
%ResultB $\triangleq$ a : Account $\wedge$ $\encapsulated{\prg{a}}$ 
%  to $\neg\encapsulated{\prg{a}}$ 
%  onlyThrough false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Int-Changes}, \textsc{BAEncapsulation}, and $\longrightarrow$
%\end{minipage}
%\end{proofBox}
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%a : Account $\wedge$ a.balance = b $\wedge$ 
%  to $\neg\encapsulated{\prg{a}}$ 
%  onlyIf $\encapsulated{\prg{a}}$ $\vee$ $\neg\encapsulated{\prg{a}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{If-True}, \textsc{Excluded Middle}, and \textsc{If}-$\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.balance = b $\wedge$ 
%  to $\neg\encapsulated{\prg{a}}$  
%  onlyIf $\neg \encapsulated{\prg{a}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{If}-$\vee$\textsc{E}$_1$ and \prg{ResultB}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=none]
%Result $\triangleq$ a : Account $\wedge$ a.balance = b $\wedge$ 
%           to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%           onlyIf $\neg \encapsulated{\prg{a}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{ResultA} and \textsc{If-Trans}
%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[mathescape=true, frame=none]
%%Result $\triangleq$ a : Account $\wedge$ a.balance = b $\wedge$ 
%%           to $\langle\ \neg$ a.balance $\neq$ b $\rangle$ 
%%           onlyIf $\neg \bencapsulated{\prg{a}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by Lemma \ref{lem:behaveToTop}(\textsc{Read}) and $\longrightarrow$
%%\end{minipage}
%\end{proofBox}
%\end{minipage}
%%\end{figure} 
%
%\newpage
%
%\subsection{Bank Account 2 - No Leaking} 
%\label{ex:bank2}
%In this version of the Bank Account, we show that we 
%are able to reason about fairly complex forms of encapsulation.
%Specifically if some \prg{Bank} \prg{b} encapsulates
%some \prg{Account} a, then it must follow that 
%the \prg{Ledger} \prg{l} that contains \prg{a}
%is also encapsulated by \prg{b}, and subsequently that any change to
%the balance of \prg{a} requires a call to \prg{transfer}
%on \prg{b}. This is interesting because, while other examples
%do not provide a way to leak access to an account, this example 
%does, but only through the \prg{Ledger} interface, and thus
%encapsulation of the \prg{Ledger} is sufficient to ensure
%encapsulation of the account. Note, this example only proves 
%that leaking of an account is not possible, it does not prove 
%that encapsulation of an account is always assured under all 
%program states. Encapsulation of the account is shown in the
%example in Section \ref{ex:bank3}.
%\begin{lstlisting}[mathescape=true, frame=lines]
%module BankMdl
%  class Account
%    field bal : int
%    method transfer(to, amt)
%      this.bal := this.bal - amt
%      to.bal := to.bal + amt
%
%  class Ledger
%    field acc1 : Account
%    field acc2 : Account
%    method getAcc1()
%      return this.acc1
%    method getAcc2()
%      return this.acc2
%
%  class Bank
%    field accs : Ledger
%    method transfer(amt)
%      this.accs.getAcc1().transfer(this.accs.getAcc2(), amt)
%\end{lstlisting}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankSpec $\triangleq$ a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%             to a.bal $\neq$ x
%             onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%As with the example in Section \ref{ex:bank1}, we require 
%the \verb|Bank| module to prove several invariants:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%AccAccess $\triangleq$ a : Account $\wedge$ $\encapsulates{\prg{B}}{\prg{a}}$
%              to $\neg\encapsulates{\prg{B}}{\prg{a}}$
%              through BankMdl
%              onlyIf $\exists$ o, l. [ l : Ledger $\wedge$ ($\calls{\prg{o}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%                                                 $\calls{\prg{o}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a)]
%\end{lstlisting}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BalChange $\triangleq$ a : Account $\wedge$ a.bal = x
%              to a.bal $\neq$ x
%              through BankMdl
%              onlyIf $\exists$ a' o. [a' : Account $\wedge$ $\external{\prg{o}}$ $\wedge$ 
%                            ($\calls{\_}{\prg{a}}{\prg{transfer}}{\prg{a'}, \_}$ $\vee$ $\calls{\_}{\prg{a'}}{\prg{transfer}}{\prg{a}, \_}$)] $\vee$
%                     $\exists$ b. [b : Bank $\wedge$ $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$ $\wedge$ 
%                            (b.accs.acc1 = a $\vee$ b.accs.acc2 = a)])]
%\end{lstlisting}
%%We also need to prove a more general property of the encapsulation of account objects by bank objects.
%%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%%AccEncap1 $\triangleq$ b : Bank $\wedge$ ($\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ $\vee$ $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$)
%%              $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs}}$
%%\end{lstlisting}
%Finally we need to prove the following property:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankEncapUnique $\triangleq$ a : Account $\wedge$ b b' : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$
%                    (b'.accs.acc1 = a || b'.accs.acc2 = a)
%                    $\longrightarrow$ b' = b
%\end{lstlisting}
%
%
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%  $\changes{\_}{\encapsulates{\prg{b}}{\prg{a}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%  $\changes{X_\prg{\{b\}}}{\encapsulates{\prg{b}}{\prg{a}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Changes}-$\longrightarrow$ and \textsc{Changes-Encap}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a)
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{AccAccess}, \textsc{Changes-Int}, and \textsc{Exists}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a) $\wedge$ $\external{\prg{x}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Calls-Ext/Int}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  x = this $\wedge$ $\access{\prg{x}}{\prg{l}}$ $\wedge$ $\access{\prg{l}}{\prg{a}}$ $\wedge$ $\external{\prg{x}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Calls-}\prg{this} and \textsc{Calls-Recv}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ 
%  ($\encapsulated{\prg{l}}$ $\vee$ l $\in$ {b})
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-}\prg{this}, \textsc{Encap-Access}, and \textsc{Encap-}$\cup$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ $\encapsulated{\prg{l}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\vee$\textsc{E}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\encapsulated{\prg{l}}$ $\wedge$
%  ($\encapsulated{\prg{this}}$ $\vee$ this $\in$ $\I$)
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Access}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\encapsulated{\prg{l}}$ $\wedge$
%  false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=none]
%ResultA $\triangleq$ a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%            $\changes{\_}{\encapsulates{\prg{b}}{\prg{a}}}$ $\longrightarrow$ false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\end{minipage}
%\end{proofBox}
%
%
%%\begin{proofBox}{white}{black}
%%\footnotesize
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg \encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\changes{\_}{\encapsulates{\prg{b}}{\prg{a}}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Changes}
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ $\changes{X_\prg{\{b\}}}{\encapsulates{\prg{b}}{\prg{a}}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Changes}-$\longrightarrow$, \textsc{Changes-Encap} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%%                  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%%                   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a)
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \prg{AccAccess}, \textsc{Changes-Int}, \textsc{Exists}, and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%%                  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%%                   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a) $\wedge$ $\external{\prg{x}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Calls-Ext/Int} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ x = this $\wedge$
%%                  $\access{\prg{x}}{\prg{l}}$ $\wedge$ $\access{\prg{l}}{\prg{a}}$ $\wedge$ $\external{\prg{x}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Calls-}\prg{this}, \textsc{Calls-Recv} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ $\external{\prg{this}}$ $\wedge$
%%                  $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ 
%%                  ($\encapsulated{\prg{l}}$ $\vee$ l $\in$ {b})
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Encap-}\prg{this}, \textsc{Encap-Access}, \textsc{Encap-}$\cup$, and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ $\external{\prg{this}}$ $\wedge$
%%                  $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ 
%%                  $\encapsulated{\prg{l}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ $\external{\prg{this}}$ $\wedge$
%%                  $\neg \encapsulated{\prg{this}}$ $\wedge$ $\encapsulated{\prg{l}}$ $\wedge$
%%                  ($\encapsulated{\prg{this}}$ $\vee$ this $\in$ $\I$)
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Encap-Access} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=none]
%%ResultA $\triangleq$ a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough false
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by $\longrightarrow$
%%\end{minipage}
%%\end{proofBox}
%
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\changes{\_}{\prg{a.bal = x}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Changes} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%     ($\changes{X_{\{\prg{b}\}}}{\prg{a.bal = x}}$ $\vee$ $\changes{X_{\{\prg{b}\}}}{\encapsulates{\prg{b}}{\prg{a}}}$)
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Write} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ $\changes{\I}{\prg{a.bal = x}}$ $\vee$ false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{ResultA}, \textsc{Encap-}$\cup$, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%              $\exists$ a' o. [a' : Account $\wedge$ $\external{\prg{o}}$ $\wedge$ 
%                          ($\calls{\prg{o}}{\prg{a}}{\prg{transfer}}{\prg{a'}, \_}$ $\vee$ 
%                           $\calls{\prg{o}}{\prg{a'}}{\prg{transfer}}{\prg{a}, \_}$)] $\vee$
%              $\exists$ b'. [b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%                      (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])]
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{BalChange}, \textsc{Changes-Int}, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%              ($\external{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{a}}$) $\vee$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Exists}, \textsc{Calls-Recv}, \textsc{Calls-Args}, \textsc{Calls-}\prg{this}, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%              ($\encapsulates{\prg{b}}{\prg{this}}$ $\vee$ this $\in$ {b}) $\vee$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Access}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-}\prg{this} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              b' = b
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{BankEncapUnique} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%Result $\triangleq$ a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%           to a.bal $\neq$ x
%           onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$
%\end{minipage}
%\end{proofBox}
%
%\newpage
%
%\subsection{Bank Account 3 - General Encapsulation  of Accounts}
%\label{ex:bank3}
%Ideally we would like the encapsulation of accounts to arise from the definition of \prg{Bank},
%and not have to provide it as a precondition to our robustness property. A preferable holistic 
%specification to \prg{Bank} would be:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankSpec $\triangleq$ b : Bank $\wedge$ b.accs.acc1.bal = x $\wedge$ b : Bank
%             to b.accs.acc1.bal $\neq$ x
%             onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%That is, under all possible program configurations, the balance of an 
%account can only be modified using the \prg{Bank} interface, i.e.
%encapsulation of the \prg{Account} by the \prg{Bank} is implicit.
%Unfortunately this proof is not possible using the \prg{Bank} as defined
%in Section \ref{ex:bank2} because there is no way to ensure encapsulation
%of the \prg{Account} by the \prg{Bank} when the \prg{Bank} is 
%created. For this we need to specify how \prg{Bank}s and \prg{Account}s are created.
%\begin{lstlisting}[mathescape=true, frame=lines]
%class Account {
%  field bal : int
%  constr (amt)
%    this.bal := amt
%  method transfer(to, amt)
%    this.bal := this.bal - amt
%    to.bal := to.bal + amt
%}
%class Ledger {
%  field acc1 : Account
%  field acc2 : Account
%  constr (amt1, amt2)
%    this.acc1 := new Account(amt1)
%    this.acc2 := new Account(amt2)
%  method getAcc1()
%    return this.acc1
%  method getAcc2()
%    return this.acc2
%}
%class Bank {
%  field accs : Ledger
%  constr (amt1, amt2)
%    this.accs := new Ledger(amt1, amt2)
%  method transfer(amt){
%    this.accs.getAcc1().transfer(this.accs.getAcc2(), amt)
%  }
%}
%\end{lstlisting}
%We also need to a proof rule that allows us to prove program invariants.
%\begin{mathpar}
%\infer
%		{
%		M;\ M',\ \sigma\ \vdash\ \exists o.[o : \prg{Object}\ \wedge\ \forall o'.[o' = o]]\ \longrightarrow\ A\\
%		M;\ M',\ \sigma\ \vdash\ \onlyThrough{A}{\neg A}{\prg{false}}
%		}
%		{
%		M;\ M',\ \sigma\ \vdash\ A
%		}
%		\quad(\textsc{Invariant})
%\end{mathpar}
%It is quite simple to prove the following property:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%$\exists$ o.[o : Object $\wedge$ $\forall$ o'.[o' = o]] $\longrightarrow$ $\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$]
%\end{lstlisting}
%Now we can use the above rule to demonstrate that given the appropriate
%traditional specifications on the methods on \prg{BankMdl} (including the constructors), 
%$\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ and $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$ 
%are program invariants. i.e. \prg{BankMdl} must use traditional specifications to 
%prove the following about all methods in \prg{Bank}, \prg{Ledger}, and \prg{Account}:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%{$\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ $\wedge$ $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$]}
%  _.m(...)
%{$\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ $\wedge$ $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$]}
%\end{lstlisting}
%With this we can prove the following internal module invariant for \prg{BankMdl}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankEncap $\triangleq$ $\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ $\wedge$ $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$
%              to $\neg\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ $\wedge$ $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$
%              through BankMdl
%              onlyIf false
%\end{lstlisting}
%
%Now we can construct a proof of \prg{BankSpec}. We will re-use the results from Section \ref{ex:bank2} 
%as the proofs are much the same.
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$
%  to $\neg$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$
%  onlyThrough $\changes{\_}{\encapsulates{\prg{b}}{\prg{b.accs.acc1}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$
%  to $\neg$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$
%  onlyThrough false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{ResultA} (from Section \ref{ex:bank1}) and \textsc{Trans}$_1$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%EncapInv $\triangleq$ $\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$]
%             to $\neg$ $\forall$ b.[b : Bank $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$]
%             onlyThrough false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by {\color{red}Julian: We need some rule to extend quantification across the whole statement. Shouldn't be too hard ...}
%\end{minipage}
%\end{proofBox}
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%b : Bank $\wedge$ a : Account $\wedge$ b.acc.acc1 = a $\wedge$ a.bal = x $\wedge$ 
%  $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{Result}(Section \ref{ex:bank2}) and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%b : Bank $\wedge$ b.acc.acc1.bal = x $\wedge$ $\encapsulates{\prg{b}}{\prg{b.acc.acc1}}$
%  to b.acc.acc1.bal $\neq$ x
%  onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%Bank3Result $\triangleq$ b : Bank $\wedge$ b.acc.acc1.bal = x
%                to b.acc.acc1.bal $\neq$ x
%                onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Invariant}, \prg{EncapInv}, and $\longrightarrow$
%\end{minipage}
%\end{proofBox}
%
%\newpage
%
%
%
%\subsection{Bank Account 4 - Ghost Field Balance {\color{red}(Julian: still working on this)}} 
%\label{ex:bank4}
%In this version of the Bank Account, we show that we 
%are able to reason about fairly complex forms of encapsulation.
%Specifically if some \prg{Bank} \prg{b} encapsulates
%some \prg{Account} a, then it must follow that 
%the \prg{Ledger} \prg{l} that contains \prg{a}
%is also encapsulated by \prg{b}, and subsequently that any change to
%the balance of \prg{a} requires a call to \prg{transfer}
%on \prg{b}. This is interesting because, while other examples
%do not provide a way to leak access to an account, this example 
%does, but only through the \prg{Ledger} interface, and thus
%encapsulation of the \prg{Ledger} is sufficient to ensure
%encapsulation of the account. Note, this example only proves 
%that leaking of an account is not possible, it does not prove 
%that encapsulation of an account is always assured under all 
%program states. Encapsulation of the account is shown in the
%example in Section \ref{ex:bank3}.
%\begin{lstlisting}[mathescape=true, frame=lines]
%module BankMdl
%  class Account
%
%  class Ledger
%    field acc : Account
%    field balance : int
%    field tail : Ledger
%    method addToBalance(amt)
%      if a == this.acc
%        this.balance := this.balance + amt
%    method find(a)
%      if a == this.acc
%        return this
%      else if this.tail == null
%        return null
%      else
%        return this.tail.find(a)
%    ghost balance(a)
%      if this.acc == a
%        return balance
%      else if this.tail == null
%        return -1
%      else 
%        return tail.balance(a)
%
%  class Bank
%    field accs : Ledger
%    
%    method transfer(from, to, amt)
%      dest := this.accs.find(from);
%      src := this.accs.find(to);
%      if dest != null && src != null && amt >= 0
%        dest.addToBalance(amt)
%        src.addToBalance(-1 * amt)
%        
%    ghost balance(acc) 
%      this.accs.balance(acc)
%      
%\end{lstlisting}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankSpec $\triangleq$ a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%             to a.bal $\neq$ x
%             onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%As with the example in Section \ref{ex:bank1}, we require 
%the \verb|Bank| module to prove several invariants:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%AccAccess $\triangleq$ a : Account $\wedge$ $\encapsulates{\prg{B}}{\prg{a}}$
%              to $\neg\encapsulates{\prg{B}}{\prg{a}}$
%              through BankMdl
%              onlyIf $\exists$ o, l. [ l : Ledger $\wedge$ ($\calls{\prg{o}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%                                                 $\calls{\prg{o}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a)]
%\end{lstlisting}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BalChange $\triangleq$ a : Account $\wedge$ a.bal = x
%              to a.bal $\neq$ x
%              through BankMdl
%              onlyIf $\exists$ a' o. [a' : Account $\wedge$ $\external{\prg{o}}$ $\wedge$ 
%                            ($\calls{\_}{\prg{a}}{\prg{transfer}}{\prg{a'}, \_}$ $\vee$ $\calls{\_}{\prg{a'}}{\prg{transfer}}{\prg{a}, \_}$)] $\vee$
%                     $\exists$ b. [b : Bank $\wedge$ $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$ $\wedge$ 
%                            (b.accs.acc1 = a $\vee$ b.accs.acc2 = a)])]
%\end{lstlisting}
%%We also need to prove a more general property of the encapsulation of account objects by bank objects.
%%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%%AccEncap1 $\triangleq$ b : Bank $\wedge$ ($\encapsulates{\prg{b}}{\prg{b.accs.acc1}}$ $\vee$ $\encapsulates{\prg{b}}{\prg{b.accs.acc2}}$)
%%              $\longrightarrow$ $\encapsulates{\prg{b}}{\prg{b.accs}}$
%%\end{lstlisting}
%Finally we need to prove the following property:
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%BankEncapUnique $\triangleq$ a : Account $\wedge$ b b' : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$
%                    (b'.accs.acc1 = a || b'.accs.acc2 = a)
%                    $\longrightarrow$ b' = b
%\end{lstlisting}
%
%
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%  $\changes{\_}{\encapsulates{\prg{b}}{\prg{a}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%  $\changes{X_\prg{\{b\}}}{\encapsulates{\prg{b}}{\prg{a}}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Changes}-$\longrightarrow$ and \textsc{Changes-Encap}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a)
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{AccAccess}, \textsc{Changes-Int}, and \textsc{Exists}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a) $\wedge$ $\external{\prg{x}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Calls-Ext/Int}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  x = this $\wedge$ $\access{\prg{x}}{\prg{l}}$ $\wedge$ $\access{\prg{l}}{\prg{a}}$ $\wedge$ $\external{\prg{x}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Calls-}\prg{this} and \textsc{Calls-Recv}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ 
%  ($\encapsulated{\prg{l}}$ $\vee$ l $\in$ {b})
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-}\prg{this}, \textsc{Encap-Access}, and \textsc{Encap-}$\cup$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ $\encapsulated{\prg{l}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\vee$\textsc{E}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\encapsulated{\prg{l}}$ $\wedge$
%  ($\encapsulated{\prg{this}}$ $\vee$ this $\in$ $\I$)
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Access}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$
%  $\external{\prg{this}}$ $\wedge$ $\neg \encapsulated{\prg{this}}$ $\wedge$ $\encapsulated{\prg{l}}$ $\wedge$
%  false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=none]
%ResultA $\triangleq$ a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%            $\changes{\_}{\encapsulates{\prg{b}}{\prg{a}}}$ $\longrightarrow$ false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\end{minipage}
%\end{proofBox}
%
%
%%\begin{proofBox}{white}{black}
%%\footnotesize
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg \encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\changes{\_}{\encapsulates{\prg{b}}{\prg{a}}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Changes}
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ $\changes{X_\prg{\{b\}}}{\encapsulates{\prg{b}}{\prg{a}}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Changes}-$\longrightarrow$, \textsc{Changes-Encap} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%%                  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%%                   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a)
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \prg{AccAccess}, \textsc{Changes-Int}, \textsc{Exists}, and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ 
%%                  ($\calls{\prg{x}}{\prg{l}}{\prg{getAcc1}}{}$ $\wedge$ l.acc1 = a $\vee$ 
%%                   $\calls{\prg{x}}{\prg{l}}{\prg{getAcc2}}{}$ $\wedge$ l.acc2 = a) $\wedge$ $\external{\prg{x}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Calls-Ext/Int} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ x = this $\wedge$
%%                  $\access{\prg{x}}{\prg{l}}$ $\wedge$ $\access{\prg{l}}{\prg{a}}$ $\wedge$ $\external{\prg{x}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Calls-}\prg{this}, \textsc{Calls-Recv} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ $\external{\prg{this}}$ $\wedge$
%%                  $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ 
%%                  ($\encapsulated{\prg{l}}$ $\vee$ l $\in$ {b})
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Encap-}\prg{this}, \textsc{Encap-Access}, \textsc{Encap-}$\cup$, and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ $\external{\prg{this}}$ $\wedge$
%%                  $\neg \encapsulated{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{l}}$ $\wedge$ 
%%                  $\encapsulated{\prg{l}}$
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true]
%%a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough $\encapsulated{\prg{a}}$ $\wedge$ l : Ledger $\wedge$ $\external{\prg{this}}$ $\wedge$
%%                  $\neg \encapsulated{\prg{this}}$ $\wedge$ $\encapsulated{\prg{l}}$ $\wedge$
%%                  ($\encapsulated{\prg{this}}$ $\vee$ this $\in$ $\I$)
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by \textsc{Encap-Access} and $\longrightarrow$
%%\end{minipage}
%%\begin{minipage}{0.75\textwidth}
%%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=none]
%%ResultA $\triangleq$ a : Account $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%%  to $\neg\encapsulates{\prg{b}}{\prg{a}}$
%%  onlyThrough false
%%\end{lstlisting}
%%\end{minipage}
%%\begin{minipage}{0.24\textwidth}
%%\scriptsize
%%\hfill by $\longrightarrow$
%%\end{minipage}
%%\end{proofBox}
%
%
%\begin{proofBox}{white}{black}
%\footnotesize
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=single]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\changes{\_}{\prg{a.bal = x}}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Changes} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%     ($\changes{X_{\{\prg{b}\}}}{\prg{a.bal = x}}$ $\vee$ $\changes{X_{\{\prg{b}\}}}{\encapsulates{\prg{b}}{\prg{a}}}$)
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Write} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ $\changes{\I}{\prg{a.bal = x}}$ $\vee$ false
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{ResultA}, \textsc{Encap-}$\cup$, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%              $\exists$ a' o. [a' : Account $\wedge$ $\external{\prg{o}}$ $\wedge$ 
%                          ($\calls{\prg{o}}{\prg{a}}{\prg{transfer}}{\prg{a'}, \_}$ $\vee$ 
%                           $\calls{\prg{o}}{\prg{a'}}{\prg{transfer}}{\prg{a}, \_}$)] $\vee$
%              $\exists$ b'. [b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%                      (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])]
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{BalChange}, \textsc{Changes-Int}, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%              ($\external{\prg{this}}$ $\wedge$ $\access{\prg{this}}{\prg{a}}$) $\vee$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Exists}, \textsc{Calls-Recv}, \textsc{Calls-Args}, \textsc{Calls-}\prg{this}, and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$ 
%              ($\encapsulates{\prg{b}}{\prg{this}}$ $\vee$ this $\in$ {b}) $\vee$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-Access}
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              (b'.accs.acc1 = a $\vee$ b'.accs.acc2 = a)])
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \textsc{Encap-}\prg{this} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%  to a.bal $\neq$ x
%  onlyThrough $\encapsulates{\prg{b}}{\prg{a}}$ $\wedge$
%              b' : Bank $\wedge$ $\calls{\_}{\prg{b'}}{\prg{transfer}}{\_}$ $\wedge$ 
%              b' = b
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by \prg{BankEncapUnique} and $\longrightarrow$
%\end{minipage}
%\begin{minipage}{0.75\textwidth}
%\begin{lstlisting}[language = Chainmail, mathescape=true]
%Result $\triangleq$ a : Account $\wedge$ a.bal = x $\wedge$ b : Bank $\wedge$ $\encapsulates{\prg{b}}{\prg{a}}$
%           to a.bal $\neq$ x
%           onlyThrough $\calls{\_}{\prg{b}}{\prg{transfer}}{\_}$
%\end{lstlisting}
%\end{minipage}
%\begin{minipage}{0.24\textwidth}
%\scriptsize
%\hfill by $\longrightarrow$
%\end{minipage}
%\end{proofBox}
