\section{Proof of Adherence to \SrobustB}
\label{s:examples}
\jm[]{In this section we revisit our example from Sections \ref{s:intro} and \ref{s:outline}:
specifying a robust bank account. 
Recall that an \prg{Account} includes %a \prg{balance} field, and a \prg{transfer} method, along with any other fields and methods. 
\susan[]{ at least a a \prg{balance} field, and a \prg{transfer} method.}
In order to confidently 
pass our account to unknown, potentially malicious code, we wish to prove that our 
\prg{Account} and the module that contains \prg{Account} satisfies \SrobustB. Below we rephrase 
\SrobustB to use the $\wrapped{\_}$ predicate.}
\begin{lstlisting}[language=Chainmail, mathescape=true, frame=lines]
$\SrobustB$ $\triangleq$ from a:Account $\wedge$ a.Account=bal 
               to a.balance < bal   onlyIf $\neg\wrapped{\prg{a.password}}$
\end{lstlisting}
\jm[]{That is, if the balance to my account ever decreases, then some external
object must know my password. Or conversely, if only I know my password, then I know my money is safe. 
Here we provide a proof that \ModC satisfies \SrobustB. We recall \ModC in Fig. \ref{f:ex-bank-short1}}.

\begin{figure}[t]
\begin{lstlisting}[mathescape=true, frame=lines]
module $\ModC$
  class Password{}
  class Account
    field balance:int
    field pwd:Password
    method set(pwd':Password, pwd'':Password):void
      {if(this.pwd==pwd') 
         this.pwd := pwd'}
	method transfer(pwd':Password, destAcc:Account)
	  {if(this.pwd==pwd' && this.balance > 100)
	     this.balance := this.balance - 100
	     destAcc.balance := destAcc.balance + 100}
\end{lstlisting}
\caption{Bank Account Module}
\label{f:ex-bank-short1}
\end{figure}

%Susan: I changed the label because somewhere (I think in an appendix) there is a f:ex-bank-short and the ref picks it up rather than this one

\subsection{Stage 1: Assertion Encapsulation}
\label{s:BA-encap}
\jm[]{The first stage of the proof is proving that the \prg{Account} \prg{balance} and \prg{password} are 
encapsulated properties. That is, for the \prg{balance} to change (i.e. for \prg{a.balance = bal} to be invalidated), 
internal computation is required. We use a conservative approach to an encapsulation system, detailed in App. \ref{s:encap-proof}, 
and provide the proof steps below.}
\\\begin{proofexample}
\proofsteps{\prg{BalEncaps}}
	{\begin{proofexample}
		\proofsteps{\prg{aEnc}}
			{\proofstepwithrule
			{$\proves{\ModC}{\givenA{\prg{a:Account $\wedge$ a.balance=bal}}{\intrnl{\prg{a}}}}$}
				{by \textsc{Enc$_e$-Obj}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{balanceEnc}}
			{\proofstepwithrule
			{$\proves{\ModC}{\givenA{\prg{a:Account $\wedge$ a.balance=bal}}{\intrnl{\prg{a.balance}}}}$}
				{by \prg{aEnc} and \textsc{Enc-Field}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{balEnc}}
			{\proofstepwithrule
			{$\proves{\ModC}{\givenA{\prg{a:Account $\wedge$ a.balance=bal}}{\intrnl{\prg{bal}}}}$}
				{by \textsc{Enc$_e$-Int}}
		}
		\endproofsteps
	\end{proofexample}
		}
		{\proofstepwithrule
			{
			$\proves{\ModC}{\givenA{\prg{a:Account $\wedge$ a.balance=bal}}{\encaps{\prg{a.balance=bal}}}}$
			}{by \prg{balanceEnc}, \prg{balEnc}, \textsc{Enc-Eq}, and \textsc{Enc-=}}}
\endproofsteps
\end{proofexample}\\
\jm[I'm not sure if this last note is necessary.]{
\textbf{\prg{aEnc}} and \textbf{\prg{balanceEnc}} state that \prg{a} is an internal object,
and thus only internal computation may write to its field \prg{balance}.
\textbf{\prg{balEnc}} states that since bal is an integer, it's value is constant
and may not change, and thus we can trivially say that if its value ever 
changed (which it never will), that must have happened internally.
These combine to prove that the assertion \prg{a.balance = bal} is an 
encapsulated one, and thus requires internal computation to invalidate.
Note: it may seem odd to say that the variable \prg{bal} never changes, but 
remember \prg{bal} refers to a specific integer value at a point in time, and 
the adaptation operator (\S \ref{sub:adapt:full}) allows us to recall that 
value even after potential rewrites.
}

\jm[]{
We similarly prove that \prg{a.password} may only be 
changed via internal computation (\textbf{\prg{PwdEncaps}}), and
\wrapped{\prg{a.password}} may only be invalidated by 
internal computation (\textbf{\prg{PwdInsideEncaps}}). 
That is, if only internal objects have access
to an account's \prg{password}, then only internal computation may grant 
access to an external object.
}
\\\begin{proofexample}
\proofsteps{\prg{PwdEncaps}}
		{\proofstepwithrule
			{
			$\proves{\ModC}{\givenA{\prg{a:Account}}{\encaps{\prg{a.password=p}}}}$
			}{by \textsc{Enc$_e$-Obj}, \textsc{Enc-Field}, and \textsc{Enc-Eq}}}
\endproofsteps
\end{proofexample}
\\\begin{proofexample}
\proofsteps{\prg{PwdInsideEncaps}}
		{\proofstepwithrule
			{
			$\proves{\ModC}{\givenA{\prg{a:Account}}{\encaps{\wrapped{\prg{a.balance}}}}}$
			}{by \textsc{Enc-Inside}}}
\endproofsteps
\end{proofexample}

\subsection{Stage 2: Per-Method \Nec Specifications}
\label{s:BA-classical}
\jm[]{
Stage 2 proves necessary preconditions for each method in 
the module interface. We employ the crucial observation that
we can build necessary pre-conditions on top of classical 
Hoare logic (\S \ref{s:classical-proof}).
\textbf{\prg{SetBalChange}} uses classical Hoare logic
to prove that the \prg{set} method in \prg{Account}
never modifies the \prg{balance}. We then use \textsc{If1-Classical}
and \Nec logic to prove that if it ever did change (a logical absurdity),
then \prg{transfer} must have been called.
}
\\{
	\begin{proofexample}
		\proofsteps{SetBalChange}
			{\proofstepwithrule
				{\hoareEx
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.balance=bal}
						{a.set(\_, \_)}
						{a$^\prime$.balance = bal}
						}
					{by classical spec.}
			}
			{\proofstepwithrule
				{\hoareEx
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.balance = bal $\wedge$ $\neg$ false}
						{a.set(\_, \_)}
						{$\neg$ a$^\prime$.balance = bal < bal}
						}
					{by classical Hoare logic}
			}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.balance=bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{set}}{\prg{\_, \_}}$}
						{a$^\prime$.balance < bal}
						{false}
						}
					{by \textsc{If1-Classical}}
			}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.balance=bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{set}}{\prg{\_, \_}}$}
						{a$^\prime$.balance < bal}
						{$\calls{\_}{\prg{a}^\prime}{\prg{transfer}}{\prg{\_, a$^\prime$.password}}$}
						}
					{by \textsc{Absurd} and \textsc{If1-}$\longrightarrow$}
			}
		\endproofsteps
	\end{proofexample}
}\\
\jm[]{
\textbf{\prg{SetPwdLeak}} demonstrates how we employ classical Hoare logic
to prove that a method does not leak access to some data (in this case the \prg{password}).
Using \textsc{If1-Inside}, we reason that since the return value of \prg{set} is
\prg{void}, and \prg{set} is prohibited from making external method calls,
no call to \prg{set} can result in an object (external or otherwise) gaining access to the \prg{password}.
}
\\{
	\begin{proofexample}
		\proofsteps{SetPwdLeak}
			{\proofstepwithrule
				{\hoareEx
						{a:Account $\wedge$ a$^\prime$:Account $\wedge$ a.password == pwd}
						{\prg{res}=a$^\prime$.set(\_, \_)}
						{res != pwd}
						}
					{by classical spec.}
			}
			{\proofstepwithrule
				{\hoareEx
						{a:Account $\wedge$ a$^\prime$:Account $\wedge$ a.password == pwd $\wedge$ $\neg$ false}
						{\prg{res}=a$^\prime$.set(\_, \_)}
						{res != pwd}
						}
					{by classical Hoare logic}
			}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{$\wrapped{\prg{pwd}}$ $\wedge$ a, a$^\prime$:Account $\wedge$ a.password=pwd $\wedge$ $\calls{\_}{\prg{a}^\prime}{\prg{set}}{\_, \_}$}
						{$\neg \wrapped{\_}$}
						{false}
						}
					{by \textsc{If1-Inside}}
			}
		\endproofsteps
	\end{proofexample}
	}\\
	
\jm[]{In the same manner as \textbf{\prg{SetBalChange}} and \textbf{\prg{SetPwdLeak}}, we also prove
\textbf{\prg{SetPwdChange}}, \textbf{\prg{TransferBalChange}}, \textbf{\prg{TransferPwdLeak}}, and \textbf{\prg{TransferPwdChange}}. We provide their 
statements below, but omit their proofs.}
\\{
	\begin{proofexample}
		\proofsteps{SetPwdChange}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.password=p $\wedge$ $\calls{\_}{\prg{a}}{\prg{set}}{\prg{\_, \_}}$}
						{$\neg$ a.password = p}
						{$\calls{\_}{\prg{a}^\prime}{\prg{set}}{\prg{a$^\prime$.password, \_}}$}
						}
					{by \textsc{If1-Classical}}
			}
		\endproofsteps
	\end{proofexample}
}\\
\\{
	\begin{proofexample}
		\proofsteps{TransferBalChange}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.balance=bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{transfer}}{\prg{\_, \_}}$}
						{a$^\prime$.balance < bal}
						{$\calls{\_}{\prg{a}^\prime}{\prg{transfer}}{\prg{\_, a$^\prime$.password}}$}
						}
					{by \textsc{If1-Classical}}
			}
		\endproofsteps
	\end{proofexample}
}\\
\\{
	\begin{proofexample}
		\proofsteps{TransferPwdLeak}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{$\wrapped{\prg{pwd}}$ $\wedge$ a, a$^\prime$:Account $\wedge$ a.password=pwd $\wedge$ $\calls{\_}{\prg{a}^\prime}{\prg{transfer}}{\_, \_}$}
						{$\neg \wrapped{\_}$}
						{false}
						}
					{by \textsc{If1-Inside}}
			}
		\endproofsteps
	\end{proofexample}
	}\\
\\{
	\begin{proofexample}
		\proofsteps{TransferPwdChange}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a, a$^\prime$:Account $\wedge$ a$^\prime$.password=p $\wedge$ $\calls{\_}{\prg{a}}{\prg{transfer}}{\prg{\_, \_}}$}
						{$\neg$ a.password = p}
						{$\calls{\_}{\prg{a}^\prime}{\prg{set}}{\prg{a$^\prime$.password, \_}}$}
						}
					{by \textsc{If1-Classical}}
			}
		\endproofsteps
	\end{proofexample}
	}\\

\subsection{Stage 3: Per-Step \Nec Specifications}
\jm[]{
Stage 3 builds upon the proofs of Stage 1 and 2 to 
construct proofs of necessary preconditions, not for single method execution, 
but any single execution step. That is, a proof that for
\emph{any} single step in program execution, certain changes
in program state require specific pre-conditions.
}
\\{
	\begin{proofexample}
		\proofsteps{BalanceChange}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a:Account $\wedge$ a.balance=bal}
						{a.balance < bal}
						{$\calls{\_}{\prg{a}}{\prg{transfer}}{\prg{\_, a.password}}$}
						}
					{by \textbf{\prg{BalEncaps}}, \textbf{\prg{SetBalChange}}, \textbf{TransferBalChange}, and \textsc{If1-Internal}}
			}
		\endproofsteps
	\end{proofexample}
	}\\
\\{
	\begin{proofexample}
		\proofsteps{PasswordChange}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a:Account $\wedge$ a.password=p}
						{$\neg$ a.password = bal}
						{$\calls{\_}{\prg{a}}{\prg{set}}{\prg{a.password, \_}}$}
						}
					{by \textbf{\prg{PwdEncaps}}, \textbf{\prg{SetPwdChange}}, \textbf{TransferPwdChange}, and \textsc{If1-Internal}}
			}
		\endproofsteps
	\end{proofexample}
	}\\
\\{
	\begin{proofexample}
		\proofsteps{PasswordLeak}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a:Account $\wedge$ a.password=p $\wedge$ $\wrapped{\prg{p}}$}
						{$\neg$ $\wrapped{\prg{p}}$}
						{false}
						}
					{by \textbf{\prg{PwdInsideEncaps}}, \textbf{\prg{SetPwdLeak}}, \textbf{TransferPwdLeak}, and \textsc{If1-Internal}}
			}
		\endproofsteps
	\end{proofexample}
}\\

	
\subsection{Stage 4: Emergent \Nec Specifications}
\jm[]{
Stage 4 raises necessary pre-conditions for single execution steps proven in Stage 3 to 
the level of an arbitrary number of execution steps in order to prove specifications of emergent behaviour.
The proof of \SrobustB takes the following form:
}
\begin{description}
\item [(1)]
If the balance of an account decreases, then
by \prg{BalanceChange} there must have been a call
to \prg{transfer} in \jm[]{\prg{Account}} with the correct password.
\item [(2)]
If there was a call where the \prg{Account}'s password 
was used, then there must have been an intermediate program state
when some external object had access to the password.
\item [(3)]
Either that password was the same password as in the starting 
program state, or it was different:
\begin{description}
\item [(Case A)]
If it is the same as the initial password, then since by \prg{PasswordLeak}
it is impossible to leak the password, it follows that some external object 
must have had access to the password initially.
\item [(Case B)]
If the password is different from the initial password, 
then there must have been an intermediate program state when it 
changed. By \prg{PasswordChange} we know that this must have occurred
by a call to \prg{set} with the correct password. Thus,
there must be a some intermediate program state where the initial
password is known. From here we proceed by the same reasoning 
as \textbf{(Case A)}.
\end{description}
\end{description}
\begin{proofexample}
\proofsteps{\SrobustB}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ a.balance=bal}
				{a.balance < bal}
				{$\calls{\_}{\prg{a}}{\prg{transfer}}{\_, \prg{a.password}}$}
				}
			{by \textsc{Changes} and \prg{BalanceChange}}}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ a.balance=bal}
				{b.balance(a) < bal}
				{$\neg$$\wrapped{\prg{a.password}}$}
				}
			{by $\longrightarrow$, \textsc{Caller-Ext}, and \textsc{Calls-Args}}}
%	{\proofstepwithrule{\onlyThroughExAlt
%				{a:Account $\wedge$ b:Bank $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
%				{a.balance < bal}
%				{$\neg$$\wrapped{\prg{a.password}}$}
%				}
%			{by $\longrightarrow$}}
	{\proofstepwithrule{\onlyThroughEx
				{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
				{a.balance < bal}
				{$\neg$$\wrapped{\prg{a.password}}$ $\wedge$ (a.password=pwd $\vee$ a.password != pwd)}
				}
			{by $\longrightarrow$ and \textsc{Excluded Middle}}}
	{\proofstepwithrule{\onlyThroughEx
				{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
				{a.balance < bal}
				{($\neg$$\wrapped{\prg{a.password}}$ $\wedge$ a.password=pwd) $\vee$\\
				($\neg$$\wrapped{\prg{a.password}}$ $\wedge$ a.password != pwd)}
				}
			{by $\longrightarrow$}}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
				{a.balance < bal}
				{$\neg$$\wrapped{\prg{pwd}}$ $\vee$
				a.password != pwd}
				}
			{by $\longrightarrow$}}
	{
	\begin{proofexample}
	\proofsteps{Case A ($\neg\wrapped{\prg{pwd}}$)}
			{\proofstepwithrule
				{\onlyIfExAlt
					{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
					{$\neg$$\wrapped{\prg{pwd}}$}
					{$\wrapped{\prg{pwd}}\ \vee \neg\wrapped{\prg{pwd}}$}
					}
				{by \textsc{If-}$\longrightarrow$ and \textsc{Excluded Middle}}}
			{\proofstepwithrule{\onlyIfExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{$\neg$$\wrapped{\prg{pwd}}$}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by $\vee$E and \prg{PasswordLeak}}}
	\endproofsteps
	\end{proofexample}
	}
	{
	\begin{proofexample}
	\proofsteps{Case B (\prg{a.password != pwd})}
		{\proofstepwithrule{\onlyThroughExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{a.password != pwd}
					{$\calls{\_}{\prg{a}}{\prg{set}}{\prg{pwd}, \_}$}
					}
				{by \textsc{Changes} and \textsc{PasswordChange}}}
		{\proofstepwithrule{\onlyThroughExAlt
					{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
					{a.password != pwd}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by $\vee$E and \prg{PasswordLeak}}}
		{\proofstepwithrule{\onlyIfExAlt
					{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
					{a.password != pwd}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by \textbf{Case A} and \textsc{Trans}}}
	\endproofsteps
	\end{proofexample}
	}
	{\proofstepwithrule{\onlyIfExAlt
				{a:Account $\wedge$ a.balance=bal $\wedge$ a.password=pwd}
				{b.balance(a) < bal}
				{$\neg\wrapped{\prg{pwd}}$}
				}
			{by \textbf{Case A}, \textbf{Case B}, \textsc{If-}$\vee$I$_2$, and \textsc{If-}$\longrightarrow$}}
\endproofsteps
\end{proofexample}
