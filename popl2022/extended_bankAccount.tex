\section{Proof of Adherence to \Snecessity}
\label{s:examples}

In this section we return to the Bank Account example, 
providing a full proof and
the accompanying Coq formalism includes a mechanized version.


As we stated in Section \ref{sub:SpecO}, 
we assume the existence of a proof system for judgments
of the form $\proves{M}{A}$, denoting that in 
any arising program state, with internal module $M$, $A$ is satisfied. 
In this section, we make use of several rules that under such a logic should be sound.
We provide a description of these rules in Appendix \ref{app:assert_logic}. 
%\jm[]{Further, recall that as per Def. \ref{def:necessity-semantics},
%$\satisfies{M}{A}$ is defined for arising program states, and thus by Theorem \ref{thm:soundness},
%if $\proves{M}{A}$, it follows that for all arising program states in the context fo internal 
%module $M$, $A$ is satisfied.}

\begin{figure}[t]
\begin{lstlisting}[mathescape=true, frame=lines]
module $\ModD$
  class Account
    field password:Object
    method authenticate(pwd:Object):bool
      {return pwd == this.password}
    method changePass(pwd:Object, newPwd:Object):void
      {if pwd == this.password
        this.password := newPwd}
  class confined Ledger
    field acc1:Account
    field bal1:int
    field acc2:Account
    field bal2:int
    ghost intrnl balance(acc):int=
      if acc == acc1
        bal1
      else if acc == acc2
        bal2
      else -1
    method transfer(amt:int, from:Account, to:Account):void
      {if from == acc1 && to == acc2
         bal1 := bal1 - amt
         bal2 := bal2 + amt
       else if from == acc2 && to == acc1
         bal1 := bal1 + amt
         bal2 := bal2 - amt}
  class Bank
    field book:Ledger
    ghost intrnrl balance(acc):int=book.balance(acc)
    method transfer(pwd:Object, amt:int, from:Account, to:Account):void
      {if (from.authenticate(pwd))
         book.transfer(amt, from, to)}
\end{lstlisting}
\caption{Bank Account Module}
\label{f:ex-bank-short}
\end{figure}
We devote the rest of this section to the \jm[]{proof}  
\sophiaPonder[]{expressed in    \Nec logic
of a module's adherence to the Bank Account specification.}
%  \jm[]{a variation on} our
% running example of a Bank Account using our \Nec logic.
\sophiaPonder[dropped: along with a proof 
of the bank account specification  using our \Nec logic.]{}

\paragraph{The Bank Account Module \ModD}
\sophiaPonder[]{In this section we define \ModD, a new Bank Account implementation, which   differs from that of Section \ref{s:outline}.}
\ModD is more complex than \ModC; \sophiaPonder[dropped: in the following  Bank Account]{} 
this allows us  to demonstrate how   \Nec logic 
%we are able to deal 
\scd{deals} with  challenges that come with more complex data structures and specifications.
These challenges are 
\begin{description}
\item[(1)] Specifications defined using ghost fields -- in this case \prg{b.balance(a)} returns the balance of account \prg{a} in \prg{Bank} \prg{b}.
\item[(2)] Modules with several \sophiaPonder[said multiple]{}  classes and methods; \scd{they all} must be considered when constructing proofs about emergent behavior.
\item[(3)] \sophiaPonder[said: How ownership systems can be used to construct proofs for \Nec specifications -- ]{}
\sophiaPonder[]{The construction of a proof of assertion encapsulation. Such a proof is necessary  here because
 the ghost field \prg{balance} reads several  fields. We use our 
 simple confinement system,}   captured by \enclosed classes in \Loo.
\end{description}


\jm[]{}\sophiaPonder[said: We rewrite]{} The \Snecessity will use the ghost field, \texttt{balance},
and not simply the balance field as in \ModA, \ModB, and \ModC. 
\begin{lstlisting}[language=Chainmail, mathescape=true, frame=lines]
$\Snecessity$ $\triangleq$ from b:Bank $\wedge$ b.balance(a)=bal 
                     to b.balance(a) < bal   onlyIf $\neg\wrapped{\prg{a}}$
\end{lstlisting}
That is, if the balance of an account ever decreases, it must be true that some object external to
\ModD has access to the password of that account. 

\jm[]{We provide the implementation of \jm[]{\ModD} in Figure \ref{f:ex-bank-short}.
In \ModD, we move the balance 
of an account into a ledger that is stored within a bank. Thus, 
the module \ModD (Figure \ref{f:ex-bank}) consists of 3 classes: (1) \texttt{Account} that
maintains a password, (2) \texttt{Bank}, a public interface 
for transferring money from one account to another, and (3) \texttt{Ledger},
a private class, annotated as \enclosed, used to map \texttt{Account} objects
to their balances. }
\susan[I removed the tt as there is no balance in Mod4]{}

A \prg{Bank} consists of a \prg{Ledger}, a method for transferring 
funds between accounts (\prg{transfer}), and a ghost field, \prg{balance}
for looking up the balance of an account at a bank.
%\footnote{A \Nec specification is independent of the implementation details of the code. It would need to hold for an account whose implementation did not use a ledger or ghost variables to hold balances.}
A \prg{Ledger} is
a mapping from \prg{Account}s to their balances. For brevity
our implementation only includes two accounts (\prg{acc1} and \prg{acc2}),
but it is easy to see how this could extend to a \prg{Ledger}
of arbitrary size. \prg{Ledger} is annotated as \enclosed, and as 
such the type system ensures our required encapsulation properties.
Finally, an \prg{Account} has some \prg{password} object, and 
methods to authenticate a provided password (\prg{authenticate}), 
change the password (\prg{changePass}).


\jm[]{Note, Figure \ref{f:ex-bank-short} does not provide the classical specifications of \ModD, 
which can be found in full in Appendix \ref{app:BankAccount}. Informally, we introduce classical specifications
that state that 
\begin{description}
\item[(1)] no method returns the password, 
\item[(2)] the \prg{transfer} method in \prg{Ledger} results in a decreased balance to the \prg{from} \prg{Account},
\item[(3)] and the \prg{transfer} method in \prg{Bank} results in a decreased balance to the \prg{from} \prg{Account} \emph{only if} the correct password is supplied, and
\item[(4)] every other method in \ModD never modifies any balance in any \prg{Bank}.
\end{description}}

\jm[]{While both the implementation and the specification being proven have changed from that of
\ref{s:outline}, the structure of the proofs do retain broad similarities. In particular the proof in this section 
follows the outline of our reasoning given in Sec. \ref{s:approach}}: we prove \jm[]{(1) encapsulation of \jm[]{the account balance and password}, 
(2) \emph{per-method} \Nec specifications on all \ModD methods, (3) \emph{per-step} \Nec specifications for changing the balance and password,
and finally (4) the \emph{emergent} \Nec specification \Snecessity.}
%\begin{description}
%\item[Part 1:]
%\jm[]{We prove assertion \emph{encapsulation} for key assertions in the proof.}
%We prove that both \prg{b.getBal(a)=bal} and \prg{a.password=pwd} are encapsulated using the 
%encapsulation system laid out in Apdx. \ref{s:encap-proof}.
%\item[Part 2:]
%\jm[]{We prove \emph{per-method} \Nec specifications for \ModD.}
%We use classical specifications to prove that only a call to \prg{Bank::transfer} 
%with the correct password may be used to decrease the balance of an account. Similarly, we
%use classical specifications to prove that no method can leak or illegally overwrite the password of an account.
%Note, it is this proof step that fails for \ModB, as the password may be overwritten. Further, in the 
%proof, there is no distinction made between leaking and overwriting of the password, as both properties allow for external 
%objects to have no access to the password, but in the next moment have access to that password.
%\item[Part 3:]
%\jm[]{We prove \emph{per-step} \Nec specifications for \ModD.}
%We combine the per-method necessary preconditions along with the encapsulation of \prg{b.getBal(a)=bal} to arrive at a per-step
%necessary precondition for reducing the balance using \emph{any} method in \jm[]{\ModD}. Similarly, 
%we show that \emph{no} step may leak the password of an account.
%\item[Part 4:]
%\jm[]{Finally, we prove \emph{emergent} \Nec specifications.} We use our \Nec logic and the results of A, B, and C, to prove the emergent behavior specified in \prg{NecessityBankSpec}.
%\end{description}

%\clearpage
\subsection{Part 1: Assertion Encapsulation}
\label{s:BA-encap}
We base the soundness of our encapsulation of the type system of \Loo, and use the proof rules given in Figures \ref{f:intrnl} and \ref{f:asrt-encap}.
\jm[]{Informally, $\intrnl{e}$ indicates that any objects inspected during the evaluation of expression $e$ are internal. $\encaps{A}$ (see Section \ref{s:inference}) indicates 
that internal computation is necessary for a change in satisfaction of $A$. Rudimentary algorithms for proving $\intrnl{}$ and $\encaps{}$ are given in 
Appendix \ref{s:encap-proof}, and used here.}
We provide the proof for the encapsulation of \prg{b.balance(a)} below\\
%\begin{figure}[h]
\begin{proofexample}
\proofsteps{\prg{BalanceEncaps}}
	{\begin{proofexample}
		\proofsteps{\prg{aEnc}}
			{\proofstepwithrule
			{$\proves{\ModD}{\givenA{\prg{b, b$^\prime$:Bank $\wedge$ a:Account $\wedge$ b.balance(a)=bal}}{\intrnl{\prg{a}}}}$}
				{by \textsc{Enc$_e$-Obj}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{bEnc}}
			{\proofstepwithrule
			{$\proves{\ModD}{\givenA{\prg{b, b$^\prime$:Bank $\wedge$ a:Account $\wedge$ b.balance(a)=bal}}{\intrnl{\prg{b}}}}$}
				{by \textsc{Enc$_e$-Obj}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{getBalEnc}}
			{\proofstepwithrule
			{$\proves{\ModD}{\givenA{\prg{b, b$^\prime$:Bank $\wedge$ a:Account $\wedge$ b.balance(a)=bal}}{\intrnl{\prg{b.balance(a)}}}}$}
				{by \prg{aEnc}, \prg{bEnc}, and \textsc{Enc$_e$-Ghost}}
		}
		\endproofsteps
	\end{proofexample}
		}
	{\begin{proofexample}
		\proofsteps{\prg{balEnc}}
			{\proofstepwithrule
			{$\proves{\ModD}{\givenA{\prg{b, b$^\prime$:Bank $\wedge$ a:Account $\wedge$ b.balance(a)=bal}}{\intrnl{\prg{bal}}}}$}
				{by \textsc{Enc$_e$-Int}}
		}
		\endproofsteps
	\end{proofexample}
		}
		{\proofstepwithrule
			{
			$\proves{\ModD}{\givenA{\prg{b, b$^\prime$:Bank $\wedge$ a:Account $\wedge$ b.balance(a)=bal}}{\encaps{\prg{b.balance(a)=bal}}}}$
			}{by \prg{getBalEnc}, \prg{balEnc}, \textsc{Enc-Exp}}}
\endproofsteps
\end{proofexample}\\
We omit the proof of $\encaps{\prg{a.password=pwd}}$, as its construction is very similar to that of $\encaps{\prg{b.balance(a)=bal}}$.
%\caption{Proof of encapsulation of \prg{b.getBal(a)=bal}}
%\end{figure}

\subsection{Part 2: Per-Method \Nec Specifications}
\label{s:BA-classical}
We now provide proofs for necessary preconditions on a per-method basis, leveraging 
classical specifications.
\jm[]{These proof steps are quite verbose, and for this reason, we only focus on proofs
of \prg{authenticate} from the \prg{Account} class.}

\jm[]{There are two \emph{per-method} \Nec specifications that we need
to prove of \prg{authenticate}: 
\begin{description}
\item[\textbf{\prg{AuthBalChange}}:] any change to the balance of an account may only occur if call to \prg{transfer} on the \prg{Bank} with the correct password is made. 
This may seem counter-intuitive as it is not possible to make two method calls (\prg{authenticate} and \prg{transfer}) at the same time, however we are able to prove this by first proving the 
absurdity that \prg{authenticate} is able to modify any balance.
\item[\textbf{\prg{AuthPwdLeak}}:] any call to \prg{authenticate} may only invalidate \wrapped{\prg{a.password}} (for any account \prg{a}) if \prg{false} is first satisfied -- clearly an absurdity.
\end{description}}

\paragraph{\emph{\textbf{\prg{AuthBalChange}}}}First we use the classical specification of the \prg{authenticate} method in \prg{Account} to prove that a call to \prg{authenticate} can only result in 
a decrease in balance in a single step if there were in fact a call to \prg{transfer} to the \prg{Bank}. This may seem 
odd at first, and impossible to prove, however we leverage the fact that we are first able to prove that \prg{false}
is a necessary condition to decreasing the balance, or in other words, it is not possible to decrease the balance by a
call to \prg{authenticate}. We then use the proof rule \textsc{Absurd} to prove our desired necessary condition.
This proof is presented as \prg{AuthBalChange} below.
\\
\noindent
{
	\begin{proofexample}
		\proofsteps{AuthBalChange}
			{\proofstepwithrule
				{\hoareEx
						{a, a$^\prime$:Account $\wedge$ b:Bank $\wedge$ b.balance(a$^\prime$)=bal}
						{a.authenticate(pwd)}
						{b.balance(a$^\prime$) == bal}
						}
					{by classical spec.}
			}
			{\proofstepwithrule
				{\hoareEx
						{a, a$^\prime$:Account $\wedge$ b:Bank $\wedge$ b.balance(a$^\prime$)=bal $\wedge$ $\neg$ false}
						{a.authenticate(pwd)}
						{$\neg$ b.balance(a$^\prime$) < bal}
						}
					{by classical Hoare logic}
			}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a, a$^\prime$:Account $\wedge$ b:Bank $\wedge$ b.balance(a$^\prime$)=bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{authenticate}}{\prg{pwd}}$}
						{b.balance(a$^\prime$) < bal}
						{false}
						}
					{by \textsc{If1-Classical}}
			}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{a:Account $\wedge$ a$^\prime$:Account $\wedge$ b:Bank $\wedge$ b.balance(a$^\prime$)=bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{authenticate}}{\prg{pwd}}$}
						{b.balance(a$^\prime$) < bal}
						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a$^\prime$.password, amt, a$^\prime$, to}}$}
						}
					{by \textsc{Absurd} and \textsc{If1-}$\longrightarrow$}
			}
		\endproofsteps
	\end{proofexample}
}

\paragraph{\emph{\textbf{\prg{AuthPwdLeak}}}} The proof of \prg{AuthPwdLeak} is given below, and is proven by application of classical Hoare logic rules and \textsc{If1-Inside}.

%We provide the statements of the specifications for the remaining methods in the module below,
%%(\textbf{changePassBalChange}, \textbf{Ledger::TransferBalChange}, and \textbf{Bank::TransferBalChange}), 
%but we elide the proof steps as they do not differ much from that of \textbf{AuthBalChange}.\\
%{
%	\begin{proofexample}
%		\proofsteps{changePassBalChange}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{a, a$^\prime$:Account $\wedge$ b:Bank $\wedge$ b.getBal(a$^\prime$)=bal $\wedge$ $\calls{\_}{\prg{a}}{\prg{changePass}}{\prg{pwd}}$}
%						{b.getBal(a$^\prime$) < bal}
%						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a$^\prime$.password, amt, a$^\prime$, to}}$}
%						}
%					{by similar reasoning to \textbf{AuthBalChange}}
%			}
%		\endproofsteps
%	\end{proofexample}
%}
%\begin{minipage}{\textwidth}
%{
%	\begin{proofexample}
%		\proofsteps{Ledger::TransferBalChange}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l:Ledger $\wedge$ a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{$\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						}
%					{by \textsc{If-Start} and \textsc{If1-If}}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l:Ledger $\wedge$ a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{$\neg\wrapped{\prg{l}}$}
%						}
%					{by \textsc{If1-}$\longrightarrow$, \textsc{Caller-Ext}, and \textsc{Caller-Recv}}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l:Ledger $\wedge$ a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{\false}
%						}
%					{by \textsc{Intrnl-Wrapped} and \textsc{If1-}$\longrightarrow$}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l:Ledger $\wedge$ a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
%						}
%					{by \textsc{Absurd} and \textsc{If1-}$\longrightarrow$}
%			}
%		\endproofsteps
%	\end{proofexample}
%}
%\end{minipage}
%{
%	\begin{proofexample}
%		\proofsteps{Ledger::TransferBalChange}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{l:Ledger $\wedge$ a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\prg{amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
%						}
%					{by similar reasoning to \textbf{\prg{AuthBalChange}}}
%			}
%		\endproofsteps
%	\end{proofexample}
%}
%{
%	\begin{proofexample}
%		\proofsteps{Bank::TransferBalChange}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{a:Account $\wedge$ b, b$^\prime$:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{b$^\prime$}}{\prg{transfer}}{\prg{pwd, amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{a == from $\wedge$ pwd == a.password $\wedge$ b$^\prime$ == b}
%						}
%					{by similar reasoning to \textbf{AuthBalChange}}
%			}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal $\wedge$ $\calls{\_}{\prg{b$^\prime$}}{\prg{transfer}}{\prg{pwd, amt, from, to}}$}
%						{b.getBal(a) < bal}
%						{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
%						}
%					{by \textsc{If1-}$\longrightarrow$}
%			}
%		\endproofsteps
%	\end{proofexample}
%}
%Below we provide the proofs for each method in \jm[]{\ModD} that they cannot
%be used to leak the password of an account. \\
{
	\begin{proofexample}
		\proofsteps{AuthPwdLeak}
			{\proofstepwithrule
				{\hoareEx
						{a:Account $\wedge$ a$^\prime$:Account $\wedge$ a.password == pwd}
						{\prg{res}=a$^\prime$.authenticate(\_)}
						{res != pwd}
						}
					{by classical spec.}
			}
			{\proofstepwithrule
				{\hoareEx
						{a:Account $\wedge$ a$^\prime$:Account $\wedge$ a.password == pwd $\wedge$ $\neg$ false}
						{\prg{res}=a$^\prime$.authenticate(\_)}
						{res != pwd}
						}
					{by classical Hoare logic}
			}
			{\proofstepwithrule
				{\onlyIfSingleExAlt
						{$\wrapped{\prg{pwd}}$ $\wedge$ a, a$^\prime$:Account $\wedge$ a.password=pwd $\wedge$ $\calls{\_}{\prg{a}^\prime}{\prg{authenticate}}{\_}$}
						{$\neg \wrapped{\_}$}
						{false}
						}
					{by \textsc{If1-Inside}}
			}
		\endproofsteps
	\end{proofexample}
	}
%	{
%	\begin{proofexample}
%		\proofsteps{changePassLeak}
%			{\proofstepwithrule
%				{\onlyIfSingleEx
%						{$\wrapped{\prg{pwd}}$ $\wedge$ a, a$^\prime$:Account $\wedge$ a.password=pwd $\wedge$ $\calls{\_}{\prg{a}^\prime}{\prg{changePass}}{\_, \_}$}
%						{$\neg \wrapped{\prg{pwd}}$}
%						{false}
%						}
%					{by similar reasoning to \textbf{AuthPwdLeak}}
%			}
%		\endproofsteps
%	\end{proofexample}
%	}
%	{
%	\begin{proofexample}
%		\proofsteps{Ledger::TransferPwdLeak}
%			{\proofstepwithrule
%				{\onlyIfSingleExAlt
%						{$\wrapped{\prg{pwd}}$ $\wedge$ a:Account $\wedge$ l:Ledger $\wedge$ a.password=pwd $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\_, \_, \_}$}
%						{$\neg \wrapped{\prg{pwd}}$}
%						{false}
%						}
%					{by similar reasoning to \textbf{AuthPwdLeak}}
%			}
%		\endproofsteps
%	\end{proofexample}
%	}
%	{
%	\begin{proofexample}
%		\proofsteps{Bank::TransferPwdLeak}
%			{\proofstepwithrule
%				{\onlyIfSingleExAlt
%						{$\wrapped{\prg{pwd}}$ $\wedge$ a:Account $\wedge$ b:Bank $\wedge$ a.password=pwd $\wedge$ $\calls{\_}{\prg{l}}{\prg{transfer}}{\_, \_, \_, \_}$}
%						{$\neg \wrapped{\prg{pwd}}$}
%						{false}
%						}
%					{by similar reasoning to \textbf{AuthPwdLeak}}
%			}
%		\endproofsteps
%	\end{proofexample}
%	}

\subsection{Part 3: Per-Step \Nec Specifications}
The next step is to construct proofs of necessary conditions for
\emph{any} possible step in our external state semantics.
In order to prove the final result in the next section,
we need to prove three per-step \Nec specifications: \prg{BalanceChange}, \prg{PasswordChange}, and \prg{PasswordLeak}.
\begin{lstlisting}[language=Chainmail, mathescape=true, frame=lines]
BalanceChange $\triangleq$ from  a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal
                 next b.balance(a) < bal   onlyIf $\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password}, \_, \prg{a}, \_}$
                 
PasswordChange $\triangleq$ from a:Account $\wedge$ a.password=p
                  next $\neg$ a.password != p   onlyIf $\calls{\_}{\prg{a}}{\prg{changePass}}{\prg{a.password}, \_}$
                  
PasswordLeak $\triangleq$ from a:Account $\wedge$ a.password=p $\wedge$ inside<p>
                  next $\neg$ inside<p>   onlyIf false
\end{lstlisting}
\jm[]{We provide the proofs of these in Appendix \ref{app:BankAccount}, but describe the construction of the proof of \prg{BalanceChange} here:
by application of the rules/results
 \prg{AuthBalChange}, \prg{changePassBalChange}, \prg{Ledger::TransferBalChange}, \prg{Bank::TransferBalChange}, \prg{BalanceEncaps}, and \textsc{If1-Internal}.}
%
%by combining the results from \ref{s:BA-encap} and \ref{s:BA-classical} using \textsc{If1-Internal}. 
%Again, we elide the details of the proof of \prg{PasswordChange} and \prg{PasswordLeak} as they are similar to that
%of \prg{BalanceChange}. \\
%\noindent
%\begin{proofexample}
%\proofsteps{\prg{BalanceChange}}
%	{\proofstepwithrule
%			{\onlyIfSingleEx
%					{a:Account $\wedge$ b:Bank $\wedge$ b.getBal(a)=bal}
%					{b.getBal(a) < bal}
%					{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password, amt, a, to}}$}
%					}
%				{by \textbf{AuthBalChange}, \textbf{changePassBalChange}, \textbf{Ledger::TransferBalChange}, \textbf{Bank::TransferBalChange}, \textbf{BalanceEncaps}, and \textsc{If1-Internal}}
%		}
%\endproofsteps
%\end{proofexample}
%\begin{proofexample}
%\proofsteps{\prg{PasswordChange}}
%	{\proofstepwithrule{\onlyIfSingleEx
%				{a:Account $\wedge$ a.password=p}
%				{a.password $\neq$ p}
%				{$\calls{\_}{\prg{a}}{\prg{changePass}}{\prg{p}, \_}$}
%				}
%			{by similar reasoning to \textbf{BalanceChange}}
%	}
%\endproofsteps
%\end{proofexample}
%\begin{proofexample}
%\proofsteps{\prg{PasswordLeak}}
%	{\proofstepwithrule{\onlyIfSingleEx
%				{a:Account $\wedge$ a.password=p $\wedge$ $\wrapped{\prg{p}}$}
%				{$\neg \wrapped{\prg{p}}$}
%				{false}
%				}
%			{by similar reasoning to \prg{Balancechange}}
%	}
%\endproofsteps
%\end{proofexample}
\subsection{Part 4: Emergent \Nec Specifications}
Finally, we combine our module-wide single-step \Nec specifications to 
prove emergent behavior of the entire system. Informally the
reasoning used in the construction of the proof of \Snecessity can be stated as
\begin{description}
\item [(1)]
If the balance of an account decreases, then
by \prg{BalanceChange} there must have been a call
to \prg{transfer} in \prg{Bank} with the correct password.
\item [(2)]
If there was a call where the \prg{Account}'s password 
was used, then there must have been an intermediate program state
when some external object had access to the password.
\item [(3)]
Either that password was the same password as in the \jm[]{starting} 
program state, or it was different:
\begin{description}
\item [(Case A)]
If it is the same as the initial password, then since by \prg{PasswordLeak}
it is impossible to leak the password, it follows that some external object 
must have had access to the password initially.
\item [(Case B)]
If the password is different from the initial password, 
then there must have been an \jm[]{intermediate} program state when it 
changed. By \prg{PasswordChange} we know that this must have occurred
by a call to \prg{changePassword} with the correct password. Thus,
there must be a some \jm[]{intermediate} program state where the initial
password is known. From here we proceed by the same reasoning 
as \textbf{(Case A)}.
\end{description}
\end{description}
\begin{proofexample}
\proofsteps{\Snecessity}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal}
				{b.balance(a) < bal}
				{$\calls{\_}{\prg{b}}{\prg{transfer}}{\prg{a.password}, \_, \prg{a}, \_}$}
				}
			{by \textsc{Changes} and \prg{BalanceChange}}}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal}
				{b.balance(a) < bal}
				{$\exists$ o.[$\external{\prg{o}}$ $\wedge$ $\access{\prg{o}}{\prg{a.password}}$]}
				}
			{by $\longrightarrow$, \textsc{Caller-Ext}, and \textsc{Calls-Args}}}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
				{b.balance(a) < bal}
				{$\neg$$\wrapped{\prg{a.password}}$}
				}
			{by $\longrightarrow$}}
	{\proofstepwithrule{\onlyThroughEx
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
				{b.balance(a) < bal}
				{$\neg$$\wrapped{\prg{a.password}}$ $\wedge$ (a.password=pwd $\vee$ a.password != pwd)}
				}
			{by $\longrightarrow$ and \textsc{Excluded Middle}}}
	{\proofstepwithrule{\onlyThroughEx
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
				{b.balance(a) < bal}
				{($\neg$$\wrapped{\prg{a.password}}$ $\wedge$ a.password=pwd) $\vee$\\
				($\neg$$\wrapped{\prg{a.password}}$ $\wedge$ a.password != pwd)}
				}
			{by $\longrightarrow$}}
	{\proofstepwithrule{\onlyThroughExAlt
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
				{b.balance(a) < bal}
				{$\neg$$\wrapped{\prg{pwd}}$ $\vee$
				a.password != pwd}
				}
			{by $\longrightarrow$}}
	{
	\begin{proofexample}
	\proofsteps{Case A ($\neg\wrapped{\prg{pwd}}$)}
			{\proofstepwithrule
				{\onlyIfExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{$\neg$$\wrapped{\prg{pwd}}$}
					{$\wrapped{\prg{pwd}}\ \vee \neg\wrapped{\prg{pwd}}$}
					}
				{by \textsc{If-}$\longrightarrow$ and \textsc{Excluded Middle}}}
			{\proofstepwithrule{\onlyIfExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{$\neg$$\wrapped{\prg{pwd}}$}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by $\vee$E and \prg{PasswordLeak}}}
	\endproofsteps
	\end{proofexample}
	}
	{
	\begin{proofexample}
	\proofsteps{Case B (\prg{a.password != pwd})}
		{\proofstepwithrule{\onlyThroughExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{a.password != pwd}
					{$\calls{\_}{\prg{a}}{\prg{changePass}}{\prg{pwd}, \_}$}
					}
				{by \textsc{Changes} and \textsc{PasswordChange}}}
		{\proofstepwithrule{\onlyThroughExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{a.password != pwd}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by $\vee$E and \prg{PasswordLeak}}}
		{\proofstepwithrule{\onlyIfExAlt
					{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
					{a.password != pwd}
					{$\neg\wrapped{\prg{pwd}}$}
					}
				{by \textbf{Case A} and \textsc{Trans}}}
	\endproofsteps
	\end{proofexample}
	}
	{\proofstepwithrule{\onlyIfExAlt
				{a:Account $\wedge$ b:Bank $\wedge$ b.balance(a)=bal $\wedge$ a.password=pwd}
				{b.balance(a) < bal}
				{$\neg\wrapped{\prg{pwd}}$}
				}
			{by \textbf{Case A}, \textbf{Case B}, \textsc{If-}$\vee$I$_2$, and \textsc{If-}$\longrightarrow$}}
\endproofsteps
\end{proofexample}