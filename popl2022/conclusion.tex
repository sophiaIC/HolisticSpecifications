A module written to be  used with other code needs to ensure that no other code 
may use it and cause unintended effects. Developers whose modules are going to be used in the wild, need the language to constrain the usage of their code, and the capability to prove that their code will always meet these constraints. 

In this paper we have defined \Chainmail, a specification language that allows us to
describe Necessity Specifications, i.e. necessary  conditions for effects.
We use the term  effect to mean the transition from a  state satisfying some assertion 
$A_1$ to some  other state satisfying  assertion $A_2$. 
Our assertion language $A$ supports the usual expressions about the values of
variables, the contents of the heap, as well as predicates to capture provenance 
and permission.

\Chainmail allows us to take a holistic view of modules, in the sense that we do not focus
on individual pieces of code; instead, we  describe  the emergent behaviour of all
the classes and all their methods. 

Modules can satisfy such Necessity Specifications, only if
the underlying programming language and the runtime system 
can give some basic guarantees:
 memory safety (addresses cannot be forged), 
and some notion of privacy (here fields are module-private, i.e. can be read and written only
by methods of the same module). Different notions of privacy 
(e.g. fields to be class-private,
or object-private, and fields to be private only if explicitly defined to be so)  would
also be sufficient to develop code that satisfies such Necessity Specifications.

We have developed an inference system which can be used to prove that modules satisfy  
\Chainmail assertions, and have applied it to our running example. 
Our inference system exploits the sufficient conditions of the classical
method specifications to infer per method Necessity Specifications;  
these describe the necessary conditions for given effects
which take place after the execution of a known method call. 
Per-method Necessity Specifications can be generalized to one-step
 Necessity Specifications; these describe necessary conditions for
 given effects  which take place after the execution of one, 
 unknown, single, step. 
 Lastly, one-step
Necessity Specifications are combined with other Necessity Specifications
 to describe the emergent behaviour, ie  necessary conditions for some effect which
 may have taken place over many, unknown, internal or external steps.
 
The use of the classical method specifications to derive per method Necessity Specifications
has two advantages: First, it means that we did not need to develop a special
purpose logic for that task. Second, it means that all modules that have the same 
classical per method specifications can be proven to satisfy the same Necessity
Specifications using the \emph{same} proof.
 This holds even when the classical specifications are ``similar enough''.
For instance, the modules \prg{Mod1} and \prg{Mod3} from the introduction,
and also module \prg{BankMdl} from section \ref{s:examples}  satisfy \prg{NecessityBankSpec}.
The proofs for these three modules differ slightly in the proof of encapsulation of the
assertion \prg{a.password=pwd} (step \textbf(A)} in section \ref{s:examples}), and
in the proof of the per-method necessity specification for \prg{transfer}, but otherwise are identical.

 
Alternatively, we could have developed a bespoke logic to infer per method Necessity Specifications.
Such a logic might be more powerful than the \Chainmail inference system; 
 we aim to consider that in further work.  Moreover, the classical specifications we using to infer the per method Necessity
Specifications are very "basic", and thus they need to explcitly state what has
not been modified -- this makes proofs very cumbersome. Classical specifications which have more information
about the affected part of the state (e.g. using  \prg{modifies}-clauses, or implicit frames
  \sophia[add ref to JML for modifies, and to some sep 
logic for the frame, and also some of the Bart Jacobs stuff]{} would make the
 step from the classical specification to per method Necessity Specifications more convenient 

Our inference system is parametric with some
algorithmic judgment which can prove that an assertion is encapsulated; we have developed a
rudimentary, types-based such inference system, but we aim to develop a logic for inferring
such assertions. The concept of encapsulation in this work is very coarse, and based on
the classes of objects; in further work, we want to refine it, and be able to 
reason  about encapsulation
into other objects.
Moreover, in the current version of our work we forbid internal objects to call into external objects;
this restriction allows for a simpler formal treatment, and we will be lifting this restriction.
