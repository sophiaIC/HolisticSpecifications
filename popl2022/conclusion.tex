SUSAN

%Susan:Please read first bit as I have just written it
%\se{When you write a module that is to be used with other code, the last thing you want to happen is that some other code uses it to cause effects that you never intended. Our specification language \Chainmail has been designed, so that developers whose modules are going to be used in the wild, have the language to constrain the usage of their code. In addition to classical function by function specification techniques, we have shown that a holistic or whole program approach is needed to make open world code robust. We have shown} 
% going to the old one, as running out of space.
% also, the new one brings new words, and I think all th words in concluson should have appeared earlier
In this paper we have motivated the need for holistic specifications,
presented the specification language \Chainmail for writing such
specifications, and outlined the formal foundations of the language.
%% , and shown 
%% how it can be used to give holistic
%% specifications of key exemplar problems: the bank account,  the
%% wrapped DOM, the ERC20, and and the DAO.
%
To focus on the key attributes of a holistic specification language,
% we have tried to keep the
\sd{we have kept  \Chainmail simple, only requiring an understanding of first order logic.}
\sd{We believe that the holistic features (permission, control, time, space and viewpoint)
are intuitive concepts %for ptogrammers. 
when reasoning informally, and were pleased to have been able to provide their
formal semantics in what  we  argue is a simple manner.}
% below not true, we do have recusrions  
%do not even support recursive procedures to avoid circularities in the
%metatheory, let alone concurrency, exceptions, distribution,
%networking, etc. 

%% \sd{The development of the semantics of \Chainmail assertions posed several interesting 
%% challenges, \eg the treatment of the open world requires two-module execution
%% and the concept of external objects,
%% recursion is confined to ghostfields and assertions require termination of included expressions,
%% space required the concept of restricting runtime configurations,
%% and time required adaptation operators which apply bindings from one configuration to another.}  

%% \sd{\Chainmail is powerful enough to express many key examples from the
%% literature; nevertheless, it lacks several important features: It provides 
%% recursion  only in a restricted form, it has a rather inflexible notion of
%% module and does not support hierarchies of modules, and knows nothing about
%% concurrency or distribution.  We plan to remove these restrictions by applying
%% techniques such as step-indexing \cite{stepindex}, but hope to keep any mathematical 
%% sophitsication in the
%% model of \Chainmail without exposing it to the person who writes the specification.  We are also
%%  interested in extending \Chainmail\ to situations
%% where internal modules are typed, but the external modules are untyped.
%% %
%% We also plan to extend \Chainmail to support reasoning about
%% conditional trust in programs, and to quantify the risks involved in
%% interacting with untrustworthy software \cite{swapsies}.
%% }

%% \sd{To make these kinds of specifications
%% practically useful,  we plan to develop logics for proving adherence of module's code to holistic specs, as well
%% as logics for using holistic specs in the proof of open programs. We want to develop 
%% dynamic monitoring  and model checking techniques for our specifications. 
%% And finally, we plan to automate reasoning with these logics.}

SOPHIA

In this paper we have defined \Chainmail, a specification language that allows us to
describe Necessity Specifications, i.e. necessary  conditions for effects.
We use the term  effect to mean the transition from a  state satisfying some assertion 
$A_1$ to some  other state satisfying  assertion $A_2$. 
The assertion language $A$ supports the usual expressions about the values of
variables, the contents of the heap, as well as predicates to capture provenance 
and permission.

\Chainmail allows us to take a holistic view of modules, in the sense that we do not focus
on individual pieces of code; instead, we  describe  the emergent behaviour of all
the classes and all their methods. 

Modules can satisfy such Necessity specifications, only if
the underlying programming language and the runtime system 
can give some basic guarantees:
 memory safety (addresses cannot be forged), 
and some notion of privacy (here fields are module-private, i.e. can be read and written only
by methods of the same module). Different notions of privacy 
(e.g. fields to be class-private,
or object-private, and fields to be private only if explicitly defined to be so)  would
also be sufficient to develop code that satisfies such necessity specifications.
 

We have developed an inference system which can be used to prove that modules satisfy  
\Chainmail assertions, and have applied it to our running example. 
Our inference system exploits the sufficient conditions of the classical
method specifications to infer per method necessity specifications;  
these describe the necessary conditions for given effects
which took place after the execution of a known method call. 
Per-method necessity specifications can be generalized to one-step
 necessity specifications; these describe necessary conditions for
 given effects  which took place after the execution one, 
 unknown, single, step. 
 Last, one-step
 necessity specifications are combined with other necessity specifications
 to describe the emergent behaviour, ie  necessary conditions for some effect which
 may have taken place over many, unknown, internal or external steps.
 
The use of the classical method specifications to derive per method necessity specifications
has two advantages: First, it means that we did not need to develop a special
purpose logic for that task. Second, it means that all modules that have the same 
classical per method specifications can be proven to satisfy the same necessity
specifications using the \emph{same} poof.
 This holds even when the classical specifications are "similar enough".
For instance, the modules \prg{Mod1} and \prg{Mod3} from the introduction,
and also module \prg{BankMdl} from section \ref{s:example}  satisfy \prg{NecessityBankSpec}.
The proofs for these three modules differ slightly in the proof of encapsulation of the
assertion \prg{a.password=pwd} (step \textbf(A)} in section \ref{s:example}), and
in the proof of the per-method necessity specification for \prg{transfer}, but otherwise are identical.

 
TODO: 

- say that we could make a specific logic for proving (B)

- say that internal/external is like trusted/untrusted hardward (Dreyer)

- say that we need to prove encapsulation and that the current system is rudimentary 

- in related work, say that separation logic cannot dela with external --- CAREFUL

- also say that we do not call from internal to external

FURTHER WORK?  
