We sincerely thank the reviewers for detailed and thoughtful comments, and for the opportunity this gives us to explain our work better

***General Comments***

**G1: external calls**

Sophia>>>

Necessity does not --yet-- support calls of external methods from within internal modules. This is, indeed, a limitation, but it is not uncommon in the related literature. For example, VerX [Permenev et al] work on effectively call-back free contracts, while and [Grossman 2018] and  [Albert 2020] on drastically restricting the effect of a callback on a contract. Therefore, we argue that a treatment of  external calls in Necessity would bring some further complexity, and would  detract from the main focus of our paper.  

We cannot promise a full treatment of external calls by end February. But we can share out current thinking:  As a first approach, we will require that the arguments to external calls do not include internal objects, except for the receiver and parameters (thus ensuring that external accessibility of internal methods does not increase); we would rely on the classical pre- and post- conditions of the internal methods -- as we currently do. As a more advanced approach, we will develop extensions to classical Hoare Logics, which would allow us to reason about points in the code where external calls are being made. This would be the first time we could be inspecting the code in the bodies of the functions,

<<<<

Julian>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response: (Julian: this is the main issue they seem to have with the contribution aspect of the paper). Most similar work TODO: Say which $ in the literature take a restricted approach to external method calls, restricting external method calls to
only being made at the end of the method, thereby eliminating the possibility of internal operations within a method occurring after unknown, and unverifiable external operations. The advantage of this restriction to us is that
it does not meaningfully interfere with the external states semantics model of our operational semantics. Thus, such a restriction could be made with little modification to the proof system. The one rule that would require some modification would be If1-Inside, as method return would no longer be the only way to expose module internal objects.
(Julian: I need to give this some more thought. I think it should be relatively simple to define this, but I need to think through it a bit more)

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

Sophia >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

I think that some of your response, Julian, is too technical too soon, for our reviewers. Also, would not promise yet o make the extension before February. And you need to back up claims. Look at my proposal

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

G2:  overlap with Chainmail
- cannot be encoded into
- we have a Logic
- % of common lines

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

There is minimal overlap between the formalism of FASE2020 and that of Necessity. It is true that some of the definitions, and their encodings, are inspired by the work of FASE2020, 
and as such there may be some similarities between the two formalisms, but these similarities do not extend to the contributions of our paper: the Necessity language and proof system, 
the soundness result, and the example of the proof system. Where there are similarities, these either have been explicitly stated in the paper (eg. permission, provenance, and control),
or are common coq idioms (eg. variable substitution).

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

G3: The Definition of $\triangle$ -- adaptation
THINK
How convince them it is not most important?
we _are_ using extra variables in the states

G4: Advantage over VerX/Chainmail (rev4)

G5: Is access deep?

Julian >>>>>>>>>>>>>>>>>>>>>>>>>

Response: <x access y> is not true for indirectly accessible fields. This is not a soundness issue as for indirect access to give rise to direct access (what we define as <x access y>), some computation is required, and as such these questions of soundness would be handled by the definition of assertion encapsulation. In the underlying language we use, field access is restricted to within the class (as per Java) to which the object containing the field belongs.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


*** Proposed Changes

We will implement all the proposals, and think we will apply all of them...

C0: external

C1: Move the clarifying examples to section 2, and explain better
ie write the explanations

C2: Rename Mod1, Mod2, Mod3 to Mod_{basic}, ....

C3: move the definition of "inside" to ...

C4: make consistent use of Section/Section

C5: encapsulation -- better explanation

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response:
Assertions are not "encapsulated" by some arbitrary code, but rather by the internal module, i.e. known code. Assertion encapsulation captures a property that is essential to proofs of safety in the open world: certain operations may only occur within the "internal" module/code, thus, the satisfaction of properties that depend on such operations may only change as a result of internal module code. The simplest such operation in a Java-like language would be the mutation of a field of an object of an internal class. Satisfaction of assertions about the value of such a field may only change as a result of internal code being executed.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

C6: adaptation -- better explanation

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response:
Adaptation is indeed an important definition to the paper, but is not a central contribution. We thank the reviewers for picking up on this, as upon reflection we recognize that the precise meaning of adaptation was not clear in the text, and potentially detracts from a critical definition, Def. 3.10. We propose the following explanation:

``Adaptation is a variable renaming operator that ensures that variable names used at one point in the execution refer to the same object at a future point in the execution. This is necessary as, within assertions, objects are referenced using variable names, and not unique and immutable identifiers. This is in keeping with how many formal specification languages refer to objects (cite????). This presents a problem when the program to be executed is not necessarily known at verification time. During program execution variables may be either overwritten or lost from scope, and as such using the same variable name at different points in execution has little meaning unless there is a way to rewrite variables so that their intended meaning can be preserved. Adapting one program state with a second allows variables in the second state to point to the same object in the first.''

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

C7: change the bank account example to be the same?
- explain advantages of current one, and put the current in the appendix

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response:
We chose the more complex form of the bank account example in order to show case some of the features of Necessity, specifically:
1) The ability to reason about ghost fields, and not just simply values within fields
2) More complex data structures which allows for more potentially complex forms of emergent behavior

The reviewers make a good point that this example is potentially too complex for an initial proof example, as such we will 
replace this example with the simpler version, and mechanise that proof using Coq by 11 February. We will retain the existing proof as part 
of the appendix for the purposes of exhibiting the more sophisticated aspects of Necessity.


<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

C8: make the section 2.4 top-down?

C9: emergent behaviour 

C10: and we will implement
 


*** Detailed Response -- per reviewer ***

Reviewer A:

Reviewer B:

Reviewer C:

Reviewer D:

Bibliography

[Grossman 2018] Shelly Grossman, Ittai Abraham, Guy Golan-Gueta, Yan Michalevsky, Noam Rinetzky, Mooly Sagiv, and Yoni Zohar. Online detection of effectively callback free objects with applications to smart contracts. In Symposium on Principles of Programming Languages, POPL. ACM, 2018.

[Albert 2020] Elvira Albert, Shelly Grossman, Noam Rinetzky, Clara Rodríguez-Núñez, Albert Rubio, and Mooly Sagiv. 2020. Taming Callbacks for Smart Contract Modularity. Proc. ACM Program. Lang. 4, OOPSLA, Article 209, 2020


QUESTIONS for us