We thank their reviewers for their detailed and thoughtful comments 
% some jike about Cs :-)


***General Comments***

G1: external calls
XXXX
--> VERX no calls backs?
callback free work .... 

Julian>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response: (Julian: this is the main issue they seem to have with the contribution aspect of the paper). Most similar work in the literature take a restricted approach to external method calls, restricting external method calls to
only being made at the end of the method, thereby eliminating the possibility of internal operations within a method occurring after unknown, and unverifiable external operations. The advantage of this restriction to us is that
it does not meaningfully interfere with the external states semantics model of our operational semantics. Thus, such a restriction could be made with little modification to the proof system. The one rule that would require some modification would be If1-Inside, as method return would no longer be the only way to expose module internal objects.
(Julian: I need to give this some more thought. I think it should be relatively simple to define this, but I need to think through it a bit more)

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

G2:  overlap with Chainmail
- cannot be encoded into
- we have a Logic
- % of common lines

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response: <x access y> is not true for indirectly accessible fields. This is not a soundness issue as for indirect access to give rise to direct access (what we define as <x access y>), some computation is required, and as such these questions of soundness would be handled by the definition of assertion encapsulation. In the underlying language we use, field access is restricted to within the class (as per Java) to which the object containing the field belongs.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

G3: The Definition of $\triangle$ -- adaptation
THINK
How convince them it is not most important?
we _are_ using extra variables in the states

G4: Advantage over VerX/Chainmail (rev4)

G5: Is access deep?

Julian >>>>>>>>>>>>>>>>>>>>>>>>>

Response: <x access y> is not true for indirectly accessible fields. This is not a soundness issue as for indirect access to give rise to direct access (what we define as <x access y>), some computation is required, and as such these questions of soundness would be handled by the definition of assertion encapsulation. In the underlying language we use, field access is restricted to within the class (as per Java) to which the object containing the field belongs.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


*** Proposed Changes

We will implement all the proposals, and think we will apply all of them...

C0: external

C1: Move the clarifying examples to section 2, and explain better
ie write the explanations

C2: Rename Mod1, Mod2, Mod3 to Mod_{basic}, ....

C3: move the definition of "inside" to ...

C4: make consistent use of Section/Section

C5: encapsulation -- better explanation

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response:
Assertions are not "encapsulated" by some arbitrary code, but rather by the internal module, i.e. known code. Assertion encapsulation captures a property that is essential to proofs of safety in the open world: certain operations may only occur within the "internal" module/code (and thus may not be performed by unknown, external code). Thus, certain properties may only change as a result of internal module code. The simplest such operation in a Java-like language would be the value of a field of an object of an internal class. Fields may only be modified by objects of the same class. Thus, fields of objects belonging to internal module classes may only be modified internally.

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

C6: adaptation -- better explanation

Julian >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

Response:
Adaptation is indeed an important definition to the paper, but is not a central contribution. Adaptation is a variable renaming operator that ensures that variable names used at one point in the execution refer to the same object at a future point in the execution. This is necessary as the assertions used are assertions, made on objects, via variable names. During program execution variables may be either overwritten or lost from scope, and as such using the same variable name at different points in execution has little meaning unless there is a way to rewrite variables so that their intended meaning can be preserved. 

<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

C7: change the bank account example to be the same?
- explain advantages of current one, and put the current in the addendix

C8: make the section 2.4 top-down?

C9: emergent behaviour 

C10: and we will implement
 


*** Detailed Response -- per reviewer ***

Reviewer1

Reviewer2


QUESTIONS for us