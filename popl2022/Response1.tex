\documentclass[11pt]{amsart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\usepackage{filecontents}
\begin{filecontents}{Response1.bib}
@article{Grossman,
author = {Grossman, Shelly and Abraham, Ittai and Golan-Gueta, Guy and Michalevsky, Yan and Rinetzky, Noam and Sagiv, Mooly and Zohar, Yoni},
title = {Online Detection of Effectively Callback Free Objects with Applications to Smart Contracts},
year = {2017},
issue_date = {January 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {2},
number = {POPL},
url = {https://doi.org/10.1145/3158136},
doi = {10.1145/3158136},
journal = {Proc. ACM Program. Lang.},
month = {dec},
articleno = {48},
numpages = {28},
keywords = {Program analysis, Modular reasoning, Smart contracts}
}
@article{Albert,
author = {Albert, Elvira and Grossman, Shelly and Rinetzky, Noam and Rodr\'{\i}guez-N\'{u}\~{n}ez, Clara and Rubio, Albert and Sagiv, Mooly},
title = {Taming Callbacks for Smart Contract Modularity},
year = {2020},
issue_date = {November 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {OOPSLA},
url = {https://doi.org/10.1145/3428277},
doi = {10.1145/3428277},
journal = {Proc. ACM Program. Lang.},
month = {nov},
articleno = {209},
numpages = {30},
keywords = {blockchain, program verification, program analysis, logic and verification, smart contracts, invariants}
}

@article{Permenev,
  title={VerX: Safety Verification of Smart Contracts},
  author={Anton Permenev and Dimitar I. Dimitrov and Petar Tsankov and Dana Drachsler-Cohen and Martin T. Vechev},
  journal={2020 IEEE Symposium on Security and Privacy (SP)},
  year={2020},
  pages={1661-1677}
  }
  
  @inproceedings{Drossopoulou,
author="Drossopoulou, Sophia and Noble, James and Mackay, Julian and Eisenbach, Susan",
editor="Wehrheim, Heike and Cabot, Jordi",
title="Holistic Specifications for Robust Programs",
booktitle="Fundamental Approaches to Software Engineering",
year="2020",
publisher="Springer International Publishing",
address="Cham",
pages="420--440",
}

@misc{Chlipala,
  author = "Adam Chlipala",
  title = "frap: Formal Reasoning about Programs",
 url = "https://github.com/achlipala/frap",
 year = 2019,
 date = "2021-12-02",
}

\end{filecontents}


\usepackage{natbib}

\title{Response for Paper 30: Necessity Specifications are Necessary for Robustness }
%\author{The Author}
%\date{3 December 2021}                                           % Activate to display a given date or no date

\begin{document}
\maketitle
\section{Overview}
We sincerely thank the reviewers for detailed and thoughtful comments, and for the opportunity this gives us to explain our work better. We feel the concerns fall into three areas. The technical concern is that Necessity does not yet support calls of external methods from within internal modules. There is a level of contribution concern as to how different it is from Chainmail and VerX. Finally, there are several areas where the presentation of our ideas should be made clearer. The changes we describe in this response could comfortably be made before the February deadline.

\subsection*{External calls}

Necessity does not --yet-- support calls of external methods from within internal modules. This is, indeed, a limitation, but it is not uncommon in the related literature. For example, VerX~\citep{Permenev} work on effectively call-back free contracts, while~\citep{Grossman} and ~\citep{Albert} on drastically restricting the effect of a callback on a contract. Therefore, we argue that a treatment of  external calls in Necessity would bring some further complexity, and would  detract from the main focus of our paper.  

\subsection*{Novelty}

Our Necessity operators are novel and we do not believe that our {\tt{onlyThrough}} operator can be encoded into either VerX or Chainmail.[Susan: is this true?]

Whereas both VerX and Necessity deal with protecting code from unknown code, VerX is Smart Contracts specific whereas Necessity is not domain specific.  The technology used is also different: VerX is a model checker whereas Necessity programs are proven using Coq.

It is true that some of the Necessity definitions, and their encodings, are inspired by Chainmail~\citep{Drossopoulou}, 
%and as such there may be some similarities between the two formalisms, but these similarities do not extend to 
but the contributions of our paper go much farther.
The Necessity language and proof system, 
the soundness result, and the proven examples have no equivalents in Chainmail.
% of the proof system. 
%Where there are similarities, these either have been explicitly stated in the paper (eg. permission, provenance, and control), or are common coq idioms (eg. variable substitution).
For the Coq code both Chainmail and Necessity use Chlipala's frap library~\citep{Chlipala}, but do not share any other code.

\subsection*{Presentation}
\paragraph{Adaptation} is indeed an important definition, but is not a central contribution. 
%We propose the following amended explanation to clarify both it's importance, and it's meaning:
`%`We deal with this via an \emph{adaptation} operator~\cite{Drossopoulou}. We write $\adapt {\sigma'} {\sigma}$   to view a future state $\sigma'$ from the perspective of a current  (or past) state $\sigma$.
It is a variable renaming operator that ensures that variable names 
used at one point in the execution refer to the same object at a future point in the execution. 
This is necessary as, within assertions, objects are referenced using variable names, and not unique and immutable identifiers.
During program execution variables may be either overwritten or lost from scope, and as such using the same variable name at 
different points in execution has little meaning unless there is a way to rewrite variables so that their intended meaning can 
be preserved. Adapting one program state with a second allows variables in the second state to point to the same object that was in the first.
%Def.\ref{d:adapt} shows how $\adapt{\sigma'}{\sigma}$, constructs a new
%state, taking the heap and most of the stack from the future state 
%$\sigma'$. We replace the top frame's variable map 
%with the variable map from the top frame of the past state $\sigma$,
%avoiding name clashes by renaming the 
%variables in the top frame of $\sigma'$ with fresh variables
%($\overline{v}$) and renaming free variables in the continuation similarly.''

\paragraph{Access} Access is not deep, and only refers to objects that an object has direct access to via a field or within the context of the current scope. If access were defined transitively, then many objects would be defined as having access that they could not gain a direct reference to. As an example, an object may have access to an account, but it could never leverage that access to gain access to the password.

\paragraph{Assertion encapsulation} captures a property that is essential to proofs of safety in the open world: certain operations may only occur within as the result of internal module method calls, thus, the satisfaction of properties that depend on such operations may only change as a result of internal module code. The simplest such operation in a Java-like language would be the mutation of a field of an object of an internal class. Satisfaction of assertions about the value of such a field may only change as a result of internal code being executed. Assertions are therefore not ``encapsulated'' by some arbitrary code, but rather by the internal module, and thus only programs that contain method calls to the internal module are able to invalidate those assertions. In the reviewer's example where C' = C; x := x, if C contains internal method calls that invalidate some assertion A, then so does C'.

\paragraph{Emergent Behaviour} 
%The reviewer correctly identifies that we did not sufficiently indicate what we meant by ``emergent behavior''. We propose the follow change 
%to Section 1, where ``emergent behavior'' is first mentioned:
The first reviewer had difficulty understanding what we meant by emergent behaviour but surmised that it meant that  ``no single procedure call is capable of breaking the necessity specification, but a sequence of calls can very well be''. That is correct.

``(S2) does not take account of the module's \emph{emergent behavior}. That is, (S2) does not consider the behaviour that emerges from the interaction between the 
\texttt{transfer} method, and the other methods of the bank module. What if the module leaks the password?''

\paragraph{Bank Account example} The formal proof of the bank account example is very heavy weight given how straightforward the introductory example is. This is because we didn't prove the existing bank account example but did a more complicated one to show off more features of Necessity.

 \section{Change List}
  We will make all the minor changes suggested by the reviewers.
 \subsection*{External calls}
 We cannot promise a full treatment of external calls by the end of February, but we can share out current thinking:  As a first approach, we will require that the arguments to external calls do not include internal objects, except for the receiver and parameters (thus ensuring that external accessibility of internal methods does not increase); we would rely on the classical pre- and post- conditions of the internal methods -- as we currently do. As a more advanced approach, we will develop extensions to classical Hoare Logics, which would allow us to reason about points in the code where external calls are being made. This would be the first time we could be inspecting the code in the bodies of the functions.
 \subsection*{Novelty}
 We will strengthen our statements about VerX and Chainmail in line with what we said above.
 
 \subsection*{Presentation}
 
 For adaption, access, and encapsulation we will amend the explanations as stated above. Susan: or do you want to discuss Julian's cleaner definition for adaption he sent yesterday???
 
 For emergent behaviour we will include the reviewer's statement and also say that ``(S2) does not take account of the module's \emph{emergent behaviour}. That is, (S2) does not consider the behavior that emerges from the interaction between the 
\texttt{transfer} method, and the other methods of the bank module. What if the module leaks the password?''
 
 We will replace the current Bank Account proof with a simpler Coq proof that matches the straightforward introductory example. We will put the current example in an appendix so that we can 
show reasoning about ghost fields and more complex data structures. 

We will move the clarifying examples to Section 2.

The largest piece of work is the proof and that shouldn't take more than a week so we believe that we can make substantial improvements in presentation before mid January.



 


 
 %We propose the following amended explanation to clarify both it's importance, and it's meaning:

 
 A list of the changes that you plan to make in
  response to the reviews and the timeline for those changes.
  
 
  
\section{Response} A reviewer-by-reviewer list of answers to questions
  with context extracted from the reviews. Use markdown syntax.

\bibliographystyle{plainnat}
\bibliography{Response1} 


\end{document}  
