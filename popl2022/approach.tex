\section{The Meaning of Necessity}
\label{s:semantics}

 
In this section we define our \Nec specification language.
%In order to do that, 
\scd{We} first define 
an underlying programming language, \Loo  (\S \ref{sub:Loo}).
%modification to description of type system. Not sure if this is clear enough.]{
%We base \Loo on \LangOO, as defined by 
%\cite{FASE}. Whereas \LangOO was untyped, \Loo 
%%includes a simple type
%%system to allow for
%has type based restrictions on external access to private data.}
We then  define an assertion language, \SpecO,  which can talk about
 the contents of the state, as well \scd{as about} 
provenance, permission and control (\S \ref{sub:SpecO}).
Finally, we define the syntax and semantics of 
\Nec specifications  (\S \ref{s:holistic-guarantees}).
% our \Nec specification language  (\S \ref{s:holistic-guarantees}).


\subsection{\Loo}
\label{sub:Loo} 
%\jm[TODO: mention the type system and the restriction on external method calls]{}
%% We introduce a simple object-oriented language, \Loo, upon 
%% which our specification language sits.
 \Loo is a  simple  imperative, \scd{sequential}, 
class based, typed, object oriented language.
%\susan[Java fields are package private not class private - are fields so important that we need to say this?]{Fields are private to the class where they are defined.}
 Given its simplicity, %  the simplicity of \Loo, we do notdefine it here, instead, 
 we direct the reader to Appendix \ref{app:loo} for 
the full definitions, \scd{and} introduce here only % syntax and operational semantics.
 the concepts most relevant to the
treatment of the open world guarantees.
%\jm[]{\Loo fields are private in the way fields in Java are private,
%the privacy is class-wide, i.e. they may only be read or written to by 
%objects of the same class.}
\scd{\Loo is based} on \LangOO from
\cite{FASE}, \scd{with some small variations}, as well as 
the addition of a % while \LangOO is untyped, \Loo 
 a simple type system -- more in \sophiaPonder[TODO]{reference}.
%has type based restrictions on external access to private data.}


A \Loo state $\sigma$ consists of a 
heap $\chi$, and a  {stack $\psi$, which is a sequence of frames $\phi$}.
A frame $\phi$ consists of
local variable map, and a continuation, i.e. a sequence of statements to be executed.
 A statement may assign to variables, create new objects and push them to the heap, 
perform field reads and writes on objects,  or
 call methods on those objects. 

%Program 
 Modules are mappings
from class names to class definitions. 
Execution takes place in the context of  a module $M$ and   \scd{a state $\sigma$}.
It is % Execution
 \scd{defined} through a small-step, unsurprising, semantics, of the form \ \ 
   $M, \sigma \leadsto \sigma'$,\  c.f. Appendix \ref{app:loo}.
The   continuation of the top frame contains the statements \scd{that will be} % currently being 
executed next.
 % chopped, as generic 
 % There are several properties  of \Loo that are important to the central topic of this paper. 
 
As discussed in \S \ref{s:approach}, we are interested in guarantees which hold
\sophiaPonder[need to remind reader of internal/external]{during execution of an internal, 
known, trusted module $M$ when linked together with any
unknown, untrusted, module $M'$.} These guarantees need only hold 
when the external module is executing; \scd{we} are not concerned if they are
temporarily broken by the internal module. Therefore, we are only interested in states where the
executing object (the \prg{this}) is an external object. 
For this, we define the  \emph{external state semantics}, of the form 
$\reduction{M'}{M}{\sigma}{\sigma'}$, where $M'$ is the external
module, and $M$ is the internal module, and where we
collapse all internal steps into one single step.

 

\begin{definition}[External State Semantics]
\label{def:pair-reduce}
For  
% If we say "internal module", it is sounds as something makes the module be internal
  modules $M$,  $M'$, and program states $\sigma$, $\sigma'$, 
we say that $\ \ \ \ \ \ \ \ \reduction{M'}{M}{\sigma}{\sigma'}\ \ \ \ \ \ \ \ $ if and only if there exist 
$n\in\mathbb{N}$, \scd{and states $\sigma_0$,...$\sigma_n$}, such that
\begin{itemize}
% SD changed because the old version was slightly wrong
\item
$\sigma$=$\sigma_1$, and  $\sigma'$=$\sigma_n$,
\item
$M' \circ M, \sigma_i \leadsto \sigma_{i+1}$  \ \ \ for all $i\in [0..n)$,
\item
$\class{\sigma}{\sigma.\prg{this}}, \class{\sigma'}{\sigma'.\prg{this}}\in M'$,
\item
$\class{\sigma_i}{\sigma_i.\prg{this}} \in M$\ \ \ for all $i\in [1..n)$.
\end{itemize} 
\end{definition}
% In Definition \ref{def:pair-reduce}  % of external state semantics makes reference to a 
The function
$\class{\sigma}{x}$  looks up 
the class of   the object referred by variable $x$ in the heap of $\sigma$. 
  % for a specific variable in a specific program.
% SD not a variable, and no program.
The module linking operator $\circ$, applied to two modules, $M\circ M'$, % . The operator $\circ$
 %  results in the union of two disjoint modules.
combines the two modules into one module in the obvious way, provided their
domains are disjoint.
Full details in  Appendix \ref{app:loo}.
\begin{figure}[htb]
%  \vspace*{-2.5mm}
%  \begin{center}
%   \begin{minipage}{0.80\textwidth}
%     \begin{center}
%       \includegraphics[width=\linewidth]{diagrams/VisibleStates.pdf}
%     \end{center}
%   \end{minipage}
%   \end{center}
%   \vspace*{-2.5mm}
TODO new figure. \scd{should only have (A) and (B)}
   \caption{External States Semantics
     (Def. \ref{def:pair-reduce}). %
     % 
     (A) $\exec{{\color{blue}M'} \circ {\color{orange}M}}{\sigma_1}{\ldots}\leadsto \sigma_9$\ \ \and \ \ \ 
     (B) $\reduction{{\color{blue}M'}}{{\color{orange}M}}{\sigma_2}{\ldots}\leadsto \sigma_9$
    %  (c) $\reduction{{\color{orange}M'}}{{\color{blue}M}}{\sigma_1}{\ldots}\leadsto \sigma_8$
    }
   \label{fig:VisibleStates}
 \end{figure}
 
Fig. \ref{fig:VisibleStates} provides a simple graphical description of 
our external states semantics: \scd{(A) is the ``normal'' execution after 
linking two modules into one: \ $M' \circ M, ... \leadsto ...$. (B) is the
 external states execution when $M'$ is external,\   $\reduction{M'}{M}{...}{...}$  (B).}
\sophiaPonder[moved to earlier]{We  use} the notation\ \  $\reductions{M'}{M}{\sigma}{\sigma'}$ \ 
to denote
zero or more reduction steps starting at state $\sigma$ and ending at state $\sigma'$, in the context of internal module 
$M$ and external module $M'$.
 





\sophiaPonder[better connection, avoided repetition, tighten]{Not only are we unconcerned 
about internal states, 
%  (where \prg{this} belongs to a class from the inernal module),
 we are also unconcerned with  states which cannot ever arise from execution.
% 
% which are upheld by the internal 
%module. Moreover,    these guarantees  need to be satisfied only at `reachable' states,
%and need not be satisfied at states that are
%not reachable -- this is described formally in Definition \ref{def:arising}. 
\emph{Arising} states are those that  may arise by external states execution
% of  a given internal module linked with an external module.
% We describe the states of interest as the \emph{arising states}. 
starting at some initial configuration:}



\begin{definition}[Arising Program State]
\label{def:arising}
For   modules $M$ and  $M'$, a program state $\sigma$ is 
said to be an \emph{arising} state, formally \ \ \ $\arising{M}{M'}{\sigma}$,\ \ \ 
if and only if there exists some $\sigma_0$ such that $\initial{\sigma_0}$ and
$\reductions{M'}{M}{\sigma_0}{\sigma}$.
\end{definition}

% Definition \ref{def:arising} uses the definition for 
% In the definition above we used 
\scd{A state is \emph{Initial}} 
% he definition of which can be found in  Definition \ref{def:initial}. 
% which  characterize states at the start of program execution.
%The heap of an initial state should 
if its heap contains a single object of class \prg{Object}, and
its  stack   consists of a single frame, whose local variable map is a
mapping from \prg{this} to the single object, and whose continuation \scd{is}  any statement.
% to be executed.
More in Def. \ref{def:initial}and Def. \ref{def:arising}.
%%========================
%%old
%Finally, \Loo has a simple class based type system with the following properties:
%\begin{description}
%\item[(1)]
%Classes may be optionally annotated as \prg{enclosed}
%\item[(2)]
%Methods of non-\prg{enclosed} classes may not return objects of \prg{enclosed} classes
%\item[(3)]
%Modules are typed in isolation of other modules, thereby implicitly prohibiting
%method calls from internal objects to external objects.
%\end{description}
%The type system \jm[]{is included to allow a simple and convenient way to prove encapsulation of \SpecO assertions,
%however it is not fundamental to the definition of either the  \Nec specification language or logic, and could easily be substituted out 
%for any other encapsulation system.}
%%==================================

\jm[]{Finally, \Loo has a simple class based type system where 
classes may be optionally annotated as \enclosed. An object 
of an \enclosed type may not be accessed by module-external
objects. This helps simplify the demonstrative proof of the running 
Bank Account example (\S\ref{s:examples}). In order to enforce this 
restriction, methods of non-\enclosed classes are prohibited from
returning \enclosed objects.}

\jm[]{\Loo's type system has one further implication: modules are typed 
in isolation of other modules, thereby implicitly prohibiting
method calls from internal objects to external objects.}

\jm[]{The type system is included to allow a simple and convenient way to prove that access to certain 
objects is restricted. This restriction simplifies the proof of our running example to a manageable degree,
however it is not fundamental to the definition of either the  \Nec specification language or logic, 
and could easily be removed.}


\subsection{\SpecO}
\label{sub:SpecO}
\SpecO extends the expressiveness of standard specification languages
with assertion forms capturing key concepts of software security:
 \emph{permission}, \emph{provenance}, and \emph{control}.
 \emph{Permission} and \emph{Provenance} are inspired by the capabilities literature, while
\emph{Control} assists construction of proofs.
%That is, \SpecO specifications are able to specify which objects have
%access to which other object (\emph{permission}), whether an object's origin
%is internal or external to known code (\emph{viewpoint}), or which objects call which 
%methods (\emph{control}). 

\subsubsection{Syntax}

%\begin{figure}[t]
%\footnotesize
%\[
%\begin{syntax}
%\syntaxElement{A}{}
%		{
%		\syntaxline
%				{e}
%				{e : C}
%				{\neg A}
%				{A\ \wedge\ A}
%				{A\ \vee\ A}
%				{\all{x}{A}}
%				{\ex{x}{A}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
%				{\access{x}{y}}
%				{\internal{x}}
%				{\external{x}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
%				{\calls{x}{y}{m}{\overline{z}}}
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\end{syntax}
%\]
%\caption{\SpecO Assertions}
%\label{f:chainmail-syntax}
%\end{figure}
%

\begin{definition}
Assertions ($A$) in the basic specification language, \SpecO, are defined as follows

\label{f:chainmail-syntax}
%\footnotesize
\[
\begin{syntax}
\syntaxElement{A}{}
		{
		\syntaxline
				{e}
				{e : C}
				{\neg A}
				{A\ \wedge\ A}
				{A\ \vee\ A}
				{\all{x}{A}}
				{\ex{x}{A}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\access{x}{y}}
				{\internal{x}}
				{\external{x}}
%		\endsyntaxline
%		}
%		{
%		\syntaxline
				{\calls{x}{y}{m}{\overline{z}}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]


\end{definition}


Def. \ref{f:chainmail-syntax} gives the assertion syntax of \SpecO. % the \SpecO specification language.
An assertion may be an expression, a class assertion, the usual connectives and quantifiers, along 
with the following non-standard assertion forms:
\begin{itemize}
\item
\emph{Permission} ($\access{x}{y}$): % Which objects have access to which other objects (i.e.
  $x$ has access to $y$.
\item
{\emph{Provenance}} ($\internal{x}$ and $\external{y}$): %Which objects are internal or external to our component.
 $x$ is internal, and $y$ is external.
\item
\emph{Control} ($\calls{x}{y}{m}{\overline{z}}$): 
$x$ calls method $m$ on object $y$ with arguments $\overline{z}$.
\end{itemize}

\subsubsection{Semantics of \SpecO}
The semantics of \SpecO assertions is given in Definition \ref{def:chainmail-semantics}. 
\SpecO makes use of several language features of 
\Loo that can be found in Appendix \ref{app:loo}. Specifically, $\eval{M}{\sigma}{e}{v}$
is the evaluation relation for expressions, and is interpreted as expression $e$ evaluates
to value $v$ in the context of program state $\sigma$, with module $M$. The full
semantics of expression evaluation are given in Fig. \ref{f:evaluation}. It should 
be noted that expressions in \Loo may be recursively defined, and thus evaluation may not
necessarily terminate, however the logic remains classical because recursion is restricted
to expressions, and not generally to assertions.

Further, Definition \ref{def:chainmail-semantics} uses the interpretation of variables
within a specific frame or state: i.e. $\interpret{\phi}{x} = v$, meaning that $x$ maps to
value $v$ in the local variable map of frame $\phi$, and $\interpret{\sigma}{x} = v$ meaning $x$ 
maps to value $v$ in the top most frame of $\sigma$'s stack. And the term  $\interpret{\sigma}{x.f} = v$
has the obvious meaning.


\begin{definition}[Satisfaction of \SpecO Assertions] 
\label{def:chainmail-semantics}
We define satisfaction of an assertion $A$ by a program state $\sigma$ with internal module $M$ as:
\begin{itemize}
\item
$\satisfiesA{M}{\sigma}{e}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{e}{\true}$
\item
$\satisfiesA{M}{\sigma}{e : C}$ \ \ \ iff \ \ \  $\eval{M}{\sigma}{e}{\alpha}$ \textit{and} $\class{\sigma}{\alpha} = C$
\item
$\satisfiesA{M}{\sigma}{\neg A}$ \ \ \ iff \ \ \  ${M},{\sigma}\nvDash{A}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \wedge\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}$ and 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{A_1\ \vee\ A_2}$ \ \ \ iff \ \ \  $\satisfiesA{M}{\sigma}{A_1}$ or 
$\satisfiesA{M}{\sigma}{A_2}$
\item
$\satisfiesA{M}{\sigma}{\all{x}{A}}$ \ \ \ iff \ \ \  
$\satisfiesA{M}{\sigma[x \mapsto \alpha]}{A}$, \ 
\ \ for some $x$ fresh in $\sigma$, and for all $\alpha\!\in\!\sigma.\prg{heap}$.
\item
$\satisfiesA{M}{\sigma}{\ex{x}{A}}$ \ \ \ iff \ \ \  
$\satisfiesA{M}{\sigma[x \mapsto \alpha]}{A}$, \ 
\ \ for some $x$ fresh in $\sigma$, and for some $ \alpha\!\in\!\sigma.\prg{heap}$. 
\item
$\satisfiesA{M}{\sigma}{\access{x}{y}}$ \ \ \ iff \ \ \  
\begin{itemize}
\item
$\interpret{\sigma}{x.f}={\interpret{\sigma}{y}}$ for some $f$, \  or
\item
there exists some $z$, and some frame $\phi$ in the stack of $\sigma$ such that {$\interpret{\sigma}{x}=\interpret{\phi}{\prg{this}}$}, {and $\interpret{\sigma}{y}=\interpret{\phi}{z}$}
\end{itemize}
\item
$\satisfiesA{M}{\sigma}{\internal{x}}$ \ \ \ iff \ \ \  
$\textit{classOf}(\sigma,x) \in M$
\item
$\satisfiesA{M}{\sigma}{\external{x}}$ \ \ \ iff \ \ \  
$\textit{classOf}(\sigma,x) \not\in M$
\item
$\satisfiesA{M}{\sigma}{\calls{x}{y}{m}{z_1, \ldots, z_n}}$ \ \ \ iff \ \ \ 
\begin{itemize}
\item
$\sigma.\prg{contn} = (\_ := y'.m(z'_1,\ldots,z'_n))$, % and is superfluous, enums are ands, unless expltly stated   
\item
$\satisfiesA{M}{\sigma}{x = \prg{this}}$
%$\interpret{\sigma}{x} = \interpret{\sigma}{\prg{this}}$  % and
\item
$\satisfiesA{M}{\sigma}{y = y'}$
%$\sd{\interpret{\sigma}{y} = \interpret{\sigma}{y'}}$ % and
\item
$\satisfiesA{M}{\sigma}{z_i = z'_i}$\ \ \ for all $1\!\leq i\!\leq n$
%$\interpret{\sigma}{z_i} = \interpret{\sigma}{z'_i}$ \ \ \ for all $1\!\leq i\!\leq n$
\end{itemize}
\end{itemize}
\end{definition}

 
Finally, we define what it means for a module to satisfy an assertion:
a module $M$ satisfies an assertion $A$, if all states $\sigma$
arising from external steps execution of that
module with any other external module, satisfy $A$. 
 
\begin{definition} [Assertion Satisfaction by Modules]
\label{def:mdl-sat}
For a module $M$ and assertion $A$, we say that\ \  $\satisfies{M}{A}$ \ \ if and only if 
for all modules $M'$, and all $\sigma$, if $\arising{M'}{M}{\sigma}$, then $\satisfiesA{M}{\sigma}{A}$.
\end{definition}


% Thus, satisfaction by a module  allows us to talk 
% about what is true for a given module without introducing the 
% details of specific program configurations, a critical component 
% of constructing our Logic of Necessity in Section \ref{s:inference}. 

A proof system for such assertions is indicated by a judgment of the form $\proves{M}{A}$. 
We will not define such a judgment, and just rely on its existence (cf. Theorem 3.2).
We define soundness of such a judgment in the usual way:

\begin{definition}[Soundness of \SpecO Provability]
\label{ax:specW-prove-soundness}
A judgment of the form $M \vdash A$ is \emph{sound}, if for all
  all modules $M$ and assertions $A$, \ if $\proves{M}{A}$ then $\satisfies{M}{A}$.
\end{definition}

\subsubsection{Wrapping}

We define a useful shorthand: the $\wrapped{}$ predicate  states 
that only \internalO objects have access to some object.
That object may be either \internalO or \externalO.
\begin{definition}[Wrapped]
$\wrapped{o}\ \triangleq\ \all{x}{\neg \access{x}{o}\ \vee\ \internal{x}}$
\end{definition}
Wrapped is critical as it captures the conditions under \jm[]{an interaction
with the \internalM module is necessary}. 
\jm[]{As an example, consider the Bank Account example from Section \ref{s:outline}: if} only \internalO
objects have access to an account's password, then
it follows that access to the password may not 
be gained except by an interaction with the \internalM
module, and subsequently if the \internalM module
is secure we know that the password cannot be leaked.
\jm[]{This predicate forms a core aspect of Part 2 mentioned in Section \ref{s:outline},
and is elaborated on more in Section \ref{s:classical-proof}.}
 
 

%\begin{figure}[t]
%\begin{mathpar}
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.f : \prg{encap}}
%		\and
%\infer
%		{M;\ M',\ \sigma\ \vdash\ e : \prg{intrnl}}
%		{M;\ M',\ \sigma\ \vdash\ e.g(e') : \prg{encap}}
%\end{mathpar}
%\caption{Encapsulated Expressions}
%\label{f:intrnl}
%\end{figure}
	
%	\begin{figure}[h]
%	\[
%	\begin{array}{llr}
%	A & ::= & \textit{Assertions}\\  
%	| & e & \\
%	| & e\ :\ C & \\
%	| & e\ \in\ S & \\
%	| & A\ \prg{in}\ S & \\
%	| & \access{x}{y} \\
%	| & \internal{x} \\
%	| & \external{x} \\
%%	| & \mut x y f &\\
%%	| & \gives x y z &\\
%	| & \calls{x}{y}{m}{args} \\
%	| & \changes{S}{A} \\
%	| & \neg A & \\
%	| & A\ \wedge\ A & \\
%	| & A\ \vee\ A & \\
%	| & A\ \longrightarrow\ A & \\
%	| & \forall\ x.\ [A] & \\
%	| & \exists\ x.\ [A] & \\
%	| & \forall\ S.\ [A] & \\
%	| & \exists\ S.\ [A] &
%	\end{array}
%%	\begin{array}{llr}
%%	s & ::= & \textit{Source}\\
%%	| & \prg{int} & \\
%%	| & \prg{ext} & \\
%%	| & \_ &
%%	\end{array}
%	\]
%	\caption{Assertions}
%	\label{f:assertions_triple2}
%	\end{figure}





\subsection {\Nec Specifications}
\label{s:holistic-guarantees}

Our \Nec specification language extends \SpecO with novel 
%\emph{Necessity Specifications}.
\sophiaPonder[]{\emph{necessity operators}}.
In this Section we define its syntax (Def. \ref{f:holistic-syntax}) and semantics 
%(Def. \ref{d:necessOpers}) 
(Def. \ref{def:necessity-semantics})
%of
%\emph{\NecessitySpecifications}.
We have the following three operators:

% described below:





\paragraph{Only If}
[$\onlyIf{A_1}{A_2}{A}$]: If an arising program state satisfies $A_1$, and after some execution, a state program state satisfying $A_2$ is reached, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over time, then there must be some external object in the current 
program state that has access to the account's password.

\paragraph{Single-Step Only If}
[$\onlyIfSingle{A_1}{A_2}{A}$]: If an arising program state satisfies $A_1$, and after a single step of execution, a state satisfying $A_2$ is reached, 
then the original program state must have also satisfied $A$.
e.g. if the balance of a bank account changes over a single execution step, then that execution step must be a method call to the bank \prg{transfer} method.

\paragraph{Only Through}
[$\onlyThrough{A_1}{A_2}{A}$]: If an arising program state satisfies $A_1$, and after some execution, a state satisfying $A_2$ is reached, then program execution must have passed through some state satisfying $A$.
e.g. if the balance of an account changes over time, then the bank's \prg{transfer} method must have been called 
in some intermediate state. Note 
that the intermediate state where $A$ is true might be the initial state,
or final state.

%\begin{figure}[t]
\begin{definition}
Assertions ($H$)
% in   \Chainmail \NecessitySpecifications  
are defined as follows:
% \footnotesize

\[
\begin{syntax}
\syntaxElement{H}{}
		{
		\syntaxline
				{A}
				{\onlyIf{A_1}{A_2}{A_3}}
				{\onlyThrough{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
		{
		\syntaxline
				{\onlyIfSingle{A_1}{A_2}{A_3}}
		\endsyntaxline
		}
\endSyntaxElement\\
\end{syntax}
\]
%\caption{Syntax of \Chainmail Necessity Specifications}
\label{f:holistic-syntax}
\end{definition}
%\end{figure}


All three operators talk about assertions satisfied in the 
current state as well as of assertions satisfied in some future state. 
These assertions may contain variables, whose denotation might change during
program execution: the 
map may change, variables may be overwritten, or the entire local variable maps may be lost on a method return.
For this reason, before we provide the semantics of our \Nec specification language, we first introduce an adaptation operator
to account for variable renaming throughout the execution of a program.
\begin{definition}
\label{d:adapt}
$\adapt{\sigma'}{\sigma} \triangleq (\chi, \{\prg{local} := \beta[\overline{z} \mapsto \beta(\overline{z}')], \prg{contn}:= [\overline{z'}/\overline{z}]c\} : \psi)$
where 
\begin{itemize}
\item
$\sigma = (\_, \{\prg{local}:=\beta; \prg{contn}:=\_\} : \_)$, and
$\sigma' = (\chi, \{\prg{local}:=\beta', \prg{contn}:=c\} : \psi)$
\item
$dom(\beta') = \overline{z'}$, $dom(\beta) \cap \overline{z} = \emptyset$, and $|\overline{z'}| = |\overline{z}|$
\end{itemize}
\end{definition}
\jm[]{Def. \ref{d:adapt} allows satisfaction to take variable renaming during evaluation into account. 
As an example, consider the following code snippet.}
\begin{lstlisting}[frame=lines]
x.f := y
x := z
\end{lstlisting}
\jm[]{After the evaluation of line 1 , \texttt{x} has access to \texttt{y}, however when we overwrite \texttt{x} in line 2, 
this is no longer necessarily true, as \texttt{x} might now refer to a different object, even though the object previously referred to 
by \texttt{x} has not changed. A similar issue might occur when either calling a method, or returning from a method, as 
the entire variable map changes under such circumstances. Adaptation (Def. \ref{d:adapt}) provides a convenient way to refer to 
objects across time, while ignoring rewrites and new frames.}


We can now define our semantics,  $M \models H$, 
%the semantics of the Necessity Specifications,
%  in Definition \ref{def:necessity-semantics}.  The definition goes 
by cases over the \sophiaPonder[we were saying three forms]{four}possible syntactic forms of $H$: 


\noindent
\begin{definition}[\Nec Semantics]\susan[Can this be called Semantics or Necessity Specification Language]{}\jm[used to be called ``Necessity Specifications'']{}
\label{def:necessity-semantics}
For any assertions $A$, $A_1$, $A_2$, and $A$,  we define \\


$\bullet$ \ $\satisfies{M}{{A}}$ \ \ \ iff\ \ \ for all $M'$, $\sigma$,\ if $\arising{M}{M'}{\sigma}$, then $\satisfiesA{M}{\sigma}{A}$. (see Def. \ref{def:mdl-sat})\\

%$\bullet$ \ $\satisfies{M}{{A}}$ \ \ \ as defined in \ref{def:mdl-sat} \\

$\bullet$ \ $\satisfies{M}{\onlyIf {A_1}{A_2}{A}}$ \ \ iff\ \  for all $M'$, $\sigma$, $\sigma'$, such that $\arising{M}{M'}{\sigma}$; \\ % and\\

\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\satisfiesA{M}{\sigma}{A}$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 

$\bullet$ \  $\satisfies{M}{\onlyIfSingle {A_1}{A_2}{A}}$\ \ iff\ \   for all $M'$, $\sigma$,   $\sigma'$, such that $\arising{M}{M'}{\sigma}$: \\

\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & \rdelim\}{3}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\satisfiesA{M}{\sigma}{A}$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
$\;\;\;\;$- $\reduction{M}{M'}{\sigma}{\sigma'}$   \\
\end{tabular}\\ 

%% here as it was 
%$\bullet$ \  $\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ \ \ iff\ \  for all $M'$, $\sigma$,   $\sigma'$, such that $\arising{M}{M'}{\sigma}$, and \\
%\begin{tabular}{lr}
%$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A_1}$  & 
%\rdelim\}{3}{3mm}%[\makecell{Some really \\ longer text}]
%[$\;\;\;\Rightarrow\;\;\;$\pbox{9cm}{then for all $\sigma_1, \ldots, \sigma_n$ such that $\reduction{M}{M'}{\sigma}{\sigma_1}\leadsto \ldots \sigma_n \leadsto \sigma'$
%there exists some $\sigma_i$ such that $\satisfiesA{M}{\sigma_i \triangleleft \sigma}{A}$ where $0\leq i \leq n$, or $\satisfiesA{M}{\sigma}{A}$, or $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A}$}] \\
%$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{A_2}$   \\
%$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma'}$   \\
%\end{tabular}\\ 
%$\bullet$ \  $\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ \ \ iff\ \  for all $M'$, $\sigma_1$,   $\sigma_n$, such that $\arising{M}{M'}{\sigma}$: \\
  
$\bullet$ \  $\satisfies{M}{\onlyThrough {A_1}{A_2}{A}}$ \ \ iff\ \  for all $M'$, $\sigma_1$,   $\sigma_n$, such that $\arising{M}{M'}{\sigma_1}$: \\

\begin{tabular}{lr}
$\;\;\;\;$- $\satisfiesA{M}{\sigma_1}{A_1}$  & 
\rdelim\}{3}{3mm}%[\makecell{Some really \\ longer text}]
[$\;\;\;\Rightarrow\;\;\;$\pbox{9cm}{$\forall \sigma_2, \ldots, \sigma_{n-1}$.  \\ 
(\ \ $\forall i\!\in\![1..n).\ \reduction{M}{M'}{\sigma_i}{\sigma_{i+1}}$   \ $\Rightarrow$
$\exists i\!\in\![1..n]. \  \satisfiesA{M}{\sigma_i \triangleleft \sigma_1}{A}$ \ \ )   }] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma_n\triangleleft \sigma}{A_2}$   \\
$\;\;\;\;$- $\reductions{M}{M'}{\sigma}{\sigma_n}$   \\
\end{tabular} 
\end{definition} 



 
%With our language as defined in Definition \ref{def:necessity-semantics},
We are now able to state what the necessary preconditions to critical functions in 
software are, including safety properties of software in the open world. The semantics
of \emph{Single-Step Only If} allow for the statement of such necessary preconditions
for any execution step for any program to achieve a certain outcome. The semantics
of \emph{Only If} and \emph{Only Through} allow us to raise these necessary preconditions
to any arbitrary number of execution steps, and thus allow for reasoning about 
the execution of an entire program.
 
Looking back at the example from the Introduction,   it holds that
\\
\strut $\hspace{1in}$ \prg{Mod1} $\models$ \prg{NecessityBankSpec}
 \\
\strut $\hspace{1in}$ \prg{Mod2} $\not\models$ \prg{NecessityBankSpec}
 \\
\strut $\hspace{1in}$ \prg{Mod3} $\models$ \prg{NecessityBankSpec}
 

 
For more specification examples, consider the
bank account discussed in Section \ref{s:intro}. We have already shown
how we can specify knowledge of an account's password using \prg{NecessityBankSpec},
but we are also able to write other useful properties about the bank account. 
 
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
NecessityBankSpec'  $\triangleq$  from a:Account $\wedge$ a.balance==bal
                       nxt a.balance < bal
                       onlyIf $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\calls{\prg{o}}{\prg{a}}{\prg{transfer}}{\prg{\_, \_, \_}}$]
\end{lstlisting}
 
\prg{NecessityBankSpec$^\prime$} states that if over a single step the balance of an account decreases, then it must have occurred as 
a result of a call to \prg{transfer}.
 
\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
NecessityBankSpec''  $\triangleq$  from a:Account $\wedge$ a.password == pwd
                        to a.password != pwd
                        onlyThrough $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\calls{\prg{o}}{\prg{a}}{\prg{set}}{\prg{pwd, \_}}$]
\end{lstlisting}
 
\prg{NecessityBankSpec$^{\prime\prime}$} states that if over an arbitrary number of execution steps, the password of an account changes,
then it follows that there must have been some intervening execution step that was a call to \prg{set} on the account 
with the correct password. Both of these specifications are important, and are both used as intermediate steps
when we present the full proof of \prg{NecessityBankSpec} later in Section \ref{s:examples}.
\Nec thus provides us with a rich language for talking about the necessary conditions
under which critical actions within of our software are allowed to occur. 
%\jm[]{It is worth discussing the semantics of \Nec specifications and their 
%relation to typical logical consequence and Hoare logic. A classical Hoare triple, 
%$\hoare{P}{C}{Q}$, denotes that any program state that satisfies $P$, after execution 
%of program $C$, will result in a program state that satisfies $Q$. Thus, $P$ represents 
%a subset of program states that after execution of $C$ results in a program state satisfying $Q$.
%Conversely, $Q$ represents a superset of program states resulting from the execution of $C$ in 
%a program state satisfying $P$. Thus, we can soundly strengthen the left hand side ($P$), and weaken
%the right hand side ($Q$). This intuition extends to all three specifications. 
%For example, from \prg{NecessityBankSpec'}, while it is somewhat contrived, we are able to
%strengthen the ``left hand side'' by adding information, and weaken the ``right hand side'', 
%and conclude that}
%\begin{lstlisting}[language = Chainmail, mathescape=true, frame=lines]
%NecessityBankSpec'''  $\triangleq$  from a:Account $\wedge$ a.balance == bal $\wedge$ bal == x + y $\wedge$ y > 0
%                       nxt a.balance == x
%                       onlyIf $\exists$ o.[$\external{\texttt{o}}$ $\wedge$ $\access{\prg{o}}{\prg{a}}$]
%\end{lstlisting}
%\jm[]{This follows because in the above specification, (a)\prg{x < bal}, and thus \prg{a.balance = x} implies and $a.balance < bal$,
%and (b) if an object calls a method on another object, it follows that it has access to that object.
%More generally, given a Single-Step Only-If specification, 
%$\onlyIfSingle{A_1}{A_2}{A}$, $A_1$ and $A_2$ represent a subset of single step execution paths starting from a program state 
%satisfying $A_1$ and reaching a program state satisfying $A_2$, that have $A$ as a necessary precondition. 
%In the same way the converse is true, i.e. $A$ represents a superset of initial program states
%for execution starting at a state satisfying $A_1$ and reaching a state satisfying $A_2$ after a single step of execution.
%As with Hoare logic, we are able to soundly strengthen the left hand side ($A_1$ and $A_2$)
%and strengthen the right hand side ($A$). This intuition also extends to Only-If and Only-Through specifications. 
%In some places later in this paper, we use the distinction ``\emph{left hand side}'' of a \Nec specification
%to denote the two left most assertions in the specification, and ``\emph{right hand side}'' to denote
%the necessity precondition.}
 




\subsection{Assertion Encapsulation}
\jm[lemmas? does A => enc(A') imply A => enc($\neg$A')?]{}
 %In order to reason about necessary requirements in an open world,
% and those assertions that may change due 
% to computation by external, unknown code.
In Section \ref{s:outline} we used the concept of encapsulation of \SpecO assertions 
 when proving adherence to \Nec specifications.
An assertion $A$ is encapsulated by a module $M$ if it cannot be invalidated unless an
internal method is called. 
Here we refine this concept, to allow for ``conditional'' encapsulation:
$M\ \vDash A\ \Rightarrow\ \encaps{A'}$ expresses that in states which satisfy $A$, the assertion 
$A'$ cannot be invalidated, unless a method from $M$ was called.

\begin{definition}[Assertion Encapsulation]
\label{def:encapsulation}
For % an internal module. -- SDL internal is nit an inherrent property
a module $M$ and assertion $A$, we define an assertion $A'$ as being 
encapsulated, written\ \  $M\ \vDash A\ \Rightarrow\ \encaps{A'}$, \ \ if and only if
%$M\ \vDash\ \onlyIfSingle{A}{\neg A}{\calls{x}{y}{m}{\overline{z}}\ \wedge\ \external{x}\ \wedge\ \internal{y}}$
for all external modules $M'$, and program states $\sigma$ and $\sigma'$
such that $\arising{M}{M'}{\sigma}$:

\begin{tabular}{lr}
$\;\;\;\;$- $\reduction{M}{M'}{\sigma}{\sigma'}$  & \rdelim\}{4}{3mm}[$\;\;\;\Rightarrow\;\;\;$  $\exists x,\ \overline{z}. (\satisfiesA{M}{\sigma}{\calls{\_}{x}{m}{\overline{\sd{z}}}\ \wedge\ \internal{x}})$] \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A}$   \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma}{A'}$   \\
$\;\;\;\;$- $\satisfiesA{M}{\sigma' \triangleleft \sigma}{\neg A'}$   \\
\end{tabular}
\end{definition}
