\section{Outline of our approach -- should go somewhere}

\subsection{Internal and External Calls} 
Our work concentrates on guarantees applicable in the \emph{open} setting; that is, a certain module
$M$ is programmed in such a robust manner\footnote{SD: We had agreed no to say "robust", but I think it is OK here. Alternatively, say defensively robust?} that execution of $M$ together with \emph{any} \externalM 
module $M'$ will uphold these guarantees. In the tradition of
visible states semantics, we are  only interested in upholding the guarantees while 
$M'$, the  \externalM module,  is executing.   
 We therefore distinguish between \emph{\internalO} and
\emph{\externalO} objects: those that belong to classes defined in $M$, and the rest. Similarly, we 
distinguish between \emph{\internalC} calls, i.e. calls made % from \externalO objects
 to \internalO objects, and \emph{\externalC} calls, i.e. calls made % from \externalC objects
 to \externalC objects. % We are less
% interested in calls made from \internalO objects to \internalO objects, because we only need 
% establish the guarantees when the \externalM module is executing. And we 
Note that we do not -- yet -- support calls from
\internalO objects to \externalO objects.\footnote{SOPHIA: we need to think where our system forbids that, ... ?}

\footnote{???? Add a paragraph to make the above now a bit more formal? Say something about arising and something about two state execution??? ???}

\subsection{How we reason}

\footnote{Shall we skip this paragraph?} Our Logic of Necessity is based on the following ingredients: 
\textbf{a:} A  % concept of a encapsulation, 
way to  establish that a certain effect is \emph{encapsulated}, in the 
sense that it can only take place if an \internalC call was made; 
\textbf{b:} A way to obtain necessary conditions given an effect and \emph{one}
 specific \internalC call;
\textbf{c:} A way to obtain necessary conditions given a certain encapsulated effect and \emph{any},
\emph{single} \internalC call;
\textbf{d:} A way to combine one-call   necessary conditions  so as to obtain necessary conditions 
for effects over 
\emph{any number} of \internalC or \externalC calls.

As an example, we   outline the proof that version III of \prg{Account} adheres to $(AccntHolisticSpec)$.

\begin{description}
\item[1st Step, a:] We establish that the balance % is \emph{encapsulated} by 
% the class \prg{Account}, in the sense that
% its value may change 
% may change only   by making \prg{Account}-\internalC calls.  
is encapsulated by \prg{Account}. 


\item[2nd Step, b:] 
For each method of the class  \prg{Account}  we establish that   
the balance does not reduce, unless the caller had access 
to the password.

\item[3rd Step, c:]  
Therefore, if the balance were to reduce in \emph{one} call, then some
external object would have to have had access to the password before the call.

\item[4th Step, b and c:] We establish % in the class \prg{Account} in Version\_III 
that   an external object has access to 
the password after \emph{one} internal call, only if it already had access before that call.
After that, we establish  that if an external object had access to 
the password after \emph{any number} of external or internal 
calls, only if it already had access before that call.

\item[5th Step, d:] We   combine the findings from the Third and Fourth Step, and obtain
that  Version\_III adheres to $(AccntHolisticSpec)$

\end{description} 
 
We  now outline  the new formal concepts needed to accomplish the five steps from above:

\begin{description}
\item[a] We introduce the concept of \emph{assertion-encapsulation}: An assertion $A$  is
encapsulated by  module $M$, if it can be invalidated only through
    an $M$-\internalC call. 
  In short, an $M$-\internalC call is a \emph{necessary} condition for
a given effect to take place.
\footnote{Notice that for the sake of simplicity, our example consists of a module with one class only, but 
    in general our approach accommodates modules with any number of classes.
     Notice also, that while in this example, the balance is 
represented by a field, our approach also works when the balance is a ghost method, defined 
recursively over several objects of different classes.}
\footnote{Say this, or  leave for later? For this work, we establish assertion-encapsulation just by considering the 
footprint of the assertion, and requiring that it only includes internal objects --
more advanced approaches are possible, and will be considered in further work.}


\item[b]  
 As we will see in Section \ref{s:classical-proof}, 
 % we do this 
if the negation of a method's
 classical postcondition infers  the effect we are interested in, then the negation of the 
 classical precondition  is the necessary precondition for the effect. Thus, 
we use a method's sufficient conditions to infer a method's and effect's necessary conditions.
\footnote{Should we say :
  The "basic" rules of our Logic of Necessity allow us to infer such necessary conditions out of classical Hoare triples. }
\footnote{Should we say: As for the first step, more powerful solutions are possible, which we will consider  in further work. }

\item[c]  Here we go from a set
of per-effect-and-method necessary  condition to a per-module assertion, as long as it is due to 
\emph{one} \internalC call.

The second tier of our Logic of Necessity allows us to generalize  such one-call per-method necessary conditions, to   method-agnostic, one-call necessary conditions.

\item[d] 
We now need to consider the \emph{emergent} behaviour of the module.  This step is crucial; namely, remember that while Version\_II adheres to
the guarantee from the \textbf{3rd Step}, it does not adhere to  $(AccntHolisticSpec)$.   
Our Logic of Necessity allows us to combine  several such one-call method-agnostic necessary conditions, and obtain a several-call   necessary condition.
\footnote{Should we say :The third tier of our Logic of Necessity allows us to generalize  such one-call method-agnostic necessary conditions, to a several-call \internalC/\externalC necessary conditions.}

\end{description} 
