\renewcommand{\sophia}[2][]{\ponders{Sophia}{blue}{#1} \textcolor{blue}{#2}\xspace}

\section{Outline of our approach}
\label{s:approach}

\subsection{Internal and External Modules, Objects, and Calls} 
Our work concentrates on guarantees made for the \emph{open} setting; that is, a certain module
$M$ is programmed in such a robust manner
%\sophia[We had agreed no to say "robust", but I think it is OK here. Alternatively, say defensively robust?]{}
 that execution of $M$ together with \emph{any} \externalM 
module $M'$ will uphold these guarantees. In the tradition of
visible states semantics, we are  only interested in upholding the guarantees while 
$M'$, the  \externalM module,  is executing.   
 We therefore distinguish between \emph{\internalO} and
\emph{\externalO} objects: those that belong to classes defined in $M$, and the rest. Similarly, we 
distinguish between \emph{\internalC} calls, i.e. calls made % from \externalO objects
 to \internalO objects, and \emph{\externalC} calls, i.e. calls made % from \externalC objects
 to \externalC objects. % We are less
% interested in calls made from \internalO objects to \internalO objects, because we only need 
% establish the guarantees when the \externalM module is executing. And we 


Moreover, because we only require that the guarantees are upheld while 
  the  \externalM module  is executing, we develop an \emph{external state} semantics, \sophia{I like the term} where
 any internal calls are executed in one, large, step.
 Note that we do not -- yet -- support calls from
\internalO objects to \externalO objects.\sophia[we need to think where our system forbids that, ... ?]{} 
 With the external steps semantics,  the executing object (the \prg{this}) is always   external. 
 
\subsection{Reasoning about Necessity}

%\footnote{Shall we skip this paragraph?} Our Logic of Necessity is based on the following ingredients: 
%\textbf{a:} A  % concept of a encapsulation, 
%way to  establish that a certain effect is \emph{encapsulated}, in the 
%sense that it can only take place if an \internalC call was made; 
%\textbf{b:} A way to obtain necessary conditions given an effect and \emph{one}
% specific \internalC call;
%\textbf{c:} A way to obtain necessary conditions given a certain encapsulated effect and \emph{any},
%\emph{single} \internalC call;
%\textbf{d:} A way to combine one-call   necessary conditions  so as to obtain necessary conditions 
%for effects over 
%\emph{any number} of \internalC or \externalC calls.

We  now outline the proof that of \prg{Account3} adheres to $(NecessitySpec)$,
and  will then use that outline to 
 introduce the main ingredients of our Necessity Logic. The proof consists,
broadly, of the following parts:

\begin{description}
\item[P1:] We establish that the balance 
 may change only   through \prg{Account}-\internalC calls.  

\item[P2:] 
For each method of the class  \prg{Account},  we establish that   
if the method were called and  caused the  balance to reduce, then, before the call,
the caller had access  to the password.

\item[P3:]  
From \textbf{P1} and \textbf{P2}, we obtain that if the balance were to 
reduce in \emph{any}  \emph{single} call, then some
external object would have to have had access to the password before the call.

\item[P4:] We establish % in the class \prg{Account} in Version\_III 
that   an external object has access to 
the password after \emph{one} internal call, only if it already had access before that call.
From that, we establish  that  an external object will have access to 
the password after \emph{any number} of external or internal 
steps, only if it already had access before these steps.

\item[P5:] Combining  the results from \textbf{P3} and \textbf{P4}, we obtain
that  Version\_III satisfies $(NecessitySpec)$

\end{description} 
 
We  now outline  the new formal concepts needed to accomplish the five parts of the proof from above:

\begin{description}
% \item[assertion encapsulation] % We introduce the concept of \emph{assertion-encapsulation}: 
  \item[from effect to module]  An assertion $A$  is
\emph{encapsulated} by a module $M$, if  $A$ can be invalidated only through
    an $M$-\internalC call. 
  In short, an $M$-\internalC call is a \emph{necessary} condition for
a given effect to take place.
\footnote{Notice that for the sake of simplicity, our example consists of a module with one class only, but 
    in general our approach accommodates modules with any number of classes.
     Notice also, that while in this example  the balance is 
represented by a field, our approach also works when the balance is a ghost method, defined 
recursively over several objects of different classes.}

In \textbf{P1}, the assertion \prg{a:Account\! $\wedge$\! a.balance=val} is encapsulated by \prg{Account}.

We assume that there exists some algorithm to judge assertion encapsulation.
The construction of such an algorithm is not the focus of our work;
  we  outline a rudimentary such algorithm, but more powerful
approaches are possible. 
 

\item[from effect and call to necessary condition] We want to infer
a necessary condition given an effect and
a single, specified, method call. 

In \textbf{P2},   a necessary condition for the  reduction of \prg{a.balance}  after the call \prg{a.transfer(a',pwd)} is that the caller had access to \prg{a.password} before the call.

We addressed the challenge of the inference of necessary conditions 
 by leveraging the sufficient conditions from classical specifications:
 \sophia[
  Here we should 
  pat ourselves on the back.  
  James, need your  magic here.]{} 
 As we will see in Section \ref{s:classical-proof}, 
if the negation of a method's
 classical postcondition implies  the effect we are interested in, then the negation of the 
 classical precondition  is the necessary precondition for the effect and the method call. Thus, 
  a method's sufficient conditions are used to infer a method's and effect's necessary conditions.


\item[from effect and single step to necessary condition]  We want to infer
a necessary condition given an effect and
a single, unspecified step. This step could be a internal, or an external method call,
or any other external step, such as field assignment, or conditional, etc.

In \textbf{P3},   a necessary condition for the  reduction of \prg{a.balance}  after \emph{any}
step, is that the caller  had access to \prg{a.password} before the call.
And similarly in \textbf{P4},   a necessary condition for an external object's
access to \prg{a.password}  after \emph{any}
step, is that that object had access to \prg{a.password} before the call.

For effects that are encapsulated in a module $M$, we can infer such one-step
necessary conditions by combining the necessary conditions for that effect and 
all   methods in $M$.



\item[from effect to necessary conditions] 
We now need to consider the \emph{emergent} behaviour of the internal module
combined with any internal module. This step is crucial; namely, remember that while Version\_II adheres to
the guarantee from the \textbf{P3}, it does not adhere to  $(NecessitySpec)$.   
Our Logic of Necessity allows us to combine  several such one-step necessary conditions, and obtain a several-step necessary condition.
 
\end{description} 
