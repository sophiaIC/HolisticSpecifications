\section{Outline of our approach -- should go somewhere}

\subsection{Internal and External Calls} 
Our work concentrates on guarantees applicable in the \emph{open} setting; that is, a certain module
$M$ is programmed in such a robust manner\footnote{SD: We had agreed no to say "robust", but I think it is OK here. Alternatively, say defensively reobust?} that execution of $M$ together with \emph{any} \externalM 
module $M'$ will make these guarantees. In the tradition of
visible states semantics, we are  only interested in upholding the guarantees while the 
\externalM module, $M'$, is executing.   
% We call $M$ the \internalM module, and $M'$ the \externalM module.\footnote{drop that sentence as it follows from what is coming?}
 We therefore distinguish between \emph{\internalO} and
\emph{\externalO} objects: those that belong to classes defined in $M$, and the rest. Similarly, we 
distinguish between \emph{\internalC} calls, i.e. calls made from \externalO objects to \internalO objects,
and \emph{\externalC} calls, i.e. calls made from \externalC objects to \externalC objects. We are less
interested in calls made from \internalO objects to \internalO objects, because we only need 
establish the guarantees when the \externalM module is executing. And we do not -- yet -- support calls from
\internalO objects to \externalO objects.\footnote{SOPHIA: we need to think where our system forbids that, ... ?}

\footnote{???? Add a paragraph to make the above now a bit more formal? Say something about arising and something about two state execution??? ???}

\subsection{How we reason}

Our Logic of Necessity is based on the following ingredients: 
a) A  % concept of a encapsulation, 
way to  establish that a certain effect is \emph{encapsulated}, in the 
sense that can only take place if an \internalC call was made; 
b) A way to obtain necessary conditions given an effect and \emph{one}
 certain \internalC;
c) A way to obtain necessary conditions given a certain encapsulated effect and \emph{any},
\emph{single} \internalC call;
d) A way to combine one-call   necessary conditions  so as to obtain necessary conditions 
for effects over 
\emph{any number} of \internalC or \externalC calls.

As an example, we   outline the proof that version III of \prg{Account} adheres to $(AccntHolisticSpec)$.

\begin{description}
\item[First Step] We establish that the balance % is \emph{encapsulated} by 
% the class \prg{Account}, in the sense that
% its value may change 
may change only   by making \prg{Account}-\internalC calls.  


\item[Second Step] 
We establish that in each method of the class  \prg{Account}
the balance does not reduce, unless the caller had access 
to the password.

\item[Third Step]  
Therefore, if the balance were to reduce in \emph{one} call, then some
external object would have to have had access to the password before the call.

\item[Fourth Step] We establish in the class \prg{Account} in Version\_III 
that   an external object has access to 
the password after \emph{one} internal call, only if it already had access before that call.

\item[Fifth Step] We establish  that if an external object had access to 
the password after \emph{any number} of external or internal 
calls, only if it already had access before that call.

\item[Fifth Step] We   combine the findings from the Third and Fourth Step, and obtain
that  Version\_III adheres to $(AccntHolisticSpec)$

\end{description} 
 
We will now outline 
the new concepts needed to accomplish the five steps from above:

\begin{description}
\item[First Step] We introduce  \emph{assertion-encapsulation}: An assertion $A$  is
encapsulated by a module $M$, it 
  its invalidation can only be caused   by a call to some method from module $M$. 
  In short, call to some method from $M$ is a \emph{necessary} condition for
a given effect to take place.
\footnote{Notice that for the sake of simplicity, our example consists of a module with one class only, but 
    in general our approach accommodates modules with any number of classes.
     Notice also, that while in this example, the balance is 
represented by a field, our approach also works when the balance is a ghost method, defined 
recursively over several objects of different classes.}

For this work, we establish assertion-encapsulation just by considering the 
footprint of the assertion, and requiring that it only includes internal objects --
more advanced approaches are possible, and will be considered in further work.


\item[Second Step]  
Here we infer  conditions for given an effect (here reduction of balance), and call to a specific method
(here \prg{transfer}). As we will see in Section ???, we do this by considering the negation of a method's
classical postconditions. Thus, we use a method's sufficient conditions to infer a method's and effect's necessary conditions.

The "basic" rules of our Logic of Necessity allow us to infer such necessary conditions out of classical Hoare triples.
As for the first step, more powerful solutions are possible, which we will consider  in further work. 

\item[Third Step]  Here we go from a set
of per-effect-and-method necessary  condition to a per-module assertion, as long as it is due to 
\emph{one} \internalC call.

The second tier of our Logic of Necessity allows us to generalize  such one-call per-method necessary conditions, to a method-agnostic, one-call necessary conditions.

\item[Fourth Step] Similar methodology as in the Third Step.



\item[Fifth Step] 
We now need to consider the \emph{emergent} behaviour of the module.  This step is crucial; namely, remember that while Version\_II adheres to
the guarantee from the Third step, it does not adhere to  $(AccntHolisticSpec)$.   

The third tier of our Logic of Necessity allows us to generalize  such one-call method-agnostic necessary conditions, to a several-call \internalC/\externalC necessary conditions.

\end{description} 
