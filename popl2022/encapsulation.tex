

%\subsection{Proving Encapsulation}
\label{s:encap-proof}

%We start by giving providing the syntax for type contexts in Fig. \ref{f:context-syntax}.
%\begin{figure}[t]
%\[
%\begin{syntax}
%\syntaxElement{\Gamma}{Type Context}
%		{
%		\syntaxline
%				{\emptyset}
%				{\alpha : C,\ \Gamma}
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\end{syntax}
%\]
%\caption{}
%\label{f:context-syntax}
%\end{figure}
%We construct type contexts out of assertions using the following rules:
%\begin{mathpar}
%\infer
%		{}
%		{\textit{Env}(\alpha : C) = \alpha : C,\ \emptyset}
%		\and
%\infer
%		{}
%		{\textit{Env}(A_1\ \wedge\ A_2) = \textit{Env}(A_1) \cup \textit{Env}(A_2)}
%\end{mathpar}
%\begin{definition}[Assertion Encapsulation]
%For all modules $M$, and assertions $A$, and $A'$ we say $M\ \vdash\ A\ \Rightarrow\ A'$ if and only if M
%\end{definition}
We provide a simple \jm[]{proof} system for assertion encapsulation (Definition \ref{def:encapsulation}),
that is proving a change in satisfaction of an assertion depends on
computation from the internal module.
\kjx{We mostly follow \citeasnoun{confined} and defer to their proof.}


\jm[]{To assist in the definition of our simple encapsulation system, we define internally evaluated expressions ($\intrnl{\_}$);
i.e. expressions whose evaluation only inspects internal objects or primitves (i.e. integers or booleans).}
\jm[]{\begin{definition}[Internally Evaluated Expressions]
For all modules $M$, assertions $A$, and expressions $e$, 
$\satisfies{M}{\givenA{A}{\intrnl{e}}}$ if and only if for all states $\sigma$
such that $\satisfiesA{M}{\sigma}{A}$, we have for all variables $x$, and heap locations $\alpha$
\begin{description}
\item[(a)]$x\ \in\ e$ implies $\class{\sigma}{x} \in M$, and
\item[(b)]$\alpha\ \in\ e$ implies $\class{\sigma}{\alpha} \in M$
\end{description}
\end{definition}}


The encapsulation proof system consists of two relations 
\begin{itemize}
\item
Purely internal expressions: $\proves{M}{\givenA{A}{\intrnl{e}}}$ and
\item
Assertion encapsulation: $\proves{M}{\givenA{A}{\encaps{A'}}}$
\end{itemize}

Fig. \ref{f:intrnl} gives proof rules for an expression comprising purely internal objects.
\jm[]{Primitives are $Enc_e$ (\textsc{Enc$_e$-Int}, \textsc{Enc$_e$-Null}, \textsc{Enc$_e$-True}, and \textsc{Enc$_e$-False}).
Addresses of internal objects are $Enc_e$ (\textsc{Enc$_e$-Obj}). Field accesses with internal types of $Enc_e$ expressions
are themselves $Enc_e$ (\textsc{Enc$_e$-Field}). Ghost field accesses annotated as $Enc_e$ on $Enc_e$ 
expressions are themselves $Enc_e$ (\textsc{Enc$_e$-Ghost}).}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{i}}}}
		\quad(\textsc{Enc$_e$-Int})
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\nul}}}}
		\quad(\textsc{Enc$_e$-Null})
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\true}}}}
		\quad(\textsc{Enc$_e$-True})
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\false}}}}
		\quad(\textsc{Enc$_e$-False})
		\and
\infer
		{
		\proves{M}{A\ \longrightarrow\ \alpha : C}\\
		C\ \in\ M
		}
		{
		\proves{M}{\givenA{A}{\intrnl{\alpha}}}
		}
		\quad(\textsc{Enc$_e$-Obj})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\intrnl{e}}}\\
		\proves{M}{A\ \longrightarrow\ e : C}\\
		[\prg{field}\ \_\ f\ :\ D]\ \in\ M(C).(\prg{flds}) \\
		D\ \in\ M
		}
		{
		\proves{M}{\givenA{A}{\intrnl{e.f}}}
		}
		\quad(\textsc{Enc$_e$-Field})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\intrnl{e_1}}}\\
		\proves{M}{\givenA{A}{\intrnl{e_2}}}\\
%		\proves{M}{\givenA{A}{\intrnl{e}}} \\
		\proves{M}{A\ \longrightarrow\ e_1 : C} \\
		\prg{ghost}\ \prg{intrnl}\ g(x : \_)\{e\} \in M(C).(\prg{gflds})
		}
		{
		\proves{M}{\givenA{A}{\intrnl{e_1.g(e_2)}}}
		}
		\quad(\textsc{Enc$_e$-Ghost})
\end{mathpar}
\caption{Internal Proof Rules}
\label{f:intrnl}
\end{figure}

\jm[]{Fig. \ref{f:asrt-encap} gives proof rules for whether an assertion is encapsulated, that is whether 
a change in satisfaction of an assertion requires interaction with the internal module.
An \prg{Intrl} expression is also an encapsulated assertion (\textsc{Enc-Exp}). A field
access on an encapsulated expression is an encapsulated expression. Binary and ternary operators
applied to encapsulated expressions are themselves encapsulated assertions (\textsc{Enc-=}, \textsc{Enc-+}, \textsc{Enc-<}, \textsc{Enc-If}).
An internal object may only lose access to another object via internal computation (\textsc{Enc-IntAccess}).
Only internal computation may grant external access to an $\wrapped{\_}$ object (\textsc{Enc-Inside}$_1$).
If an object is $\wrapped{\_}$, then nothing (not even internal objects) may gain access
to that object except by internal computation (\textsc{Enc-Inside}$_2$).
If an assertion $A_1$ implies assertion $A_2$, then $A_1$ implies the encapsulation of any assertion that
$A_2$ does. Further, if an assertion is encapsulated, then any assertion that is implied by it is also encapsulated.
These two rules combine into the encasulation rule for consequence (\textsc{Enc-Conseq}).}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
		{\proves{M}{\givenA{A}{\intrnl{e}}}}
		{\proves{M}{\givenA{A}{\encaps{e}}}}
		\quad(\textsc{Enc-Exp})
		\and
\infer
		{\proves{M}{\givenA{A}{\intrnl{e}}}}
		{\proves{M}{\givenA{A}{\encaps{e.f}}}}
		\quad(\textsc{Enc-Field})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 = e_2}}}
		}
		\quad(\textsc{Enc-=})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 + e_2}}}
		}
		\quad(\textsc{Enc-+})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 < e_2}}}
		}
		\quad(\textsc{Enc-<})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e}}} \\
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{\prg{if}\ e\ \prg{then}\ e_1\ \prg{else}\ e_2}}}
		}
		\quad(\textsc{Enc-If})
		\and
\infer
		{\proves{M}{A\ \longrightarrow\ \internal{x}}}
		{\proves{M}{\givenA{A}{\encaps{\access{x}{y}}}}}
		\quad(\textsc{Enc-IntAccess})
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\encaps{\wrapped{x}}}}}
		\quad(\textsc{Enc-Inside}_1)
		\and
\infer
		{\proves{M}{A\ \longrightarrow\ \wrapped{x}}}
		{\proves{M}{\givenA{A}{\encaps{\neg \access{x}{y}}}}}
		\quad(\textsc{Enc-Inside}_2)
		\and
\infer
		{
		\proves{M}{A_1\ \longrightarrow\ A_2} \\
		\proves{M}{A\ \longrightarrow\ A'} \\
		\proves{M}{\givenA{A_2}{\encaps{A}}}
		}
		{\proves{M}{\givenA{A_1}{\encaps{A'}}}}
		\quad(\textsc{Enc-Conseq})
\end{mathpar}
\caption{Assertion Encapsulation Proof Rules}
\label{f:asrt-encap}
\end{figure}
