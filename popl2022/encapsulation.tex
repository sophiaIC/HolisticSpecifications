

\subsection{Proving Encapsulation}
\label{s:encap-proof}

%We start by giving providing the syntax for type contexts in Fig. \ref{f:context-syntax}.
%\begin{figure}[t]
%\[
%\begin{syntax}
%\syntaxElement{\Gamma}{Type Context}
%		{
%		\syntaxline
%				{\emptyset}
%				{\alpha : C,\ \Gamma}
%		\endsyntaxline
%		}
%\endSyntaxElement\\
%\end{syntax}
%\]
%\caption{}
%\label{f:context-syntax}
%\end{figure}
%We construct type contexts out of assertions using the following rules:
%\begin{mathpar}
%\infer
%		{}
%		{\textit{Env}(\alpha : C) = \alpha : C,\ \emptyset}
%		\and
%\infer
%		{}
%		{\textit{Env}(A_1\ \wedge\ A_2) = \textit{Env}(A_1) \cup \textit{Env}(A_2)}
%\end{mathpar}
%\begin{definition}[Assertion Encapsulation]
%For all modules $M$, and assertions $A$, and $A'$ we say $M\ \vdash\ A\ \Rightarrow\ A'$ if and only if M
%\end{definition}
We provide a simple inference system for assertion encapsulation (Definition \ref{def:encapsulation}),
that is proving a change in satisfaction of an assertion depends on computation from the internal module. 
As encapsulation is not the core topic of this paper, we keep this relatively simple. As discussed before, 
we assume the existence of a simple ownership type system to ensure certain forms of encapsulation.

To assist in the definition of a proof system to proof assertion encapsulation,
we define proof rules for expressions that depend entirely on internal objects (or primitves)
for their evaluation.
\begin{definition}[Internal Expressions]
For all modules $M$, assertions $A$, and expressions $e$, 
$\satisfies{M}{\givenA{A}{\intrnl{e}}}$ if and only if for all external modules 
$M'$, heaps $\chi$, frame stacks $\psi$, and values $v$,
such that $\satisfiesA{M}{M'}{(\chi, \psi)}{A}$ and
$\eval{M \circ M'}{(\chi, \psi)}{e}{v}$
then 
$\eval{M \circ M'}{(\chi', \psi)}{e}{v}$, 
where $\chi'$ is the portion of $\chi$ internal to $M$, i.e. 
$\chi' = \{[\alpha \mapsto o]| [\alpha \mapsto o] \in \chi\ \textit{and}\ o.(\prg{class}) \in M \}$
\end{definition}


The encapsulation proof system thus consists of two relations 
\begin{itemize}
\item
Purely internal expressions: $\proves{M}{\givenA{A}{\intrnl{e}}}$ and
\item
Assertion encapsulation: $\proves{M}{\givenA{A}{\encaps{A'}}}$
\end{itemize}

Fig. \ref{f:intrnl} gives proof rules for evaluation of an expression comprising of purely module internal objects.
Fig. \ref{f:asrt-encap} gives proof rules for whether an assertion is encapsulated, that is whether 
a change in satisfaction of an assertion requires interaction with the internal module.

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{i}}}}
		\quad(\textsc{Intrnl-Int})
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\nul}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\true}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\intrnl{\false}}}}
		\and
\infer
		{
		\proves{M}{A\ \longrightarrow\ \alpha : C}\\
		C\ \in\ M
		}
		{
		\proves{M}{\givenA{A}{\intrnl{\alpha}}}
		}
		\quad(\textsc{Intrnl-Obj})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\intrnl{e}}}\\
		\proves{M}{A\ \longrightarrow\ e : C}\\
		[\prg{field}\ \_\ f\ :\ D]\ \in\ M(C).(\prg{flds}) \\
		D\ \in\ M
		}
		{
		\proves{M}{\givenA{A}{\intrnl{e.f}}}
		}
		\quad(\textsc{Intrnl-Field})
		\and
\infer
		{
		\proves{M}{\givenA{A}{\intrnl{e_1}}}\\
		\proves{M}{\givenA{A}{\intrnl{e_2}}}\\
%		\proves{M}{\givenA{A}{\intrnl{e}}} \\
		\proves{M}{A\ \longrightarrow\ e_1 : C} \\
		\prg{ghost}\ \prg{intrnl}\ g(x : \_)\{e\} \in M(C).(\prg{gflds})
		}
		{
		\proves{M}{\givenA{A}{\intrnl{e_1.g(e_2)}}}
		}
		\quad(\textsc{Intrnl-Ghost})
\end{mathpar}
\caption{Internal Proof Rules}
\label{f:intrnl}
\end{figure}

\begin{figure}[t]
\footnotesize
\begin{mathpar}
\infer
		{\proves{M}{\givenA{A}{\intrnl{e}}}}
		{\proves{M}{\givenA{A}{\encaps{e}}}}
		\quad(\textsc{Enc-Intrnl})
		\and
\infer
		{\proves{M}{\givenA{A}{\intrnl{e}}}}
		{\proves{M}{\givenA{A}{\encaps{e.f}}}}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 = e_2}}}
		}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 + e_2}}}
		}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{e_1 < e_2}}}
		}
		\and
\infer
		{
		\proves{M}{\givenA{A}{\encaps{e}}} \\
		\proves{M}{\givenA{A}{\encaps{e_1}}} \\
		\proves{M}{\givenA{A}{\encaps{e_2}}}
		}
		{
		\proves{M}{\givenA{A}{\encaps{\prg{if}\ e\ \prg{then}\ e_1\ \prg{else}\ e_2}}}
		}
		\and
\infer
		{\proves{M}{A\ \longrightarrow\ \internal{\alpha_1}}}
		{\proves{M}{\givenA{A}{\encaps{\access{\alpha_1}{\alpha_2}}}}}
		\and
\infer
		{}
		{\proves{M}{\givenA{A}{\encaps{\wrapped{\alpha}}}}}
		\quad(\textsc{Enc-Wrapped})
		\and
\infer
		{\proves{M}{A\ \longrightarrow\ \wrapped{\alpha_2}}}
		{\proves{M}{\givenA{A}{\encaps{\neg \access{\alpha_1}{\alpha_2}}}}}
		\and
\infer
		{
		\proves{M}{A_1\ \longrightarrow\ A_2} \\
		\proves{M}{A\ \longrightarrow\ A_1} \\
		\proves{M}{\givenA{A}{\encaps{A_1}}}
		}
		{\proves{M}{\givenA{A}{\encaps{A_2}}}}
\end{mathpar}
\caption{Assertion Encapsulation Proof Rules}
\label{f:asrt-encap}
\end{figure}

\begin{lemma}[Intrnl is Encapsulated]
For all modules $M$, assertions $A$, and expressions $e$, 
if $\proves{M}{\givenA{A}{\intrnl{e}}}$, 
then $\satisfies{M}{\givenA{A}{\encaps{e}}}$
\end{lemma}

\begin{lemma}[Encapsulation Soundness]
For all modules $M$, and assertions $A$ and $A'$, 
if $\proves{M}{\givenA{A}{\encaps{A'}}}$ then $\satisfies{M}{\givenA{A}{A'}}$
\end{lemma}
\begin{proof}asdf
\begin{case}asdf
\end{case}
\end{proof}