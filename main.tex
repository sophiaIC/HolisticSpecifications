\documentclass[acmsmall,screen,anonymous,review]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}

%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{CONF} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2018}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

\setcopyright{none}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%  \citestyle{acmauthoryear}
\usepackage{ amssymb }
\usepackage{stmaryrd}


\usepackage{subcaption}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[british]{babel}
\usepackage{xspace, listings, lstcustom, wrapfig, graphicx, enumerate}
\usepackage{paralist}
\usepackage{color,colortbl, relsize}
\usepackage{rotating}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{soul}
\usepackage{tcolorbox}
\usepackage[scaled=.9, light]{zlmtt}
\usepackage{siunitx}
\usepackage{setspace}

\include{macros}

\usepackage{times}
\usepackage{latexsym}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=Java,                % the language of the code
  mathescape=true,
  basicstyle=\footnotesize\tt,           % the size of the fonts that are used for the code
%  numbers=left,                   % where to put the line-numbers
%  numberstyle=\tiny\color{dkgreen},  % the style that is used for the line-numbers
%  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
                                  % will be numbered
%  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
%  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{gray},       % comment style
  stringstyle=\color{mauve},         % string literal style
 % escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={PRE,POST,result,assume,function,fresh,assert,private,then,elseif,public,final,this,throw,new,||,to,def,any,fun,fld,abstract,policy,specification,ghost,field,func}        }  
         % if you want to add more keywords to the set
 


\newcommand{\kjx}[1]{{\color{orange}{KJX: #1}}}
\newcommand{\scd}[1]{{\color{dkgreen}{SD: #1}}}
\newcommand{\sdcomment}[1]{{\ensuremath{\blacksquare}}\footnote{\color{dkgreen}{SD: #1}}}
\newcommand{\secomment}[1]{{\ensuremath{\blacksquare}}\footnote{\se{#1}}}
\newcommand{\jncomment}[1]{{\ensuremath{\blacksquare}}\footnote{\kjx{#1}}}

 \newcommand{\sd}[1]{{\color{dkgreen}{#1}}}
\newcommand{\tobyM}[1]{{\color{purple}{Toby: #1}}}
\newcommand{\se}[1]{{\color{blue}{susan: #1}}}


\newcommand{\ponders}[3]{\marginpar{\tiny\itshape\raggedright\textcolor{#2}{\textbf{#1:} #3}}\ignorespaces}
\marginparwidth=1.6cm \marginparsep=0cm
\newcommand{\TODO}[1]{{\color{red}#1}}
\newcommand{\sophia}[1]{\ponders{Sophia}{dkgreen}{#1}}
\newcommand{\toby}[1]{\ponders{Toby}{purple}{#1}}
\newcommand{\susan}[1]{\ponders{Susan}{blue}{#1}}
\newcommand{\james}[1]{\ponders{James}{orange}{#1}}

\begin{document}

\author{ author}\affiliation{Address}

%\authorinfo{Sophia Drossopoulou$^1$, James Noble$^{2,1}$, Toby Murray$^4$, Mark Miller$^3$, Shupeng Loh$^1$, Susan Eisenbach$^1$}{$^1$Imperial College London, $^2$Victoria University Wellington, $^3$Google Inc, $^3$NICTA and UNSW.}{}


\title{Holistic Specifications for Robust Programs}


\begin{abstract}
Functional specifications of program components describe what
components \emph{can} do --- the \emph{sufficient} conditions to
invoke the component's behaviour: a client who supplies arguments
meeting an operation's preconditions can invoke that operation. 
While specifications of sufficient conditions may be enough to reason about the behaviour of
complete, unchanging  programs, they cannot support reasoning about
individual components that interact with external components of possibly unknown provenance. 
In this open world ensuring that your component is robust even when executing with buggy or malicious external code is critical.
 \emph{Holistic specifications}
--- as their name implies --- describe the \emph{necessary}
conditions under which a behaviour can take place: constraining
components' behaviours and defining what they \emph{cannot} do.  By
adopting holistic specification techniques,
programmers can explicitly define what their programs should not do
making it easier to write components
that support the construction
of robust and reliable programs.


%% especially in an open world


%% We argue  that it is essential to specify policies which make a program robust,
%% and that the specification of what such robustness policies goes beyond  traditional function pre- and post-conditions.
%We propose new fundamental object-capability-inspired assertions
%which describe access and change, and combine these with space and time considersations
%(footprints temporal logic).
%Thus we obtain a logic which reflects not only over the current state, but
%also over the complete trace of an execution.
\end{abstract}


\maketitle

\section{Introduction}
\input{introduction}


\section{Motivating Example: The Bank}
\label{sect:motivate:Bank}
\input{motivateBank}



\section{\Chainmail\ Overview}
\label{sect:chainmail}
\input{overChainmail}


\section{Formal foundations}
\subsection{\Chainmail}
\label{sect:overviewmodel}
\input{overModel}

\subsection{\LangOO}
\label{sect:PL}
\input{summaryExecution}

\section{Assertions}
\label{sect:assertions}
\input{assertions}

\section{Examples}
\label{sect:example}
%\input{ExampleDOM}
\sophia{This section now needs to be updated, as it has moved to later in the paper}
\label{sect:example:DOM}
\input{ExampleDOM}


\section{Discussion}
\label{sec:discussion} 
\input{discussion}

\section{Related Work}
\label{sec:related}
\input{related}

\section{Conclusion}
\label{sec:conclusion}
\input{conclusion}

\bibliography{Case,more}


\appendix

\sdcomment{Note that the file rest.tex contains more material.}

 



\section{The underlying programming language, \LangOO}
\label{app:LangOO}
\input{langOO}

\forget{
\input{motivateDOM}

\input{DOM.appendix}


\section{Example -- ERC20}
\input{ERC20}

\section{Example -- DAO}
\input{DAO}

\section{Example -- Purse and Mint}
take from our earlier works

In two versions: one where there is a ledger inside the Mint, and one where the Mint has no path to the Purses. This will serve to demonstrate how \prg{internal} is supposed to work.

\section{Example -- Membrane}

TODO - take from ShuPeng's thesis
}

%% \newpage
%% replaced for ACM-ization
%% % \small{
%%   \bibliographystyle{plain}
%% \onecolumn{
%%  \bibliography{Case,more}
%% }

\end{document}

THE rest
\include{rest}

\subsection*{LATEX mysteries and terminology}
 \begin{enumerate}
 \item
 How can we make the references refer to the Definitions, Lemmas etc
 rather than the section where these appear?
 \begin{quotation}
   \color{orange} KJX:   Not sure what the problem is. I've put labels
   in the definitions and I can use refs to get definition
   numbers~\ref{defONE} and~\ref{def:syntax:classes} ---
   not ~\ref{secONE} and ~\ref{sec:syntax:classes}, the section
   numbers containing those definions.

   Alternatively there is the ``cleveref'' package
   \url{http://tug.ctan.org/tex-archive/macros/latex/contrib/cleveref/cleveref.pdf}
   where a ``\verb+\cref{foo}+'' can generate both the type and the
   numbner e.g.  ``Definition 3''.
 \end{quotation}

 \item
 Need a nice metavariable for set of addresses, currently it is $R$. Perhaps instead use an enumeration, as eg $\{ \ \alpha_1,...\alpha_n\ \} $
 or $\kappa$?

 \begin{quotation}
 \color{orange} KJX: Hmm, the enumeration is fine. Otherwise $A$?
 $\mathcal{A}$?  Or we could call that set a ``footprint'' and so go
 with $F$ or $\mathcal{F}$\ldots
 \end{quotation}
\item
Find a nice term  to refer to module pairs  (internal, external), and a term for
our version visible states semantics.
 \begin{quotation}
   \color{orange} KJX: ``modules'' and ``modular state semantics''.
   Going to ``modules'' only makes sense with my answer below.
   Other permutations of
   ``visible module/modular state semantics'' work also work:
     modular visible state; visible modular state; etc\ldots
 \end{quotation}


\item
Better symbols for module linking (currently a $\M\link\M'$), and
for module pairing (currently a $\M\mkpair \M'$) -- perhaps there should not be such an operator, as
it does not create a new module, it is only used in execution ($\M\mkpair \M', \sigma \leadsto \sigma'$)
and in satisfaction of assertions ($\M\mkpair \M', \sigma\models \A$).
\footnote{\toby{TM: I like~$\M \mkpair \M'$ as it suggests the asymmetry of the visible
    state semantics wrt~$\M$ and~$\M'$.}}

 \begin{quotation}
   \color{orange} KJX: I'm so used to $\M\link\M'$ that I can't think
   of an alternative --- or do I recall we used $\M * \M'$ as a
   separating conjunction?

   So I really liked $\M\mkpair \M'$ --- except then I though that I
   couldn't remember which was the module (inside) and which the
   anti-module (the outside).  For some reason I thought outside would
   go first.  Then I realised, it's easy, cos $\M$ is always the
   module, and $\M'$ is the antimodule.

   At which point I though: OK so let's just write $\M$ as the module,
   and given any $\M$, then $\M'$ (or $\overline{\M}$ or I guess
   \textbf{out}($\M$)) for the antimodule.

   The only thing I think this loses is that the $\M\mkpair \M'$
   syntax, also like a seperating conjunction, is sort of
   self-framing: $\M\mkpair \M'$ encompasses the universe of modules.
   Whereas the other way around, we'd need a (implicit) universe of
   all modules $\mathcal{U}$, and then define $\M' \triangleq
   \mathcal{U} - \M$  If we went with $\M'$ then Sophia couldn't use
   $\M''$ and friends --- have to write \texttt{N} and \texttt{O} for other
   modules?

   I think the only change I could see in the whole document was that
   lemma~\ref{lemma:module_pair_execution} is subsumed into
   lemma~\ref{lemma:linking:properties}.
 \end{quotation}


 \end{enumerate}
